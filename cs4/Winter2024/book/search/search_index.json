{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 4 book: Winter 2024","text":"<p>This book is the official document repository for the Caltech CS 4 course  (Fundamentals of Computer Programming) for the Winter 2024 term.</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p> <p>Please read this page for an overview of the course.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 4 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>You are welcome to collaborate informally on your assignments (but not on exams!) with other individuals who are taking the course, but you must write all of your own code and you must not look at other students' code, except to help them as described below. Copying another student's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another student's file and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another student's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone dictate code while you type isn't acceptable either. Basically, you have to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine.</p> <p>All of the above also applies if you are getting tutored for the course, officially or unofficially.</p> <p>All of the above also applies to student work from previous years. We re-use some problems in assignments, and copying answers from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a student who is currently taking the course.</p>"},{"location":"admin/collab/#in-class-exercises","title":"In-class exercises","text":"<p>Some lectures will feature in-class exercises (programming problems that will be solved during the lecture by students). These exercises will also be on the assignments. While in the lecture where the exercise is presented, students may collaborate with other students as well as take notes on the solution given by the instructor (if there is one). However, on the assignment, these in-class exercise problems are no collaboration; you are only allowed to consult notes that you personally took during the lecture where the exercise was done.</p> <p>Note</p> <p>If you did not attend the lecture where a particular in-class exercise was presented, you must do the problem without any additional help (no collaboration). (Among other objectives, in-class exercises are an incentive for you to come to lectures.)</p> <p>Note that if you missed a lecture, you may not get notes on an in-class exercise from other students at any time, including in a subsequent lecture.</p> <p>If you attended a lecture where an in-class exercise was presented, but didn't take notes, you may not borrow the notes from another student, whether you collaborated with them in class or not.</p>"},{"location":"admin/collab/#exams-midterm-final","title":"Exams (midterm, final)","text":"<p>Exams are strictly no-collaboration under all circumstances. The only exception is that you can ask the instructor (Mike) for clarification on anything in the exam that is confusing (for example, when you don't know exactly what a problem is asking you to do). Don't ask a teaching assistant; clarifying exam questions is not their responsibility.</p>"},{"location":"admin/collab/#helping-others-and-the-50-foot-rule","title":"Helping others and the \"50-foot rule\"","text":"<p>It is common for students to want to help other students to write and debug their assignments. While we prefer that you go to one of the course teaching assistants when you need help on the assignments (it doesn't matter which one), we don't forbid you from seeking help from other students or offering your help to other students. However, we do insist on some guidelines to make the process fair for everyone.</p> <p>When you are helping another student with their homework, you are acting as an unofficial teaching assistant, and thus you must behave like one. A teaching assistant will not just tell you the answer or dictate code to you; they will help you work through the problem so that you understand what you are doing wrong. If you don't have the time or the inclination to do this, do not assist other students. If you just give them your code, you are violating the Honor Code and both you and the people you are giving the code to may be in for some serious consequences.</p> <p>As a way of clarifying the way in which you can help other students (especially when it comes to debugging their code), we want you to obey the \"50 foot rule\". This rule states that if you help another student with their programming problems (including debugging), you must not consult your own code while doing so. Specifically, we ask that your own code be at least 50 feet away i.e. not visible to you or the person you are helping while you are helping them. (It doesn't have to be exactly 50 feet; the point is that you can't see your code while helping the other person and you shouldn't run back and forth between your computer with your code and the computer of the person you're helping.) The slogan of the 50-foot rule is: \"Help them with your brain, not with your code.\" Please do not try to find a loophole kind of way around this e.g. projecting your code on a building 50 feet away; that is clearly not what we mean. Posting your code on a pastebin-like internet site, emailing your code to other people, sharing your screen with your code on it, printing it out, or even referring to it on your laptop while helping someone else, are all clear violations of the collaboration policy for this course. Also, we don't want you to put your code up on a computer in a room 50 feet away from where you're helping someone and run back and forth, dictating a line at a time. If you can't help them without consulting your code, don't help them. Refer them to a teaching assistant.</p> <p>Note</p> <p>The 50-foot rule only applies when helping another student in person.</p> <p>Helping another student using teleconferencing software like Zoom, Skype, Discord etc. is covered below, but one aspect of it is that screen sharing is not permitted.</p> <p>We realize that it's more convenient to ask someone in your house for help than to walk all the way to the Annenberg building. A possible solution is to get to know a TA and meet with them in their dorm room (if they are willing). Another possibility is to meet with a TA on Zoom (if they are OK with this).</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord with VOIP), you may not share your screen with other students, whether to help them or to get help from them. This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software. This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs. If this happens you may lose the ability to use the discussion board for any purpose.</p> <p>This also applies to programs with chat features that are not used in the course (like Slack or Discord), or email for that matter.</p>"},{"location":"admin/collab/#use-of-websites","title":"Use of websites","text":"<p>It is strictly forbidden to post any of the problems from the assignments onto websites (for instance, Stack Overflow), and anyone caught doing this will be charged with an Honor Code violation. This includes problems that are similar to assignment problems even if not identical. If you find a discussion of course-related material on internet websites, you may read it as long as the discussion is not about a problem that is identical to or very similar to a problem on one of the course assignments. However, do not transcribe code from the internet into your homework submissions.</p> <p>It is strictly forbidden to look at any solutions to any previous years' CS4 work posted on internet code repository sites (including but not limited to GitHub, GitLab, BitBucket, etc.). It is also strictly forbidden to put your own code on such a repository unless (a) it is a private repository, and (b) you do not allow anyone else access to this private repository. You may also not fork any such repositories that you might happen to find; we will consider this prima facie evidence of intent to plagiarize.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-eg-github-copilot-chatgpt","title":"Use of code hinting software (e.g. Github Copilot, ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. (This should be obvious.)</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments and exams.</p> Item Status Course book OK Course textbook OK Official OCaml documentation OK Other OCaml documentation OK Other OCaml books OK Your notes OK Notes of other students Not allowed Your graded assignments OK Other students' graded assignments Not allowed Other students' ungraded assignments Not allowed Other code written by anyone else that answers an assigned problem Not allowed Solutions to assignment/exam problems from a previous year Not allowed Material posted on internet forums that answers specific problems Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor (Mike). Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the course syllabus for CS 4 (Fundamentals of Computer Programming) for the Winter 2024 term.</p>"},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor/lecturer for the course is Mike Vanier (mvanier@cms.caltech.edu). Mike's pronouns are he/him.</p>"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held in Beckman Institute Auditorium (Beckman Institute, room 134) on Mondays, Wednesdays, and Fridays from 3 PM to 4 PM.</p> <p>If attendance drops significantly, lectures may be moved to Annenberg room 105. You will be informed before this happens.</p>"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for the course. Contact information and office hours for teaching assistants will be posted on the course Canvas page.</p> <p>Teaching assistants are TBA.</p>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Times and locations of office hours for teaching assistants and the instructor will be posted on the course Piazza page (see below).</p> <p>TA office hours are normally held in-person, but may be held on Zoom in certain situations.</p> <p>The instructor (Mike) will hold office hours on Zoom.</p>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>From the Caltech catalog entry for CS 4:</p>  This course gives students the conceptual background necessary to construct and analyze programs, which includes specifying computations, understanding evaluation models, and using major programming language constructs (functions and procedures, conditionals, recursion and looping, scoping and environments, compound data, side effects, higher-order functions and functional programming, and object-oriented programming). It emphasizes key issues that arise in programming and in computation in general, including time and space complexity, choice of data representation, and abstraction management. This course is intended for students with some programming background who want a deeper understanding of the conceptual issues involved in computer programming. Prerequisites: CS 1 or instructor's permission.  <p>A longer (and arguably more accurate) description of the course is given in the Motivation page of this book.</p>"},{"location":"admin/syllabus/#recommended-textbooks","title":"Recommended textbooks","text":"<p>There are two recommended textbooks, both available online in their entirety:</p> <ul> <li> <p>Structure and Interpretation of Computer Programs,   (usually referred to as \"SICP\", and pronounced \"sick pea\"),   by Hal Abelson, Gerry Sussman, and Julie Sussman</p> </li> <li> <p>Real World OCaml, also known as \"RWO\",   by Yaron Minsky, Anil Madhavapeddy and Jason Hickey</p> </li> </ul> <p>Both books are excellent (and we thank their authors for providing them for free online!), but neither is a perfect match for CS 4. The conceptual basis of CS 4 largely derives from SICP, but SICP uses Scheme, not OCaml, as its programming language. RWO is a more recent book which has excellent coverage of OCaml, but uses the <code>Base</code> and <code>Core</code> libraries throughout, which we will not use. Nevertheless, both books are good references for the material covered in this course.</p>"},{"location":"admin/syllabus/#additional-reference-material","title":"Additional reference material","text":"<p>You should definitely bookmark the OCaml manual. Even though this is not the easiest way to learn OCaml, the manual has complete coverage of the language, including obscure topics and language extensions. More important for day-to-day programming are the chapters on the core library and (especially) the standard library, which contains links to the <code>List</code> library, the <code>Array</code> library, and so on. You should have these close by whenever writing any moderately complicated OCaml program.</p> <p>Another great resource is the online textbook for the Cornell CS 3110 course, OCaml Programming: Correct + Efficient + Beautiful, most of which was written by Michael Clarkson. This book contains a lot of excellent explanatory material on OCaml programming, and goes over the material at a slower pace than the manual. It also includes videos!</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There will be a Piazza site, which you will be enrolled in if you are registered for this course.</p> <p>For homework submission and grading, we will use CodePost.</p>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>There will be 7 assignments, one midterm exam, and one final exam. Grades will be calculated as follows:</p> Item Points Assignments (7 x 10 points each) 70 Midterm exam 20 Final exam 30 Total 120 <p>The total out of 120 will be rescaled to give an actual grade out of 100%. Letter grades will be assigned as follows:</p> Numerical grade (out of 100%) Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 65-70% C+ 62-65% C 60-62% C- 58-60% D+ 55-58% D &lt; 55% F"},{"location":"admin/syllabus/#grading-individual-assignments","title":"Grading individual assignments","text":"<p>On CodePost, assignments will be graded out of 100. Each assignment will be divided into sections. On CodePost, each section will get a certain number of points (not necessarily the same for each section). The actual grade of the assignment is the sum of all the section grades. The CodePost grade will be divided by 10 to get the actual recorded grade.</p> <p>Note</p> <p>We refer to the numerical grade on CodePost (out of 100) as the \"CodePost grade\". We divide the CodePost grade by 10 to get the actual grade. Similarly, marks on CodePost are called \"CodePost marks\", in contrast to actual marks. So 10 CodePost marks is 1 actual mark.</p> <p>The reason for this is that CodePost only lets you record grades to a precision of 0.5 marks, and we want to be able to grade in a more fine-grained manner.</p>"},{"location":"admin/syllabus/#redoing-assignments","title":"Redoing assignments","text":"<p>After you receive your initial grade on an assignment, you have one week to submit a redo. Redos will be submitted as a separate CodePost assignment called <code>Assignment N (rework)</code> (for assignment <code>N</code>). Late redos (received after the 1-week redo window) will not be graded and your previous grade will stand. You may not submit more than one redo per assignment.</p>"},{"location":"admin/syllabus/#late-policy-for-assignments","title":"Late policy for assignments","text":"<p>If an assignment is late when first submitted, marks are deducted at the rate of 2.0 marks/day (20 CodePost marks). These marks can't be regained through rework. If a rework is late (i.e. is submitted more than one week after the original grade was submitted), it doesn't count, and the previous grade stands.</p> <p>Note</p> <p>If an assignment is submitted on time, but is missing one or more sections, those sections will be graded as a 0. The assignment can be reworked, of course, but assuming the sections that were missing on the initial submission are submitted with the rework, there is no additional rework for these sections. This means (for instance) if you don't submit a section on the initial submission, but do submit it in the rework, the grade of that section in the rework is final \u2013 you don't get to rework it just because you hadn't submitted it before. So please don't leave out sections!</p> <p>Students may request extensions for assignments due to unusual circumstances. These extensions have to be approved by the course instructor (Mike).</p>"},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Friday at 2 PM unless otherwise indicated. Note that a due time of 2 PM means early that morning, so effectively it means very late the previous evening.</p>"},{"location":"admin/syllabus/#attendance-and-participation","title":"Attendance and participation","text":"<p>Attendance and participation currently do not count towards the final grade. However, we strive to make lectures interactive and do a lot of live coding during lectures. Missing out on this will deprive you of many of the benefits of the course (as well as a lot of the fun!). Lectures will not be recorded, but all slides and code will be posted.</p> <p>In addition, many lectures will feature in-class exercises which will also appear on the assignments. These exercises can be (and are expected to be) solved collaboratively in class, but must be solved without collaboration on the assignments. (You may of course take notes on the solution during lectures, but you may not share these notes with other students. Consult the collaboration policies for more details.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech\u2019s Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this page.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>The course collaboration policies are listed in the collaboration policies page in this book.</p> <p>Note</p> <p>Please read the collaboration policies! You are responsible for knowing what is and isn't acceptable collaboration, and if you over-collaborate you may be sent to the Board of Control, which is never pleasant.</p>"},{"location":"admin/syllabus/#software","title":"Software","text":"<p>In this course, we will be using the OCaml programming language. Assignment 0 (which is not graded) will instruct you on how to set up the OCaml environment on your computer.</p> <p>Other than that, you will only need a terminal program and a plain text editor. There are a variety of choices for these; assignment 0 discusses this further. For in-class live coding demos, we will use either the Neovim text editor or the Visual Studio Code editor.</p> <p>If you want to try out code examples during the lectures, you can also use the online OCaml environment. This environment is sometimes a bit sluggish, so a good alternative is the Try OCaml site.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated by your classmates and the course staff with respect. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to your learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructors know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student Wellness","text":"<p>It is very important to us that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation,  recommend reasonable accommodations,  and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made.  Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See the CASS website for more information.</p> <p>Undergraduate students should contact Dr. Lesley Nye, interim Dean of Undergraduate Students (administrative contact: Beth Larranaga) and graduate students should contact Darrell Peterson, Associate Dean of Graduate Studies (administrative contact: Georgine Okura).</p>"},{"location":"assignments/0/assignment0/","title":"Assignment 0: Getting set up","text":""},{"location":"assignments/0/assignment0/#due-date","title":"Due date","text":"<p>This assignment has no due date, and isn't graded.</p>"},{"location":"assignments/0/assignment0/#overview","title":"Overview","text":"<p>The purpose of this pseudo-assignment is to make sure that all the software you need in order to do the assignments for this class is set up correctly. This is not a real assignment and it's not worth any marks, but if you want to complete the actual assignments you'll need to do it.</p>"},{"location":"assignments/0/assignment0/#getting-ocaml-installed","title":"Getting OCaml installed","text":"<p>Here are the steps you should go through to install OCaml on your computer.</p>"},{"location":"assignments/0/assignment0/#install-ocaml-and-opam","title":"Install OCaml and <code>opam</code>","text":"<p>See the instructions on the OCaml website.</p> <p>Note</p> <p>Be aware that the version numbers may have changed since that document was written. Be sure to install the correct version! This term, we are using OCaml version 5.1.1.</p>"},{"location":"assignments/0/assignment0/#macos","title":"MacOS","text":"<p>The instructions for MacOS refer to the Homebrew package manager, which needs to be installed first.</p> <p>Note</p> <p>Homebrew does not come pre-installed on Macs, but it is easy to install and is incredibly useful. Almost any open-source command-line program you can imagine can be installed using Homebrew with a single command. (This includes most programming languages, including OCaml).</p> <p>We strongly recommend that you use Homebrew, and not the MacPorts package manager (an alternative package manager for Macs), unless you happen to be an expert MacPorts user.</p>"},{"location":"assignments/0/assignment0/#linux","title":"Linux","text":"<p>If you are using Linux, you can install OCaml using your system's package manager. If your Linux is an Ubuntu variant (the most common kind), you should install OCaml using the Ubuntu package manager <code>apt</code>. The commands are:</p> <pre><code>$ sudo apt update\n$ sudo apt install opam\n</code></pre> <p>The <code>sudo</code> is so you don't have to install the software as the root user. You may be asked to enter your password, which you should do.</p>"},{"location":"assignments/0/assignment0/#windows","title":"Windows","text":"<p>If you are using Windows, you should install a Linux system inside of Windows using the Windows Subsystem for Linux, also known as \"WSL\". Then you can use <code>apt</code> like on any Ubuntu Linux system. Don't try to install OCaml natively on Windows; although this may be possible, you are very likely to run into problems beyond the capability of the instructors to solve. Use WSL.</p>"},{"location":"assignments/0/assignment0/#initialization","title":"Initialization","text":"<p>Once you have a version of OCaml and <code>opam</code> installed, you need to set it up, and, if necessary, upgrade the versions. Go through the following steps.</p> <ul> <li>Start a terminal.   If you are running MacOS, you can use the <code>Terminal</code> program.   If you're using Windows/WSL, you can either use   Windows Terminal   or use Visual Studio Code   and start a terminal inside the editor.   If you're using Windows, make sure you are   running WSL inside the terminal and not Powershell   (a terminal shell that is native to Windows).   Both Windows Terminal and VS Code   allow you to select either Powershell or WSL,   assuming WSL has been installed.   The Ubuntu shell will usually be called <code>bash</code> but may be called <code>zsh</code>.</li> </ul> <p>You will be using the terminal a lot in this course, so you should   definitely get used to working inside it.</p> <ul> <li> <p>Initialize <code>opam</code> by typing <code>opam init</code> in a terminal   and following the instructions.</p> <p>Note</p> <p>There is an issue with initializing <code>opam</code> inside of WSL. Basically, due to the way WSL works, you have to initialize <code>opam</code> differently by disabling sandboxing. This theoretically can cause some problems if a package does something really stupid, but it probably won't. The fix is to use this command instead of just <code>opam init</code>:</p> <pre><code>$ opam init --disable-sandboxing\n</code></pre> </li> <li> <p>At the end of the <code>opam init</code> command,   it will ask you to run <code>eval ${opam env}</code><sup>1</sup>   to set up the <code>PATH</code> variable of your shell   to point to the <code>opam</code> directories.   This is important, because if you don't do this,   adding new packages (and new OCaml versions) will not work.   Opam will also ask you if it can change your shell initialization file   (e.g. <code>~/.bashrc</code> for <code>bash</code> or <code>~/.zshrc</code> for <code>zsh</code>)   by adding some commands.   You should say yes, because if you don't,   every time you start up a new terminal   you will have to type <code>eval ${opam env}</code>   to get <code>opam</code> to work correctly.</p> </li> <li> <p>In your terminal, type:</p> <pre><code>$ opam update\n$ opam upgrade\n</code></pre> <p>to make sure the package repository is up to date and all OCaml packages have been upgraded to the most recent versions.</p> </li> <li> <p>Check the OCaml version by typing <code>ocaml --version</code>.   If it's the desired version (which is 5.1.1 this term),   you are done with this part.   Otherwise do</p> <pre><code>$ opam switch create 5.1.1\n</code></pre> <p>and wait for the new version to be installed. (This will take a while.)</p> </li> <li> <p>Install some libraries and programs:</p> <pre><code>$ opam install utop dune ocamlformat\n</code></pre> <p>This will install the <code>utop</code>, <code>dune</code>, and <code>ocamlformat</code> programs, as well as a number of other OCaml libraries you don't have to worry about.</p> <p><code>utop</code> is the OCaml interactive interpreter. (The name <code>utop</code> is short for \"Universal Toplevel for OCaml\") We will be working with this a lot!</p> <p>Note</p> <p>There is a more primitive interactive OCaml interpreter just called <code>ocaml</code> that comes with the OCaml distribution. We won't use this, because <code>utop</code> is vastly more featureful and nicer to use.</p> <p><code>dune</code> is the OCaml compilation manager. We will introduce this when we need it (which won't be for a few weeks).</p> <p><code>ocamlformat</code> is an auto-formatter for OCaml code. You don't absolutely need this, but it's useful when you are working with longer files of code and you want to make sure everything is formatted neatly.<sup>2</sup></p> </li> </ul> <p>We will also be installing other libraries as needed for the assignments.</p>"},{"location":"assignments/0/assignment0/#using-ocaml","title":"Using OCaml","text":"<p>There are only a few things you need to know in order to use OCaml effectively.</p>"},{"location":"assignments/0/assignment0/#starting-ocaml","title":"Starting OCaml","text":"<p>Open a terminal and type:</p> <pre><code>$ utop\n</code></pre> <p>at the terminal prompt. (The <code>$</code> is the terminal prompt; don't type that.) This will bring up the OCaml interactive interpreter, which is a good environment for experimenting with the language and for testing code you've written. (This is similar to the Python interactive interpreter.)</p> <p>Note</p> <p>You can also type <code>ocaml</code> instead of <code>utop</code>, which will bring up the simpler interactive interpreter that ships with the OCaml distribution. However, <code>utop</code> is so much better than <code>ocaml</code> that there is no need to do this unless <code>utop</code> isn't working for some reason.</p> <p><code>utop</code> makes it possible to easily recall and edit previously-input lines of text by using the up and down arrow keys. To see what it can do, start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>and type the following commands (one per line, hitting the return key at the end of each line):</p> <pre><code># Printf.printf \"hello\\n\" ;;\n# Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>Note</p> <p>The <code>utop</code> prompt is the hash sign (<code>#</code>); don't type that!</p> <p>These lines should, when evaluated, print the words <code>\"hello\"</code> and <code>\"goodbye\"</code> respectively. Once you've done this, you should be able to recall either line by using the up arrow key. For instance, you can hit the up arrow key once to get the line:</p> <pre><code>Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>and edit it so that it says:</p> <pre><code>Printf.printf \"hasta la vista\\n\" ;;\n</code></pre> <p>When you hit return, it should print out <code>\"hasta la vista\"</code> on a separate line. This feature makes line editing much easier. You can also use control-a (hold the control key down and type <code>a</code>) to get to the beginning of a line you are editing and control-e to get to the end. control-l (lower-case L) clears the terminal and puts the cursor at the top of the terminal window.</p> <p>By the way, in addition to printing out the messages you wanted, you'll also see the line:</p> <pre><code>- : unit = ()\n</code></pre> <p>printed out after hitting return. This is OCaml telling you the type of the result. In this case it's the <code>unit</code> type, which is what <code>printf</code> returns. We will talk about this in class.</p> <p>Exit the interpreter by typing control-d (this is just like Python). You can also type <code>#quit;;</code> at the prompt:</p> <pre><code># #quit;;\n</code></pre> <p>and that will also work.</p>"},{"location":"assignments/0/assignment0/#configuring-utop","title":"Configuring <code>utop</code>","text":"<p>One annoying thing about <code>utop</code> is that it tends to go overboard on command completion. You can disable this by typing this inside <code>utop</code>:</p> <pre><code># #utop_prompt_dummy;;\n# UTop.set_show_box false;;\n</code></pre> <p>It's annoying to type this every time you start <code>utop</code>, so what I do is make a <code>utop</code> initialization file called <code>init.ml</code> and put it in the directory <code>~/.config/utop</code> (creating that directory if necessary). Then these commands will be run every time <code>utop</code> starts.</p> <p>Note</p> <p>Unfortunately, this will not work properly if used in a directory that has a <code>.ocamlinit</code> file in it (usually your home directory). There are workarounds, but most of the time it will work properly. Other than that, <code>utop</code> is far superior to the basic <code>ocaml</code> interpreter.</p>"},{"location":"assignments/0/assignment0/#notes-on-the-interactive-interpreter","title":"Notes on the interactive interpreter","text":"<p>One confusing aspect of OCaml is that when entering code in the interactive interpreter, nothing gets evaluated until you enter a double semicolon (<code>;;</code>) followed by a carriage return. What this does is tell the OCaml interpreter \"Hey, I'm done entering code, so take the code I've entered and evaluate it.\" The advantage of this is that you can enter code that spans more than one line without having to enter line continuation characters at the end of lines (like you have to do in e.g. Python). The confusing part is that it's almost never necessary to enter the double semicolons when writing OCaml code in a file (though it is legal). This is a very common style mistake beginning OCaml programmers make. It usually doesn't cause any harm, but it looks bad, so don't use the double semicolons when writing OCaml code in files. (We will take style marks off if you violate this guideline, so don't do it.)</p> <p>Tip</p> <p>Don't write <code>;;</code> to end chunks of code in a file of OCaml code!</p> <p>The usual way of writing code using OCaml is to write it in a file and then load the code into the interactive interpreter to test it. The interactive interpreter has several commands that are used for this, all of which begin with the hash sign (<code>#</code>). The simplest one is the <code>#use</code> command, which loads up some OCaml source code from a file, compiles it, and runs it. For instance, open up your text editor and type the following into a file called <code>test.ml</code>:</p> <pre><code>let f x = 3 * x * x + 4 * x + 5\n</code></pre> <p>(Note, by the way, that we didn't use the double semicolons, since this is OCaml code in a file!) Save the file, then start a terminal and navigate to the directory containing that file. Then start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>Inside the interpreter, type the following command:</p> <pre><code># #use \"test.ml\";;\n</code></pre> <p>The first <code>#</code> is just the OCaml prompt and shouldn't be typed. If you've done this right, OCaml should respond with:</p> <pre><code>val f : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>What this means is that OCaml has compiled the code in the file <code>test.ml</code> and is printing out the type signature of all functions it has found there (in this case, there is only one, <code>f</code>). Test that it works by typing the following:</p> <pre><code># f 10 ;;\n</code></pre> <p>OCaml should reply with:</p> <pre><code>- : int = 345\n</code></pre> <p>By the way, the <code>-</code> to the left of the colon just indicates that the value that is printed is not a named value (unlike <code>f</code>, which we saw above).</p> <p>Interpreter commands like <code>#use</code> are not part of the OCaml language; they are only used in the interactive interpreter.</p> <p>Most of the time, we will compile OCaml code outside of the interactive interpreter by using the OCaml compilers <code>ocamlc</code> and <code>ocamlopt</code>; we will discuss how to do this in later assignments. Even later, we'll learn how to automate this process using the <code>dune</code> compilation manager.</p>"},{"location":"assignments/0/assignment0/#using-visual-studio-code","title":"Using Visual Studio Code","text":"<p>You can use any text editor you like to write OCaml code, but we recommend you try Visual Studio Code (also known as VS Code), which has excellent OCaml support, and isn't difficult to set up.<sup>3</sup> In order to use it, you need to do the following steps:</p> <ul> <li> <p>Install the OCaml Language Server Protocol by typing this into a terminal:</p> <pre><code>$ opam install ocaml-lsp-server\n</code></pre> <p>A \"language server protocol\" provides a way for editors to query languages so that things like command completion and type information can be displayed in the editor while you're editing code.</p> </li> <li> <p>Install Visual Studio Code from the   VS Code website.</p> </li> <li> <p>When inside VS Code, look at the Extensions pane   (select View/Extensions from the menu).   Type \"OCaml\" into the search bar at the top,   and select and install \"OCaml Platform\".</p> </li> </ul> <p>Now you will get nice syntax highlighting and code completion when you edit OCaml source code. You can also start a terminal while inside VS Code to test your code by running the OCaml interpreter.</p> <p>OK, now you are ready to write OCaml code!</p> <ol> <li> <p>Or possibly <code>eval ${opam config env}</code> or something similar. It all does the same thing.\u00a0\u21a9</p> </li> <li> <p>It's also a great way to avoid losing marks for poor coding style!\u00a0\u21a9</p> </li> <li> <p>I (Mike) actually use Neovim as my code editor most of the time. Neovim is incredibly powerful, but it takes a lot longer to learn and to configure. I don't recommend it to students unless they are willing to spend a lot of time learning it.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/assignment1/","title":"Assignment 1: Evaluation and recursion","text":""},{"location":"assignments/1/assignment1/#things-you-should-read","title":"Things you should read","text":"<p>As this is the first real assignment, we would like to remind you of some documents that you should read (or at least skim) before starting your assignment:</p> <ul> <li> <p>The course syllabus.</p> <p>This contains all the administrative information of the course. In particular, it describes the grading scheme for the course as a whole and also for individual assignments. It also describes the rework and late policies for assignments.</p> </li> <li> <p>The course collaboration policies.</p> <p>This document describes what kind of collaboration are allowed on assignments, and what isn\u2019t allowed.</p> <p>Note</p> <p>It\u2019s easy to just assume you won\u2019t do anything wrong, but please read this page, because if you don\u2019t, and you\u2019re involved in some kind of collaboration that isn\u2019t allowed, you could end up getting called before the Caltech Board of Control (BoC), which is not a pleasant experience.</p> </li> <li> <p>The OCaml cheat sheet.</p> <p>The cheat sheet describes a number of possibly confusing aspects of OCaml syntax. If you discover some weird behavior of OCaml you don\u2019t understand, the cheat sheet is the first place you should look. You don\u2019t need to read all of it now, but take a look and come back to it as needed.</p> </li> </ul>"},{"location":"assignments/1/assignment1/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, January 12th, at 2 PM.</p>"},{"location":"assignments/1/assignment1/#grading-scheme","title":"Grading scheme","text":"<p>See the syllabus for the assignment grading scheme.</p>"},{"location":"assignments/1/assignment1/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 4, corresponding to section 1.2.3 of SICP. Some material from recitation 1 is also covered.</p>"},{"location":"assignments/1/assignment1/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab1.ml</code>.  This file should be submitted to CodePost as <code>Assignment 1</code>.  Please indicate in a comment what problem any piece of code in your submission refers to. For instance:</p> <pre><code>(* A.2 *)\n</code></pre> <p>refers to problem 2 of section A.</p>"},{"location":"assignments/1/assignment1/#supplied-files","title":"Supplied files","text":"<p>We are supplying you with this file:</p> <ul> <li><code>lab1.mli</code></li> </ul> <p>You should download it from the course Canvas site. Its use will be described below.</p>"},{"location":"assignments/1/ocaml_notes/","title":"Assignment 1: OCaml notes","text":""},{"location":"assignments/1/ocaml_notes/#mli-files","title":"<code>.mli</code> files","text":"<p>For this and all subsequent assignments, we will be supplying you with one or more OCaml interface files to be used with your code. For this assignment, the file is called <code>lab1.mli</code> (note the <code>.mli</code> extension; all OCaml interface files have this filename extension), and you should download it into the same directory that you are using to write and test your <code>lab1.ml</code> code.</p> <p>The interface file consists mostly of type signatures of functions, though occasionally it will have other things as well. The <code>lab1.mli</code> interface file looks like this:</p> <pre><code>(* Interface file for lab1.ml *)\n\nval sum_of_squares_of_two_largest : int -&gt; int -&gt; int -&gt; int\nval factorial : int -&gt; int\nval e_term : int -&gt; float\nval e_approximation : int -&gt; float\nval is_even : int -&gt; bool\nval is_odd : int -&gt; bool\nval f_rec : int -&gt; int\nval f_iter : int -&gt; int\nval pascal_coefficient : int -&gt; int -&gt; int\n</code></pre> <p>The <code>val</code> declarations indicate that the type signature of a particular value is being described. Here, all such values are functions (functions are values in OCaml). For instance, the <code>factorial</code> function has the type signature:</p> <pre><code>val factorial : int -&gt; int\n</code></pre> <p>which indicates that it takes one argument (an <code>int</code>) and returns an <code>int</code>, as you would expect. Functions which take more arguments (like <code>pascal_coefficient</code>, which takes two integer arguments) have somewhat less intuitive type signatures:</p> <pre><code>val pascal_coefficient : int -&gt; int -&gt; int\n</code></pre> <p>You might have expected something like this instead:</p> <pre><code>val pascal_coefficient : int int -&gt; int  (* WRONG *)\n</code></pre> <p>The reason why this is wrong is that arguments to OCaml functions are automatically curried, which means that they can be partially applied. (The name \"curried\" is a tribute to Haskell Curry, a logician who provided much of the theoretical foundation for modern functional programming languages.) In this case, it means that if we call <code>pascal_coefficient</code> with only one argument (an integer), it will return a function that takes the other integer argument and returns the integer result. Currying can occasionally give rise to confusing error messages, but it\u2019s also extremely handy in practice, as we will see.</p> <p>OK, let\u2019s assume you\u2019ve written all of your code, and you want to check that it conforms to the type declarations in the <code>.mli</code> file. How do you do that? The simplest way is to compile your code along with the interface file from the command line:</p> <pre><code>$ ocamlc -c lab1.mli lab1.ml\n</code></pre> <p>If no error messages are printed, your code is at least type-correct! Also, if you list the files in your directory, you will see two new ones: <code>lab1.cmi</code> and <code>lab1.cmo</code>. These are the (byte-code) compiled versions of the <code>lab1.mli</code> and <code>lab1.ml</code> files, respectively. Note that you have to put the <code>.mli</code> file before the <code>.ml</code> file on the command line; this won\u2019t work:</p> <pre><code>$ ocamlc -c lab1.ml lab1.mli\n</code></pre> <p>unless the <code>.cmi</code> file has already been compiled, in which case you don\u2019t have to have <code>lab1.mli</code> on the command line anyway. This is a bit annoying, but we live with it.</p> <p>You can now load the <code>.cmo</code> file into an interactive OCaml session as follows:</p> <pre><code># #load \"lab1.cmo\";;\n</code></pre> <p>In this case, nothing will be printed if there are no errors. A different way to load your code is to use the <code>#use</code> command:</p> <pre><code># #use \"lab1.ml\";;\n</code></pre> <p>If you do this, then OCaml will compile your code and print out the signature of every value in <code>lab1.ml</code>. When using <code>#use</code>, you don\u2019t need to compile your code beforehand. When using <code>#load</code>, you do. As a result, we tend to use <code>#use</code> more than <code>#load</code> when interactively developing code. You should know both forms.</p> <p>Let's go back to what would happen if you typed:</p> <pre><code># #load \"lab1.cmo\";;\n</code></pre> <p>You might expect that you could then use all the functions in <code>lab1.ml</code> (as you could if you\u2019d used <code>#use</code>). Actually, that isn\u2019t the case (yet). If you try, this will happen:</p> <pre><code># pascal_coefficient;;\nError: Unbound value pascal_coefficient\n</code></pre> <p>Huh? We just loaded <code>lab1.ml</code>, and <code>lab1.ml</code> defines <code>pascal_coefficient</code>, so why do we get an error message? It turns out that <code>#load</code> loads the code as a separate module called <code>Lab1</code> (the name of the file, without the extension, and with the first letter capitalized). This is like saying <code>import lab1</code> in Python. We can get the function by using the module name as a prefix:</p> <pre><code># Lab1.pascal_coefficient;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>Notice that we have to capitalize the first letter of <code>Lab1</code>. Module names are always capitalized in OCaml.</p> <p>If this is too tedious, you can dump all the names in the module into the local namespace by using an <code>open</code> declaration:</p> <pre><code># open Lab1;;\n# pascal_coefficient;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>This is like saying <code>from lab1 import *</code> in Python. Alternatively, if you used <code>#use</code> to load and compile the code, all the functions in the file are available immediately. This is another reason why <code>#use</code> is used more often for interactive development.</p> <p>It\u2019s important to realize that <code>#use</code> and <code>#load</code> are special commands of the OCaml interactive interpreter (also called the \"toplevel\"); they are not part of the OCaml language itself. (There are other special interpreter commands as well, which we will get to when we need them.)</p> <p>We will have much, much more to say about the OCaml module system in future assignments. OCaml actually has the most powerful module system of any computer language in wide use.</p> <p>Once you have finished writing your code, you should always compile it against the <code>.mli</code> file we provide to check that your code not only compiles, but also has the type signature we want. (Using <code>#use</code> will check that your code compiles, but it may not have the type signature we want.)</p> <p>In later assignments, we will introduce the <code>dune</code> compilation manager, which will automate all the tedious parts of compilation.</p>"},{"location":"assignments/1/partA_exercises/","title":"Part A: Basic exercises","text":"<p>Some of the following problems are taken from the textbook (Structure and Interpretation of Computer Programs, or SICP for short). If so, the SICP exercise numbers are included, though you shouldn't need to consult the book.</p>"},{"location":"assignments/1/partA_exercises/#1-expressions","title":"1. Expressions","text":"<p>[10 points]</p> <p>Below is a sequence of expressions. What is the result (the type and value or the error message) printed by the OCaml interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented. If the interpreter indicates an error, explain briefly (one sentence) why the error occurred. There are also some other questions below which you should answer to the best of your ability. Note that entering each code fragment interactively requires that you add the <code>;;</code> terminator to terminate input. Write your answers as OCaml comments <code>(* like this *)</code>.</p> <ol> <li><code>10</code></li> <li><code>10.</code></li> <li><code>5 + 3 + 4</code></li> <li><code>3.2 + 4.2</code></li> <li><code>3 +. 4</code></li> <li><code>3 + 4.2</code></li> <li><code>3 +. 4.2</code></li> <li><code>3.0 +. 4.2</code></li> <li><code>9 - 3 - 1</code></li> <li><code>9 - (3 - 1)</code></li> <li><code>let a = 3</code></li> <li><code>let b = a + 1</code></li> <li><code>a = b</code></li> <li><code>[1; 2; 3] = [1; 2; 3]</code></li> <li><code>[1; 2; 3] == [1; 2; 3]</code> Is this the same as or different from the previous expression? Why or why not?</li> <li><code>[(1, 2, 3)]</code></li> <li><code>[1, 2, 3]</code> Explain why this gives the result it does. This is a nasty pitfall which highlights one of the less desirable features of OCaml\u2019s syntax. (See the OCaml cheat sheet for more on this.)</li> <li><code>if b &gt; a &amp;&amp; b &lt; a * b then b else a</code></li> <li><code>if b &gt; a and b &lt; a * b then b else a</code></li> <li><code>2 + if b &gt; a then b else a</code></li> <li><code>if b &gt; a then b else a + 2</code> Why is this different from the previous case?</li> <li><code>(if b &gt; a then b else a) + 2</code></li> <li><code>if b &gt; a then b</code> This is not a syntax error. Why does this give a type error? Hint: What does OCaml assume if the <code>else</code> in an <code>if</code>/<code>then</code>/<code>else</code> form is left off?</li> </ol>"},{"location":"assignments/1/partA_exercises/#2-sicp-exercise-13","title":"2. (SICP exercise 1.3)","text":"<p>[10 points]</p> <p>Define a function that takes three integer numbers as arguments and returns the sum of the squares of the two larger numbers. Call the function you define <code>sum_of_squares_of_two_largest</code>. You will probably find the <code>&amp;&amp;</code> special operator to be handy.</p>"},{"location":"assignments/1/partA_exercises/#3-sicp-exercise-14","title":"3. (SICP exercise 1.4)","text":"<p>[10 points]</p> <p>Our evaluation model allows you to use a function which is a compound expression (something that evaluates to a function). Use this observation to describe the behavior of the following function:</p> <pre><code>let a_plus_abs_b a b =\n  (if b &gt; 0 then (+) else (-)) a b\n</code></pre> <p>Write your answer in a comment. Note that surrounding an operator with parentheses makes it into a two-argument function, so</p> <pre><code>(+) 2 3\n</code></pre> <p>is the same as:</p> <pre><code>2 + 3\n</code></pre>"},{"location":"intro/history/","title":"History","text":"<p>The history of functional programming, OCaml, and this course is described here. You aren't required to know any of this, but I think the history is quite interesting (and convoluted), so if you're curious and have a few minutes to spare, read on!</p>"},{"location":"intro/history/#a-brief-history-of-functional-programming","title":"A brief history of functional programming","text":"<p>The ideas which eventually turned into functional programming date back to the 1920s and 1930s, when many people were working on the foundations of mathematics and computation. Moses Sch\u00f6nfinkel and Haskell Curry (see also here) developed combinatory logic, which (despite the name) is a model of computation that uses very simple functions called combinators which can be combined to create a full programming language.<sup>1</sup> Alonzo Church developed the lambda calculus, which can be viewed as the simplest possible programming language and also as the simplest functional programming language.<sup>2</sup></p> <p>Fun fact</p> <p>Alan Turing was Alonzo Church's Ph.D. student. Both lambda calculus and Turing machines can express arbitrary computations, which is known as the Church-Turing thesis. Nevertheless, Turing's formulation of the process of computation is much better known, which is why you learn about Turing machines in CS 21 instead of lambda calculus.</p> <p>Both Church and Curry continued to develop their systems. In particular, Church extended his lambda calculus (which is now called \"untyped lambda calculus\") into a typed version which is the ultimate predecessor of all typed functional programming languages, including OCaml.</p> <p>The systems of Church and Curry were purely formal systems, since there were no computers at the time. Once computers were developed in the 1940s and 1950s, there was interest in using them for symbolic manipulation tasks (as opposed to numerical computations, which was what computers were mainly used for at the time). One of the pioneers of this was John McCarthy, who developed the Lisp programming language starting around 1958. This language had an extremely simple syntax made of \"S-expressions\", which are basically just lists of symbols surrounded by parentheses. More importantly for us, Lisp was the first computer language that had both recursion and anonymous functions (known as \"lambda expressions\" in Lisp). Therefore, Lisp can be considered to be the first real functional programming language. Lisp was used primarily for artificial intelligence applications for many decades, and is still used for this. Lisp spawned a number of variants, including Common Lisp and Scheme, both of which are still in use today. Later, many other functional programming languages, including OCaml and Haskell, were developed. These later languages were notable for introducing static type checking to functional programming, as well as many other features.</p>"},{"location":"intro/history/#a-brief-history-of-ocaml","title":"A brief history of OCaml","text":"<p>One of the applications that early artificial intelligence researchers were interested in was using computers to prove mathematical theorems. The original work on this topic concentrated on fully-automatic theorem proving programs. However, the large number of choices at any point in a proof made this intractable except for proofs in very narrow domains. Then interest shifted to \"proof assistants\", which are programs where a human user guides the computer to a proof using \"tactics\", which automate routine steps. One of the earlier proof assistants (though not the earliest) was called LCF, which stood for \"logic for computable functions\". It was developed first at Stanford and then at the University of Edinburgh by Robin Milner and his collaborators in the early 1970s. Early versions of LCF used Lisp as the \"meta-language\" in which proof tactics could be written. However, the proof assistant would sometimes derive incorrect proofs, so the implementors invented a \"typed Lisp\" which they called \"ML\" for \"Meta-Language\" which contained a type checker that wouldn't permit the generation of incorrect proofs.<sup>3</sup> They then implemented LCF in ML. ML was originally implemented as an interpreter written in Lisp, but standalone compiled implementations were soon developed. Along the way, it was eventually realized that ML was a full-fledged programming language that could be used for any kind of application, not just as the implementation language for proof assistants.</p> <p>Interest in proof assistants spread to INRIA in France in the 1980s, where an ML dialect called \"CAML\"<sup>4</sup> was developed by Gerard Huet, Xavier Leroy, and others. CAML went through a number of versions, including \"Caml light\" and finally \"Objective Caml\" (also known as \"OCaml\"), which appeared in 1996. OCaml included object-oriented features, making it a multi-paradigm language (functional, imperative, and object-oriented), though it is mainly used as a functional language. In parallel with the development of Caml dialects, the proof assistant Coq was developed at INRIA, and one of the main motivations for the development of OCaml at INRIA was to serve as the implementation language for Coq.</p> <p>Note</p> <p>If you are interested in proof assistants, you should take CS 128, which is a course on interactive theorem proving using Coq.</p> <p>OCaml is currently an extremely popular language in computer science education, especially for courses on functional programming and compilers. OCaml has also spread beyond academia, and is now used a lot in financial institutions such as Jane Street Capital, who have also been very active in improving the OCaml infrastructure. OCaml has also been used for compiler development by many groups, including Facebook (the Hack language) and the Rust developers; both the Hack and Rust compilers were originally written in OCaml. Other industrial users of OCaml are listed on this page. While the core language of OCaml is extremely stable, OCaml is still under heavy development; version 5 of the language was recently released, containing new support for parallel programming and an innovative effect handling system.</p>"},{"location":"intro/history/#a-brief-history-of-cs-4","title":"A brief history of CS 4","text":"<p>In the early 2000s, Andre Dehon took over the Caltech CS 1 course and based it on the MIT 6.001 course, which used SICP as the textbook and Scheme (a Lisp dialect) as the programming language. Mike Vanier took over this course after a few years, first with Ben Brantley co-teaching, then by himself. This version of CS 1 was never broadly popular; though some students liked it a lot, most felt that it was too difficult and abstract for a course aimed at freshmen, many of whom had little programming experience. In 2009, CS 1 was completely overhauled (by Mike) to use Python as its programming language. Mike still wanted to keep teaching the old CS 1 material, though, so CS 4 was created. Originally, CS 4 still used Scheme as the language and SICP as the textbook, but more advanced material was soon incorporated.<sup>5</sup> After a few years, Mike got tired of using Scheme because he found it difficult to debug due to the syntax, the lack of type checking, and the unstructured kind of object-oriented programming that is used in many parts of SICP. Mike had been programming a lot in OCaml and Haskell at that time, and had already been giving a couple of lectures introducing OCaml at the end of CS 4. In 2016, Mike switched the entire course over to OCaml. Fortunately, most of the SICP exercises used in the course were not Scheme-specific and worked fine in OCaml.<sup>6</sup> Unexpectedly, switching to OCaml had the effect of raising the average grade significantly! We think this is because the OCaml type checker tends to refuse to pass code until it is either correct or much closer to correct than would be the case in a dynamically-typed language like Scheme. Since then, the course has evolved steadily to incorporate new material and refine old material.</p> <ol> <li> <p>The Haskell functional programming language is named after Haskell Curry.\u00a0\u21a9</p> </li> <li> <p>This depends on what your definition of \"simple\" is.  In some ways, the combinatory logic systems of Sch\u00f6nfinkel and Curry are simpler than lambda calculus.\u00a0\u21a9</p> </li> <li> <p>The use of the acronym \"ML\" to mean \"Machine Learning\" is a much more recent development.\u00a0\u21a9</p> </li> <li> <p>The name \"CAML\" originally meant \"Categorical Abstract Machine Language\", which means something in the context of the original implementation.  However, that implementation was replaced by a different one, so the name \"CAML\" survives for historical reasons only.\u00a0\u21a9</p> </li> <li> <p>Such as the Y Combinator lecture, which is Mike's favorite lecture.\u00a0\u21a9</p> </li> <li> <p>In fact, many were significantly improved in OCaml due to OCaml's better facilities for type definition.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/motivation/","title":"Motivation","text":"<p>Here we'll talk about why we think you should learn the material in this course, and what you can hope to gain from taking it.</p>"},{"location":"intro/motivation/#what-are-the-goals-of-this-course","title":"What are the goals of this course?","text":"<p>Very broadly speaking, I would say that the goals of this course are:</p> <ol> <li>to make you a better programmer,</li> <li>to deepen your understanding of programming,</li> <li>to teach you to think about programming at a higher level,</li> <li>and to learn some beautiful ideas.</li> </ol> <p>We also hope that you have fun doing it, because programming should be fun! If it isn't fun, we're doing something wrong, and you should complain.<sup>1</sup></p> <p>The goals just given can be approached in many different ways. Programming is a big field, and there is no shortage of useful information on how to improve yourself as a programmer. Similarly, there are lots of beautiful ideas in programming, and we can't cover all of them in this course! What we can do is cover interesting and useful programming methods and ideas that most of you haven't encountered before. Some of these ideas are unfamiliar even to professional programmers who have been programming for a living for decades.</p> <p>If we can open your eyes to some of these ideas, if we help you see that there is more to programming than just grinding out solutions to problems, that programs can be beautiful as well as (ahem) functional, then we've done our job.</p> <p>Our way of approaching these goals will be to teach you a new way of writing programs, a way that is usually referred to as \"functional programming\".</p>"},{"location":"intro/motivation/#what-is-functional-programming","title":"What is functional programming?","text":"<p>What functional programming is will take many lectures to describe fully, but we can say a few things about it here.</p> <p>It's important to realize that functional programming isn't a yes/no proposition. There are many aspects of functional programming, and some languages support some of them but not others. Even languages that call themselves functional programming languages can have significant differences in how they implement these ideas. Conversely, languages that do not call themselves functional programming languages can still support many features of functional languages. Python is one such language; if you want to, you can program in a functional style in Python, for the most part. However, real \"functional languages\" make this style of programming more convenient and more efficient than languages that aren't specifically functional.</p> <p>The overall goal of functional programming is to make programming easier. This has two interrelated aspects. Compared to programs written in non-functional languages:</p> <ul> <li>programs are shorter</li> <li>programs have fewer bugs</li> </ul> <p>Some important aspects of functional languages that contribute to these goals include the following.</p> <ul> <li> <p>Functions are data,   and functions can be passed as arguments to other functions,   returned from functions,   created on-the-fly,   and stored into and retrieved from data structures.   Functions that take or return functions   are referred to as higher-order functions,   and they are massively useful!   They can drastically cut down on the amount of repeated code in programs,   which lets programs be shorter.   Also, since programming patterns can be captured in higher-order functions   and re-used in many different contexts,   once you've debugged a higher-order function   it will work correctly in many different contexts,   which means your programs will have fewer bugs.</p> </li> <li> <p>Functional programming emphasizes immutable data,   which means data that doesn't change.   Functional programmers prefer to compute new data than change old data.   So even things as basic as variables   (names whose values change as the program evolves) are discouraged,   which means that we need to find new ways to do   what we previously did with variables.   Functional languages also discourage mutable data structures like arrays   (where you can change the contents of a part of the data structure),   preferring immutable data structures   like singly-linked lists and immutable maps and sets   (where you can't change the contents of the data structure,   but you can create new ones that extend the old ones).   It turns out that avoiding variables and using immutable data structures   gets rid of large classes of potential bugs.</p> <p>Note</p> <p>Don't panic! Just because functional programming languages discourage the use of mutable variables and mutable data structures doesn't mean the languages don't have them.<sup>2</sup> It's just that you usually reserve them for situations where they really are the best choice, instead of just using them everywhere.</p> </li> <li> <p>Functional languages discourage the use of looping constructs,   preferring to use recursion or higher-order functions   to achieve the same effect.   This heavy use of recursion is quite startling   to new functional programmers,   but after a while it becomes as natural as using loops.   Also, unlike loops, recursive functions   are much less likely to have subtle off-by-one errors,   which means fewer bugs.</p> <p>Note</p> <p>Once again, \"discourage\" doesn't mean that looping constructs don't exist (at least, they exist in OCaml). But you never need them, so you almost never use them.</p> <p>Also, one hidden benefit of this course is that by the end of it, you will understand recursion completely, even if you're a bit fuzzy on it at the beginning.</p> </li> <li> <p>Most, but not all, functional languages are statically typed,   which means that they make sure that code has no type errors   before it executes.   Many non-functional languages are also statically typed   (for instance, C, C++, and Java),   but the type system of functional languages is much more powerful   (able to express more features of data in the type system),   and also easier to use   (because of type inference,   which means you rarely have to declare types in your code).   Most functional languages   also provide a very powerful pattern matching feature   that works with the type system;   this can lead to very concise code   which expresses the intent of the programmer in a clean and natural style.</p> <p>A powerful static type system, coupled with pattern matching, allows code to be shorter and have fewer bugs.</p> <p>Note</p> <p>In fact, some people will tell you that in functional languages, \"if it compiles, it works!\". Sadly, this isn't always true, but it's surprising how often this is the case.</p> </li> </ul>"},{"location":"intro/motivation/#why-learn-functional-programming","title":"Why learn functional programming?","text":"<p>We learn functional programming because:</p> <ul> <li>we want to write less code,</li> <li>we want our code to be correct,</li> <li>we want to think at a higher level,</li> <li>and we want our code to be beautiful!</li> </ul> <p>We've talked above about how functional programming contributes to the first two goals. Why should functional programs be more \"beautiful\" than code written in non-functional languages? How can functional languages allow us to think at a higher level? What does \"higher level\" even mean?</p> <p>These are aesthetic judgments, and reasonable people can disagree on this. In fact, you might be wondering why we should even care about how \"beautiful\" code is. I think a good point of comparison is with mathematical proofs. Most true statements in mathematics can be proved in more than one way. However, good mathematicians definitely favor certain kinds of proofs, which they call more \"beautiful\" or \"elegant\" than others. The mathematician Paul Erd\u00f6s used to talk about \"the Book\", which was where God kept the most perfect proofs of each theorem. There is even a whole book of such proofs, called, not surprisingly, Proofs from the Book.<sup>3</sup> And since computer programs are in some sense concrete crystallizations of mathematical ideas, if you can accept that some proofs are more \"beautiful\" than others, then it's also likely that some ways of writing code are more \"beautiful\" than others. But what would this elusive concept of \"code beauty\" entail?</p> <p>I think one important aspect of beautiful code is that it's lean \u2014 it has nothing superfluous in it. It's concise without being cryptic. It expresses the essence of a computation in as straightforward and clear a way as it can be expressed.</p> <p>The problem with this criterion is that what is \"straightforward\" and \"clear\" depends greatly on the way you've been taught to think about programming. And this is where the \"higher level thinking\" comes in. For example, Python is often praised as a language in which code is extremely clear and readable, and that's true, if you restrict yourself only to the kind of programming idioms that are found in Python (and in most other languages). But functional languages introduce a whole new set of idioms, and once you understand them, you can think at a higher level. And because of this, you can write better code.</p> <p>Here's a simple example. Let's write a function that takes a list of integers and returns a new list, where the new list has all the same numbers as the original list, but multiplied by 2. Also, the original list shouldn't be altered.</p> <p>In Python, you might write this function as follows:</p> <pre><code>def double_list(lst):\n    new_lst = lst[:]\n    for i in range(len(new_lst)):\n        new_lst[i] *= 2\n    return new_lst\n</code></pre> <p>This is pretty straightforward. You copy the list, and then go through each element of the new list, multiplying the element by 2 and storing the new value in place of the old value. Then you return the new list.</p> <p>In OCaml, you could write this function like this:</p> <pre><code>let double_list lst = List.map (fun x -&gt; x * 2) lst\n</code></pre> <p>In fact, you can write it even more concisely:</p> <pre><code>let double_list = List.map (fun x -&gt; x * 2)\n</code></pre> <p>What this is saying is \"take a function which doubles its argument (<code>fun x -&gt; x * 2</code>) and apply (map) it to each element of a list, collecting all the values in a new list\". This includes two ideas which are fundamental to functional languages: anonymous functions (the doubling function doesn't have a name), and mapping a function over a list (although other data structures can also be mapped over). The <code>map</code> function is also a \"higher-order\" function, since its first argument is itself a function. And once you understand these ideas, you can write more elegant code. In this case, we took five lines of Python and reduced them to one line of OCaml.</p> <p>I can't leave this without also mentioning that you can write this code in a functional style in Python as well:</p> <pre><code>def double_list(lst): return list(map(lambda x: x * 2, lst))\n</code></pre> <p>It's not quite as simple as the OCaml code, but it's pretty close.<sup>4</sup> (On the other hand, the OCaml code is type checked, but the Python code isn't.)</p> <p>So Python supports some (but not all) ideas from functional programming.<sup>5</sup> But a lot of Python programmers are unaware of this. So one benefit of learning functional programming is that you'll be able to use some of the functional programming ideas you learn in the languages you already know! In fact, it may totally change the way you write code even in non-functional languages. And the new code you write will be shorter and more elegant than the code you used to write.</p> <p>This is just a very simple example. CS 4 will show you many more kinds of beautiful code, and (more importantly) will teach you how to think about computational processes at a higher level, which will make the code you write better no matter what language you use.</p>"},{"location":"intro/motivation/#is-functional-programming-better-than-other-kinds-of-programming","title":"Is functional programming better than other kinds of programming?","text":"<p>It depends on the application.</p> <p>We love functional programming, but we are not zealots. Functional programming is a great fit for a lot of different programming tasks, but it isn't right for everything. Furthermore, in practice, language choice is usually much more likely to be made because of the availability of libraries than because of any intrinsic quality of the language.</p> <p>For instance, if you are programming graphical user interfaces (GUIs), you would probably be better off using Java than OCaml, because Java has more and better GUI libraries than OCaml does, and object-oriented programming has proven to be a good fit for this task. Or if you are doing numerical computations for machine learning or data science, you might be better off using Python with NumPy and Pandas, because those libraries are better suited for those tasks than anything in OCaml (at least currently).</p> <p>On the other hand, if you're doing anything that involves very complex algorithms, symbolic manipulations, or are writing an interpreter (e.g. if you take CS 131) or a compiler (e.g. if you take CS 164), functional programming and OCaml are a great fit. It takes time to learn which kinds of problems are best suited to which languages, but having a functional language in your toolkit is a good idea, not least because other languages (even Java!) keep borrowing ideas from functional languages.</p>"},{"location":"intro/motivation/#why-are-we-using-ocaml","title":"Why are we using OCaml?","text":"<p>There are a number of programming languages that are usually considered to be \"functional programming languages\". Why are we choosing to use OCaml instead of another one (say, Haskell)?</p> <p>There are three reasons for this:</p> <ol> <li> <p>OCaml contains all the features one would expect to have in a full-fledged functional programming language.</p> </li> <li> <p>OCaml is easier to learn than many other functional languages. In particular, it's easier to learn than Haskell. (But after learning OCaml, Haskell is a lot easier to learn; take CS 115 if you're interested in Haskell.)</p> </li> <li> <p>OCaml is not dogmatic. In addition to its functional features, OCaml also fully supports imperative and object-oriented programming, and sometimes, those features are exactly what you need in order to write the best code.</p> </li> </ol> <p>In addition to being a great on-ramp to the world of functional programming, OCaml is a useful language in its own right, and is used as a production language in a number of companies, including Jane Street Capital, Bloomberg, and Facebook.</p>"},{"location":"intro/motivation/#going-further","title":"Going further","text":"<p>If you want to go deeper into the world of functional programming after taking this course, take CS 115 and you'll learn Haskell and how it differs from the ideas you'll learn in CS 4. In some ways, Haskell is a \"super-OCaml\" which pushes functional programming ideas to their limits. In other ways (notably the module system and its multi-paradigm nature) OCaml still has the edge.</p> <p>Recently, the Rust programming language has become quite popular. Rust is a systems-level language which does not use garbage collection and which is used for computationally-intensive tasks. The Rust compiler was originally written in OCaml, but more interesting to us is that the Rust language has borrowed many features from OCaml, including algebraic datatypes, pattern matching and an emphasis on immutable data. If you want to learn Rust, learning OCaml is an excellent starting point. In fact, Rust is basically as close to a functional language as you can get without having garbage collection.</p> <p>Note</p> <p>There is a CS 11 Rust track which is taught in the Spring term, so take that if you are interested in Rust.</p> <p>In addition to Rust, there are other languages that are even closer to OCaml, including F#, which is a language very similar to OCaml for the .NET platform, and ReScript and ReasonML, which are OCaml dialects which compile to Javascript. All of these languages are used for very practical purposes (including web development), so they aren't just academic languages. And there are many other functional languages that share many features with OCaml, including Lisp dialects (Common Lisp, Scheme, Racket, and Clojure), Erlang dialects (Erlang itself and Elixir), and many others.</p> <p>Learning OCaml will make it much easier to learn any of these languages.</p> <ol> <li> <p>That is, except for the substitution model evaluations. Those aren't much fun, but we think that they're worth doing \u2014 once.\u00a0\u21a9</p> </li> <li> <p>At least, OCaml has them. Haskell, another well-known functional language, kind-of has them, but the story is more complicated. Take CS 115 to learn all about Haskell.\u00a0\u21a9</p> </li> <li> <p>However, to the best of our knowledge, God was not directly involved in the preparation of this book.\u00a0\u21a9</p> </li> <li> <p>You can make the Python code even shorter using list comprehensions:</p> <pre><code>def double_list(lst): return [x * 2 for x in lst]\n</code></pre> <p>OCaml doesn't have list comprehensions, though other functional languages (like Haskell) do. In fact, Python borrowed the idea of list comprehensions from Haskell.\u00a0\u21a9</p> </li> <li> <p>One very important idea from functional programming is called tail call optimization, which we'll be learning about. People have been begging Guido van Rossum (the author of Python) to add tail call optimization to Python for a long time, but so far he has vetoed it.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/welcome/","title":"Welcome to CS 4!","text":"<p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about the material.  In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>coding notes and tips</li> <li>readings on particular topics</li> </ul> <p>and anything else we consider useful. Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>lecture slides</li> <li>code supplied to students for assignments</li> <li>exams (midterm and final)</li> <li>some administrative information e.g. contact information</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"intro/welcome/#instructor-and-course-staff","title":"Instructor and course staff","text":"<p>The course instructor is Mike Vanier (mvanier@cms.caltech.edu).</p> <p>The teaching assistants are listed in the syllabus. Their contact information will be posted on the course Canvas page.</p>"},{"location":"intro/welcome/#what-this-course-is-about","title":"What this course is about","text":"<p>This course is officially titled \"Fundamentals of Computer Programming\", but that's a vague name that says basically nothing about what the course is about. What this course actually is is an introduction to functional programming using the OCaml programming language.</p> <p>More importantly, this is a course on teaching you a new, better, and more enjoyable way of programming.<sup>1</sup> What this means will be fleshed out in the lectures and in the assignments.</p> <p>This course will be a bit disorienting and even mind-bending at times, but our primary goal is to expose you to new ideas, new ways of programming, and for you to have an enjoyable time learning. If you aren't having fun, we aren't doing our job right, so let us know what you don't like so we can improve it!</p> <p>For more general information about the course, please read the motivation and history pages.</p> <ol> <li> <p>All opinions expressed are the views of the instructor and do not necessarily reflect the views of other instructors, other professors in the Caltech CMS department, or the majority of programmers  and employers of programmers in the world.\u00a0\u21a9</p> </li> </ol>"},{"location":"readings/ocaml_cheat_sheet/","title":"OCaml syntax cheat sheet","text":"<p>OCaml is a great language, but its syntax is not its best feature. More importantly, the syntax is probably quite different from any other language you know, so getting comfortable with it will take some time.</p> <p>In this document we describe aspects of OCaml syntax that are most likely to be confusing and/or counterintuitive, as well as some other features which may trip you up. This document is not a complete description of OCaml syntax. For that, consult the lectures and the online OCaml documentation. We also refer you to the official OCaml cheat sheet which is here.</p> <p>Along the way, we will also sometimes mention non-syntactic aspects of OCaml that are confusing to new OCaml programmers.</p>"},{"location":"readings/ocaml_cheat_sheet/#operators","title":"Operators","text":""},{"location":"readings/ocaml_cheat_sheet/#operator-underloading","title":"Operator underloading","text":"<p>OCaml doesn't overload most of its operators. Notably, arithmetic operators like <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> are not overloaded. Instead, they are considered to be exclusively integer operators. The corresponding operators on floating-point numbers have an extra dot (<code>.</code>) at the end e.g. <code>+.</code>, <code>-.</code>, <code>*.</code> and <code>/.</code>. Confusingly, the floating-point power operator (<code>**</code>) doesn't have a dot at the end.</p> <pre><code># let sumsq x y = x *. x +. y *. y;;\nval sumsq : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre> <p>This is by far the most annoying aspect of OCaml's syntax. The reason for it is so that every operator has a very specific type, which makes type inference much simpler.</p>"},{"location":"readings/ocaml_cheat_sheet/#operator-overloading","title":"Operator overloading","text":"<p>On the other hand, OCaml does overload some operators. The comparison/equality operators (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) are all polymorphic, which means they work on arbitrary OCaml datatypes. (This is also true of the <code>max</code> and <code>min</code> functions.) One exception: you are not allowed to compare functional values, though you can check identity:</p> <pre><code># abs;;\n- : int -&gt; int = &lt;fun&gt;\n# abs == abs;;\n- : bool = true\n# abs = abs;;\nException: Invalid_argument \"compare: functional value\".\n# max abs abs;;\nException: Invalid_argument \"compare: functional value\".\n</code></pre> <p>We'll discuss equality comparisons and identity comparisons below.</p>"},{"location":"readings/ocaml_cheat_sheet/#operators-as-functions","title":"Operators as functions","text":"<p>This is a good feature, but it can be confusing as well. Operators can be converted into two-argument functions by wrapping parentheses around them. For instance, the operator <code>+</code> can be made into the two-argument function <code>(+)</code>.</p> <pre><code># (+);;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 + 3;;\n- : int = 5\n# (+) 2 3;;\n- : int = 5\n</code></pre> <p>The only time this causes problems is with the multiplication operators (<code>*</code>) and (<code>*.</code>), because if the left parenthesis is next to the asterisk OCaml thinks it's the start of a comment:</p> <pre><code># (*);;\nLine 1, characters 0-3:\n1 | (*);;\n    ^^^\nWarning 1: this `(*' is the start of a comment.\nHint: Did you forget spaces when writing the infix operator `( * )'?\n* *);;\n# ( * ) ;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# ( *);;\nLine 1, characters 2-4:\n1 | ( *);;\n      ^^\nWarning 2: this is not the end of a comment.\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>(Notice that after the first error the prompt changed to <code>*</code> (which means that OCaml thinks we're still inside a comment) and we had to manually insert a <code>*)</code> to close the comment.)</p> <p>Fortunately, here OCaml is smart enough to catch this problem and issue a warning. However, this doesn't always happen (see below).</p>"},{"location":"readings/ocaml_cheat_sheet/#equalityinequality-operators","title":"Equality/inequality operators","text":"<p>OCaml has two different equality operators and two different inequality operators:</p> <ul> <li>equality: <code>=</code> and <code>==</code></li> <li>inequality: <code>&lt;&gt;</code> and <code>!=</code></li> </ul> <p>Almost always, you want to use the <code>=</code> operator for equality testing and the <code>&lt;&gt;</code> operator for inequality testing. They test for structural equality i.e. whether one operand is equivalent to the other (or \"has the same contents\"). The <code>==</code> and <code>!=</code> operators check for identity i.e. whether two things are the exact same thing in memory. Even though this may sometimes work, it can lead to very difficult-to-find bugs. (It's unfortunate that the operators you shouldn't use in OCaml are the ones you should use in most other languages.)</p> <pre><code># \"foo\" = \"bar\";;\n- : bool = false\n# \"foo\" = \"foo\";;\n- : bool = true\n# \"foo\" == \"foo\";;\n- : bool = false   (* not the same object in memory! *)\n# \"foo\" &lt;&gt; \"bar\";;\n- : bool = true\n# \"foo\" != \"bar\";;\n- : bool = true\n# \"foo\" &lt;&gt; \"foo\";;\n- : bool = false\n# \"foo\" != \"foo\";;\n- : bool = true\n</code></pre> <p>Here, the two <code>\"foo\"</code>s are different objects in memory.</p> <pre><code># let x = \"foo\";;\nval x : string = \"foo\"\n# x = x;;\n- : bool = true\n# x == x;;\n- : bool = true\n</code></pre> <p>Here, <code>x</code> is equal to itself and is also the same object in memory as itself.</p>"},{"location":"readings/ocaml_cheat_sheet/#word-operators","title":"Word operators","text":"<p>OCaml has a number of infix operators which are words. Here they are:</p> Operator Description <code>mod</code> integer remainder (modulus) <code>asr</code> arithmetic shift right <code>lsr</code> logical shift right <code>lsl</code> logical shift left <code>land</code> logical (bitwise) AND <code>lor</code> logical (bitwise) OR <code>lxor</code> logical (bitwise) XOR <code>lnot</code> logical (bitwise) NOT <p>You probably won't need any of these except the <code>mod</code> operator, which is handy:</p> <pre><code># 5 mod 2;;\n- : int = 1\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#unusual-operators","title":"Unusual operators","text":"<p>The built-in OCaml operators are described in the documentation for the <code>Stdlib</code> library, which is here.</p> <p>Note especially the following operators:</p> Operator Description <code>^</code> string concatenation <code>^^</code> format string concatenation <code>@</code> list concatenation <code>~-</code> unary negation <code>~-.</code> unary float negation <code>@@</code> function application (<code>f @@ x</code> is the same as <code>f x</code>) <code>|&gt;</code> reverse function application (<code>x |&gt; f</code> is the same as <code>f x</code>) <code>!</code> dereference a <code>ref</code> cell <code>:=</code> assignment into a <code>ref</code> cell <p>Note that unary negation can also be indicated by a <code>-</code> or <code>-.</code> operator without a left-hand operand, if there is no ambiguity. The <code>~-</code> and <code>~-.</code> operators are strictly unary operators and can work in contexts where conventional unary negation doesn't:</p> <pre><code># -1;;\n- : int = -1\n# abs (-1);;\n- : int = 1\n# abs -1;;\nLine 1, characters 0-3:\n1 | abs -1;;\n    ^^^\nError: This expression has type int -&gt; int\n       but an expression was expected of type int\n</code></pre> <p>OCaml is telling you you can't subtract 1 from the <code>abs</code> function.</p> <pre><code># ~-1;;\n- : int = -1\n# abs ~-1;;\n- : int = 1\n</code></pre> <p>This works. Here's another example where these operators are handy:</p> <pre><code># List.map (~-) [1;2;3;4;5];;\n- : int list = [-1; -2; -3; -4; -5]\n</code></pre> <p>Nevertheless, most people don't bother with the unary negation operators and just add extra parentheses if needed.</p> <p>The function application operators are interesting. The reverse function application operator <code>|&gt;</code> is nearly always used to chain together a series of computations, each taking the result of the previous one:</p> <pre><code># open List;;\n# map (fun x -&gt; x * 2) [1; 2; 3; 4; 5];;\n- : int list = [2; 4; 6; 8; 10]\n# filter (fun x -&gt; x &gt; 5) (map (fun x -&gt; x * 2) [1; 2; 3; 4; 5]);;\n- : int list = [6; 8; 10]\n# List.fold_left max 0\n    (filter (fun x -&gt; x &gt; 5) (map (fun x -&gt; x * 2) [1; 2; 3; 4; 5]));;\n- : int = 10\n# [1; 2; 3; 4; 5]\n    |&gt; map (fun x -&gt; x * 2)\n    |&gt; filter (fun x -&gt; x &gt; 5)\n    |&gt; List.fold_left max 0;;\n- : int = 10\n</code></pre> <p>I'd argue that the last expression is much more readable than the second-last one. You read it as \"take the list from 1 to 5, double all the numbers, keep only the numbers that are greater than 5, and find the maximum\". (You don't have to line up the <code>|&gt;</code> operators, but it looks good that way.)</p> <p>The function call after a <code>|&gt;</code> gets one less argument than usual, which is supplied by the result of evaluating the expression before the <code>|&gt;</code>.</p> <p>The <code>@@</code> operator might seem useless since <code>f @@ x</code> is the same as <code>f x</code>. However, its precedence is extremely low, so the expression to the right of the <code>@@</code> will be evaluated before calling the function. This can allow us to drop some parentheses:</p> <pre><code># abs (-2 + 1);;\n- : int = 1\n# abs @@ (-2 + 1);;\n- : int = 1\n# abs @@ -2 + 1;;\n- : int = 1\n</code></pre> <p>Note that the expression <code>-2 + 1</code> is evaluated in the last case before calling the <code>abs</code> function. This can be useful if you have a lot of functions acting on the result of other functions. (Note that this is just like the <code>|&gt;</code> operator except that the function calls are arranged right-to-left instead of left-to-right.) Another example:</p> <pre><code># List.rev (List.sort compare [4;2;5;2;7;5;4;1;3;9;0]);;\n- : int list = [9; 7; 5; 5; 4; 4; 3; 2; 2; 1; 0]\n# List.rev @@ List.sort compare [4;2;5;2;7;5;4;1;3;9;0];;\n- : int list = [9; 7; 5; 5; 4; 4; 3; 2; 2; 1; 0]\n</code></pre> <p>One of the least-used operators is the <code>^^</code> operator, which concatenates strings used as format strings. We will talk about this below.</p> <p>Note that some libraries define their own operators (see below). For instance, the <code>Num</code> library defines operators on rational numbers: <code>+/</code>, <code>-/</code>, <code>*/</code>, and <code>//</code>. (These also work with arbitrary-precision integers, since the <code>Num</code> data type contains both these and arbitrary-precision rationals.)</p>"},{"location":"readings/ocaml_cheat_sheet/#defining-new-operators","title":"Defining new operators","text":"<p>Unusually for programming languages, OCaml allows you to define your own operators. All user-defined operators must be made from \"operator characters\" and get their operator precedence and associativity from the first character of the operator (if it is itself an operator).</p> <pre><code># let (++) x y = x * y;;\nval ( ++ ) : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 ++ 3;;\n- : int = 6\n# 1 + 2 ++ 3;;\n- : int = 9\n</code></pre> <p>Note that the <code>++</code> operator has the same precedence as the <code>+</code> operator, so the expression <code>1 + 2 ++ 3</code> is evaluated from left to right. Let's try this with a new operator that starts with the <code>*</code> character instead:</p> <pre><code># let (*+) x y = x * y;;\n* *);;\nLine 2, characters 2-4:\n2 | *);;\n      ^^\nError: Syntax error\n</code></pre> <p>Oops! We forgot that the <code>(*</code> characters will be interpreted as the start of a comment. Notice that we didn't even get an error message; the prompt just turned to a <code>*</code> (indicating that OCaml thought we were still in a comment). When we added the <code>*)</code> to terminate the comment, we got an unhelpful error message.</p> <pre><code># let ( *+ ) x y = x * y;;\nval ( *+ ) : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 *+ 3;;\n- : int = 6\n# 1 + 2 *+ 3;;\n- : int = 7\n</code></pre> <p>Now we see that the <code>*+</code> operator has the same precedence as the <code>*</code> operator.</p> <p>Tip</p> <p>When defining new operators, it's always a good idea to put a blank space after the <code>(</code> and before the <code>)</code> characters that surround the operator.</p> <p>You can even define unary prefix operators, as long as they start with the <code>!</code> character:</p> <pre><code># let ( !++ ) x = x := !x + 1;;\nval ( !++ ) : int ref -&gt; unit = &lt;fun&gt;\n# let r = ref 0;;\nval r : int ref = {contents = 0}\n# !++ r;;\n- : unit = ()\n# !r;;\n- : int = 1\n</code></pre> <p>We will have more to say about <code>ref</code> types below.</p>"},{"location":"readings/ocaml_cheat_sheet/#printf-and-format-strings","title":"<code>printf</code> and format strings","text":"<p>OCaml has a <code>printf</code> function (technically, <code>Printf.printf</code>) which has a number of pecularities. Check this out:</p> <pre><code># Printf.printf;;\n- : ('a, out_channel, unit) format -&gt; 'a = &lt;fun&gt;\n# Printf.printf \"%d\\n\";;\n- : int -&gt; unit = &lt;fun&gt;\n# \"%d\\n\";;\n- : string = \"%d\\n\"\n</code></pre> <p>So even though <code>\"%d\\n\"</code> appears to be just a string, somehow it can also be the first argument of <code>Printf.printf</code>, where it is somehow compatible with the type <code>('a, out_channel, unit) format</code>. What is actually happening is that OCaml is turning a literal string into a something that does not have the <code>string</code> type, but is instead something called a format string. You can actually convert strings to format strings manually, but do not expect to understand the process:</p> <pre><code># format_of_string;;\n- : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n&lt;fun&gt;\n# let fs = format_of_string \"%d\\n\";;\nval fs :\n  (int -&gt; '_weak5, '_weak6, '_weak7, '_weak8, '_weak8, '_weak5) format6 =\n  CamlinternalFormatBasics.Format\n   (CamlinternalFormatBasics.Int (CamlinternalFormatBasics.Int_d,\n     CamlinternalFormatBasics.No_padding,\n     CamlinternalFormatBasics.No_precision,\n     CamlinternalFormatBasics.Char_literal ('\\n',\n      CamlinternalFormatBasics.End_of_format)),\n   \"%d\\n\")\n# Printf.printf fs;;\n- : int -&gt; unit = &lt;fun&gt;\n# Printf.printf fs 10;;\n10\n- : unit = ()\n</code></pre> <p>Note</p> <p>Another peculiarity is that <code>format_of_string</code> only works when the string argument is a literal string; its first argument is not actually a string. Don't worry about any of this!</p> <p>Regardless of the weird types that format strings have, when you give a (literal) format string as the first argument of <code>Printf.printf</code>, the result will have the correct type (here, <code>int -&gt; unit</code> because it takes an <code>int</code> and returns a value of type <code>unit</code>).</p> <p>Since format strings aren't strings, this doesn't work:</p> <pre><code># let fs = \"%d\\n\";;\nval fs : string = \"%d\\n\"\n# Printf.printf fs 10;;\nLine 1, characters 14-16:\n1 | Printf.printf fs 10;;\n                  ^^\nError: This expression has type string but an expression was expected of type\n         ('a -&gt; 'b, out_channel, unit) format =\n           ('a -&gt; 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n</code></pre> <p>One issue with format strings is that sometimes you would like to be able to divide them over multiple lines. However, you can't just concatenate them as if they were strings:</p> <pre><code># Printf.printf (\"int: %d\\t\" ^ \"string: %s\\n\") 10 \"foo\";;\nLine 1, characters 14-44:\n1 | Printf.printf (\"int: %d\\t\" ^ \"string: %s\\n\") 10 \"foo\";;\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a -&gt; 'b -&gt; 'c, out_channel, unit) format =\n           ('a -&gt; 'b -&gt; 'c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n</code></pre> <p>Instead, you have to use the special format string concatenation operator <code>(^^)</code> to do the job:</p> <pre><code># Printf.printf (\"int: %d\\t\" ^^ \"string: %s\\n\") 10 \"foo\";;\nint: 10 string: foo\n- : unit = ()\n# (^^) ;;\n- : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt;\n    ('f, 'b, 'c, 'e, 'g, 'h) format6 -&gt; ('a, 'b, 'c, 'd, 'g, 'h) format6\n= &lt;fun&gt;\n# \"int: %d\\t\" ^^ \"string: %s\\n\";;\n- : (int -&gt; string -&gt; '_weak9, '_weak10, '_weak11, '_weak12, '_weak12,\n     '_weak9)\n    format6\n=\nCamlinternalFormatBasics.Format\n (CamlinternalFormatBasics.String_literal (\"int: \",\n   CamlinternalFormatBasics.Int (CamlinternalFormatBasics.Int_d,\n    CamlinternalFormatBasics.No_padding,\n    CamlinternalFormatBasics.No_precision,\n    CamlinternalFormatBasics.Char_literal ('\\t',\n     CamlinternalFormatBasics.String_literal (\"string: \",\n      CamlinternalFormatBasics.String (CamlinternalFormatBasics.No_padding,\n       CamlinternalFormatBasics.Char_literal ('\\n',\n        CamlinternalFormatBasics.End_of_format)))))),\n \"int: %d\\t%,string: %s\\n\")\n</code></pre> <p>You probably won't need this operator much, if at all.</p>"},{"location":"readings/ocaml_cheat_sheet/#lists","title":"Lists","text":"<p>There are three important things you need to remember about lists in OCaml:</p> <ol> <li>All the elements of a list must be of the same type.</li> <li>You can't change the elements of a list.</li> <li>Elements are separated with semicolons (<code>;</code>), not commas.</li> </ol> <p>A very common pitfall is to use commas instead of semicolons, which not only doesn't do what you expect but sometimes seems to work only to fail later while giving hilariously obscure type errors. We will see why in the section on tuples below. Remember: OCaml's syntax is different from Python's!</p> <p>There is a List module with many useful functions on lists.</p>"},{"location":"readings/ocaml_cheat_sheet/#arrays","title":"Arrays","text":"<p>Syntactically, arrays are exactly like lists except that they use different delimiters. Instead of <code>[</code> and <code>]</code> arrays use <code>[|</code> and <code>|]</code>. Here is a literal array:</p> <pre><code># let my_array = [| 1; 2; 3; 4; 5 |];;\nval my_array : int array = [|1; 2; 3; 4; 5|]\n</code></pre> <p>Notice that the array has type <code>int array</code>; the type of the elements is part of the type of the array.</p> <p>Accessing elements from arrays uses the unusual <code>&lt;array&gt;.(&lt;index&gt;)</code> syntax:</p> <pre><code># my_array.(0);;\n- : int = 1\n# my_array.(4);;\n- : int = 5\n# my_array.(5);;\nException: Invalid_argument \"index out of bounds\".\n</code></pre> <p>Mutating (changing) elements in an array also uses an unusual syntax:</p> <pre><code># my_array;;\n- : int array = [|1; 2; 3; 4; 5|]\n# my_array.(0) &lt;- 42;;\n- : unit = ()\n# my_array;;\n- : int array = [|42; 2; 3; 4; 5|]\n</code></pre> <p>There is an Array module with many useful functions on arrays.</p>"},{"location":"readings/ocaml_cheat_sheet/#tuples","title":"Tuples","text":"<p>A fundamental data type in OCaml is the tuple (pronounced \"too-ple\" or \"tup-ple\" depending on your preference; I prefer \"too-ple\"). It is nothing more than a sequence of arbitrary OCaml values wrapped in parentheses, separated by commas. Tuples can (and usually do) contain data of different types.</p> <p>Note</p> <p>Tuples exist in Python too, but in that language they are almost superfluous, being basically a restricted form of lists. In OCaml, tuples are necessary because lists can only contain one type of data.</p>"},{"location":"readings/ocaml_cheat_sheet/#type-notation","title":"Type notation","text":"<p>The notation for tuple types is a bit weird; they are written as the product of the individual types:</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n</code></pre> <p>This tuple has the type <code>int * string * float</code>, which is a type-theoretic \"product\" of the individual types. This notion of \"product\" is basically the same as the set-theoretic notion, but don't worry about that. Just make sure you realize that this use of the <code>*</code> operator doesn't represent multiplication.</p>"},{"location":"readings/ocaml_cheat_sheet/#implicit-parentheses","title":"Implicit parentheses","text":"<p>Unfortunately, OCaml (like Python) allows you to omit the parentheses in many situations:</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n# 1, \"foo\", 3.14;;\n- : int * string * float = (1, \"foo\", 3.14)\n# let tup = (1, \"foo\", 3.14);;\nval tup : int * string * float = (1, \"foo\", 3.14)\n# let tup = 1, \"foo\", 3.14;;\nval tup : int * string * float = (1, \"foo\", 3.14)\n</code></pre> <p>\"So what?\", you say. \"What's the big deal?\" Well, look at this code:</p> <pre><code># [1; 2; 3];;\n- : int list = [1; 2; 3]\n</code></pre> <p>This is the correct way to write a list, using semicolons as separators. A common error is to write lists with commas, which gives this:</p> <pre><code># [1, 2, 3];;\n- : (int * int * int) list = [(1, 2, 3)]\n</code></pre> <p>Note that this is not a syntax error! Instead, OCaml has interepreted the commas as meaning a tuple, so it thinks you want a list with a single element which is a 3-tuple. Then, when you try to use this list, it will not do what you expect, and the error messages will probably not be very helpful.</p> <p>We recommend that you never write a tuple without explicit parentheses. However, this will not fix the problem above, because OCaml will still interpret the wrongly-written \"list\" as a list of N-tuples. Ultimately, you just have to be able to recognize this problem for what it is, and learn to write lists the right way.</p>"},{"location":"readings/ocaml_cheat_sheet/#commas-vs-semicolons","title":"Commas vs. semicolons","text":"<p>What about the opposite problem: writing a tuple with semicolons as separators instead of using commas?</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n# (1; \"foo\"; 3.14);;\nLine 1, characters 1-2:\n1 | (1; \"foo\"; 3.14);;\n     ^\nWarning 10: this expression should have type unit.\nLine 1, characters 4-9:\n1 | (1; \"foo\"; 3.14);;\n        ^^^^^\nWarning 10: this expression should have type unit.\n- : float = 3.14\n</code></pre> <p>A parenthesized expression with semicolon separators is a sequence expression, which is mainly used in imperative code. (You can also write them with <code>begin</code>/<code>end</code> delimiters instead of parentheses, which we prefer.) In a sequence expression, all but the last subexpression should have type <code>unit</code>, or you get warnings (as you see above). You probably won't run into this pitfall, but you should be aware of it. We will talk about sequence expressions more below when we discuss imperative programming.</p>"},{"location":"readings/ocaml_cheat_sheet/#records","title":"Records","text":"<p>Records are basically a generalization of tuples where each component of the record has a name (called a \"field name\", so each component is a \"field\" of the record). You need to define a record type before using a record.</p> <pre><code>type my_record = { foo : int; bar : string }\n</code></pre> <p>Then you can create records by giving the field names and the values like this:</p> <pre><code>let a_record = { foo = 10; bar = \"ten\" }\n</code></pre> <p>You can extract the contents of a record using the \"dot notation\" as in most programming languages:</p> <pre><code>Printf.printf \"foo field: %d\\n\" a_record.foo\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#pattern-matching-and-field-punning","title":"Pattern matching and field punning","text":"<p>To pattern match on a record, you give the field names and corresponding variable names that you choose.</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x = x_coord; y = y_coord } = x_coord + y_coord\n</code></pre> <p>Note that <code>x</code> and <code>y</code> are field names here, and <code>x_coord</code> and <code>y_coord</code> are variable names you chose for this function.</p> <p>Note that the field names don't have to come in any particular order:</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { y = y_coord; x = x_coord } = x_coord + y_coord\n</code></pre> <p>A shortcut is to use the field name as a variable name. This is called field punning.</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x; y } = x + y\n(* Also OK: let sum_xy { y; x } = x + y *)\n</code></pre> <p>This is exactly equivalent to:</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x = x; y = y } = x + y\n</code></pre> <p>but shorter.</p>"},{"location":"readings/ocaml_cheat_sheet/#matching-a-part-of-a-record","title":"Matching a part of a record","text":"<p>Often, we only need part of a record. You could write code like this:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x = x_coord; y = y_coord } = x_coord\n</code></pre> <p>but you might get a warning about unused variable names. The solution is to use the <code>_</code> syntax:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x = x_coord; _ } = x_coord\n</code></pre> <p>The <code>_</code> means \"all other fields in the record\".</p> <p>With field punning, this becomes:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x; _ } = x\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#strings","title":"Strings","text":"<p>Strings are pretty standard in OCaml, except that the notation for accessing characters in a string is weird:</p> <pre><code># let s = \"this is a string\";;\nval s : string = \"this is a string\"\n# s.[0];;\n- : char = 't'\n# s.[9];;\n- : char = ' '\n</code></pre> <p>OCaml treats strings like a kind of specialized array. Up until recently, strings were mutable (you could change the characters in a string). Thankfully, that is no longer the case. (There is a mutable string type called <code>bytes</code> if you really need it.)</p>"},{"location":"readings/ocaml_cheat_sheet/#conditionals","title":"Conditionals","text":""},{"location":"readings/ocaml_cheat_sheet/#if-expressions","title":"<code>if</code> expressions","text":"<p>In most programming languages, <code>if</code> is a statement, but in functional languages like OCaml, <code>if</code> is an expression. This means that an <code>if</code> expression returns a value. This is nice in that you can use <code>if</code> expressions anywhere an expression is desired. For instance, this function computes the ratio of the maximum and minimum of two floats:</p> <pre><code>let scale x y = (if x &gt; y then x else y) /. (if x &gt; y then y else x)\n</code></pre> <p>(Note the <code>/.</code> operator for float division.) This is not the most elegant way to write this function, but it illustrates that <code>if</code> expressions can be embedded in larger expressions.</p> <p>Since <code>if</code> is an expression, <code>if</code> expressions must have a specific type regardless of whether the test clause of the <code>if</code> returns <code>true</code> or <code>false</code>. Therefore, both branches of the <code>if</code> (the <code>then</code> branch and the <code>else</code> branch) must be expressions which have the exact same type. Something like this is not legal:</p> <pre><code># let a = 10;;\nval a : int = 10\n# let b = 20;;\nval b : int = 20\n# if a &gt; b then \"success\" else 0;;\nLine 1, characters 29-30:\n1 | if a &gt; b then \"success\" else 0;;\n                                 ^\nError: This expression has type int but an expression was expected of type\n         string\n</code></pre> <p>This is easy to understand, but things are not always so clear, as we will see.</p>"},{"location":"readings/ocaml_cheat_sheet/#if-without-else","title":"<code>if</code> without <code>else</code>","text":"<p>OCaml allows you to have an <code>if</code> expression without an <code>else</code> clause, but if you do that, the <code>then</code> clause must have type <code>unit</code>.</p> <pre><code># let a = 10;;\nval a : int = 10\n# if a &gt; 5 then Printf.printf \"big!\\n\";;\nbig!\n- : unit = ()\n</code></pre> <p>This works because <code>printf</code> has a return type of <code>unit</code>. But this won't work:</p> <pre><code># let b = if a &gt; 5 then 10;;\nLine 1, characters 22-24:\n1 | let b = if a &gt; 5 then 10;;\n                          ^^\nError: This expression has type int but an expression was expected of type\n         unit\n       because it is in the result of a conditional with no else branch\n</code></pre> <p>Both branches of a conditional must have the same type, and if you leave out the <code>else</code> branch, its type is assumed to be <code>unit</code>. In other words, <code>if</code> without <code>else</code> is desugared as follows. This:</p> <pre><code>if &lt;bool expr&gt; then &lt;then expr&gt;\n</code></pre> <p>is equivalent to this:</p> <pre><code>if &lt;bool expr&gt; then &lt;then expr&gt; else ()\n</code></pre> <p>When you think about it, this makes perfect sense. Normally you would only want to do an <code>if</code>-without-<code>else</code> if you are writing imperative code in the <code>then</code> clause (see below).</p>"},{"location":"readings/ocaml_cheat_sheet/#else-if","title":"<code>else if</code>","text":"<p>Technically, OCaml doesn't have an <code>else if</code> construct. However, if you're careful you can use it anyway:</p> <pre><code># let abs x =\n  if x &lt; 0 then\n    -x\n  else if x &gt; 0 then\n    x\n  else 0;;\nval abs : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>What's actually happening is that there are two nested <code>if</code> expressions:</p> <pre><code># let abs x =\n  if x &lt; 0 then\n    -x\n  else\n    (if x &gt; 0 then\n       x\n     else 0);;\n</code></pre> <p>As long as you can write your code as a sequence of nested <code>if</code> expressions like this, it will work as you expect. But if you put something more complicated in one of the <code>then</code> or <code>else</code> clauses (like another <code>if</code> expression) you may have to wrap parentheses or a <code>begin</code>/<code>end</code> pair around the inner expression:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\"\n    (* no else! *)\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\nval test : int -&gt; unit = &lt;fun&gt;\n# test 15;;\ninner if\n- : unit = ()\n# test 9;;\n- : unit = ()\n</code></pre> <p>Note that <code>test 9</code> doesn't print anything, though we might expect it to print <code>\"outer if 1\"</code>. The code above is parsed as follows:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      (if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\"\n       else if n mod 3 = 0 then\n         Printf.printf \"outer if 1\\n\"\n       else\n         Printf.printf \"outer if 2\\n\")\n  ;;\n</code></pre> <p>which is probably not what was intended. To fix it, insert either parentheses or a <code>begin</code>/<code>end</code> pair to disambiguate it:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      (if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\")\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\nval test : int -&gt; unit = &lt;fun&gt;\n# test 15;;\ninner if\n- : unit = ()\n# test 9;;\nouter if 1\n- : unit = ()\n# test 8;;\nouter if 2\n- : unit = ()\n</code></pre> <p>With <code>begin</code>/<code>end</code> it looks like this:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      begin\n        if n mod 3 = 0 then\n          Printf.printf \"inner if\\n\"\n      end\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\n</code></pre> <p>Either are acceptable.</p> <p>If OCaml's <code>else if</code> situation makes you uneasy, there is a perfectly reasonable alternative... that will probably also make you uneasy! It's a way of using OCaml's <code>match</code> form that is like a sequence of <code>if</code>/<code>else if</code>/<code>else</code> forms. Example:</p> <pre><code>let abs n =\n  match () with\n    | _ when n &gt; 0 -&gt; n\n    | _ when n &lt; 0 -&gt; -n\n    | _ -&gt; 0\n</code></pre> <p>We match against <code>()</code> because we don't care about the value matched; that's also why we use the <code>_</code> in each clause of the match. Instead, we're using the <code>match</code> form solely because of the ability to use <code>when</code> pattern guards; these contain the actual logic. This can often be a bit more concise and clean than an actual <code>else if</code>, but be careful: if you need to do another <code>match</code> in the expression following the right arrow (<code>-&gt;</code>) you may have to wrap it in parentheses or a <code>begin</code>/<code>end</code> form (see below for why).</p>"},{"location":"readings/ocaml_cheat_sheet/#functions","title":"Functions","text":"<p>OCaml is a functional language, so functions are fundamental. There are a number of unusual features of OCaml functions.</p>"},{"location":"readings/ocaml_cheat_sheet/#syntax-and-currying","title":"Syntax and currying","text":"<p>Unlike most conventional languages, OCaml doesn't require you to put parentheses around the arguments to a function. In fact, if you do, you change the meaning! Consider this innocent-looking function:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n# add 2 3;;\n- : int = 5\n# add (2 + 3) (3 + 4);;\n- : int = 12\n</code></pre> <p>OK, so we can get by without parentheses around the arguments. (The parentheses in the last line are to create the arguments, not to surround them for the function call.) What if we use them anyway?</p> <pre><code># add (2, 3);;\nLine 1, characters 4-10:\n1 | add (2, 3);;\n        ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n</code></pre> <p>Nope, that isn't correct. The error message may confuse you. Let's see a variation:</p> <pre><code># let add' (x, y) = x + y;;\nval add' : int * int -&gt; int = &lt;fun&gt;\n# add' (2, 3);;\n- : int = 5\n</code></pre> <p>(Note that in OCaml, you can use the <code>'</code> character (pronounced \"prime\") in identifiers.)</p> <p>If we define the function with parentheses, we have to call it with parentheses. If not:</p> <pre><code># add' 2 3;;\nLine 1, characters 0-4:\n1 | add' 2 3;;\n    ^^^^\nError: This function has type int * int -&gt; int\n       It is applied to too many arguments; maybe you forgot a `;'.\n</code></pre> <p>Huh. What is really going on here?</p> <p>Look at the second version again:</p> <pre><code># let add' (x, y) = x + y;;\nval add' : int * int -&gt; int = &lt;fun&gt;\n</code></pre> <p>Look at the type signature. The <code>int * int</code> part says that the input to the function is a single argument which must be a two-tuple (a tuple with two elements), where both elements are <code>int</code>s. If you leave the arguments \"naked\", they don't form a two-tuple, and there are two arguments, not one. This explains the error message. Now look at the first version:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>The type signature is a bit odd. Since the <code>-&gt;</code> type operator associates to the right, this is equivalent to:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; (int -&gt; int) = &lt;fun&gt;\n</code></pre> <p>This is an example of what's called currying. What the type signature means is that the <code>add</code> function actually only takes a single argument (an <code>int</code>) and returns a function of type <code>int -&gt; int</code>. If you call the function with both arguments, the function returned by applying <code>add</code> to the first argument (which has type <code>int -&gt; int</code>) is immediately applied to the second argument (of type <code>int</code>) to give the result, which is an <code>int</code>. So this function call:</p> <pre><code># add 2 3;;\n- : int = 5\n</code></pre> <p>is actually this:</p> <pre><code># (add 2) 3;;\n- : int = 5\n</code></pre> <p>And if we leave out the second argument, we get this:</p> <pre><code># add 2;;\n- : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>which shows currying in action. We can use this function:</p> <pre><code># let add2 = add 2;;\nval add2 : int -&gt; int = &lt;fun&gt;\n# add2 3;;\n- : int = 5\n</code></pre> <p>Curried functions are often useful to create a partially-evaluated function whose final value will be supplied later. For instance:</p> <pre><code># List.map (add 2) [1; 2; 3; 4; 5]\n- : int list = [3; 4; 5; 6; 7]\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#anonymous-functions","title":"Anonymous functions","text":"<p>Functions are a kind of data in functional languages like OCaml, and you can define function values directly using the <code>fun</code> expression. So instead of writing:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>we could write the definition like this:</p> <pre><code># let add = fun x y -&gt; x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>The meaning is exactly the same. We say that the first form is syntactic sugar for the latter form. We can even use a <code>fun</code> expression without giving it a name at all:</p> <pre><code># (fun x y -&gt; x + y) 2 3;;\n- : int = 5\n</code></pre> <p>Therefore, we say that the <code>fun</code> form defines an anonymous function. Anonymous functions are often used with higher-order functions (functions that take functions as input and/or return functions as output).</p> <p>Note also that because of currying, the function</p> <pre><code>fun x y -&gt; x + y\n</code></pre> <p>is the same as:</p> <pre><code>fun x -&gt; fun y -&gt; x + y\n</code></pre> <p>You should think of the first form as syntactic sugar for the second.</p>"},{"location":"readings/ocaml_cheat_sheet/#match-expressions","title":"<code>match</code> expressions","text":"<p>OCaml <code>match</code> expressions are pretty straightforward. They have a couple of subtleties you should know about.</p>"},{"location":"readings/ocaml_cheat_sheet/#optional-before-first-match","title":"Optional <code>|</code> before first match","text":"<p>In a <code>match</code> expression, the alternatives are separated by a vertical bar character (<code>|</code>). You can also (optionally) put a vertical bar character before the first pattern to be matched. This often makes the code look cleaner. Compare:</p> <pre><code>let rec sum_list lst =\n  match lst with\n      [] -&gt; []\n    | h :: t -&gt; h + sum_list t\n</code></pre> <p>with</p> <pre><code>let rec sum_list lst =\n  match lst with\n    | [] -&gt; []\n    | h :: t -&gt; h + sum_list t\n</code></pre> <p>These two functions are identical in terms of their functionality, but the code for the second looks cleaner because of the extra <code>|</code> before the first match.</p>"},{"location":"readings/ocaml_cheat_sheet/#nested-match-expressions","title":"Nested match expressions","text":"<p>It's not uncommon to want to put a <code>match</code> expression inside another <code>match</code> expression. If you do, you have to be careful with the inner <code>match</code> expression so that its clauses aren't confused with the outer <code>match</code>'s clauses. Here's an example from the internet:</p> <pre><code>let rec filter exp =\n  match exp with\n    | Var v -&gt; Var v\n    | Sum(e1, e2) -&gt; Sum(e1, e2)\n    | Prod(e1, e2) -&gt; Prod(e1, e2)\n    | Diff(e1, e2) -&gt;\n      match e2 with  (* nested match *)\n        | Sum(e3, e4) -&gt; filter (diffRule e2)\n        | Diff(e3, e4) -&gt; filter (diffRule e2)\n        | _ -&gt; filter e2\n    (* Oops! These following clauses should belong to the outer match, but\n       they actually belong to the inner match. *)\n    | Quot(e1, e2) -&gt;\n        match e2 with\n        | Quot(e3, e4) -&gt; filter (quotRule e2)\n        | Prod(e3, e4) -&gt; filter (quotRule e2)\n        | _ -&gt; filter e2\n</code></pre> <p>The solution is to wrap the inner <code>match</code> using parentheses or <code>begin</code>/<code>end</code>. For instance:</p> <pre><code>let rec filter exp =\n  match exp with\n    | Var v -&gt; Var v\n    | Sum(e1, e2) -&gt; Sum(e1, e2)\n    | Prod(e1, e2) -&gt; Prod(e1, e2)\n    | Diff(e1, e2) -&gt;\n      begin\n        match e2 with  (* nested match *)\n          | Sum(e3, e4) -&gt; filter (diffRule e2)\n          | Diff(e3, e4) -&gt; filter (diffRule e2)\n          | _ -&gt; filter e2\n      end\n    | Quot(e1, e2) -&gt;\n        match e2 with\n        | Quot(e3, e4) -&gt; filter (quotRule e2)\n        | Prod(e3, e4) -&gt; filter (quotRule e2)\n        | _ -&gt; filter e2\n</code></pre> <p>Now it will do what it's supposed to.</p>"},{"location":"readings/ocaml_cheat_sheet/#function-expressions","title":"<code>function</code> expressions","text":"<p>This kind of pattern is extremely common:</p> <pre><code>let rec &lt;function name&gt; &lt;arg&gt; =\n  match &lt;arg&gt; with\n    | &lt;pattern 1&gt; -&gt; ...\n    | &lt;pattern 2&gt; -&gt; ...\n    ...\n</code></pre> <p>For instance, the <code>sum_list</code> function above is an example of this pattern. The essence of this pattern is that you pattern match on the last argument. Sometimes you have more arguments:</p> <pre><code>let rec &lt;function name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; =\n  match &lt;argN&gt; with\n    | &lt;pattern 1&gt; -&gt; ...\n    | &lt;pattern 2&gt; -&gt; ...\n    ...\n</code></pre> <p>Whenever you have a function that pattern matches on its last argument, you can rewrite it using the <code>function</code> keyword. This is like an automatic <code>match</code> on the last argument. The patterns above would be written like this using <code>function</code>:</p> <pre><code>let rec &lt;function name&gt; = function (* leave off &lt;arg&gt; *)\n  | &lt;pattern 1&gt; -&gt; ...\n  | &lt;pattern 2&gt; -&gt; ...\n  ...\n\nlet rec &lt;function name&gt; &lt;arg1&gt; &lt;arg2&gt; ... = function (* leave off &lt;argN&gt; *)\n  | &lt;pattern 1&gt; -&gt; ...\n  | &lt;pattern 2&gt; -&gt; ...\n  ...\n</code></pre> <p>Rewriting <code>sum_list</code> using <code>function</code> gives this:</p> <pre><code>let rec sum_list = function (* leave off &lt;arg1&gt; *)\n  | [] -&gt; []\n  | h :: t -&gt; h + sum_list t\n</code></pre> <p>This way of writing functions has advantages and disadvantages. The advantage is that it's more concise. The disadvantage is that you have to remember that the <code>function</code> keyword means that the function you are defining has an extra argument that doesn't have a name. Also, if you do need the name of the argument inside the body of the function, you can't use <code>function</code>. <code>function</code> is mostly used for simple functions of a simple argument where the only thing you do with the argument is pattern match on it. It's never necessary, though, so feel free to write all your code without it if you don't like it.</p>"},{"location":"readings/ocaml_cheat_sheet/#the-fragile-pattern-match-compiler-warning","title":"The \"fragile pattern match\" compiler warning","text":"<p>We like to compile OCaml code with most of the warning settings enabled. This provides a lot of suggestions for fixing problematic code which is still technically correct. You can turn on all compiler warnings by compiling with the <code>-w A</code> (<code>A</code> means \"all\") command-line option. This works both for <code>ocamlc</code> and for the interactive interpreters <code>ocaml</code> and <code>utop</code>.</p> <p>Note</p> <p>We don't necessarily recommend the <code>-w A</code> option for routine use with interactive interpreters, because some warnings would cause problems with normal use of interpreters, such as redefining datatypes.</p> <p>One particular compiler warning can be very confusing. Consider this code:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n\nlet get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | _ -&gt; 0\n</code></pre> <p>With warnings enabled, this gives this warning:</p> <pre><code>Warning 4 [fragile-match]: this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type foo.\nval get_foo_int : foo -&gt; int = &lt;fun&gt;\n</code></pre> <p>What this is complaining about is the last line in the <code>get_foo_int</code> function: <code>| _ -&gt; 0</code>. The intent of this line is to say that for all constructors except the <code>Bar</code> constructor, return the integer <code>0</code>. This is not incorrect code! On the other hand, let's say we modified the <code>foo</code> type to have another constructor that contained an <code>int</code> value:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n  | Boom of int\n</code></pre> <p>but we forgot to change the <code>get_foo_int</code> function. The function will still work, but it won't do the right thing. You would probably want to change it to this:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Boom i -&gt; i\n    | _ -&gt; 0\n</code></pre> <p>so that any constructor with an <code>int</code> value has the <code>int</code> value returned. But since the old code is still correct, you won't know that you need to make this change.</p> <p>This is what a \"fragile pattern match\" means: it's a catch-all case that matches more than one constructor, so if you happen to add more constructors to the datatype, it will match those as well.  What you would like it to do is to warn you: \"Hey!  I've never seen the <code>Boom</code> case before, and you're not handling it, so that's probably an error!\" The way to do this is to explicitly handle all constructors in the original function.</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo -&gt; 0\n    | Baz _ -&gt; 0\n</code></pre> <p>Then the warning will go away. On the other hand, it's annoying to have to write the same value (here, <code>0</code>) for two cases. In this case, we can use the \"fall through\" mechanism of pattern matching to make the code simpler:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo   (* no `-&gt;` so fall through to next case *)\n    | Baz _ -&gt; 0\n</code></pre> <p>And we can write all the catch-all cases on one line:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo | Baz _ -&gt; 0\n</code></pre> <p>Now, if we add the <code>Boom</code> constructor, we will have to add a case for that:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n  | Boom of int   (* new constructor *)\n\nlet get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Boom i -&gt; i   (* new case *)\n    | Foo | Baz _ -&gt; 0\n</code></pre> <p>If we left out the <code>Boom</code> case, we would get a warning about a non-exhaustive pattern-match, and we would know just what to fix.</p> <p>Writing out catch-all cases like this is a bit tedious at times, but if you don't do it, you can sometimes get bugs that are extremely hard to track down.<sup>1</sup></p>"},{"location":"readings/ocaml_cheat_sheet/#let-expressions","title":"<code>let</code> expressions","text":""},{"location":"readings/ocaml_cheat_sheet/#explicit-recursion","title":"Explicit recursion","text":"<p>OCaml requires you to say <code>let rec</code> when defining a recursive function.</p> <p>You can easily define mutually recursive functions by using the</p> <pre><code>let rec f x =\n  ...  (* expression using g *)\nand g y =\n  ...  (* expression using f *)\n</code></pre> <p>syntax for top-level mutually-recursive functions, or the</p> <pre><code>let rec f x =\n  ...  (* expression using g *)\nand g y =\n  ...  (* expression using f *)\nin\n  ...\n</code></pre> <p>syntax for mutually-recursive functions inside an expression.  Leaving out the <code>rec</code> is one of the commonest mistakes beginning OCaml programmers make.  Conversely, don't use the <code>rec</code> unless the function is actually recursive! (This will rarely cause problems, but it's poor style, and it may generate a warning.)</p>"},{"location":"readings/ocaml_cheat_sheet/#imperative-programming","title":"Imperative programming","text":""},{"location":"readings/ocaml_cheat_sheet/#references","title":"References","text":"<p>OCaml doesn't have \"variables\" in the sense that most programming languages do.  Instead, it has references, which are basically records with a single mutable field.  These are effectively the same as variables except that you have to explicitly dereference them to get the value they contain.  I'm not going to lie to you, this is a pain in highly imperative code! However, it is extremely explicit and it allows you to define useful functions on references.</p> <pre><code># let r = ref 0;;  (* r is a reference *)\nval r : int ref = {contents = 0}\n# r;;\n- : int ref = {contents = 0}\n# (!);;      (* ! is the dereference operator *)\n- : 'a ref -&gt; 'a = &lt;fun&gt;\n# !r;;\n- : int = 0\n# (:=);;     (* := is the assignment operator *)\n- : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;\n# r := 42;;\n- : unit = ()\n# r;;\n- : int ref = {contents = 42}\n# !r;;\n- : int = 42\n# incr;;     (* incr is a function on references *)\n- : int ref -&gt; unit = &lt;fun&gt;\n# incr r;;\n- : unit = ()\n# !r;;\n- : int = 43\n</code></pre> <p>Fun fact: we could have defined the <code>!</code> and <code>:=</code> operators ourselves, and we could have defined the <code>incr</code> function as well:</p> <pre><code># let ( ! ) r = r.contents;;\nval ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;\n# let ( := ) r v = r.contents &lt;- v;;\nval ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;\n# let incr r = r.contents &lt;- !r + 1;;\nval incr : int ref -&gt; unit = &lt;fun&gt;\n</code></pre> <p>This works because references (<code>ref</code> cells) are records with a single field called <code>contents</code>, so the record accessing and mutating syntax can be used on them.</p>"},{"location":"readings/ocaml_cheat_sheet/#sequence-expressions","title":"Sequence expressions","text":"<p>When you are doing imperative programming, it's often necessary to have a notion of sequencing, as in do-this-then-do-that etc. In OCaml, this requires a sequence expression, which has two forms:</p> <ul> <li>a series of statements separated by semicolons    and wrapped with <code>begin</code>/<code>end</code></li> <li>the same, but using parentheses instead of <code>begin</code>/<code>end</code></li> </ul> <p>The choice between using <code>begin</code>/<code>end</code> or parentheses is a style decision. I prefer parentheses for very short (one-liner) sequence expressions and <code>begin</code>/<code>end</code> for sequence expressions that span multiple lines.</p> <p>Here's an example of an (inefficient) imperative function to compute greatest common denominators (GCDs):</p> <pre><code>let gcd m n =\n  let p = ref m in\n  let q = ref n in\n    begin\n      while !p &lt;&gt; !q do\n          if !p &gt; !q then\n            p := !p - !q\n          else\n            q := !q - !p\n      done;\n      !p\n    end\n</code></pre> <p>This also shows the use of an imperative <code>while</code> loop. It also shows how annoying imperative programming is in OCaml <code>!</code> because <code>!</code> of <code>!</code> all <code>!</code> the <code>!</code> exclamation <code>!</code> points!</p>"},{"location":"readings/ocaml_cheat_sheet/#weakly-polymorphic-types","title":"Weakly polymorphic types","text":"<p>OCaml's type system has some peculiarities.  One that you are likely to run into when you do imperative programming is that there are types that are \"weakly polymorphic\".  A truly polymorphic type can be parameterized on one or more type variables, which are written with a leading quote i.e. <code>'a</code>, <code>'b</code> etc. But some types are not actually polymorphic, they are \"write-once\" types.  Look at this:</p> <pre><code># let r = ref [];;\nval r : '_weak1 list ref = {contents = []}\n# !r;;\n- : '_weak1 list = []\n# r := [1; 2; 3];;\n- : unit = ()\n# r;;\n- : int list ref = {contents = [1; 2; 3]}\n# !r;;\n- : int list = [1; 2; 3]\n</code></pre> <p>The initial type of <code>r</code> is <code>'_weak1 list ref</code>, which is pretty odd. You might expect it to be <code>'a list ref</code> i.e. that <code>r</code> is a reference which can contain any kind of list.  But this would not be type-safe; if <code>r</code> holds a list of <code>int</code>s at one time and a list of <code>bool</code>s at another, then all the types are not known at compile-time, and you might as well be writing Python code.</p> <p>Instead, what this odd type means is that <code>r</code> is a reference containing a list of currently unspecified type.  That's what the <code>'_weak1 list ref</code> means.  Since <code>r</code> was initialized with an empty list, which could have any element type, you can't say any more.  Once you reassign a list of known type to <code>r</code>, it then has a concrete type (<code>int list</code> in this case), and the type is fixed thereafter.</p> <p>OK, so what if you aren't using references or imperative features? Unfortunately, you can still get weakly polymorphic types if you partially apply a function.  Here's a trivial example:</p> <pre><code># let const x y = y ;;\nval const : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# let f = const () ;;  (* partial application of the const function *)\nval f : '_weak1 -&gt; '_weak1 = &lt;fun&gt;\n</code></pre> <p>This is purely functional code, but you still get a weak type! The reasons for this are quite involved (see the references below), but one trick that will work in most cases is to change the partial application to a full application by adding arguments:</p> <pre><code># let const x y = y ;;\nval const : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# let f x = const () x ;;  (* no longer a partial application of the const function *)\nval f : 'a -&gt; 'a = &lt;fun&gt;\n</code></pre> <p>Now <code>f</code> has the expected type.  This trick (called \"eta expansion\") is definitely worth remembering.</p> <p>For more on this issue (really far more than you need to know at this point), here are some good references:</p> <ul> <li>https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html</li> <li>https://ocamlverse.github.io/content/weak_type_variables.html</li> </ul> <p>However, don't stress too much about it. This is expert-level stuff, and at this point in your OCaml learning process, the main reason we're bringing this up is in case you encounter this in practice and want to have an idea about what's going on. Sophisticated type systems like OCaml are quite involved, and few people have completely mastered all of the details.</p> <ol> <li> <p>In the CS 164 course (Compilers), which uses OCaml, this kind of situation comes up quite frequently, because many of the compilers start with compiler passes from a simpler compiler and extend them to handle new constructors.\u00a0\u21a9</p> </li> </ol>"},{"location":"readings/subst/","title":"The substitution model","text":"<p>This reading is a summary of the rules of the substitution model, discussed in lecture 2.</p>"},{"location":"readings/subst/#overview","title":"Overview","text":"<p>The substitution model is a way of manually evaluating OCaml expressions. It's similar to, but not identical to, what the computer does when it evaluates OCaml code. The point of learning the model is so that you have a good mental framework for how OCaml code evaluates.</p> <p>Note</p> <p>At some point, this model will not be sufficient to explain all the features of OCaml that we will use (for instance, updating variables in imperative programming), so we will define a new model: the environment model. That model will share many features with the substitution model, but its handling of name lookup will be much more precise.</p> <p>The substitution model is adequate to understand the purely functional subset of OCaml we will use for the first half of the course.</p>"},{"location":"readings/subst/#desugaring-and-precedence","title":"Desugaring and precedence","text":"<p>Before evaluating any OCaml code using the substitution model, the code should first be desugared, and then operator precedence should be made explicit using parentheses.</p>"},{"location":"readings/subst/#desugaring","title":"Desugaring","text":"<p>The main kind of desugaring we need is to replace expressions of this form:</p> <pre><code>let f x y = ...\n</code></pre> <p>with this:</p> <pre><code>let f = fun x y -&gt; ...\n</code></pre> <p>After desugaring, all <code>let</code> expressions are \"simple\" i.e. they bind a single name (here, <code>f</code>) to a value (the result of evaluating the expression on the right-hand side of the <code>=</code>; here, <code>fun x y -&gt; ...</code>).</p> <p>Note</p> <p>If we are really being picky, we could desugar this further to:</p> <pre><code>let f = fun x -&gt; fun y -&gt; ...\n</code></pre> <p>but we don't require that.  This is because of function currying, which is the way that OCaml interprets functions with multiple arguments.</p> <p>We recommend that you don't do this in your written evaluations, unless you have to for some reason.</p>"},{"location":"readings/subst/#precedence","title":"Precedence","text":"<p>Operator precedence should be made explicit by wrapping parentheses around nested operator expressions. For instance, this code:</p> <pre><code>1 + 2 * 7\n</code></pre> <p>would become:</p> <pre><code>1 + (2 * 7)\n</code></pre> <p>The full precedence table of OCaml operators is here. In most cases, it will be what you would expect.</p> <p>This step is done so that there is never any question about what the operands of an operator are.</p>"},{"location":"readings/subst/#the-basic-rule","title":"The basic rule","text":"<p>To evaluate an OCaml expression:</p> <ol> <li>evaluate the operands of the expression</li> <li>evaluate the operator or function of the expression</li> <li>apply the operator/function to the evaluated operands</li> </ol> <p>Note</p> <p>OCaml actually evaluates operands from right-to-left, in contrast to most languages, which evaluate operands from left-to-right. Evaluation order is not part of the substitution model, and shouldn't make any difference.</p> <p>Similarly, you can evaluate the operator/function before or after evaluating the operands, and it won't make any difference in this model.</p> <p>The basic rule is used when evaluating a function call or an operator expression. Other expressions (such as <code>let</code>, <code>fun</code> and <code>if</code> expressions) do not use the basic rule; they have their own evaluation rules. Such expressions are called special forms.</p>"},{"location":"readings/subst/#specific-cases-of-the-basic-rule","title":"Specific cases of the basic rule","text":"<ul> <li> <p>Numbers evaluate to themselves: <code>10</code> \u2192 <code>10</code>   (In fact, any literal data value evaluates to itself;   that's why it's called \"literal\".   For now, we are mostly working with numbers.)</p> </li> <li> <p>Primitive (built-in) functions evaluate   to the corresponding internal procedure.   We can write this as either:   <code>+</code> \u2192 <code>[primitive function +]</code>   or just <code>+</code> \u2192 <code>+</code></p> </li> <li> <p>Variables that have been previously defined   are \"looked up\" (in some unspecified way)   and evaluate to the value that they were previously bound to.   (If they weren't bound to a value previously, it's an error.)</p> </li> </ul>"},{"location":"readings/subst/#let-bound-names","title":"<code>let</code>-bound names","text":"<p>There are two kinds of <code>let</code>-bound names: top-level and in-expression. They evaluate differently.</p>"},{"location":"readings/subst/#top-level-let-expressions","title":"Top-level <code>let</code> expressions","text":"<p>A top-level <code>let</code> expression<sup>1</sup> looks like this:</p> <pre><code>let &lt;var&gt; = &lt;expr&gt;\n</code></pre> <p>for some variable name <code>&lt;var&gt;</code> and some expression <code>&lt;expr&gt;</code>. For instance:</p> <pre><code>let x = 2 + 3\n</code></pre> <p>To evaluate this, you</p> <ul> <li> <p>evaluate the expression to the right of the <code>=</code> sign   (here, <code>2 + 3</code>, which evaluates to <code>5</code>);</p> </li> <li> <p>\"make an association\" or \"bind\" the name (<code>x</code> here)   to the value of the evaluated expression (<code>5</code>).   The details of how to make this association aren't important for now,   though we'll revisit this later.</p> </li> </ul> <p>In this case, we make an association between the name <code>x</code> and the value <code>5</code>. We can also say that we bind <code>x</code> to <code>5</code>.</p> <p>After this expression is evaluated, the name <code>x</code> will be bound to the value <code>5</code> for the rest of the evaluated code, unless <code>x</code> is given a new binding with a new top-level <code>let</code> expression.</p> <p>Note</p> <p>A new binding for <code>x</code> would be something like:</p> <pre><code>let x = 42\n</code></pre> <p>From then on, any reference to <code>x</code> would get the new value. This is not the same as assignment in an imperative language, because it doesn't overwrite the old binding. Instead, this code creates a new binding to <code>x</code> which \"shadows\" the old binding, but the old binding still exists, and in some cases can still have effects.</p>"},{"location":"readings/subst/#local-let-expressions","title":"Local <code>let</code> expressions","text":"<p>A \"local\" <code>let</code> expression is a <code>let</code> expression where a name is bound to a value and then immediately used in another expression, such as this:</p> <pre><code>let x = 2 + 3 in x * x\n</code></pre> <p>In this case, the name <code>x</code> has a meaning inside the body of the expression (the <code>x * x</code> part) but not outside. To evaluate this, you:</p> <ul> <li> <p>evaluate the binding expression   (here, <code>2 + 3</code>, which evaluates to <code>5</code>),</p> </li> <li> <p>bind the name to the value (here, bind <code>x</code> to <code>5</code>),</p> </li> <li> <p>and evaluate the body expression (here, <code>x * x</code>).</p> </li> </ul> <p>In the body expression, of course, you can use the name <code>x</code>, which has a value (<code>5</code>). Outside of this expression, the name <code>x</code> either has no value (if it wasn't bound before) or has the value it previously had (if it was). Remember: you aren't changing a previous binding (to <code>x</code>), you're creating a new one that is used only in a single expression.</p>"},{"location":"readings/subst/#if-expressions","title":"<code>if</code> expressions","text":"<p><code>if</code> expressions consist of three subexpressions:</p> <ul> <li>the test subexpression (between the <code>if</code> and the <code>then</code> keywords)</li> <li>the <code>then</code> subexpression (between the <code>then</code> and the <code>else</code> keywords)</li> <li>the <code>else</code> subexpression (everything following the <code>else</code> keyword)</li> </ul> <p>They have the following evaluation rule.</p> <ol> <li>Evaluate the test subexpression.</li> <li>If the test subexpression evaluates to <code>true</code>,    evaluate the <code>then</code> subexpression.</li> <li>If the test subexpression evaluates to <code>false</code>,    evaluate the <code>else</code> subexpression.</li> </ol> <p>One consequence of this is that you never evaluate both the <code>then</code> and <code>else</code> subexpressions. This is why <code>if</code> can't be a function (it's not just the syntax!)<sup>2</sup></p>"},{"location":"readings/subst/#if-without-else","title":"<code>if</code> without <code>else</code>","text":"<p>When writing purely functional code in OCaml, <code>if</code> expressions always have both a <code>then</code> subexpression and an <code>else</code> subexpression. (These are sometimes called the \"then clause\" and the \"else clause\".) With respect to the substitution model, we will always have <code>else</code> subexpressions in <code>if</code> expressions.</p> <p>To learn more about how <code>if</code> expressions without <code>else</code> subexpressions work, see the OCaml cheat sheet.</p>"},{"location":"readings/subst/#fun-expressions","title":"<code>fun</code> expressions","text":"<p>A <code>fun</code> expression (like <code>fun x y -&gt; x + y</code>) represents an anonymous function. In the substitution model, a <code>fun</code> expression is usually the result of desugaring a regular function definition, like</p> <pre><code>let f x y = x + y\n</code></pre> <p>which desugars to:</p> <pre><code>let f = fun x y -&gt; x + y\n</code></pre> <p><code>fun</code> expressions consist of two parts:</p> <ul> <li>the formal parameters of the function (here, <code>x</code> and <code>y</code>),</li> <li>the body of the function (here, <code>x + y</code>).</li> </ul> <p><code>fun</code> expressions are trivial to evaluate: you basically just leave them alone. For this reason, in written evaluations you can write:</p> <pre><code>fun x y -&gt; x + y  --&gt;  fun x y -&gt; x + y\n</code></pre> <p>or just:</p> <pre><code>fun x y -&gt; x + y  --&gt;  itself\n</code></pre>"},{"location":"readings/subst/#function-application","title":"Function application","text":"<p>Function application is at the heart of the substitution model. There are two cases.</p>"},{"location":"readings/subst/#applying-built-in-functions-or-operators","title":"Applying built-in functions or operators","text":"<p>Applying a built-in function or operator is simple: you just do it. For instance:</p> <pre><code>Evaluate: 2 + 3\n  2 --&gt; 2\n  3 --&gt; 3\n  + --&gt; [primitive function +]\n  apply + to 2, 3 --&gt; 5\n\nEvaluate: abs (-10)\n  -10 --&gt; -10\n  abs --&gt; [primitive function abs]\n  apply abs to -10 --&gt; 10\n</code></pre> <p>In some cases we'll allow you to shorten lines like</p> <pre><code>abs --&gt; [primitive function abs]\n</code></pre> <p>to just:</p> <pre><code>abs --&gt; abs\n</code></pre> <p>Don't do this unless we explicitly say it's OK.</p>"},{"location":"readings/subst/#applying-user-defined-functions-substitution","title":"Applying user-defined functions: substitution","text":"<p>Now we come to the \"substitution\" part of the substitution model. It happens when you are applying a user-defined function (which means a <code>fun</code> expression, or a function which gets desugared to a <code>fun</code> expression) to its arguments (which have already been evaluated to values, so they aren't expressions anymore).</p> <p>The rules for applying user-defined functions are:</p> <ol> <li> <p>Substitute the function argument variables (formal parameters)    with the values given in the call    everywhere they occur in the function body.</p> </li> <li> <p>Evaluate the resulting expression.</p> </li> </ol> <p>For the most part, the substitution process is straightforward. For each function parameter, you substitute the argument value for the function parameter name in the function body to get the substituted expression, which you then evaluate. For instance, this expression:</p> <pre><code>(fun x y -&gt; x + y) 2 3\n</code></pre> <p>evaluates as follows:</p> <pre><code>Evaluate: (fun x y -&gt; x + y) 2 3\n  2 --&gt; 2\n  3 --&gt; 3\n  (fun x y -&gt; x + y) --&gt; itself\n  apply (fun x y -&gt; x + y) to 2, 3\n    substitute 2 for x, 3 for y in x + y --&gt; 2 + 3\n    evaluate: 2 + 3\n      2 --&gt; 2\n      3 --&gt; 3\n      + --&gt; [primitive function +]\n      apply + to 2, 3 --&gt; 5\n</code></pre> <p>You can even evaluate inside a complex expression (for instance, an <code>if</code> expression):</p> <pre><code>Evaluate (fun x y -&gt; if x &gt; y then x + y else x - y) 2 3\n  2 --&gt; 2\n  3 --&gt; 3\n  (fun x y -&gt; ...) --&gt; itself\n  apply (fun x y -&gt; ...) to 2, 3\n    substitute 2 for x, 3 for y in if x &gt; y then x + y else x - y\n    --&gt; if 2 &gt; 3 then 2 + 3 else 2 - 3\n    evaluate: if 2 &gt; 3 then 2 + 3 else 2 - 3\n      if is a special form; evaluate 2 &gt; 3\n        2 --&gt; 2\n        3 --&gt; 3\n        &gt; --&gt; [primitive function &gt;]\n        apply &gt; to 2, 3 --&gt; false\n      For false case, evaluate else clause: 2 - 3\n        2 --&gt; 2\n        3 --&gt; 3\n        - --&gt; [primitive function -]\n        apply - to 2, 3 --&gt; -1\n</code></pre> <p>Notice that the substitution goes right inside the <code>if</code> expression, regardless of which branch of the <code>if</code> will eventually end up being evaluated. (Here we also see that for long <code>fun</code> expression bodies, we can abbreviate them with <code>...</code>.)</p> <p>Note</p> <p>On the other hand, we can't substitute inside a nested <code>fun</code> expression in all cases.  See below for more details.</p>"},{"location":"readings/subst/#recursion","title":"Recursion","text":"<p>Recursion doesn't require any special treatment in the substitution model, except that you have to replace a function name with the correct definition of that function when looking up the name. This is usually obvious, and probably won't cause you any problems. It can get weird in pathological cases where you redefine a name. Here's a silly example:</p> <pre><code>let factorial n = 0   (* obviously wrong *)\n\n(* Redefine factorial. *)\nlet factorial n =     (* oops, forgot the \"rec\" *)\n  if n = 0 then\n    1\n  else\n    n * factorial (n - 1)\n</code></pre> <p>When evaluating this function, the \"recursive\" call to <code>factorial</code> will actually pick up the previous definition of <code>factorial</code>, and <code>factorial</code> will return <code>0</code> for any input but <code>0</code>. The solution is to include the <code>rec</code> in the second definition:</p> <pre><code>let factorial n = 0   (* obviously wrong *)\n\n(* Redefine factorial. *)\nlet rec factorial n =\n  if n = 0 then\n    1\n  else\n    n * factorial (n - 1)\n</code></pre> <p>Now everything will work correctly because the <code>rec</code> tells OCaml that any references to <code>factorial</code> inside the body of <code>factorial</code> represent the function being defined.<sup>3</sup></p> <p>Of course, this normally doesn't come up because you normally don't redefine functions in a file, but something like this could happen when defining functions interactively inside the OCaml interpreter. This can lead to very peculiar bugs.</p>"},{"location":"readings/subst/#nested-fun-expressions-and-shielding","title":"Nested <code>fun</code> expressions and shielding","text":"<p>The substitution model has to be adjusted to deal with nested <code>fun</code> expressions. Here's a simple example:</p> <pre><code>let f x =\n  fun x -&gt; x + x\n</code></pre> <p>How would you evaluate <code>f 3</code>? Here's a first (wrong) attempt:</p> <pre><code>Evaluate (f 3)\n  3 --&gt; 3\n  f --&gt; fun x -&gt; fun x -&gt; x + x\n  apply (fun x -&gt; fun x -&gt; x + x) to 3\n    substitute 3 for x in (fun x -&gt; x + x)\n    --&gt; fun 3 -&gt; 3 + 3  (* ??? *)\n</code></pre> <p>at which point it seems clear that something has gone wrong.</p> <p>You might think that <code>fun 3 -&gt; 3 + 3</code> is a syntax error, but that isn't actually the case in OCaml! The <code>fun</code> form uses pattern-matching to decide what to do with the arguments, so <code>fun 3 -&gt; 3 + 3</code> is a function that can only take as its input the integer <code>3</code>, and will always return 6. Clearly, this isn't going to be useful, and is not what was intended.</p> <p>Note</p> <p>If you type in <code>fun 3 -&gt; 3 + 3</code> into the OCaml interpreter, you'll get a warning about non-exhaustive pattern matches, as you'd expect.</p> <p>OK, so it seems that naively doing substitution in cases like this (where you have nested <code>fun</code> expressions that use the same argument name) doesn't work properly. So how can we fix our model so it can handle situations like this?</p> <p>The key is to realize that the problems started with this line:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n</code></pre> <p>Normally, we are substituting a value for a free variable, which is one that isn't being bound by a <code>fun</code> expression. However, in the expression <code>fun x -&gt; x + x</code>, there are two different <code>x</code>s:</p> <ul> <li> <p>the first <code>x</code>, which is in the binding position of the <code>fun</code> expression</p> </li> <li> <p>the second two <code>x</code>s, which are both bound variables, which means that their value is determined by the (eventual) value passed to the <code>fun</code> expression as its <code>x</code> argument.</p> </li> </ul> <p>Neither case corresponds to a free variable. And, as it turns out, we can't substitute into either of them.</p> <p>We've already seen that when we allow substituting into the binding position of a <code>fun</code> expression, strange things like <code>fun 3 -&gt; 3 + 3</code> result. So it's perfectly reasonable to add an extra rule to the substitution model which says \"don't allow substitutions into the binding position of <code>fun</code> expressions\".  So let's do that:</p> <p>Extra rule for the substitution model</p> <p>Don't allow substituting into the binding position of a <code>fun</code> expression.</p> <p>If we go back to the substitution that gave us grief:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n</code></pre> <p>then we could do the substitution with the extra rule to get:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n--&gt; fun x -&gt; 3 + 3\n</code></pre> <p>This isn't as obviously broken as the previous attempt, but something is still funny here. It doesn't seem reasonable that we would want to generate a function that, given an arbitrary argument <code>x</code>, would always return <code>6</code>.</p> <p>In fact, the expression <code>fun x -&gt; x + x</code> is completely self-contained (other than the <code>+</code> symbol). It only has one reasonable interpretation: a function which doubles its input. So we should disallow substitution into the <code>x</code>s that come after the arrow (<code>-&gt;</code>) in the <code>fun</code> expression too. Our rationale for this is that the <code>x</code> in the binding position \"shields\" the other <code>x</code>s (which we refer to as being bound by the <code>x</code> in the binding position) from substitution. So we have yet another rule for the substitution model:</p> <p>Second extra rule for the substitution model</p> <p>Don't allow substituting into a variable which is shielded by the same variable in the binding position of a <code>fun</code> expression.</p> <p>We can combine both rules into a single rule:</p> <p>Shielding rule for the substitution model</p> <p>Don't allow substituting into a variable when it is either in the binding position of a <code>fun</code> expression or when it is a bound variable of a <code>fun</code> expression. We say that the variable in the binding position shields the bound variables from substitution.</p> <p>That's basically it for the substitution model. We will find eventually that this model has limitations that can only be overcome by switching to a new mode (the environment model), which we shall discuss later in the course.</p> <ol> <li> <p>Technically speaking, this isn't a true expression, since it doesn't return a value. It would be more accurate to call this a top-level <code>let</code> binding.\u00a0\u21a9</p> </li> <li> <p>In a lazy functional language like Haskell, <code>if</code> could be a function, except for the syntax.\u00a0\u21a9</p> </li> <li> <p>This would make an awesome assignment problem, but I'm not quite that mean.\u00a0\u21a9</p> </li> </ol>"}]}