{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 4 book: Winter 2024","text":"<p>This book is the official document repository for the Caltech CS 4 course  (Fundamentals of Computer Programming) for the Winter 2024 term.</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p> <p>Please read this page for an overview of the course.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 4 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>You are welcome to collaborate informally on your assignments (but not on exams!) with other individuals who are taking the course, but you must write all of your own code and you must not look at other students' code, except to help them as described below. Copying another student's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another student's file and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another student's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone dictate code while you type isn't acceptable either. Basically, you have to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine.</p> <p>All of the above also applies if you are getting tutored for the course, officially or unofficially.</p> <p>All of the above also applies to student work from previous years. We re-use some problems in assignments, and copying answers from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a student who is currently taking the course.</p>"},{"location":"admin/collab/#in-class-exercises","title":"In-class exercises","text":"<p>Some lectures will feature in-class exercises (programming problems that will be solved during the lecture by students). These exercises will also be on the assignments. While in the lecture where the exercise is presented, students may collaborate with other students as well as take notes on the solution given by the instructor (if there is one). However, on the assignment, these in-class exercise problems are no collaboration; you are only allowed to consult notes that you personally took during the lecture where the exercise was done.</p> <p>Note</p> <p>If you did not attend the lecture where a particular in-class exercise was presented, you must do the problem without any additional help (no collaboration). (Among other objectives, in-class exercises are an incentive for you to come to lectures.)</p> <p>Note that if you missed a lecture, you may not get notes on an in-class exercise from other students at any time, including in a subsequent lecture.</p> <p>If you attended a lecture where an in-class exercise was presented, but didn't take notes, you may not borrow the notes from another student, whether you collaborated with them in class or not.</p> <p>You are also not allowed to ask for help from the TAs or instructor on in-class exercises after the class in which they were presented (for instance, during office hours), unless you are working on a rework of an assignment containing in-class exercises, in which case you can ask for help from TAs or the instructor only. (You can't ask for help from other students.)</p>"},{"location":"admin/collab/#exams-midterm-final","title":"Exams (midterm, final)","text":"<p>Exams are strictly no-collaboration under all circumstances. The only exception is that you can ask the instructor (Mike) for clarification on anything in the exam that is confusing (for example, when you don't know exactly what a problem is asking you to do). Don't ask a teaching assistant; clarifying exam questions is not their responsibility.</p>"},{"location":"admin/collab/#helping-others-and-the-50-foot-rule","title":"Helping others and the \"50-foot rule\"","text":"<p>It is common for students to want to help other students to write and debug their assignments. While we prefer that you go to one of the course teaching assistants when you need help on the assignments (it doesn't matter which one), we don't forbid you from seeking help from other students or offering your help to other students. However, we do insist on some guidelines to make the process fair for everyone.</p> <p>When you are helping another student with their homework, you are acting as an unofficial teaching assistant, and thus you must behave like one. A teaching assistant will not just tell you the answer or dictate code to you; they will help you work through the problem so that you understand what you are doing wrong. If you don't have the time or the inclination to do this, do not assist other students. If you just give them your code, you are violating the Honor Code and both you and the people you are giving the code to may be in for some serious consequences.</p> <p>As a way of clarifying the way in which you can help other students (especially when it comes to debugging their code), we want you to obey the \"50 foot rule\". This rule states that if you help another student with their programming problems (including debugging), you must not consult your own code while doing so. Specifically, we ask that your own code be at least 50 feet away i.e. not visible to you or the person you are helping while you are helping them. (It doesn't have to be exactly 50 feet; the point is that you can't see your code while helping the other person and you shouldn't run back and forth between your computer with your code and the computer of the person you're helping.) The slogan of the 50-foot rule is: \"Help them with your brain, not with your code.\" Please do not try to find a loophole kind of way around this e.g. projecting your code on a building 50 feet away; that is clearly not what we mean. Posting your code on a pastebin-like internet site, emailing your code to other people, sharing your screen with your code on it, printing it out, or even referring to it on your laptop while helping someone else, are all clear violations of the collaboration policy for this course. Also, we don't want you to put your code up on a computer in a room 50 feet away from where you're helping someone and run back and forth, dictating a line at a time. If you can't help them without consulting your code, don't help them. Refer them to a teaching assistant.</p> <p>Note</p> <p>The 50-foot rule only applies when helping another student in person.</p> <p>Helping another student using teleconferencing software like Zoom, Skype, Discord etc. is covered below, but one aspect of it is that screen sharing is not permitted.</p> <p>We realize that it's more convenient to ask someone in your house for help than to walk all the way to the Annenberg building. A possible solution is to get to know a TA and meet with them in their dorm room (if they are willing). Another possibility is to meet with a TA on Zoom (if they are OK with this).</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord with VOIP), you may not share your screen with other students, whether to help them or to get help from them. This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software. This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs. If this happens you may lose the ability to use the discussion board for any purpose.</p> <p>This also applies to programs with chat features that are not used in the course (like Slack or Discord), or email for that matter.</p>"},{"location":"admin/collab/#use-of-websites","title":"Use of websites","text":"<p>It is strictly forbidden to post any of the problems from the assignments onto websites (for instance, Stack Overflow), and anyone caught doing this will be charged with an Honor Code violation. This includes problems that are similar to assignment problems even if not identical. If you find a discussion of course-related material on internet websites, you may read it as long as the discussion is not about a problem that is identical to or very similar to a problem on one of the course assignments. However, do not transcribe code from the internet into your homework submissions.</p> <p>It is strictly forbidden to look at any solutions to any previous years' CS4 work posted on internet code repository sites (including but not limited to GitHub, GitLab, BitBucket, etc.). It is also strictly forbidden to put your own code on such a repository unless (a) it is a private repository, and (b) you do not allow anyone else access to this private repository. You may also not fork any such repositories that you might happen to find; we will consider this prima facie evidence of intent to plagiarize.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-eg-github-copilot-chatgpt","title":"Use of code hinting software (e.g. Github Copilot, ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. (This should be obvious.)</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments and exams.</p> Item Status Course book OK Course textbook OK Official OCaml documentation OK Other OCaml documentation OK Other OCaml books OK Your notes OK Notes of other students Not allowed Your graded assignments OK Other students' graded assignments Not allowed Other students' ungraded assignments Not allowed Other code written by anyone else that answers an assigned problem Not allowed Solutions to assignment/exam problems from a previous year Not allowed Material posted on internet forums that answers specific problems Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor (Mike). Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the course syllabus for CS 4 (Fundamentals of Computer Programming) for the Winter 2024 term.</p>"},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor/lecturer for the course is Mike Vanier (mvanier@cms.caltech.edu). Mike's pronouns are he/him.</p>"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held in Beckman Institute Auditorium (Beckman Institute, room 134) on Mondays, Wednesdays, and Fridays from 3 PM to 4 PM.</p> <p>If attendance drops significantly, lectures may be moved to Annenberg room 105. You will be informed before this happens.</p>"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for the course. Contact information for teaching assistants will be posted on the course Canvas page. Office hours for teaching assistants will be posted on the course Piazza page.</p> <ul> <li>John Brysacz</li> <li>Raffey Iqbal</li> <li>Rachael Kim</li> <li>Emily Pan</li> <li>Anagha Satish</li> <li>Jia Yue Wu</li> <li>Leo Yang</li> <li>Kyla Yu-Swanson  (head TA)</li> <li>Philippe des Boscs</li> </ul>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Times and locations of office hours for teaching assistants and the instructor will be posted on the course Piazza page (see below).</p> <p>TA office hours are normally held in-person, but may be held on Zoom in certain situations.</p> <p>The instructor (Mike) will hold office hours on Zoom.</p>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>From the Caltech catalog entry for CS 4:</p>  This course gives students the conceptual background necessary to construct and analyze programs, which includes specifying computations, understanding evaluation models, and using major programming language constructs (functions and procedures, conditionals, recursion and looping, scoping and environments, compound data, side effects, higher-order functions and functional programming, and object-oriented programming). It emphasizes key issues that arise in programming and in computation in general, including time and space complexity, choice of data representation, and abstraction management. This course is intended for students with some programming background who want a deeper understanding of the conceptual issues involved in computer programming. Prerequisites: CS 1 or instructor's permission.  <p>A longer (and arguably more accurate) description of the course is given in the Motivation page of this book.</p>"},{"location":"admin/syllabus/#recommended-textbooks","title":"Recommended textbooks","text":"<p>There are two recommended textbooks, both available online in their entirety:</p> <ul> <li> <p>Structure and Interpretation of Computer Programs,   (usually referred to as \"SICP\", and pronounced \"sick pea\"),   by Hal Abelson, Gerry Sussman, and Julie Sussman</p> </li> <li> <p>Real World OCaml, also known as \"RWO\",   by Yaron Minsky, Anil Madhavapeddy and Jason Hickey</p> </li> </ul> <p>Both books are excellent (and we thank their authors for providing them for free online!), but neither is a perfect match for CS 4. The conceptual basis of CS 4 largely derives from SICP, but SICP uses Scheme, not OCaml, as its programming language. RWO is a more recent book which has excellent coverage of OCaml, but uses the <code>Base</code> and <code>Core</code> libraries throughout, which we will not use. Nevertheless, both books are good references for the material covered in this course.</p>"},{"location":"admin/syllabus/#additional-reference-material","title":"Additional reference material","text":"<p>You should definitely bookmark the OCaml manual. Even though this is not the easiest way to learn OCaml, the manual has complete coverage of the language, including obscure topics and language extensions. More important for day-to-day programming are the chapters on the core library and (especially) the standard library, which contains links to the <code>List</code> library, the <code>Array</code> library, and so on. You should have these close by whenever writing any moderately complicated OCaml program.</p> <p>Another great resource is the online textbook for the Cornell CS 3110 course, OCaml Programming: Correct + Efficient + Beautiful, most of which was written by Michael Clarkson. This book contains a lot of excellent explanatory material on OCaml programming, and goes over the material at a slower pace than the manual. It also includes videos!</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There will be a Piazza site, which you will be enrolled in if you are registered for this course.</p> <p>For homework submission and grading, we will use CodePost.</p>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>There will be 7 assignments, one midterm exam, and one final exam. Grades will be calculated as follows:</p> Item Points Assignments (7 x 10 points each) 70 Midterm exam 20 Final exam 30 Total 120 <p>The total out of 120 will be rescaled to give an actual grade out of 100%. Letter grades will be assigned as follows:</p> Numerical grade (out of 100%) Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 65-70% C+ 62-65% C 60-62% C- 58-60% D+ 55-58% D &lt; 55% F"},{"location":"admin/syllabus/#grading-individual-assignments","title":"Grading individual assignments","text":"<p>On CodePost, assignments will be graded out of 100. Each assignment will be divided into sections. On CodePost, each section will get a certain number of points (not necessarily the same for each section). The actual grade of the assignment is the sum of all the section grades. The CodePost grade will be divided by 10 to get the actual recorded grade.</p> <p>Note</p> <p>We refer to the numerical grade on CodePost (out of 100) as the \"CodePost grade\". We divide the CodePost grade by 10 to get the actual grade. Similarly, marks on CodePost are called \"CodePost marks\", in contrast to actual marks. So 10 CodePost marks is 1 actual mark.</p> <p>The reason for this is that CodePost only lets you record grades to a precision of 0.5 marks, and we want to be able to grade in a more fine-grained manner.</p>"},{"location":"admin/syllabus/#redoing-assignments","title":"Redoing assignments","text":"<p>After you receive your initial grade on an assignment, you have one week to submit a redo. Redos will be submitted as a separate CodePost assignment called <code>Assignment N (rework)</code> (for assignment <code>N</code>). Late redos (received after the 1-week redo window) will not be graded and your previous grade will stand. You may not submit more than one redo per assignment.</p>"},{"location":"admin/syllabus/#late-policy-for-assignments","title":"Late policy for assignments","text":"<p>If an assignment is late when first submitted, marks are deducted at the rate of 2.0 marks/day (20 CodePost marks). These marks can't be regained through rework. If a rework is late (i.e. is submitted more than one week after the original grade was submitted), it doesn't count, and the previous grade stands.</p> <p>Note</p> <p>If an assignment is submitted on time, but is missing one or more sections, those sections will be graded as a 0. The assignment can be reworked, of course, but assuming the sections that were missing on the initial submission are submitted with the rework, there is no additional rework for these sections. This means (for instance) if you don't submit a section on the initial submission, but do submit it in the rework, the grade of that section in the rework is final \u2013 you don't get to rework it just because you hadn't submitted it before. So please don't leave out sections!</p> <p>Students may request extensions for assignments due to unusual circumstances. These extensions have to be approved by the course instructor (Mike).</p>"},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Thursday at 2 AM unless otherwise indicated. Note that a due time of 2 AM means early that morning, so effectively it means very late the previous evening.</p>"},{"location":"admin/syllabus/#attendance-and-participation","title":"Attendance and participation","text":"<p>Attendance and participation currently do not count towards the final grade. However, we strive to make lectures interactive and do a lot of live coding during lectures. Missing out on this will deprive you of many of the benefits of the course (as well as a lot of the fun!). Lectures will not be recorded, but all slides and code will be posted.</p>"},{"location":"admin/syllabus/#in-class-exercises","title":"In-class exercises","text":"<p>Many lectures will feature in-class exercises which will also appear on the assignments. These exercises can be (and are expected to be) solved collaboratively in class, but must be solved without collaboration on the assignments. (You may of course take notes on the solution during lectures, but you may not share these notes with other students. Consult the collaboration policies for more details.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech\u2019s Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this page.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>The course collaboration policies are listed in the collaboration policies page in this book.</p> <p>Note</p> <p>Please read the collaboration policies! You are responsible for knowing what is and isn't acceptable collaboration, and if you over-collaborate you may be sent to the Board of Control, which is never pleasant.</p>"},{"location":"admin/syllabus/#software","title":"Software","text":"<p>In this course, we will be using the OCaml programming language. Assignment 0 (which is not graded) will instruct you on how to set up the OCaml environment on your computer.</p> <p>Other than that, you will only need a terminal program and a plain text editor. There are a variety of choices for these; assignment 0 discusses this further. For in-class live coding demos, we will use either the Neovim text editor or the Visual Studio Code editor.</p> <p>If you want to try out code examples during the lectures, you can also use the online OCaml environment. This environment is sometimes a bit sluggish, so a good alternative is the Try OCaml site.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated by your classmates and the course staff with respect. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to your learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructors know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student Wellness","text":"<p>It is very important to us that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation,  recommend reasonable accommodations,  and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made.  Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See the CASS website for more information.</p> <p>Undergraduate students should contact Dr. Lesley Nye, interim Dean of Undergraduate Students (administrative contact: Beth Larranaga) and graduate students should contact Darrell Peterson, Associate Dean of Graduate Studies (administrative contact: Georgine Okura).</p>"},{"location":"assignments/0/assignment0/","title":"Assignment 0: Getting set up","text":""},{"location":"assignments/0/assignment0/#due-date","title":"Due date","text":"<p>This assignment has no due date, and isn't graded.</p>"},{"location":"assignments/0/assignment0/#overview","title":"Overview","text":"<p>The purpose of this pseudo-assignment is to make sure that all the software you need in order to do the assignments for this class is set up correctly. This is not a real assignment and it's not worth any marks, but if you want to complete the actual assignments you'll need to do it.</p>"},{"location":"assignments/0/assignment0/#getting-ocaml-installed","title":"Getting OCaml installed","text":"<p>Here are the steps you should go through to install OCaml on your computer.</p>"},{"location":"assignments/0/assignment0/#install-ocaml-and-opam","title":"Install OCaml and <code>opam</code>","text":"<p>See the instructions on the OCaml website.</p> <p>Note</p> <p>Be aware that the version numbers may have changed since that document was written. Be sure to install the correct version! This term, we are using OCaml version 5.1.1.</p>"},{"location":"assignments/0/assignment0/#macos","title":"MacOS","text":"<p>Note</p> <p>If you have never installed the MacOS command-line tools, you need to do that first.  In a terminal, type:</p> <pre><code>$ xcode-select \u2013-install\n</code></pre> <p>See this page for more information on this.</p> <p>The OCaml installation instructions for MacOS refer to the Homebrew package manager, which needs to be installed first.</p> <p>Note</p> <p>Homebrew does not come pre-installed on Macs, but it is easy to install and is incredibly useful. Almost any open-source command-line program you can imagine can be installed using Homebrew with a single command. (This includes most programming languages, including OCaml).</p> <p>We strongly recommend that you use Homebrew, and not the MacPorts package manager (an alternative package manager for Macs), unless you happen to be an expert MacPorts user.</p>"},{"location":"assignments/0/assignment0/#linux","title":"Linux","text":"<p>If you are using Linux, you can install OCaml using your system's package manager. If your Linux is an Ubuntu variant (the most common kind), you should install OCaml using the Ubuntu package manager <code>apt</code>. The commands are:</p> <pre><code>$ sudo apt update\n$ sudo apt install opam\n</code></pre> <p>The <code>sudo</code> is so you don't have to install the software as the root user. You may be asked to enter your password, which you should do.</p>"},{"location":"assignments/0/assignment0/#windows","title":"Windows","text":"<p>If you are using Windows, you should install a Linux system inside of Windows using the Windows Subsystem for Linux, also known as \"WSL\". Then you can use <code>apt</code> like on any Ubuntu Linux system. Don't try to install OCaml natively on Windows; although this may be possible, you are very likely to run into problems beyond the capability of the instructors to solve. Use WSL.</p>"},{"location":"assignments/0/assignment0/#initialization","title":"Initialization","text":"<p>Once you have a version of OCaml and <code>opam</code> installed, you need to set it up, and, if necessary, upgrade the versions. Go through the following steps.</p> <ul> <li>Start a terminal.   If you are running MacOS, you can use the <code>Terminal</code> program.   If you're using Windows/WSL, you can either use   Windows Terminal   or use Visual Studio Code   and start a terminal inside the editor.   If you're using Windows, make sure you are   running WSL inside the terminal and not Powershell   (a terminal shell that is native to Windows).   Both Windows Terminal and VS Code   allow you to select either Powershell or WSL,   assuming WSL has been installed.   The Ubuntu shell will usually be called <code>bash</code> but may be called <code>zsh</code>.</li> </ul> <p>You will be using the terminal a lot in this course, so you should   definitely get used to working inside it.</p> <ul> <li> <p>Initialize <code>opam</code> by typing <code>opam init</code> in a terminal   and following the instructions.</p> <p>Note</p> <p>There is an issue with initializing <code>opam</code> inside of WSL. Basically, due to the way WSL works, you have to initialize <code>opam</code> differently by disabling sandboxing. This theoretically can cause some problems if a package does something really stupid, but it probably won't. The fix is to use this command instead of just <code>opam init</code>:</p> <pre><code>$ opam init --disable-sandboxing\n</code></pre> </li> <li> <p>At the end of the <code>opam init</code> command,   it will ask you to run <code>eval ${opam env}</code><sup>1</sup>   to set up the <code>PATH</code> variable of your shell   to point to the <code>opam</code> directories.   This is important, because if you don't do this,   adding new packages (and new OCaml versions) will not work.   Opam will also ask you if it can change your shell initialization file   (e.g. <code>~/.bashrc</code> for <code>bash</code> or <code>~/.zshrc</code> for <code>zsh</code>)   by adding some commands.   You should say yes, because if you don't,   every time you start up a new terminal   you will have to type <code>eval ${opam env}</code>   to get <code>opam</code> to work correctly.</p> </li> <li> <p>In your terminal, type:</p> <pre><code>$ opam update\n$ opam upgrade\n</code></pre> <p>to make sure the package repository is up to date and all OCaml packages have been upgraded to the most recent versions.</p> </li> <li> <p>Check the OCaml version by typing <code>ocaml --version</code>.   If it's the desired version (which is 5.1.1 this term),   you are done with this part.   Otherwise do</p> <pre><code>$ opam switch create 5.1.1\n</code></pre> <p>and wait for the new version to be installed. (This will take a while.)</p> </li> <li> <p>Install some libraries and programs:</p> <pre><code>$ opam install utop dune ocamlformat\n</code></pre> <p>This will install the <code>utop</code>, <code>dune</code>, and <code>ocamlformat</code> programs, as well as a number of other OCaml libraries you don't have to worry about.</p> <p><code>utop</code> is the OCaml interactive interpreter. (The name <code>utop</code> is short for \"Universal Toplevel for OCaml\") We will be working with this a lot!</p> <p>Note</p> <p>There is a more primitive interactive OCaml interpreter just called <code>ocaml</code> that comes with the OCaml distribution. We won't use this, because <code>utop</code> is vastly more featureful and nicer to use.</p> <p><code>dune</code> is the OCaml compilation manager. We will introduce this when we need it (which won't be for a few weeks).</p> <p><code>ocamlformat</code> is an auto-formatter for OCaml code. You don't absolutely need this, but it's useful when you are working with longer files of code and you want to make sure everything is formatted neatly.<sup>2</sup></p> </li> </ul> <p>We will also be installing other libraries as needed for the assignments.</p>"},{"location":"assignments/0/assignment0/#using-ocaml","title":"Using OCaml","text":"<p>There are only a few things you need to know in order to use OCaml effectively.</p>"},{"location":"assignments/0/assignment0/#starting-ocaml","title":"Starting OCaml","text":"<p>Open a terminal and type:</p> <pre><code>$ utop\n</code></pre> <p>at the terminal prompt. (The <code>$</code> is the terminal prompt; don't type that.) This will bring up the OCaml interactive interpreter, which is a good environment for experimenting with the language and for testing code you've written. (This is similar to the Python interactive interpreter.)</p> <p>Note</p> <p>You can also type <code>ocaml</code> instead of <code>utop</code>, which will bring up the simpler interactive interpreter that ships with the OCaml distribution. However, <code>utop</code> is so much better than <code>ocaml</code> that there is no need to do this unless <code>utop</code> isn't working for some reason.</p> <p><code>utop</code> makes it possible to easily recall and edit previously-input lines of text by using the up and down arrow keys. To see what it can do, start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>and type the following commands (one per line, hitting the return key at the end of each line):</p> <pre><code># Printf.printf \"hello\\n\" ;;\n# Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>Note</p> <p>The <code>utop</code> prompt is the hash sign (<code>#</code>); don't type that!</p> <p>These lines should, when evaluated, print the words <code>\"hello\"</code> and <code>\"goodbye\"</code> respectively. Once you've done this, you should be able to recall either line by using the up arrow key. For instance, you can hit the up arrow key once to get the line:</p> <pre><code>Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>and edit it so that it says:</p> <pre><code>Printf.printf \"hasta la vista\\n\" ;;\n</code></pre> <p>When you hit return, it should print out <code>\"hasta la vista\"</code> on a separate line. This feature makes line editing much easier. You can also use control-a (hold the control key down and type <code>a</code>) to get to the beginning of a line you are editing and control-e to get to the end. control-l (lower-case L) clears the terminal and puts the cursor at the top of the terminal window.</p> <p>By the way, in addition to printing out the messages you wanted, you'll also see the line:</p> <pre><code>- : unit = ()\n</code></pre> <p>printed out after hitting return. This is OCaml telling you the type of the result. In this case it's the <code>unit</code> type, which is what <code>printf</code> returns. We will talk about this in class.</p> <p>Exit the interpreter by typing control-d (this is just like Python). You can also type <code>#quit;;</code> at the prompt:</p> <pre><code># #quit;;\n</code></pre> <p>and that will also work.</p>"},{"location":"assignments/0/assignment0/#configuring-utop","title":"Configuring <code>utop</code>","text":"<p>One annoying thing about <code>utop</code> is that it tends to go overboard on command completion. You can disable this by typing this inside <code>utop</code>:</p> <pre><code># #utop_prompt_dummy;;\n# UTop.set_show_box false;;\n</code></pre> <p>It's annoying to type this every time you start <code>utop</code>, so what I do is make a <code>utop</code> initialization file called <code>init.ml</code> and put it in the directory <code>~/.config/utop</code> (creating that directory if necessary). Then these commands will be run every time <code>utop</code> starts.</p> <p>Note</p> <p>Unfortunately, this will not work properly if used in a directory that has a <code>.ocamlinit</code> file in it (usually your home directory). There are workarounds, but most of the time it will work properly. Other than that, <code>utop</code> is far superior to the basic <code>ocaml</code> interpreter.</p>"},{"location":"assignments/0/assignment0/#notes-on-the-interactive-interpreter","title":"Notes on the interactive interpreter","text":"<p>One confusing aspect of OCaml is that when entering code in the interactive interpreter, nothing gets evaluated until you enter a double semicolon (<code>;;</code>) followed by a carriage return. What this does is tell the OCaml interpreter \"Hey, I'm done entering code, so take the code I've entered and evaluate it.\" The advantage of this is that you can enter code that spans more than one line without having to enter line continuation characters at the end of lines (like you have to do in e.g. Python). The confusing part is that it's almost never necessary to enter the double semicolons when writing OCaml code in a file (though it is legal). This is a very common style mistake beginning OCaml programmers make. It usually doesn't cause any harm, but it looks bad, so don't use the double semicolons when writing OCaml code in files. (We will take style marks off if you violate this guideline, so don't do it.)</p> <p>Tip</p> <p>Don't write <code>;;</code> to end chunks of code in a file of OCaml code!</p> <p>The usual way of writing code using OCaml is to write it in a file and then load the code into the interactive interpreter to test it. The interactive interpreter has several commands that are used for this, all of which begin with the hash sign (<code>#</code>). The simplest one is the <code>#use</code> command, which loads up some OCaml source code from a file, compiles it, and runs it. For instance, open up your text editor and type the following into a file called <code>test.ml</code>:</p> <pre><code>let f x = 3 * x * x + 4 * x + 5\n</code></pre> <p>(Note, by the way, that we didn't use the double semicolons, since this is OCaml code in a file!) Save the file, then start a terminal and navigate to the directory containing that file. Then start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>Inside the interpreter, type the following command:</p> <pre><code># #use \"test.ml\";;\n</code></pre> <p>The first <code>#</code> is just the OCaml prompt and shouldn't be typed. If you've done this right, OCaml should respond with:</p> <pre><code>val f : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>What this means is that OCaml has compiled the code in the file <code>test.ml</code> and is printing out the type signature of all functions it has found there (in this case, there is only one, <code>f</code>). Test that it works by typing the following:</p> <pre><code># f 10 ;;\n</code></pre> <p>OCaml should reply with:</p> <pre><code>- : int = 345\n</code></pre> <p>By the way, the <code>-</code> to the left of the colon just indicates that the value that is printed is not a named value (unlike <code>f</code>, which we saw above).</p> <p>Interpreter commands like <code>#use</code> are not part of the OCaml language; they are only used in the interactive interpreter.</p> <p>Most of the time, we will compile OCaml code outside of the interactive interpreter by using the OCaml compilers <code>ocamlc</code> and <code>ocamlopt</code>; we will discuss how to do this in later assignments. Even later, we'll learn how to automate this process using the <code>dune</code> compilation manager.</p>"},{"location":"assignments/0/assignment0/#using-visual-studio-code","title":"Using Visual Studio Code","text":"<p>You can use any text editor you like to write OCaml code, but we recommend you try Visual Studio Code (also known as VS Code), which has excellent OCaml support, and isn't difficult to set up.<sup>3</sup> In order to use it, you need to do the following steps:</p> <ul> <li> <p>Install the OCaml Language Server Protocol by typing this into a terminal:</p> <pre><code>$ opam install ocaml-lsp-server\n</code></pre> <p>A \"language server protocol\" provides a way for editors to query languages so that things like command completion and type information can be displayed in the editor while you're editing code.</p> </li> <li> <p>Install Visual Studio Code from the   VS Code website.</p> </li> <li> <p>When inside VS Code, look at the Extensions pane   (select View/Extensions from the menu).   Type \"OCaml\" into the search bar at the top,   and select and install \"OCaml Platform\".</p> </li> </ul> <p>Now you will get nice syntax highlighting and code completion when you edit OCaml source code. You can also start a terminal while inside VS Code to test your code by running the OCaml interpreter.</p> <p>OK, now you are ready to write OCaml code!</p>"},{"location":"assignments/0/assignment0/#using-dune-with-visual-studio-code","title":"Using <code>dune</code> with Visual Studio Code","text":"<p>Some aspects of the OCaml LSP server require the <code>dune</code> compilation manager in order to work. In particular, if you want to have completion on libraries (like the <code>num</code> library used in assignment 2), you will need to use <code>dune</code>.</p> <p>Note</p> <p>You should have installed <code>dune</code> using <code>opam</code> if you followed the instructions above. If not, install it like this:</p> <pre><code>$ opam install dune\n</code></pre> <p>Fortunately, using <code>dune</code> isn't hard. In the directory in which your OCaml code is being developed, create a file called <code>dune-project</code> with these contents:</p> <pre><code>(lang dune 3.1)\n</code></pre> <p>Also create a file called <code>dune</code> with these contents:</p> <pre><code>(library  \n  (name cs4)  \n  (modules lab2)  \n  (libraries num)  \n  (modes byte))\n\n(env  \n  (dev  \n    (flags (:standard -warn-error -A))))\n</code></pre> <p>Once this is done, exit restart VS Code and type this in your terminal:</p> <pre><code>$ dune build\n</code></pre> <p>Then restart VS Code, and you should get completion even on functions from the included libraries.</p> <p>For later assignments, you will be able to re-use the <code>dune-project</code> file unchanged. However, the <code>dune</code> file will need to be modified depending on the name of your code file(s) and the library/libraries you are using. Here, we are assuming that the code is <code>lab2.ml</code>, which becomes one of the \"modules\" listed (without the <code>.ml</code> suffix), and we are using the <code>num</code> library, which becomes one of the \"libraries\" listed. You can specify multiple modules and multiple libraries. If you aren't using any libraries, you can leave out the <code>(libraries ...)</code> line.</p> <p>Also, if you are developing each assignment in a separate directory (which you should be), then you can just put the <code>dune-project</code> in the parent directory of all the assignment directories and it will work (you won't need to copy that file). On the other hand, each assignment directory will need its own <code>dune</code> file.</p> <ol> <li> <p>Or possibly <code>eval ${opam config env}</code> or something similar. It all does the same thing.\u00a0\u21a9</p> </li> <li> <p>It's also a great way to avoid losing marks for poor coding style!\u00a0\u21a9</p> </li> <li> <p>I (Mike) actually use Neovim as my code editor most of the time. Neovim is incredibly powerful, but it takes a lot longer to learn and to configure. I don't recommend it to students unless they are willing to spend a lot of time learning it.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/assignment1/","title":"Assignment 1: Evaluation and recursion","text":""},{"location":"assignments/1/assignment1/#things-you-should-read","title":"Things you should read","text":"<p>As this is the first real assignment, we would like to remind you of some documents that you should read (or at least skim) before starting your assignment:</p> <ul> <li> <p>The course syllabus.</p> <p>This contains all the administrative information of the course. In particular, it describes the grading scheme for the course as a whole and also for individual assignments. It also describes the rework and late policies for assignments.</p> </li> <li> <p>The course collaboration policies.</p> <p>This document describes what kind of collaboration are allowed on assignments, and what isn\u2019t allowed.</p> <p>Note</p> <p>It\u2019s easy to just assume you won\u2019t do anything wrong, but please read this page, because if you don\u2019t, and you\u2019re involved in some kind of collaboration that isn\u2019t allowed, you could end up getting called before the Caltech Board of Control (BoC), which is not a pleasant experience.</p> </li> <li> <p>The OCaml cheat sheet.</p> <p>The cheat sheet describes a number of potentially confusing aspects of OCaml syntax. If you discover some weird behavior of OCaml you don\u2019t understand, the cheat sheet is the first place you should look. You don\u2019t need to read all of it now, but take a look and come back to it as needed.</p> </li> </ul>"},{"location":"assignments/1/assignment1/#due-date","title":"Due date","text":"<p>This assignment is due on Thursday, January 18th, at 2 AM.</p>"},{"location":"assignments/1/assignment1/#grading-scheme","title":"Grading scheme","text":"<p>See the syllabus for the assignment grading scheme.</p>"},{"location":"assignments/1/assignment1/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 4, corresponding to section 1.2.3 of SICP. Some material from recitation 1 is also covered.</p>"},{"location":"assignments/1/assignment1/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab1.ml</code>.  This file should be submitted to CodePost as <code>Assignment 1</code>.  Please indicate in a comment what problem any piece of code in your submission refers to. For instance:</p> <pre><code>(* A.2 *)\n</code></pre> <p>refers to problem 2 of section A.</p>"},{"location":"assignments/1/assignment1/#supplied-files","title":"Supplied files","text":"<p>We are supplying you with this file:</p> <ul> <li><code>lab1.mli</code></li> </ul> <p>You should download it from the course Canvas site. Its use will be described below.</p>"},{"location":"assignments/1/ocaml_notes/","title":"Assignment 1: OCaml notes","text":""},{"location":"assignments/1/ocaml_notes/#mli-files","title":"<code>.mli</code> files","text":"<p>For this and all subsequent assignments, we will be supplying you with one or more OCaml interface files to be used with your code. For this assignment, the file is called <code>lab1.mli</code> (note the <code>.mli</code> extension; all OCaml interface files have this filename extension), and you should download it into the same directory that you are using to write and test your <code>lab1.ml</code> code.</p> <p>The interface file consists mostly of type signatures of functions, though occasionally it will have other things as well. The <code>lab1.mli</code> interface file looks like this:</p> <pre><code>(* Interface file for lab1.ml *)\n\nval sum_squares_to : int -&gt; int\nval sum_of_squares_of_two_largest : int -&gt; int -&gt; int -&gt; int\nval factorial : int -&gt; int\nval e_term : int -&gt; float\nval e_approximation : int -&gt; float\nval is_even : int -&gt; bool\nval is_odd : int -&gt; bool\nval f_rec : int -&gt; int\nval f_iter : int -&gt; int\nval pascal_coefficient : int -&gt; int -&gt; int\n</code></pre> <p>The <code>val</code> declarations indicate that the type signature of a particular value is being described. Here, all such values are functions (functions are values in OCaml). For instance, the <code>factorial</code> function has the type signature:</p> <pre><code>val factorial : int -&gt; int\n</code></pre> <p>which indicates that it takes one argument (an <code>int</code>) and returns an <code>int</code>, as you would expect. Functions which take more arguments (like <code>pascal_coefficient</code>, which takes two integer arguments) have somewhat less intuitive type signatures:</p> <pre><code>val pascal_coefficient : int -&gt; int -&gt; int\n</code></pre> <p>You might have expected something like this instead:</p> <pre><code>val pascal_coefficient : int int -&gt; int  (* WRONG *)\n</code></pre> <p>The reason why this is wrong is that arguments to OCaml functions are automatically curried, which means that they can be partially applied. (The name \"curried\" is a tribute to Haskell Curry, a logician who provided much of the theoretical foundation for modern functional programming languages.) In this case, it means that if we call <code>pascal_coefficient</code> with only one argument (an integer), it will return a function that takes the other integer argument and returns the integer result. Currying can occasionally give rise to confusing error messages, but it\u2019s also extremely handy in practice, as we will see.</p> <p>OK, let\u2019s assume you\u2019ve written all of your code, and you want to check that it conforms to the type declarations in the <code>.mli</code> file. How do you do that? The simplest way is to compile your code along with the interface file from the command line:</p> <pre><code>$ ocamlc -c lab1.mli lab1.ml\n</code></pre> <p>If no error messages are printed, your code is at least type-correct! Also, if you list the files in your directory, you will see two new ones: <code>lab1.cmi</code> and <code>lab1.cmo</code>. These are the (byte-code) compiled versions of the <code>lab1.mli</code> and <code>lab1.ml</code> files, respectively. Note that you have to put the <code>.mli</code> file before the <code>.ml</code> file on the command line; this won\u2019t work:</p> <pre><code>$ ocamlc -c lab1.ml lab1.mli\n</code></pre> <p>unless the <code>.cmi</code> file has already been compiled, in which case you don\u2019t have to have <code>lab1.mli</code> on the command line anyway. This is a bit annoying, but we live with it.</p> <p>You can now load the <code>.cmo</code> file into an interactive OCaml session as follows:</p> <pre><code># #load \"lab1.cmo\";;\n</code></pre> <p>In this case, nothing will be printed if there are no errors. A different way to load your code is to use the <code>#use</code> command:</p> <pre><code># #use \"lab1.ml\";;\n</code></pre> <p>If you do this, then OCaml will compile your code and print out the signature of every value in <code>lab1.ml</code>. When using <code>#use</code>, you don\u2019t need to compile your code beforehand. When using <code>#load</code>, you do. As a result, we tend to use <code>#use</code> more than <code>#load</code> when interactively developing code. You should know both forms.</p> <p>Let's go back to what would happen if you typed:</p> <pre><code># #load \"lab1.cmo\";;\n</code></pre> <p>You might expect that you could then use all the functions in <code>lab1.ml</code> (as you could if you\u2019d used <code>#use</code>). Actually, that isn\u2019t the case (yet). If you try, this will happen:</p> <pre><code># pascal_coefficient;;\nError: Unbound value pascal_coefficient\n</code></pre> <p>Huh? We just loaded <code>lab1.ml</code>, and <code>lab1.ml</code> defines <code>pascal_coefficient</code>, so why do we get an error message? It turns out that <code>#load</code> loads the code as a separate module called <code>Lab1</code> (the name of the file, without the extension, and with the first letter capitalized). This is like saying <code>import lab1</code> in Python. We can get the function by using the module name as a prefix:</p> <pre><code># Lab1.pascal_coefficient;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>Notice that we have to capitalize the first letter of <code>Lab1</code>. Module names are always capitalized in OCaml.</p> <p>If this is too tedious, you can dump all the names in the module into the local namespace by using an <code>open</code> declaration:</p> <pre><code># open Lab1;;\n# pascal_coefficient;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>This is like saying <code>from lab1 import *</code> in Python. Alternatively, if you used <code>#use</code> to load and compile the code, all the functions in the file are available immediately. This is another reason why <code>#use</code> is used more often for interactive development.</p> <p>It\u2019s important to realize that <code>#use</code> and <code>#load</code> are special commands of the OCaml interactive interpreter (also called the \"toplevel\"); they are not part of the OCaml language itself. (There are other special interpreter commands as well, which we will get to when we need them.)</p> <p>We will have much, much more to say about the OCaml module system in future assignments. OCaml actually has the most powerful module system of any computer language in wide use.</p> <p>Once you have finished writing your code, you should always compile it against the <code>.mli</code> file we provide to check that your code not only compiles, but also has the type signature we want. (Using <code>#use</code> will check that your code compiles, but it may not have the type signature we want.)</p> <p>In later assignments, we will introduce the <code>dune</code> compilation manager, which will automate all the tedious parts of compilation.</p>"},{"location":"assignments/1/partA_exercises/","title":"Part A: Exercises (35 points)","text":"<p>Some of the following problems are taken from the textbook (Structure and Interpretation of Computer Programs, or SICP for short). If so, the SICP exercise numbers are included, though you shouldn't need to consult the book.</p> <p>The online version of SICP is here.</p>"},{"location":"assignments/1/partA_exercises/#0-in-class-exercise-no-collaboration","title":"0. In-class exercise [No collaboration]","text":"<p>Note</p> <p>Problems in the in-class exercises section (there's only one in this assignment) were done in class collaboratively. However, you must reproduce them here (or write them from scratch, if you didn't attend class) without any collaboration. You are allowed to use notes/code that you yourself wrote down during the lecture, but that is all.</p> <p>You also cannot ask the TAs or the instructor for help solving in-class exercises, unless you are working on a rework of the (graded) assignment which included the exercise(s).</p> <p>See the collaboration policies for more information on in-class exercises.</p> <p>[5 points]</p> <p>Write a recursive function called <code>sum_squares_to</code> that takes a non-negative integer <code>n</code> as its only argument. It returns the sum of the squares of all integers from 0 to <code>n</code>.</p> <p>You can use either an <code>if</code> expression or pattern matching.</p> <p>Examples</p> <pre><code>sum_squares_to 0    --&gt; 0\nsum_squares_to 1    --&gt; 1\nsum_squares_to 2    --&gt; 5\nsum_squares_to 3    --&gt; 14\nsum_squares_to 5    --&gt; 55\nsum_squares_to 10   --&gt; 385\nsum_squares_to 20   --&gt; 2870\nsum_squares_to 50   --&gt; 42925\nsum_squares_to 100  --&gt; 338350\nsum_squares_to 1000 --&gt; 333833500\n</code></pre>"},{"location":"assignments/1/partA_exercises/#1-expressions","title":"1. Expressions","text":"<p>[10 points]</p> <p>Below is a sequence of expressions. What is the result (the type and value or the error message) printed by the OCaml interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented. If the interpreter indicates an error, explain briefly (one sentence) why the error occurred. There are also some other questions below which you should answer to the best of your ability. Note that entering each code fragment interactively requires that you add the <code>;;</code> terminator to terminate input. Write your answers as OCaml comments <code>(* like this *)</code>.</p> <ol> <li><code>10</code></li> <li><code>10.</code></li> <li><code>5 + 3 + 4</code></li> <li><code>3.2 + 4.2</code></li> <li><code>3 +. 4</code></li> <li><code>3 + 4.2</code></li> <li><code>3 +. 4.2</code></li> <li><code>3.0 +. 4.2</code></li> <li><code>9 - 3 - 1</code></li> <li><code>9 - (3 - 1)</code></li> <li><code>let a = 3</code></li> <li><code>let b = a + 1</code></li> <li><code>a = b</code></li> <li><code>[1; 2; 3] = [1; 2; 3]</code></li> <li><code>[1; 2; 3] == [1; 2; 3]</code> Is this the same as or different from the previous expression? Why or why not?</li> <li><code>[(1, 2, 3)]</code></li> <li><code>[1, 2, 3]</code> Explain why this gives the result it does. This is a nasty pitfall which highlights one of the less desirable features of OCaml\u2019s syntax. (See the OCaml cheat sheet for more on this.)</li> <li><code>if b &gt; a &amp;&amp; b &lt; a * b then b else a</code></li> <li><code>if b &gt; a and b &lt; a * b then b else a</code></li> <li><code>2 + if b &gt; a then b else a</code></li> <li><code>if b &gt; a then b else a + 2</code> Why is this different from the previous case?</li> <li><code>(if b &gt; a then b else a) + 2</code></li> <li><code>if b &gt; a then b</code> This is not a syntax error. Why does this give a type error? Hint: What does OCaml assume if the <code>else</code> in an <code>if</code>/<code>then</code>/<code>else</code> form is left off?</li> </ol>"},{"location":"assignments/1/partA_exercises/#2-sicp-exercise-13","title":"2. (SICP exercise 1.3)","text":"<p>[10 points]</p> <p>Define a function that takes three integer numbers as arguments and returns the sum of the squares of the two larger numbers. Call the function you define <code>sum_of_squares_of_two_largest</code>. You will probably find the <code>&amp;&amp;</code> special operator to be handy.</p>"},{"location":"assignments/1/partA_exercises/#3-sicp-exercise-14","title":"3. (SICP exercise 1.4)","text":"<p>[10 points]</p> <p>Our evaluation model allows you to use a function which is a compound expression (something that evaluates to a function). Use this observation to describe the behavior of the following function:</p> <pre><code>let a_plus_abs_b a b =\n  (if b &gt; 0 then (+) else (-)) a b\n</code></pre> <p>Write your answer in a comment. Note that surrounding an operator with parentheses makes it into a two-argument function, so</p> <pre><code>(+) 2 3\n</code></pre> <p>is the same as:</p> <pre><code>2 + 3\n</code></pre>"},{"location":"assignments/1/partB_evaluation/","title":"Part B: Evaluation (35 points)","text":"<p>In this section, write all essay-question-type answers inside OCaml comments.</p>"},{"location":"assignments/1/partB_evaluation/#1-sicp-exercise-15","title":"1. (SICP exercise 1.5)","text":"<p>[10 points]</p> <p>Note</p> <p>Before tackling this problem, read the subsection in SICP, section 1.1.5 (scroll down a little to get to the subsection) called Applicative order versus normal order (not covered in class!). Applicative order evaluation is just the evaluation rule we described in class; it\u2019s usually just called \"strict evaluation\". Normal order evaluation is an alternative to the evaluation rule we learned in class. In normal order evaluation, nothing is evaluated unless it needs to be to get the final result (it\u2019s sometimes called \"call-by-need\" where applicative order evaluation is called \"call-by-value\"). Normal order evaluation is used in some functional languages like Haskell (more accurately, Haskell uses lazy evaluation, which is a more efficient version of normal order evaluation).</p> <p>Ben Bitfiddle has invented a test to determine whether the interpreter he is faced with is using applicative order evaluation or normal order evaluation. He defines the following two functions:</p> <pre><code>let rec p () = p ()\nlet test x y = if x = 0 then 0 else y\n</code></pre> <p>He then evaluates the expression:</p> <pre><code>test 0 (p ())\n</code></pre> <p>What behavior will Ben observe with an interpreter that uses applicative order evaluation? What behavior will he observe with an interpreter that uses normal order evaluation? Explain your answer. (Assume that the evaluation rule for the special form <code>if</code> is the same whether the interpreter is using normal or applicative order: the predicate (test) expression is evaluated first, and the result determines whether to evaluate the consequent (<code>then</code>) or the alternative (<code>else</code>) expression.)</p> <p>NOTE: This problem doesn\u2019t require a lengthy explanation; two or three sentences should be enough.</p>"},{"location":"assignments/1/partB_evaluation/#2-sicp-exercise-16","title":"2. (SICP exercise 1.6)","text":"<p>[5 points]</p> <p>This problem is one of my (Mike\u2019s) favorites.</p> <p>Alyssa P. Hacker doesn\u2019t see why <code>if</code> needs to be provided as a special syntactic form. \"Why can\u2019t I just define <code>if</code> as an ordinary function?\" she asks. Alyssa\u2019s friend Eva Lu Ator claims this can indeed be done, and she defines a new version of <code>if</code> using pattern matching:</p> <pre><code>let new_if predicate then_clause else_clause =\n  match predicate with\n    | true  -&gt; then_clause\n    | false -&gt; else_clause\n</code></pre> <p>Note</p> <p>Of course, since this is a function it will have to be called using function syntax (the <code>if</code> syntax is built-in to OCaml).</p> <p>Eva demonstrates its use to Alyssa:</p> <pre><code># new_if (2 = 3) 0 5;;\n- : int = 5\n# new_if (1 = 1) 0 5;;\n- : int = 0\n</code></pre> <p>Delighted, Alyssa uses <code>new_if</code> to write the following program to compute square roots:</p> <pre><code>let square x = x *. x\nlet average x y = (x +. y) /. 2.0\n\nlet improve guess x = average guess (x /. guess)\nlet is_good_enough guess x =\n  abs_float (square guess -. x) &lt; 0.00001\n\nlet rec sqrt_iter guess x =\n  new_if (is_good_enough guess x)\n         guess\n         (sqrt_iter (improve guess x) x)\n</code></pre> <p>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>"},{"location":"assignments/1/partB_evaluation/#3-sicp-exercise-19","title":"3. (SICP exercise 1.9)","text":"<p>[20 points]</p> <p>Each of the following two functions defines a method for adding two positive integers in terms of the functions <code>inc</code>, which increments its argument by 1, and <code>dec</code>, which decrements its argument by 1.</p> <pre><code>let rec add_a a b =\n  if a = 0\n    then b\n    else inc (add_a (dec a) b)\n\nlet rec add_b a b =\n  if a = 0\n    then b\n    else add_b (dec a) (inc b)\n</code></pre> <p>Note that <code>inc</code> or <code>dec</code> could trivially be defined as:</p> <pre><code>let inc a = a + 1\nlet dec a = a - 1\n</code></pre> <p>but for this problem, assume that they are primitive functions.</p> <p>We will use the substitution model to understand the process generated by each function when evaluating <code>add_a 2 5</code> and <code>add_b 2 5</code>.</p> <ol> <li> <p>Both <code>add_a</code> and <code>add_b</code> are recursive functions. State whether they generate recursive or iterative processes in the sense described in the lectures and in the book.</p> </li> <li> <p>For the <code>add_a</code> function only, we want you to write out the substitution model evaluation in great detail. That means you have to actually write out the fact that numbers evaluate to themselves, built-in functions evaluate to their internal representations, functions with arguments desugar to their corresponding <code>fun</code> forms, etc. Don\u2019t skip steps or you\u2019ll lose marks on this problem. Also note when names are bound to their values.</p> <p>One shortcut that you can take is to replace the body of a function with ellipses (<code>...</code>), or to replace parts of it that aren\u2019t relevant with ellipses. Please indent your work to make it obvious when you are evaluating a subexpression, a sub-sub-expression, etc. Be explicit about writing out evaluate, apply, and substitution steps, and when you are desugaring a function definition into the equivalent <code>fun</code> form. Also note where you are invoking a special form rule distinct from the usual evaluation rule (e.g. with an <code>if</code> expression).</p> <p>Assume that function arguments evaluate from left to right. This isn\u2019t necessary to get the right result, but it will make it easier for your graders to grade if everyone does this the same way.</p> <p>Write the substitution model evaluation in an OCaml comment. Our solution for this part is around 60-70 lines long. If your solution is much shorter than that, then you are skipping too many steps.</p> <p>You may find the reading on the substitution model to be useful.</p> <p>Note</p> <p>We realize that some of you (OK, all of you) may dislike this problem. Think of it the same way you might think of taking cod liver oil or eating broccoli; unpleasant but ultimately good for you. Understanding how a computer evaluates expressions is fundamental knowledge, and we will revisit this idea several times in this course (but it will never again be as tedious as in this problem!).</p> </li> <li> <p>For the <code>add_b</code> function, we want you to correct the following substitution model evaluation that Ben Bitfiddle dashed off in a hurry. Copy his evaluation into a comment and add the lines that Ben forgot to include. Each such line should start with the characters:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> <p>so your grader can easily identify them.</p> <p>Note</p> <p>Don't write out your own substitution model evaluation from scratch! Just modify the evaluation below by adding the missing lines.</p> <pre><code>(*\nlet rec add_b a b =\n  if a = 0\n     then b\n     else add_b (dec a) (inc b)\n\nDesugar this to:\n\nlet rec add_b =\n  fun a b -&gt;\n    if a = 0\n       then b\n       else add_b (dec a) (inc b)\n\nBind the name \"add_b\" to the value:\n\n  fun a b -&gt;\n    if a = 0\n       then b\n       else add_b (dec a) (inc b)\n\nEvaluate (add_b 2 5)\n  apply (fun a b -&gt; if ...) to 2, 5\n  substitute 2 for a, 5 for b in (if ...)\n    -&gt; if 2 = 0 then 5 else add_b (dec 2) (inc 5)\n  evaluate (if 2 = 0 then 5 else add_b (dec 2) (inc 5))\n    if is a special form, so evaluate the first operand:\n      evaluate (2 = 0)\n        apply = to 2, 0 -&gt; false\n    first argument of if is false, so evaluate the third operand:\n      evaluate (add_b (dec 2) (inc 5))\n        evaluate (dec 2)\n          apply dec to 2 -&gt; 1\n        evaluate (inc 5)\n          apply inc to 5 -&gt; 6\n        apply (fun a b -&gt; if ...) to 1, 6\n        substitute 1 for a, 6 for b in (if ...)\n          -&gt; if 1 = 0 then 6 else add_b (dec 1) (inc 6)\n        evaluate (if 1 = 0 then 6 else add_b (dec 1) (inc 6))\n          if is a special form, so evaluate the first operand:\n            evaluate (1 = 0)\n              apply = to 1, 0 -&gt; false\n          first argument of if is false, so evaluate the third operand:\n            evaluate (add_b (dec 1) (inc 6))\n              evaluate (dec 1)\n                apply dec to 1 -&gt; 0\n              evaluate (inc 6)\n                apply inc to 6 -&gt; 7\n              apply (fun a b -&gt; if ...) to 0, 7\n              substitute 0 for a, 7 for b in (if ...)\n                -&gt; if 0 = 0 then 7 else add_b (dec 0) (inc 7)\n              evaluate (if 0 = 0 then 7 else add_b (dec 0) (inc 7))\n                if is a special form, so evaluate the first operand:\n                  evaluate (0 = 0)\n                    apply = to 0, 0 -&gt; true\n                first argument of if is true, so evaluate the second operand:\n                  result: 7\n*)\n</code></pre> </li> </ol>"},{"location":"assignments/1/partC_recursion/","title":"Part C: Recursion (30 points)","text":""},{"location":"assignments/1/partC_recursion/#1-computing-e","title":"1. Computing e","text":"<p>[10 points]</p> <p>In this problem we're going to write a function that enables us to compute the number e, the base of natural logarithms, which is equal to 2.7182818... We will do this by summing a part of an infinite series expansion which computes e:</p> <pre><code>e = 1/0! + 1/1! + 1/2! + ...\n</code></pre> <p>where <code>n!</code> is the factorial of <code>n</code>, which in defined as</p> <pre><code>n! = n * (n-1) * (n-2) * ... * 1\n</code></pre> <p>We'll start out with the factorial function itself:</p> <pre><code>(* This function computes the factorial of the input number,\n   which for a number n is equal to n * (n-1) * ... * 1. *)\nlet rec factorial n =\n  if n = 0 then 1 else n * factorial (n - 1)\n</code></pre> <p>Note</p> <p>The definition of <code>factorial</code> has to be included in your assignment submission or the rest of the code won't work.</p> <p>Also, if you're unhappy because this is a space-inefficient way to compute factorials, you're right! But it won't matter for this problem.</p>"},{"location":"assignments/1/partC_recursion/#a-e_term","title":"a. <code>e_term</code>","text":"<p>Write a simple function called <code>e_term</code> which takes a (non-negative) integer argument and computes that term of the infinite series expansion of <code>e</code>. This function is not recursive. Note that the result must be a floating-point number; use the <code>float_of_int</code> function to convert from an OCaml <code>int</code> to a <code>float</code>.</p> <p>Note</p> <p>OCaml never implicitly promotes one numeric type to another, so you must do it explicitly if that's what you want.</p> <p>Examples</p> <pre><code># e_term 0;;\n- : float = 1.\n# e_term 1;;\n- : float = 1.\n# e_term 2;;\n- : float = 0.5\n# e_term 5;;\n- : float = 0.00833333333333333322\n</code></pre>"},{"location":"assignments/1/partC_recursion/#b-e_approximation","title":"b. <code>e_approximation</code>","text":"<p>Write a recursive function called <code>e_approximation</code> that takes one positive integer argument and computes an approximation to e (an \"e-proximation\", as it were) by summing up that many terms of the infinite series expansion of e (actually, it'll sum up the first n+1 terms, since it starts at term 0 and ends at term n). Write the function as a linear recursive process. Use your <code>e_term</code> function to help you write this one.</p> <p>Examples</p> <pre><code># e_approximation 0;;\n- : float = 1.\n# e_approximation 1;;\n- : float = 2.\n# e_approximation 2;;\n- : float = 2.5\n# e_approximation 5;;\n- : float = 2.71666666666666634\n# e_approximation 10;;\n- : float = 2.71828180114638451\n</code></pre>"},{"location":"assignments/1/partC_recursion/#c-computing-the-approximation","title":"c. Computing the approximation","text":"<p>Compute an approximation to e by summing up to the 20th term of the infinite series expansion. Write down the answer that OCaml gives you in a comment in your lab submission. Then write down the value of <code>exp 1.0</code> which is <code>e</code> to the power of <code>1</code>, and compare with the result given by <code>e_approximation 20</code> (they should be nearly identical).</p>"},{"location":"assignments/1/partC_recursion/#d-too-many-terms","title":"d. Too many terms?","text":"<p>What happens if you try to compute a better approximation to <code>e</code> by summing up to the 100th term of the infinite series expansion? Why does this happen? Write your answer in a comment.</p>"},{"location":"assignments/1/partC_recursion/#2-mutual-recursion","title":"2. Mutual recursion","text":"<p>[5 points]</p> <p>It's possible to have a kind of recursion which involves more than one function; this is called mutual recursion. A simple example is a pair of functions <code>is_even</code> and <code>is_odd</code>. <code>is_even</code> is a predicate which returns <code>true</code> if its argument is an even (non-negative) integer and <code>false</code> if its argument is an odd (non-negative) integer (zero is considered even). <code>is_odd</code> returns <code>true</code> if its numeric argument is odd and <code>false</code> otherwise. Write these functions, using only recursion, testing for equality with zero, and subtracting 1. (The solution is very short.) Since the solution uses mutual recursion, the <code>is_even</code> function will need to call the <code>is_odd</code> function and the <code>is_odd</code> function will need to call the <code>is_even</code> function.</p> <p>Note</p> <p>Of course, this is an extremely inefficient way of computing evenness and oddness! It's just for illustration purposes.</p> <p>When defining mutually recursive functions in OCaml, you need to use the <code>let rec ... and ...</code> syntax:</p> <pre><code>let rec f1 a b c = ...  (* ... may include f2 *)\nand f2 x y z = ...      (* ... may include f1 *)\n</code></pre> <p>This works for any number of mutually-recursive functions. The whole form starts with a <code>let rec</code> and then each function after the first in the group starts with <code>and</code>.</p> <p>Note</p> <p>Mutual recursion might seem like something extremely esoteric with few real uses, but it isn't. If you are writing a programming language interpreter or compiler (as you will if you take CS 131 or CS 164), you will find that your code is full of large swaths of mutually-recursive functions.</p>"},{"location":"assignments/1/partC_recursion/#3-sicp-exercise-111","title":"3. (SICP exercise 1.11)","text":"<p>[5 points]</p> <p>A function <code>f</code> is defined by the rules:</p> <ul> <li><code>f(n) = n</code> if <code>n &lt; 3</code></li> <li><code>f(n) = f(n - 1) + 2 * f(n - 2) + 3 * f(n - 3)</code> if <code>n &gt;= 3</code>.</li> </ul> <p>Write a function called <code>f_rec</code> that computes <code>f</code> by means of a recursive process. Write another function called <code>f_iter</code> that computes <code>f</code> by means of an iterative process.</p> <p>Hint</p> <p>The recursive definition is straightforward. Use it to check the correctness of the iterative definition. The iterative definition will need a helper function that keeps track of the last three numbers in the series, among other things.</p> <p>Examples</p> <pre><code># f_rec 0;;\n- : int = 0\n# f_rec 1;;\n- : int = 1\n# f_rec 3;;\n- : int = 4\n# f_rec 10;;\n- : int = 1892\n# f_rec 20;;\n- : int = 10771211\n(* f_iter gives the same results *)\n</code></pre>"},{"location":"assignments/1/partC_recursion/#4-sicp-exercise-112","title":"4. (SICP exercise 1.12)","text":"<p>[10 points]</p> <p>The following pattern of numbers is called \"Pascal's triangle\":</p> <pre><code>    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n</code></pre> <p>The numbers at the edges of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it to the left and right. Write a function called <code>pascal_coefficient</code> which takes two <code>int</code> arguments (corresponding to the row number (starting from 1) and the index inside the row (also starting from 1)) and computes elements of Pascal's triangle by means of a recursive process.</p> <p>Use pattern matching to make the code cleaner. This is not optional! Use of <code>if</code>/<code>then</code>/<code>else</code> in your solution will result in lost marks.</p> <p>Note</p> <p>If you have a <code>match</code>, but use a <code>when</code> clause with each match case, this is equivalent to having nested <code>if</code>/<code>then</code>/<code>else</code> expressions, and you will still lose marks.  See the hint below.</p> <p>For arguments that don't correspond to locations in Pascal's triangle (like numbers &lt; 1 or index numbers that are greater than the row number) you should signal an error using the code: <code>failwith \"invalid arguments\"</code>. This raises a <code>Failure</code> exception. We'll talk more about exceptions later in the course.</p> <p>Examples</p> <pre><code># pascal_coefficient 1 1 ;; (* row 1, index 1 in row *)\n- : int = 1\n# pascal_coefficient 2 1 ;;\n- : int = 1\n# pascal_coefficient 2 2 ;;\n- : int = 1\n# pascal_coefficient 3 1 ;;\n- : int = 1\n# pascal_coefficient 3 2 ;;\n- : int = 2\n# pascal_coefficient 3 3 ;;\n- : int = 1\n# pascal_coefficient 10 5 ;;\n- : int = 126\n# pascal_coefficient 1 0 ;;\nException: Failure \"invalid arguments\".\n</code></pre> <p>Hints</p> <ul> <li> <p>It's much easier to write this as a recursive process   (i.e. with pending operations) than as an iterative process,   though both approaches will involve recursive functions.   Since you don't have to do it both ways,   we recommend you write it as a recursive process.</p> </li> <li> <p>Pattern match on a tuple of both input arguments.   Use the <code>when</code> form in a pattern   when you need to specify non-structural conditions for a match   (like two things being equal).   Only use <code>when</code> when you can't use structural pattern matching.   For instance, don't do this kind of thing:</p> <pre><code>match x with\n  | x' when x' = 1 -&gt; ...\n  ...\n</code></pre> <p>when you can do this instead:</p> <pre><code>match x with\n  | 1 -&gt; ...\n  ...\n</code></pre> <p>Also don't forget about the <code>_</code> (wildcard) syntax for don't-care patterns. Remember that a number in a pattern matches that literal number only.</p> </li> <li> <p>It's convenient (though not required)   to use the first pattern match for error checking only.</p> </li> </ul> <p>Despite all this explanation, this function only needs to be a few lines long.</p>"},{"location":"assignments/2/assignment2/","title":"Assignment 2: Asymptotic complexity and higher-order functions","text":""},{"location":"assignments/2/assignment2/#due-date","title":"Due date","text":"<p>This assignment is due on Thursday, January 25th, at 2 AM.</p>"},{"location":"assignments/2/assignment2/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 6, corresponding to section 1.3.4 of SICP.</p>"},{"location":"assignments/2/assignment2/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab2.ml</code>. This file should be submitted to CodePost as <code>Assignment 2</code>. Do not submit the interface file (<code>lab2.mli</code>), or the test script (<code>tests_lab2.ml</code>), or the <code>Makefile</code> we supply for you.</p>"},{"location":"assignments/2/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/2/ocaml_notes/#packages-needed","title":"Packages needed","text":"<p>For this assignment, you\u2019ll need to have the following <code>opam</code> packages installed:</p> <ul> <li><code>ocamlfind</code> (various compilation utilities)</li> <li><code>ounit2</code> (unit testing)</li> <li><code>num</code> (arbitrary-precision integer/rational number arithmetic)</li> </ul> <p><code>ocamlfind</code> should already be installed if you followed the instructions in assignment 0. Install the other packages using <code>opam</code> as follows:</p> <pre><code>$ opam update\n$ opam install ounit2 num\n</code></pre> <p>As you can see, you can install multiple packages using one <code>opam</code> command. Type this:</p> <pre><code>$ opam list\n</code></pre> <p>after installation and verify that the <code>ocamlfind</code>, <code>ounit2</code>, and <code>num</code> packages are installed. If not, consult with a TA or the instructor.</p>"},{"location":"assignments/2/ocaml_notes/#testing","title":"Testing","text":"<p>Note</p> <p>In what follows, we're assuming that you are editing and running your code in a Unix-like environment (MacOS X, Linux, or Windows with WSL). If you aren't (e.g. if you are running Windows and are using Powershell instead of the WSL <code>bash</code> shell), things will not work correctly.</p> <p>Note that you can easily run WSL shells from inside Visual Studio Code, and this is recommended if you're using Windows.</p> <p>See a TA if you are having problems getting set up. (Also review assignment 0, which contains detailed instructions on how to get set up.)</p> <p>For this assignment, we are supplying you with these support files:</p> <ol> <li>An OCaml interface file: <code>lab2.mli</code></li> <li>a test script: <code>tests_lab2.ml</code></li> <li>a <code>Makefile</code> to automate compilation.</li> </ol> <p>These files are all available on the course Canvas site in a single zip file called <code>lab2.zip</code>. Download this file and unzip it:</p> <pre><code>$ unzip lab2.zip\n</code></pre> <p>This will create a <code>lab2</code> directory with the files inside it. You should not change these files, and you should not submit them as part of your assignment submission. You should create and edit the file <code>lab2.ml</code> (which you will be handing in) in the same directory.</p> <p>In order to run the test script, you will need to use the <code>ounit2</code> unit testing libraries, which you should have installed (see above). <code>ounit2</code> is a set of libraries which make it easy to write unit tests for OCaml code (sort of like <code>pytest</code> for Python).</p> <p>Note</p> <p>The term library is vague. The technical terms are package (used mainly by <code>opam</code>) and module (used by OCaml itself). We'll often use the word \"library\" informally to refer to the set of modules in a package.</p> <p>Once your assignment is done, you should compile it and check that it conforms to the interface file by entering this command:</p> <pre><code>$ make compile\n</code></pre> <p>Of course, you can also compile your code from inside the <code>utop</code> OCaml interpreter using the <code>#use</code> directive. Using <code>#use</code> is recommended while developing code to check that the code has no type errors. Using the <code>make</code> command is useful when the code is finished to make sure that all your functions, types etc. have the correct type signatures (which they should, if you have been following the directions). Note that it\u2019s possible to write a function that type checks but doesn\u2019t have the type we want it to have; that\u2019s why using <code>make</code> is important. The type signatures we expect are in the <code>lab2.mli</code> interface file, and these are used by the <code>Makefile</code> when compiling the code.</p> <p>Finally, to run the test script, type this after compiling the code with <code>make compile</code>:</p> <pre><code>$ make test\n</code></pre> <p>This will compile the <code>tests_lab2.ml</code> file (which contains the unit tests) and output an executable program called <code>tests_lab2</code>. Then it will run that program and report all test failures. If the test program doesn\u2019t compile, you probably haven\u2019t installed the <code>ounit2</code> library; see above. If you did and it still doesn\u2019t work, ask a TA or the instructor for help.</p> <p>If you want to compile the code and immediately run the test script (useful during development/debugging), type:</p> <pre><code>$ make all\n</code></pre> <p>or just type:</p> <pre><code>$ make\n</code></pre> <p>which does the same thing. This is equivalent to typing <code>make compile</code> followed by <code>make test</code>.</p> <p>Running the tests generates some log files; to get rid of them (as well as all compiled OCaml files), type:</p> <pre><code>$ make clean\n</code></pre> <p>It\u2019s worthwhile taking a look at the code in the <code>tests_lab2.ml</code> file, even though you don\u2019t have to change it. Most of the tests are very straightforward; they use a function called <code>assert_equal</code> to test that a particular function call gives a particular result. There are some interesting operators in the file (such as <code>&gt;:::</code> and <code>&gt;::</code>) which are defined in the <code>ounit2</code> libraries; one of the cool things about OCaml is that you can define new operators!</p> <p>Finally, be aware that the test scripts are in no way exhaustive! Some functions are just inherently hard to test, or else hard to test in a way that wouldn\u2019t give away the answer to a student who looked at the test script code. We recommend that you experiment with the code on your own as well (using the <code>utop</code> interactive interpreter) in addition to running the test script.</p> <p>Warning</p> <p>Don\u2019t assume that just because your code passes all the tests that everything is perfect! It's necessary but not sufficient, as the math folks like to say.</p>"},{"location":"assignments/2/ocaml_notes/#compiler-warnings","title":"Compiler warnings","text":"<p>The <code>Makefile</code> commands to compile OCaml code turn on most of the OCaml compiler warning options, even ones that are normally turned off. Therefore, you might see some warnings when compiling your code that you don't see when loading it into the interpreter. Compiling your code shouldn't give rise to any warnings, so if there are any, fix them. If you don't understand what a compiler warning means, ask us!</p> <p>A list of compiler warnings is on this page; scroll down to find it (under the <code>-w</code> command-line option). Don't expect to understand all of them, but the ones you are likely to encounter should be comprehensible.</p>"},{"location":"assignments/2/ocaml_notes/#using-libraries-in-ocaml","title":"Using libraries in OCaml","text":"<p>Some of the problems below require the use of arbitrary-precision integers and rational numbers. The easiest way to get this in OCaml is by using the <code>Num</code> library.<sup>1</sup> Here we will show you how to use OCaml libraries in two different ways: in the <code>utop</code> interactive interpreter (useful for debugging and testing code) and while compiling code. We\u2019ll use the <code>Num</code> library as an example, but the information will apply to any OCaml library.</p>"},{"location":"assignments/2/ocaml_notes/#in-the-utop-interactive-interpreter","title":"In the <code>utop</code> interactive interpreter","text":"<p>The most basic way to use an OCaml library inside <code>utop</code> (which we don't recommend) is to use the <code>#load</code> command. This requires that you know the full name of the compiled library file. This means that you have to enter the following commands before using the <code>Num</code> library interactively:</p> <pre><code># #load \"nums.cma\";;\n# open Num;;\n</code></pre> <p>(In all the interactive OCaml examples, the first <code>#</code> is the interactive prompt that you shouldn\u2019t type.)</p> <p>Here, we have to know that the library file is called <code>\"nums.cma\"</code>, which is a bit annoying. The line <code># open Num;;</code> brings all the contents of the <code>Num</code> library into the top-level namespace, so you don\u2019t have to use the <code>Num</code> prefix when using any of the functions in the <code>Num</code> library. (This is like entering <code>from Num import *</code> in Python.)</p> <p>If the library file is in a non-standard location, it\u2019s even worse; you have to add this line before the <code>#load</code> line:</p> <pre><code>#directory /path/to/the/library/directory\n</code></pre> <p>(where you should substitute the real path for <code>/path/to/the/library/directory</code>) or else start <code>utop</code> with the <code>-I</code> argument:</p> <pre><code>$ utop -I /path/to/the/library/directory\n</code></pre> <p>Either way, it\u2019s a nuisance.</p> <p>Fortunately, the <code>utop</code> interactive interpreter supports a much simpler way of loading libraries. (Internally, it uses the <code>ocamlfind</code> library to do this, but you don't need to know exactly how this works.) All you need to do is type the following commands inside <code>utop</code>:</p> <pre><code># #require \"num\";;\n# open Num;;\n</code></pre> <p>Now you can use anything in the <code>Num</code> module without having to qualify it with the <code>Num.</code> prefix.</p> <p>We\u2019d like to reiterate here that all the <code>#</code>-commands like <code>#use</code>, <code>#require</code> etc. are not part of the OCaml language but are specific to the interactive interpreter. Please do not use these commands in compiled OCaml code (i.e. <code>.ml</code> and <code>.mli</code> files)!</p>"},{"location":"assignments/2/ocaml_notes/#in-compiled-code","title":"In compiled code","text":"<p>If you want to compile an executable program that uses the <code>Num</code> library, there are three ways to do it: the hard way, the easy way, and the automatic way.</p> <p>The hard way is to specify the library information explicitly when you compile your code. For instance, if you have a file <code>\"myprog.ml\"</code> that uses the <code>Num</code> library, you can compile it like this:</p> <pre><code>$ ocamlc nums.cma myprog.mli myprog.ml -o myprog\n</code></pre> <p>Here, <code>ocamlc</code> is the name of the OCaml compiler program.<sup>2</sup></p> <p>Note again that you have to specify the library name in full. If the directory where <code>nums.cma</code> is located is not a standard location (which it probably isn\u2019t), you would additionally have to specify the directory with the <code>-I</code> option, e.g.:</p> <pre><code>$ ocamlc -I /path/to/the/library/directory nums.cma myprog.mli myprog.ml -o myprog\n</code></pre> <p>Clearly, this is a nuisance, and the easy way to do this involves using the <code>ocamlfind</code> package. In this case we will use the <code>ocamlfind</code> program (which is part of the <code>ocamlfind</code> package; don\u2019t confuse the two distinct uses of <code>ocamlfind</code>):</p> <pre><code>$ ocamlfind ocamlc -package num myprog.mli myprog.ml -o myprog -linkpkg\n</code></pre> <p>You can also use <code>ocamlfind</code> for compiling non-executables (e.g. object code files or libraries); in that case you leave off the <code>-linkpkg</code> argument and adjust the <code>ocamlc</code> arguments as necessary. For instance, if we were compiling a library <code>mylib.ml</code> that used the <code>Num</code> library we would compile it like this:</p> <pre><code>$ ocamlfind ocamlc -c  -package num mylib.mli mylib.ml\n</code></pre> <p>We will be using <code>ocamlfind</code> for compiling code which uses libraries from now on.</p> <p>Since this is still kind of annoying, we automate this by putting these kinds of commands in a <code>Makefile</code> that we will supply to you. Then, in order to compile your program, you will just have to type:</p> <pre><code>$ make\n</code></pre> <p>as previously discussed.</p> <p>For more complicated programs involving multiple files of OCaml code, the best approach is to use the Dune compilation manager. We'll learn more about Dune in later assignments.</p>"},{"location":"assignments/2/ocaml_notes/#using-the-num-library","title":"Using the <code>Num</code> library","text":"<p>The <code>Num</code> library defines a data type called <code>num</code> which can represent arbitrarily-large integers and rational numbers composed of arbitrarily-large integers. The library documentation is here.</p> <p>The <code>num</code> type is abstract, so you have to convert e.g. integers to and from <code>num</code>s in order to use them. To convert an integer to a <code>num</code>, use the <code>num_of_int</code> function and to convert back use the <code>int_of_num</code> function. The <code>string_of_num</code> function converts a <code>num</code> to a string, while <code>float_of_num</code> converts a <code>num</code> to a floating-point number. The numeric operators in the <code>Num</code> library all have a <code>/</code> suffix, so instead of <code>+ - * /</code> etc. we have <code>+/ -/ */ //</code> etc. This is analogous to floating-point numbers which use <code>+. -. *. /.</code> etc. It\u2019s not terribly pleasant to use, but it works.</p> <p>There are also <code>num</code>-specific relational operators (<code>&lt;/</code>, <code>&lt;=/</code>, <code>&gt;/</code>, etc.). You should use these on <code>num</code>s instead of the (overloaded) built-in ones (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, etc.) because the overloaded ones won\u2019t always work properly on <code>num</code>s.  This includes the equality operators, which for <code>num</code>s are <code>=/</code> and <code>&lt;&gt;/</code>.</p> <p>Here are some examples of the <code>Num</code> library in use in the interactive interpreter:</p> <pre><code>$ utop\n# #require \"num\";;\n# open Num;;\n# let n1 = num_of_int 42;;\nval n1 : Num.num = &lt;num 42&gt;\n# let n2 = num_of_int 57;;\nval n2 : Num.num = &lt;num 57&gt;\n# n1 +/ n2;;\n- : Num.num = &lt;num 99&gt;\n# n1 */ n2;;\n- : Num.num = &lt;num 2394&gt;\n# n1 // n2;;\n- : Num.num = &lt;num 14/19&gt;\n# float_of_num (n1 // n2);;\n- : float = 0.736842105263\n# string_of_num (n1 // n2);;\n- : string = \"14/19\"\n# int_of_num (n1 // n2);;\nException: Failure \"integer argument required\".\n# int_of_num ((num_of_int 42) // (num_of_int 21));;\n- : int = 2\n</code></pre> <p>This should be enough to get you through this assignment.</p> <ol> <li> <p>The <code>Num</code> package is pretty much deprecated in favor of the <code>Zarith</code> package, but we still use <code>Num</code> because it\u2019s simpler.\u00a0\u21a9</p> </li> <li> <p>More specifically, this is the OCaml bytecode compiler, which is optimized for very fast compilation. There is also a native-code OCaml compiler called <code>ocamlopt</code>, which is slower but produces much faster code. We will usually just use <code>ocamlc</code>, because it will be fast enough for our purposes.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partA_orders_of_growth/","title":"Part A: Orders of growth (40 points)","text":"<p>This section will feature problems relating to estimating time and space complexity in OCaml functions. As usual, write essay-type answers as OCaml comments.</p>"},{"location":"assignments/2/partA_orders_of_growth/#0-in-class-exercise","title":"0. In-class exercise","text":"<p>[5 points]</p> <p>What are the time and space complexities of the following function?</p> <pre><code>let rec is_power_of_two n =\n  if n = 1 then\n    true\n  else if n mod 2 &lt;&gt; 0 then\n    false\n  else\n    is_power_of_two (n / 2)\n</code></pre> <p>Explain your reasoning.</p>"},{"location":"assignments/2/partA_orders_of_growth/#1-fibonacci-again","title":"1. Fibonacci again","text":"<p>[5 points]</p> <p>Consider the tree-recursive fibonacci function discussed in class:</p> <pre><code>let rec fib n =\n  if n &lt; 2\n     then n\n     else fib (n - 1) + fib (n - 2)\n</code></pre> <p>You know that the time complexity for this function is \\(O(2^n)\\).</p> <p>Note</p> <p>More specifically, it is \\(\\Theta(g^n)\\), where \\(g\\) is the golden ratio (\\(1.618...\\)). See SICP section 1.2.2 and exercise 1.13 for more on this.</p> <p>If we assume that OCaml is using applicative-order evaluation (the normal OCaml evaluation rule), then what is its space complexity? Explain why this is different from the time complexity.</p> <p>Hint: consider what the largest number of pending operations would have to be when evaluating <code>fib 7</code>. You may assume that once an expression is fully evaluated, all the memory used in evaluating that expression is returned to the system.</p> <p>Note</p> <p>You are not required to state what the effect of normal-order evaluation is on the space requirements of the <code>fib</code> function, though it is interesting! </p>"},{"location":"assignments/2/partA_orders_of_growth/#2-sicp-exercise-115","title":"2. (SICP exercise 1.15)","text":"<p>[5 points]</p> <p>The sine of an angle (specified in radians) can be computed by making use of the approximation:</p> \\[ sin\\ x = x \\] <p>(if \\(x\\) is \"sufficiently small\"), and the trigonometric identity:</p> \\[ sin\\ x = 3 \\ sin(x / 3) - 4 \\ sin^3(x/3) \\] <p>to reduce the size of the argument of \\(sin\\) if \\(x\\) is not sufficiently small. For purposes of this exercise an angle is considered \"sufficiently small\" if its magnitude is less than 0.1 radians.</p> <p>These ideas are incorporated in the following functions (using floating-point arithmetic throughout):</p> <pre><code>let cube x = x *. x *. x\nlet p x = 3.0 *. x -. 4.0 *. cube x\nlet rec sine angle =\n  if abs_float angle &lt; 0.1\n     then angle\n     else p (sine (angle /. 3.0))\n</code></pre> <ol> <li> <p>How many times is the function <code>p</code> applied when <code>sine 12.15</code> is    evaluated?</p> </li> <li> <p>What is the order of growth in space and number of steps    used by the process generated by the <code>sine</code> function    when <code>sine a</code> is evaluated (as a function of <code>a</code>)?</p> </li> </ol> <p>By \"growth in number of steps\", we mean the asymptotic time complexity of the <code>sine</code> function as a function of the size of the input. Explain the reason for the space/time complexities; don\u2019t just state an answer.</p>"},{"location":"assignments/2/partA_orders_of_growth/#3-sicp-exercise-116","title":"3. (SICP exercise 1.16)","text":"<p>[5 points]</p> <p>SICP describes a non-iterative function called <code>fast_expt</code> that does exponentiation using successive squaring (when possible). Translated into OCaml, that function looks like this:</p> <pre><code>let rec fast_expt b n =\n  let is_even m = m mod 2 = 0 in\n  let square m = m * m in\n    if n = 0 then 1\n    else if is_even n then square (fast_expt b (n / 2))\n    else b * fast_expt b (n - 1)\n</code></pre> <p>Note that <code>mod</code> is a predefined infix operator in OCaml (not a function!) which computes remainders; you use it like this: <code>5 mod 2</code> (which will return <code>1</code>).</p>"},{"location":"assignments/2/partA_orders_of_growth/#a","title":"a.","text":"<p>This function uses nested <code>if</code>/<code>then</code>/<code>else</code> forms, which are a bit ugly and error-prone (since OCaml doesn\u2019t actually have an <code>else if</code> syntax). Rewrite the function using pattern matching on the <code>n</code> argument (a <code>match</code> expression); use <code>when</code> clauses in pattern matches when you need to test for non-structural conditions (and only then). Your function should not have any <code>if</code> expressions.</p> <p>Here is a skeleton version of the function you should write:</p> <pre><code>let rec fast_expt b n =\n  let is_even m = m mod 2 = 0 in\n  let square m = m * m in\n    match n with\n      (* fill in the rest here *)\n</code></pre> <p>N.B. the \"wildcard\" pattern <code>_</code> may be useful to you. Any compiler warnings will be considered to be errors.</p>"},{"location":"assignments/2/partA_orders_of_growth/#b","title":"b.","text":"<p>Write a function called <code>ifast_expt</code> that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps.</p> <p>Hint</p> <p>Using the observation that \\(b^n = (b^{n/2})^2 = (b^2)^{n/2}\\), keep, along with the exponent \\(n\\) and the base \\(b\\), an additional state variable \\(a\\), and define the state transformation in such a way that the product \\(a b^n\\) is unchanged from state to state. At the beginning of the process \\(a\\) is taken to be 1, and the answer is given by the value of \\(a\\) at the end of the process. In general, the technique of defining an invariant quantity that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.</p> <p>Use integer arithmetic for this problem. You may assume that all the (integer) arguments to your function are non-negative.</p> <p>You will need some helper functions in the implementation of your <code>ifast_expt</code> function. You should make these internal to your <code>ifast_expt</code> function, as was done with the <code>fast_expt</code> function above. One of these will need to be recursive; call it <code>iter</code>. Only use <code>let rec</code> with that function; use <code>let</code> for all other internal definitions and for the <code>ifast_expr</code> function as a whole.</p> <p>Use pattern matching instead of nested <code>if</code>/<code>then</code>/<code>else</code> forms as you did for the <code>fast_expt</code> function.</p>"},{"location":"assignments/2/partA_orders_of_growth/#4-sicp-exercise-117","title":"4. (SICP exercise 1.17)","text":"<p>[5 points]</p> <p>The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. The simplest such function is this:</p> <pre><code>let rec expt a b =\n  if b = 0\n     then 1\n     else a * expt a (b - 1)\n</code></pre> <p>In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication function (in which it is assumed that our language can only add, not multiply), is analogous to the <code>expt</code> function:</p> <pre><code>let rec mult a b =\n  if b = 0\n     then 0\n     else a + mult a (b - 1)\n</code></pre> <p>This algorithm takes a number of steps that is linear in <code>b</code>. Now suppose we include, together with addition, the operations <code>double</code>, which doubles an integer, and <code>halve</code>, which divides an (even) integer by 2. Using these, design a multiplication function analogous to <code>fast_expt</code> that uses a logarithmic number of steps. Call this function <code>fast_mult</code>.</p> <p>Note</p> <p>Don't do any multiplications or divisions in <code>fast_mult</code> except indirectly by using <code>double</code> or <code>halve</code>. (<code>double</code> and <code>halve</code> themselves can do multiplication or division, of course.) You can also use addition, subtraction, and the <code>mod</code> operator to test for evenness.</p> <p>Use integer arithmetic for this problem. The multiplication function you write should generate a recursive process.</p> <p>For this problem, write all helper functions (including <code>double</code> and <code>halve</code>) inside the <code>fast_mult</code> function, and again use pattern matching on the <code>n</code> argument instead of nested <code>if</code>/<code>then</code>/<code>else</code> expressions.</p>"},{"location":"assignments/2/partA_orders_of_growth/#5-sicp-exercise-118","title":"5. (SICP exercise 1.18)","text":"<p>[5 points]</p> <p>Using the results of the previous exercises, devise a function called <code>ifast_mult</code> that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.</p> <p>This multiplication function should generate an iterative process. If you are multiplying integer \\(b\\) by integer \\(n\\), you will need another state variable \\(a\\) such that the invariant is \\(a + bn\\), and \\(n\\) will decrease to zero, at which point \\(a\\) will be the answer.</p> <p>Again, use pattern matching instead of nested <code>if</code>/<code>then</code>/<code>else</code> expressions. And again, only use <code>let rec</code> where it\u2019s absolutely necessary.</p>"},{"location":"assignments/2/partA_orders_of_growth/#6-a-mysterious-function","title":"6. A mysterious function","text":"<p>[5 points]</p> <p>Consider the following (higher-order) function:</p> <pre><code>let rec foo f n =\n  if n &lt;= 1\n     then f 0\n     else foo f (n / 2) + foo f (n / 2)\n</code></pre> <p>Note that function calls have the highest precedence in OCaml, so the last expression is the same as <code>(foo f (n / 2)) + (foo f (n / 2))</code>.</p> <p>If we assume that the function <code>f</code> can compute its result in constant time and constant space, what are the (worst-case) time and space complexities of the function <code>foo</code>? Justify your answer. (It doesn\u2019t have to be a full mathematical proof, but it should be a convincing argument.) Assume that the integer input <code>n</code> is always non-negative, and assume the usual applicative-order evaluation rule.</p>"},{"location":"assignments/2/partA_orders_of_growth/#7-fibonacci-yet-again","title":"7. Fibonacci yet again","text":"<p>[5 points]</p> <p>Consider this function to compute fibonacci numbers:</p> <pre><code>let fib n =\n  let rec last_two n =\n    if n &lt; 1\n      then (0, 1)\n      else\n        let (p0, p1) = last_two (n - 1) in\n          (p1, p0 + p1)\n  in\n    fst (last_two n)\n</code></pre> <p>A couple of OCaml notes:</p> <ul> <li> <p>It\u2019s legal to assign more than one value at a time   in a <code>let</code> expression as shown above.   (Effectively, you are doing a pattern match that cannot fail.)</p> </li> <li> <p><code>fst</code> is a built-in function which extracts the first value of a two-tuple.</p> </li> </ul> <p>Please answer the following two questions in OCaml comments:</p> <ol> <li> <p>What kind of process does this function represent    (linear recursive, linear iterative, tree recursive etc.)    and why?</p> </li> <li> <p>What is the space and time complexity of this function    with respect to its argument <code>n</code>?</p> </li> </ol>"},{"location":"assignments/2/partB_evaluation/","title":"Part B: Evaluation (20 points)","text":"<p>In this section, write all answers inside OCaml comments. (If you don\u2019t, your <code>lab2.ml</code> file probably won\u2019t compile.)</p>"},{"location":"assignments/2/partB_evaluation/#1-desugaring-let","title":"1. Desugaring <code>let</code>","text":"<p>[10 points]</p> <p>Desugar the following (nonrecursive) <code>let</code> expressions to the equivalent <code>fun</code> expressions applied to arguments. You do not need to evaluate the resulting <code>fun</code> expressions. Use the OCaml interpreter to test that your desugared versions are equivalent to the original versions. (You don\u2019t have to prove this to anyone but yourself.)</p> <p>Note</p> <p>A non-recursive <code>let</code> / <code>and</code> form binds multiple values to the result of evaluating the corresponding expressions, but none of the binding expressions can depend on the other bindings. (In a recursive <code>let rec</code> / <code>and</code> form, any or all of the binding expressions can depend on the bindings.) A non-recursive <code>let</code> / <code>and</code> form is therefore equivalent to a function of more than one argument applied to its arguments, as discussed in the lectures.</p>"},{"location":"assignments/2/partB_evaluation/#a","title":"a.","text":"<pre><code>let x = 20\nand y = 2 * 4\nin x * (2 + y)\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#b","title":"b.","text":"<pre><code>let a = 1.0\nand b = 20.0\nand c = 3.0\nin sqrt (b *. b -. 4.0 *. a *. c)\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#c","title":"c.","text":"<p>For this problem, desugar all of the <code>let</code> expressions. Note that successive <code>let</code>/<code>in</code> forms are not the same as a <code>let</code>/<code>and</code> form with multiple <code>and</code>s, because expressions can depend on earlier bindings.</p> <pre><code>let x = 1 in\nlet y = 2 in\nlet z = 3 in\n  x * y * z\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#d","title":"d.","text":"<p>For this problem, desugar all of the <code>let</code> expressions.</p> <pre><code>let x = 1 in\nlet x = 2 in\nlet x = 3 in\n  x * x * x\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#2-desugaring-let-and-the-substitution-model","title":"2. Desugaring <code>let</code> and the substitution model","text":"<p>[5 points]</p> <p>Using the substitution model (including desugaring <code>let</code> to <code>fun</code>), evaluate the following expression. You may skip obvious steps (for instance, you can reduce <code>2 + 2</code> to <code>4</code> in a single step).</p> <p>Hint</p> <p>Desugar all the <code>let</code>s to <code>fun</code>s before doing anything else.</p> <p>Our evaluation took about 35 lines. Watch out for lambda shielding!</p> <pre><code>let x = 2 * 10\nand y = 3 + 4\nin\n  let y = 14 in\n  let z = 22 in\n    x * y * z\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#3-why-doesnt-this-work","title":"3. Why doesn\u2019t this work?","text":"<p>[5 points]</p> <p>Ben Bitfiddle can\u2019t understand why the following code gives an error:</p> <pre><code>let x = 10\nand y = x * 2\nand z = y + 3\nin x + y + z\n</code></pre> <p>When Ben runs this (expecting the result to be 53), OCaml complains about <code>x</code> being an unbound value. \"That\u2019s not true!\" cries Ben angrily, \"<code>x</code> was bound on the first line!\". Explain why this doesn\u2019t work by first desugaring the <code>let</code> to a <code>fun</code>, and then explain in words why it can\u2019t work, by referring to the way expressions get evaluated (you don\u2019t need to evaluate the expression explicitly). Then show Ben a simple way to fix this code to make it do what he wants.</p>"},{"location":"assignments/2/partC_higher_order_functions/","title":"Part C. Higher-order functions (30 points)","text":"<p>In this section, use <code>num</code> as the numeric type for all operations unless otherwise indicated. For convenience, put this at the top of the file:</p> <pre><code>open Num\n</code></pre> <p>and define this helper function (really just an alias):</p> <pre><code>let ni = num_of_int     (* convert int -&gt; num *)\n</code></pre> <p>We will use <code>num</code> as the numeric type when we want either or both of arbitrarily large integers and rational numbers. Note that doing arithmetic on <code>num</code>s requires the use of the special <code>num</code> operators <code>+/</code>, <code>-/</code>, <code>*/</code>, <code>//</code> etc. The usual relational operators (<code>&lt;</code>, <code>&lt;=</code>, <code>=</code> etc.) will work if used on integers, but don't work with rational numbers, so use the <code>num</code> equivalents <code>&lt;/</code>, <code>&lt;=/</code>, <code>=/</code> in these cases.</p>"},{"location":"assignments/2/partC_higher_order_functions/#1-sicp-exercise-130","title":"1. (SICP exercise 1.30)","text":"<p>[5 points]</p> <p>The following <code>sum</code> function generates a linear recursion:</p> <pre><code>let rec sum term a next b =\n  if a &gt;/ b\n     then (ni 0)\n     else term a +/ (sum term (next a) next b)\n</code></pre> <p>(Recall that the <code>&gt;/</code> operator is comparison of <code>num</code>s and the <code>+/</code> operator is addition of <code>num</code>s.) <code>term</code> is a function of one argument which generates the current term in a sequence given a sequence value, while <code>next</code> is a function of one argument which generates the next value in the sequence. For instance:</p> <pre><code>sum (fun x -&gt; x */ x) (ni 1) (fun n -&gt; n +/ (ni 1)) (ni 10)\n</code></pre> <p>will compute the sum of all squares of the numbers 1 through 10 (expressed as <code>num</code>s).</p> <p>The function can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:</p> <pre><code>let isum term a next b =\n  let rec iter a result =\n    if &lt;??&gt;\n       then &lt;??&gt;\n       else iter &lt;??&gt; &lt;??&gt;\n  in\n    iter &lt;??&gt; &lt;??&gt;\n</code></pre> <p>Assume that <code>term</code> is a function of type <code>num -&gt; num</code>.</p> <p>Examples</p> <pre><code># let square n = n */ n ;;\nval square : Num.num -&gt; Num.num = &lt;fun&gt;\n# let step1 n = n +/ (ni 1) ;;\nval step1 : Num.num -&gt; Num.num = &lt;fun&gt;\n# isum square (ni 10) step1 (ni 0);;\n- : Num.num = &lt;num 0&gt;\n# isum square (ni 4) step1 (ni 4);;\n- : Num.num = &lt;num 16&gt;\n# isum square (ni 0) step1 (ni 10);;\n- : Num.num = &lt;num 385&gt;\n</code></pre>"},{"location":"assignments/2/partC_higher_order_functions/#2-sicp-exercise-131","title":"2. (SICP exercise 1.31)","text":"<p>[5 points]</p> <ol> <li> <p>The <code>sum</code> function is only the simplest of a vast number of similar abstractions that can be captured as higher-order functions. Write an analogous function called <code>product</code> that returns the product of the values of a function at points over a given range. Show how to define <code>factorial</code> in terms of product. Also use <code>product</code> to compute approximations to \\(\\pi\\) (3.1415926...) using the formula:</p> \\[ \\frac{\\pi}{4} = \\frac{2 \\cdot 4 \\cdot 4 \\cdot 6 \\cdot 6 \\cdot 8}        {3 \\cdot 3 \\cdot 5 \\cdot 5 \\cdot 7 \\cdot 7} \\] </li> <li> <p>If your product function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p> </li> </ol> <p>Call your recursive <code>product</code> function <code>product_rec</code> and your iterative one <code>product_iter</code>. Define a version of <code>factorial</code> using both forms of <code>product</code>, calling one <code>factorial_rec</code> and the other <code>factorial_iter</code>.</p> <p>Examples</p> <pre><code># factorial_rec (ni 0)\n- : Num.num = &lt;num 1&gt;\n# factorial_iter (ni 0)\n- : Num.num = &lt;num 1&gt;\n# factorial_rec (ni 10)\n- : Num.num = &lt;num 3628800&gt;\n# factorial_iter (ni 10)\n- : Num.num = &lt;num 3628800&gt;\n</code></pre> <p>Also write the code to generate an approximation to \\(\\pi\\) (using either the recursive or iterative version of <code>product</code>) by filling in the following definitions using the formula described above. Use at least 1000 terms from the product.</p> <pre><code>let pi_product n = &lt;??&gt;   (* infinite product expansion up to n terms *)\nlet pi_approx = &lt;??&gt;      (* defined in terms of pi_product *)\n</code></pre> <p>Note</p> <p>For the purposes of this problem, consider a \"single term\" of the \\(\\pi\\) approximation to be two consecutive numerator numbers and two consecutive denominator numbers. So the first \"term\" would be </p> \\[ \\frac{2 \\cdot 4}{3 \\cdot 3} \\] <p>the second \"term\" would be</p> \\[ \\frac{4 \\cdot 6}{5 \\cdot 5} \\] <p>etc. Multiplying all the terms together gives the desired approximation to \\(\\pi\\).</p> <p>Use <code>num</code> as the numeric type for all operations except for the <code>pi_approx</code> value, which should be a <code>float</code>. Use the <code>float_of_num</code> function to convert from a rational approximation to pi (obtained by the formula given above) to a <code>float</code>. Note that we're using <code>num</code>s in this case because we want arbitrarily-precise rational numbers. Be careful to use <code>num</code> operators throughout!</p> <p>Note that none of these functions need to be more than a few lines long. (Our longest function for this problem is 7 lines long.)</p>"},{"location":"assignments/2/partC_higher_order_functions/#3-sicp-exercise-132","title":"3. (SICP exercise 1.32)","text":"<p>[5 points]</p> <ol> <li> <p>Show that <code>sum</code> and <code>product</code> from the previous problems are both special cases of a still more general notion called <code>accumulate</code><sup>1</sup> that combines a collection of terms, using some general accumulation function:</p> <pre><code>accumulate combiner null_value term a next b\n</code></pre> <p><code>accumulate</code> takes as arguments the same term and range specifications as <code>sum</code> and <code>product</code>, together with a <code>combiner</code> function (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms, and a <code>null_value</code> that specifies what base value to use when the terms run out. Write <code>accumulate</code> and show how <code>sum</code> and <code>product</code> can both be defined as simple calls to <code>accumulate</code>. Assume that all numeric types are <code>num</code>.</p> </li> <li> <p>If your <code>accumulate</code> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p> </li> </ol> <p>Call the recursive <code>accumulate</code> function <code>accumulate_rec</code> and the iterative version <code>accumulate_iter</code>. You can use either form to define <code>sum</code> and <code>product</code>. Note that in order to use an operator as a function, you must wrap it in parentheses (this is useful when passing an operator as an argument to a function). If the operator name starts with an asterisk, you have to put a space between it and the open parenthesis so OCaml doesn't mistake it for a comment! In other words, write <code>( */ )</code> instead of <code>(*/)</code>.</p>"},{"location":"assignments/2/partC_higher_order_functions/#4-sicp-exercise-142","title":"4. (SICP exercise 1.42)","text":"<p>[5 points]</p> <p>Let <code>f</code> and <code>g</code> be two one-argument functions. The composition of function \\(f\\) after \\(g\\) (often written \\(f \\circ g\\)) is defined to be the function \\(x \\mapsto f(g(x))\\). Define a function <code>compose</code> that implements composition.</p> <p>In the examples below, we use <code>int</code> instead of <code>num</code> as the numeric type. The type of <code>compose</code> doesn't depend on what numeric type we use.</p> <p>Examples</p> <pre><code># let square n = n * n;;\n# let inc n = n + 1;;\n# (compose square inc) 6\n- : int = 49\n# (compose inc square) 6\n- : int = 37\n</code></pre>"},{"location":"assignments/2/partC_higher_order_functions/#5-sicp-exercise-143","title":"5. (SICP exercise 1.43)","text":"<p>[5 points]</p> <p>If \\(f\\) is a numerical function and \\(n\\) is a positive integer, then we can form the \\(n\\)th repeated application of \\(f\\), which is defined to be the function whose value at \\(x\\) is \\(f(f(\\ldots(f(x))\\ldots))\\) (with \\(n\\) \\(f\\)s).</p> <p>For example, if \\(f\\) is the function \\(x \\mapsto x + 1\\), then the \\(n\\)th repeated application of \\(f\\) is the function \\(x \\mapsto x + n\\). If \\(f\\) is the operation of squaring a number, then the \\(n\\)th repeated application of \\(f\\) is the function that raises its argument to the \\(2n\\)th power.</p> <p>Write a function that takes as inputs a function that computes \\(f\\) and a positive integer \\(n\\) and returns the function that computes the \\(n\\)th repeated application of \\(f\\). Your function should be able to be used as follows:</p> <pre><code># (repeated square 2) 5\n- : int = 625\n</code></pre> <p>Hint</p> <p>You may find it convenient to use <code>compose</code> from the previous exercise in your definition of <code>repeated</code>.</p> <p>In the examples below, we use <code>int</code> instead of <code>num</code> as the numeric type. The type of <code>repeated</code> doesn't depend on what numeric type we use.</p> <p>Examples</p> <pre><code># let square n = n * n;;\n# (repeated square 0) 6\n- : int = 6\n# (repeated square 1) 6\n- : int = 36\n# (repeated square 2) 6\n- : int = 1296\n</code></pre> <p>Note that a function repeated 0 times is the identity function. If you do this right, the solution will be very short.</p>"},{"location":"assignments/2/partC_higher_order_functions/#6-sicp-exercise-144","title":"6. (SICP exercise 1.44)","text":"<p>[5 points]</p> <p>The idea of smoothing a function is an important concept in signal processing. If \\(f\\) is a function of one (numerical) argument and \\(dx\\) is some small number, then the smoothed version of \\(f\\) is the function whose value at a point \\(x\\) is the average of \\(f(x - dx)\\), \\(f(x)\\), and \\(f(x + dx)\\).</p> <p>Write a function <code>smooth</code> that takes as input a function <code>f</code> and a <code>dx</code> value and returns a function (of one numerical argument) that computes the smoothed <code>f</code>.</p> <p>It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the \\(n\\)-fold smoothed function. Show how to generate the \\(n\\)-fold smoothed function of any given function using <code>smooth</code> and the <code>repeated</code> function you defined in the previous problem. Call this second function <code>nsmoothed</code>.</p> <p>For this problem, we use <code>float</code> instead of <code>num</code> as the numeric type.</p> <p>Hint</p> <p>Be careful with the <code>dx</code> argument to <code>nsmoothed</code>! It's actually more convenient to have <code>smooth</code> take the <code>dx</code> argument as its first argument, because you may need to partially apply <code>smooth</code> to <code>dx</code> in the definition of <code>nsmoothed</code> (at least, that's one way to do it).</p> <p>Note that both <code>smooth</code> and <code>nsmoothed</code> are very short if you write them the right way.</p> <p>Here are some examples. Note that your results may not be identical; floating-point math is notoriously hard to reproduce between computers. However, your results should be pretty close to these.</p> <p>Examples</p> <pre><code>(* smooth examples *)\n\n(* smoothed sin function *)\n# let ssin = smooth 0.1 sin;;\nval ssin : float -&gt; float = &lt;fun&gt;\n# sin 0.0;;\n- : float = 0.\n# ssin 0.0;;\n- : float = 0.\n# sin 0.1;;\n- : float = 0.0998334166468281548\n# ssin 0.1;;\n- : float = 0.0995009158139631283\n# sin 1.0;;\n- : float = 0.841470984807896505\n# ssin 1.0;;\n- : float = 0.838668418165605112\n# sin 3.0;;\n- : float = 0.141120008059867214\n# ssin 3.0;;\n- : float = 0.14064999990238003\n# let pi = 4.0 *. atan 1.0;;\n# sin (pi /. 2.0);;\n- : float = 1.\n# ssin (pi /. 2.0);;\n- : float = 0.996669443518683806\n\n(* nsmoothed examples *)\n\n# let nssin n = nsmoothed 0.1 sin n\nval nssin : int -&gt; float -&gt; float = &lt;fun&gt;\n\n(* ssin0 is the same as sin *)\n# let ssin0 = nssin 0;;\nval ssin0 : float -&gt; float = &lt;fun&gt;\n# ssin0 (pi /. 2.0);;\n- : float = 1.\n# sin (pi /. 2.0);;\n- : float = 1.\n# ssin0 1.0;;\n- : float = 0.841470984807896505\n# sin 1.0;;\n- : float = 0.841470984807896505\n\n(* ssin1 is the same as ssin *)\n# let ssin1 = nssin 1;;\nval ssin1 : float -&gt; float = &lt;fun&gt;\n# ssin 1.0;;\n- : float = 0.838668418165605112\n# ssin1 1.0;;\n- : float = 0.838668418165605112\n# ssin 2.0;;\n- : float = 0.906268960387323297\n# ssin1 2.0;;\n- : float = 0.906268960387323297\n\n(* ssin10 is flatter than ssin1 *)\n# let ssin10 = nssin 10;;\nval ssin10 : float -&gt; float = &lt;fun&gt;\n# ssin10 1.0;;\n- : float = 0.813861644301632103\n# ssin1 1.0;;\n- : float = 0.838668418165605112\n# ssin1 (pi /. 2.0);;\n- : float = 0.996669443518683806\n# ssin10 (pi /. 2.0);;\n- : float = 0.96718919486859356\n</code></pre> <ol> <li> <p>The recursive and iterative forms of <code>accumulate</code> exist in the OCaml standard library as <code>List.fold_right</code> and <code>List.fold_left</code> respectively. You are not allowed to use these functions in your solution to this problem.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partD_additional_problems/","title":"Part D: Additional problems (10 points)","text":"<p>In this section, we\u2019ll write some functions that were referred to in the lectures but not defined.</p>"},{"location":"assignments/2/partD_additional_problems/#1-is_prime","title":"1. <code>is_prime</code>","text":"<p>[5 points]</p> <p>In lecture 5, we referred to a function called <code>is_prime</code> which returns <code>true</code> if an integer is a prime number and <code>false</code> otherwise. Write this function. For the purposes of the function, consider all negative numbers, zero, and 1 to be non-prime (and thus return <code>false</code> instead of e.g. raising an exception). Your function doesn\u2019t have to be maximally efficient, but it should have a time complexity of at most \\(\\Theta(\\sqrt{n})\\) for input \\(n\\).</p> <p>Hints</p> <p>For any input \\(n\\) you only have to check if numbers up to \\(\\sqrt{n}\\) can divide \\(n\\), since if they can't, no larger number can either, and so \\(n\\) must be prime.</p> <p>The OCaml builtin function <code>sqrt</code> works on <code>float</code>s only; you may find the functions <code>float_of_int</code> and <code>int_of_float</code> to be useful.</p>"},{"location":"assignments/2/partD_additional_problems/#2-smallest_prime_factor","title":"2. <code>smallest_prime_factor</code>","text":"<p>[5 points]</p> <p>In lecture 5, we also referred to a function called <code>smallest_prime_factor</code> which returns the smallest prime factor of a composite (non-prime) positive integer. Write this function. (You can use the <code>is_prime</code> function you defined above in the definition.) If the input number is prime or less than 2, raise an exception using the <code>invalid_arg</code> function. Again, we\u2019re not worried about maximal efficiency here, but your function must work properly.</p>"},{"location":"assignments/3/assignment3/","title":"Assignment 3: Lists","text":""},{"location":"assignments/3/assignment3/#due-date","title":"Due date","text":"<p>This assignment is due on Thursday, Febuary 1st, at 2 AM.</p>"},{"location":"assignments/3/assignment3/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 8, corresponding to section 2.2.3 of SICP.</p>"},{"location":"assignments/3/assignment3/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab3.ml</code>. This file should be submitted to CodePost as <code>Assignment 3</code>. Do not submit the interface file (<code>lab3.mli</code>), or the test script (<code>tests_lab3.ml</code>), or the <code>Makefile</code> we supply for you.</p>"},{"location":"assignments/3/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/3/ocaml_notes/#testing","title":"Testing","text":"<p>For this assignment, we are supplying you with these support files:</p> <ol> <li>a <code>.mli</code> OCaml interface file (<code>lab3.mli</code>)</li> <li>a test script (<code>tests_lab3.ml</code>)</li> <li>a <code>Makefile</code></li> </ol> <p>These files are all available on the course Canvas site in a single zip file called <code>lab3.zip</code>. Download this file and unzip it:</p> <pre><code>$ unzip lab3.zip\n</code></pre> <p>This will create a <code>lab3</code> directory with the files inside it. You should not change these files, and you should not submit them as part of your assignment submission. You should create and edit the file <code>lab3.ml</code> (which you will be handing in) in the same directory.</p> <p>Once your assignment is done, you should compile it and check that it conforms to the interface file by entering this command:</p> <pre><code>$ make compile\n</code></pre> <p>To run the test script, type this after compiling the code with <code>make compile</code>:</p> <pre><code>$ make test\n</code></pre> <p>This will compile the <code>tests_lab3.ml</code> file (which contains the unit tests) and output an executable program called <code>tests_lab3</code>. Then it will run that program and report all test failures.</p> <p>If you want to compile the code and immediately run the test script (useful during development/debugging), type:</p> <pre><code>$ make all\n</code></pre> <p>or just type:</p> <pre><code>$ make\n</code></pre> <p>which does the same thing. This is equivalent to typing <code>make compile</code> followed by <code>make test</code>.</p> <p>Running the tests generates some log files; to get rid of them (as well as all compiled OCaml files), type:</p> <pre><code>$ make clean\n</code></pre>"},{"location":"assignments/3/ocaml_notes/#ocaml-documentation","title":"OCaml documentation","text":"<p>The OCaml library documentation is located here. (You should bookmark this page.) For this assignment, the documentation on the <code>List</code> library will be extremely useful.</p>"},{"location":"assignments/3/ocaml_notes/#signalling-errors","title":"Signalling errors","text":"<p>We will soon start to explore exception handling in OCaml, but in the meantime, if at any time you need to signal an error in a function (for instance, if the function received an invalid input), you can use the <code>invalid_arg</code> and <code>failwith</code> functions. They both take a single string as their only argument, and raise an exception which uses that string as an error message. The difference is that <code>invalid_arg</code> raises an <code>Invalid_argument</code> error (which is most appropriate if a function received an invalid argument), and <code>failwith</code> raises a <code>Failure</code> exception (which is more appropriate for other situations). For instance:</p> <pre><code># invalid_arg \"argument should be &gt; 0\" ;;\nException: Invalid_argument \"argument should be &gt; 0\".\n# raise (Invalid_argument \"argument should be &gt; 0\") ;;  (* same thing *)\nException: Invalid_argument \"argument should be &gt; 0\".\n# failwith \"everything is messed up for no good reason!\" ;;\nException: Failure \"everything is messed up for no good reason!\".\n# raise (Failure \"everything is messed up for no good reason!\") ;;  (* same thing *)\nException: Failure \"everything is messed up for no good reason!\".\n</code></pre> <p>As you can see, <code>invalid_arg</code> and <code>failwith</code> are just functions that raise particular exceptions.</p>"},{"location":"assignments/3/ocaml_notes/#the-function-keyword","title":"The <code>function</code> keyword","text":"<p>In OCaml code, it's extremely common to see this pattern:</p> <pre><code>let f n =\n  match n with\n    | 0 -&gt; 1\n    | n' -&gt; n' + 1\n</code></pre> <p>In other words, you are defining a function with only one argument, and you are immediately pattern-matching on that argument. This is so common that there is a shorthand way of writing this:</p> <pre><code>let f = function\n  | 0 -&gt; 1\n  | n' -&gt; n' + 1   (* we could have used n here too *)\n</code></pre> <p>Note that <code>function</code> is not the same thing as <code>fun</code>! <code>function</code> just allows you to leave off the last argument of the function and instead pattern-match on it. <code>fun</code> can be used with any number of arguments, and doesn't automatically define a pattern match (though you can add a <code>match</code> statement inside the <code>fun</code>, of course).</p> <p>Note also that <code>function</code> can be used with functions of more than one argument. For instance, this (not very useful) function:</p> <pre><code>let f x y =\n  match y with\n    | 0 -&gt; x + n\n    | n -&gt; x + n * n\n</code></pre> <p>could be written like this:</p> <pre><code>let f x = function\n  | 0 -&gt; x + n\n  | n -&gt; x + n * n\n</code></pre> <p>This is harder to read, but the <code>function</code> keyword takes the place of the <code>y</code> argument and the <code>match</code> expression.</p> <p>There are some cases where you can instantly pattern match on the arguments of a <code>fun</code> definition (or even the arguments of a function which doesn't use <code>fun</code>) if the arguments have only one kind of structure you can pattern match on. For instance, this code:</p> <pre><code>let sum_of_pair = fun (x, y) -&gt; x + y\n(* Or equivalently: let sum_of_pair (x, y) = x + y *)\n</code></pre> <p>defines a function <code>sum_of_pair</code> which takes a 2-tuple of <code>int</code>s as its only argument and immediately pattern matches on it to extract the two components. This is more convenient than having to write a trivial <code>match</code> expression in such cases.</p> <p>Using <code>function</code> where appropriate can make your code more concise and easier to read, especially when the function has only one argument.</p>"},{"location":"assignments/3/ocaml_notes/#terminology-cons-and-append","title":"Terminology: \"cons\" and \"append\"","text":"<p>Sometimes, we will refer to the act of adding an item to the front of a list using the <code>::</code> constructor as \"cons-ing\" the item to the front of the list. This terminology comes from the Scheme programming language (which borrowed it from the even older Lisp language), where the closest equivalent to <code>::</code> is a function called <code>cons</code>. Even though CS 4 doesn't use Scheme (unlike SICP)<sup>1</sup>, we will use this term because there is no suitable replacement. This term is also commonly used in the functional programming literature for a variety of languages, whether they have a <code>cons</code> function or not.</p> <p>Similarly, we will refer to the adding of combining two lists together to form a single list using the <code>@</code> operator as \"appending\" the two lists. This is standard terminology.</p> <ol> <li> <p>Long ago, CS 4 did use Scheme as the programming language.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/3/partA_lists/","title":"Part A: Working with lists (50 points)","text":""},{"location":"assignments/3/partA_lists/#0-in-class-exercise","title":"0. In-class exercise","text":"<p>[5 points]</p> <p>Write a function called <code>range</code> which takes two <code>int</code> arguments <code>m</code> and <code>n</code>, and returns a list containing all the numbers from <code>m</code> up to an including <code>n</code>. This function should generate a recursive process. Also write a function called <code>irange</code> which generates an iterative process.</p> <p>Examples</p> <p>Both functions (<code>range</code> and <code>irange</code>) return the same results for the same inputs.</p> <pre><code># range 1 10;;\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range 1 1;;\n- : int list = [1]\n# range 1 0;;\n- : int list = []\n</code></pre> <p>You may find the library function <code>List.rev</code> (which returns the reverse of a list) to be useful in your <code>irange</code> definition, though it's not absolutely necessary.</p> <p>Note</p> <p>Both <code>range</code> and <code>irange</code> must have linear time complexities, i.e. they must be \\(\\Theta(|n - m|)\\).</p>"},{"location":"assignments/3/partA_lists/#1-sicp-exercise-217","title":"1. (SICP exercise 2.17)","text":"<p>[5 points]</p> <p>Define a function <code>last_sublist</code> that returns the list that contains only the last element of a given (nonempty) list:</p> <pre><code># last_sublist [23; 72; 149; 34] ;;\n- : int list = [34]\n</code></pre> <p>Your function should signal an error if the list is empty. Use <code>invalid_arg</code> to generate the error; the error message should be <code>\"last_sublist: empty list\"</code> (that exact message; we\u2019ll check it!).</p> <p>You should write this function using pattern matching and the <code>function</code> keyword, since there is only one argument and the function pattern matches on it. The resulting function should generate a linear iterative process when run (in other words, the function should be tail recursive.) Also, this function should work on arbitrary lists (the element type shouldn\u2019t matter).</p>"},{"location":"assignments/3/partA_lists/#2-sicp-exercise-218","title":"2. (SICP exercise 2.18)","text":"<p>[5 points]</p> <p>Define a function <code>reverse</code> that takes a list as argument and returns a list of the same elements in reverse order:</p> <pre><code># reverse [1; 4; 9; 16; 25] ;;\n- : int list = [25; 16; 9; 4; 1]\n# reverse [] ;;\n- : 'a list = []\n# reverse [[1; 4]; [9]; [16; 25]] ;;\n- : int list list = [[16; 25]; [9]; [1; 4]]\n</code></pre> <p>Note the type of the last example; it is a <code>list</code> of <code>int list</code>s! Read <code>int list list</code> as <code>(int list) list</code>.</p> <p>Your <code>reverse</code> function should have a linear time complexity, be tail recursive (i.e. iterative), and should (naturally) work on lists of any element types. It should not use the list append (<code>@</code>) operator.</p> <p>There is a library function called <code>List.rev</code> which reverses lists. Obviously, you shouldn\u2019t use it in your answer to this problem.</p>"},{"location":"assignments/3/partA_lists/#3-sicp-exercise-221","title":"3. (SICP exercise 2.21)","text":"<p>[5 points]</p> <p>The function <code>square_list</code> takes a list of integers as argument and returns a list of the squares of those numbers.</p> <pre><code># square_list [1; 2; 3; 4]\n- : int list = [1; 4; 9; 16]\n</code></pre> <p>Here are two different definitions of <code>square_list</code>. Complete both of them by filling in the missing expressions:</p> <pre><code>let rec square_list = function\n  | [] -&gt; []\n  | h :: t -&gt; &lt;??&gt;\n\nlet square_list2 items = List.map &lt;??&gt; &lt;??&gt;\n</code></pre> <p>Use the List library documentation to find the description of <code>List.map</code>.</p>"},{"location":"assignments/3/partA_lists/#4-sicp-exercise-222","title":"4. (SICP exercise 2.22)","text":"<p>[5 points]</p> <p>Louis Reasoner tries to rewrite the first <code>square_list</code> function from the previous problem so that it evolves an iterative process:</p> <pre><code>let square_list items =\n  let rec iter things answer =\n    match things with\n      | [] -&gt; answer\n      | h :: t -&gt; iter t ((h * h) :: answer)\n  in iter items []\n</code></pre> <p>Unfortunately, defining <code>square_list</code> this way produces the answer list in the reverse order of the one desired. Why? Write your answer in a comment.</p> <p>Louis then tries to fix his bug by interchanging the arguments to the <code>::</code> constructor:</p> <pre><code>let square_list items =\n  let rec iter things answer =\n    match things with\n      | [] -&gt; answer\n      | h :: t -&gt; iter t (answer :: (h * h))\n  in iter items []\n</code></pre> <p>This doesn\u2019t work either. Explain why in a comment.</p> <p>Can you modify Louis' second solution slightly to make it work properly? (By \"slightly\", we mean changing the <code>::</code> constructor to a different list operator and making one more small modification on the same line?) If so, would the resulting function be efficient? Why or why not?</p> <p>Note</p> <p>We\u2019re interested in time efficiency here, not space efficiency.</p>"},{"location":"assignments/3/partA_lists/#5-count_negative_numbers","title":"5. <code>count_negative_numbers</code>","text":"<p>[5 points]</p> <p>Write a function called <code>count_negative_numbers</code> that counts the negative integers in a list and returns the count.</p>"},{"location":"assignments/3/partA_lists/#6-power_of_two_list","title":"6. <code>power_of_two_list</code>","text":"<p>[5 points]</p> <p>Write a function called <code>power_of_two_list</code> that takes in an integer <code>n</code>, and creates a list containing the first <code>n</code> powers of 2 starting with \\(2^0\\) and up to \\(2^{n-1}\\).</p> <p>You can write a <code>pow</code> helper function inside this function if you like (though you\u2019re not required to; there are other ways to do it). The <code>pow</code> function (if you write it) takes two non-negative integers and returns the first raised to the power of the second. (For the pedantic: you can assume that \\(0^0 = 1\\)). Don\u2019t use the <code>**</code> operator (which is a floating-point operator anyway) in your definition of <code>pow</code>.</p> <p>Examples</p> <pre><code># power_of_two_list 0 ;;\n- : int list = []\n# power_of_two_list 1 ;;\n- : int list = [1]\n# power_of_two_list 2 ;;\n- : int list = [1; 2]\n# power_of_two_list 4 ;;\n- : int list = [1; 2; 4; 8]\n# power_of_two_list 8 ;;\n- : int list = [1; 2; 4; 8; 16; 32; 64; 128]\n</code></pre>"},{"location":"assignments/3/partA_lists/#7-prefix_sum","title":"7. <code>prefix_sum</code>","text":"<p>[5 points]</p> <p>Write a function called <code>prefix_sum</code> that takes in a list of numbers, and returns a list containing the prefix sum of the original list. e.g. <code>prefix-sum [1; 3; 5; 2] ==&gt; [1; 4; 9; 11]</code>. The prefix sum is the sum of all of the elements in the list up to that point, so for the list <code>[1; 3; 5; 2]</code> the prefix sum is <code>[1; 1+3; 1+3+5; 1+3+5+2]</code> or <code>[1; 4; 9; 11]</code>.</p> <p>Examples</p> <pre><code># prefix_sum [] ;;\n- : int list = []\n# prefix_sum [1] ;;\n- : int list = [1]\n# prefix_sum [1; 2; 3; 4; 5] ;;\n- : int list = [1; 3; 6; 10; 15]\n# prefix_sum [-1; 1; -1; 1; -1; 1] ;;\n- : int list = [-1; 0; -1; 0; -1; 0]\n</code></pre>"},{"location":"assignments/3/partA_lists/#8-sicp-exercise-227","title":"8. (SICP exercise 2.27)","text":"<p>[5 points]</p> <p>Modify the <code>reverse</code> function you defined previously in this assignment to produce a <code>deep_reverse</code> function that takes a list of lists (of arbitrary type) as its argument and returns as its value the same list with its elements reversed and with its immediate sublists reversed as well.</p> <p>Note</p> <p>You are allowed to use the <code>reverse</code> function you defined above in your <code>deep_reverse</code> function.</p> <p>Examples</p> <pre><code># let lst = [[1; 2]; [3; 4]] ;;\nval lst : int list list = [[1; 2]; [3; 4]]\n# reverse lst ;;\n- : int list list = [[3; 4]; [1; 2]]\n# deep_reverse lst ;;\n- : int list list = [[4; 3]; [2; 1]]\n# let lst2 = [[[1; 2]; [3; 4]]; [[5; 6]; [7; 8]]] ;;\n- : int list list list = [[[1; 2]; [3; 4]]; [[5; 6]; [7; 8]]]\n# deep_reverse lst2 ;;\n- : int list list list = [[[7; 8]; [5; 6]]; [[3; 4]; [1; 2]]]\n</code></pre>"},{"location":"assignments/3/partA_lists/#9-s-expressions","title":"9. S-expressions","text":"<p>[5 points]</p> <p>Sometimes people learning OCaml from a background of dynamically typed languages like Python miss having lists which can store arbitrary values. In particular, it would be nice to have a list that can store either values of a particular type <code>'a</code>, or a list of such values, or a list of lists of such values, and so on, with any combination of values and lists. This is easily modeled in OCaml by defining a new datatype:</p> <pre><code>type 'a nested_list =\n  | Value of 'a\n  | List of 'a nested_list list\n</code></pre> <p>Now you can have a list-like data structure that can mix together values and lists with arbitrary nesting. (This datatype is actually isomorphic to a datatype called S-expressions which are used as the basis of the syntax of Scheme and related languages.) For instance:</p> <pre><code># Value 10 ;;\n- : int nested_list = Value 10\n# List [Value 10] ;;\n- : int nested_list = List [Value 10]\n# List [Value 10; Value 20; Value 30] ;;\n- : int nested_list = List [Value 10; Value 20; Value 30]\n# List [Value 10; List [Value 20; List [Value 30; Value 40]; Value 50]; Value 60] ;;\n- : int nested_list =\nList\n [Value 10; List [Value 20; List [Value 30; Value 40]; Value 50]; Value 60]\n# List [List [Value 1; Value 2]; List [Value 3; Value 4]] ;;\n- : int nested_list = List [List [Value 1; Value 2]; List [Value 3; Value 4]]\n</code></pre> <p>Define a version of the <code>deep_reverse</code> function from the previous problem that works on <code>nested_list</code>s. Call it <code>deep_reverse_nested</code>. Don\u2019t use the <code>reverse</code> or <code>deep_reverse</code> functions in your definition. Note that <code>Value</code>s don\u2019t get reversed, because there is in general no way to reverse them; only the <code>List</code> constructor contents get reversed. <code>deep_reverse_nested</code> should reverse lists all the way down, no matter how deeply nested the lists are.</p> <p>Examples</p> <pre><code># deep_reverse_nested (Value 10) ;;\n- : int nested_list = Value 10\n# deep_reverse_nested (List [Value 10; Value 20; Value 30; Value 40]) ;;\n- : int nested_list = List [Value 40; Value 30; Value 20; Value 10]\n# deep_reverse_nested (List [List [Value 10; Value 20]; List [Value 30; Value 40]]) ;;\n- : int nested_list =\nList [List [Value 40; Value 30]; List [Value 20; Value 10]]\n# deep_reverse_nested (List [Value 10; List [Value 20; Value 30]]) ;;\n- : int nested_list = List [List [Value 30; Value 20]; Value 10]\n# deep_reverse_nested (List [List [Value 10; Value 20]; Value 30]) ;;\n- : int nested_list = List [Value 30; List [Value 20; Value 10]]\n# deep_reverse_nested (List [Value 10; List [Value 20; List [Value 30; Value 40]; Value 50]; Value 60]) ;;\n- : int nested_list =\nList\n [Value 60; List [Value 50; List [Value 40; Value 30]; Value 20]; Value 10]\n</code></pre> <p>Hint</p> <p>Check for the <code>Value</code> case first, because if the input is just a <code>Value</code>, it doesn\u2019t need to be reversed. Otherwise, extract the (OCaml) list from the <code>List</code> constructor and pass it to a recursive helper function which will assemble the result.</p> <p>Warning</p> <p>There is a very simple solution to this problem that uses the library functions <code>List.map</code> and <code>List.rev</code>. This is not what we want, so please don't use those functions in your answer.</p>"},{"location":"assignments/3/partB_structural_generative_recursion/","title":"Part B: Structural and generative recursion (20 points)","text":"<p>In the lectures, we talked about the difference between structural and generative recursion. In this section we\u2019ll give you a chance to learn about generative recursion first-hand, by implementing a version of a sorting algorithm called \"quicksort\". The version we\u2019ll implement may be quite different from ones you may have seen before; this version of quicksort will work on lists (not arrays) and will not change the input list. This section also includes some other problems involving structural and generative recursion.</p> <p>In SICP, the authors introduce the <code>filter</code> higher-order function. Translated into OCaml, that definition would be:</p> <pre><code>let rec filter predicate sequence =\n  match sequence with\n    | [] -&gt; []\n    | h :: t when predicate h -&gt; h :: filter predicate t\n    | _ :: t -&gt; filter predicate t\n</code></pre> <p>where <code>predicate</code> is a function of one argument returning a <code>bool</code>, and <code>sequence</code> is a list. We will use this in this section. (In the OCaml libraries, this function is available as <code>List.filter</code>).</p>"},{"location":"assignments/3/partB_structural_generative_recursion/#1-quicksort","title":"1. Quicksort","text":"<p>[8 points]</p> <p>Implement a <code>quicksort</code> function that sorts a list of integers in ascending order, returning the new (sorted) list. The <code>quicksort</code> function works like this:</p> <ol> <li> <p>If the list is empty, return the empty list.</p> </li> <li> <p>Otherwise, the first element in the list is called the pivot. Use it to create a list of all the elements in the original list which are smaller than the pivot (using the <code>filter</code> function), and another list of elements in the original list which are equal to or larger than the pivot (not including the pivot itself). Then recursively quicksort those two lists and assemble the complete list using the OCaml list append operator (<code>@</code>).</p> </li> <li> <p>To make this function extra-general, instead of using the <code>&lt;</code> operator to define whether an element is smaller than another, abstract it around a comparison function <code>cmp</code> which takes two values and returns a <code>bool</code>. We saw examples of this in lecture 9. Make the comparison function the first argument of <code>quicksort</code>. Using <code>(&lt;)</code> as this argument makes the function sort in ascending order (the most usual way of sorting).</p> </li> </ol> <p>Examples</p> <pre><code># quicksort (&lt;) [] ;;\n- : 'a list = []\n# quicksort (&lt;) [1] ;;\n- : int list = [1]\n# quicksort (&lt;) [1; 2; 3; 4; 5] ;;\n- : int list = [1; 2; 3; 4; 5]\n# quicksort (&lt;) [5; 4; 3; 2; 1; 2; 3; 4; 5] ;;\n- : int list = [1; 2; 2; 3; 3; 4; 4; 5; 5]\n# quicksort (&gt;) [5; 4; 3; 2; 1; 2; 3; 4; 5] ;;\n- : int list = [5; 5; 4; 4; 3; 3; 2; 2; 1]\n</code></pre> <p>Our solution is 7 lines long.</p>"},{"location":"assignments/3/partB_structural_generative_recursion/#2-quicksorts-recursion-class","title":"2. Quicksort\u2019s recursion class","text":"<p>[2 points]</p> <p>Explain (in an OCaml comment) why the <code>quicksort</code> function is an instance of generative recursion and not structural recursion.</p>"},{"location":"assignments/3/partB_structural_generative_recursion/#3-merge-sort-base-cases","title":"3. Merge sort base cases","text":"<p>[5 points]</p> <p>Ben Bitfiddle doesn\u2019t understand why the <code>merge_sort</code> function in the lectures has to have two base cases. He writes a version which only checks for the empty list, not for lists of length 1. Recall that the <code>merge_sort</code> function and its helper functions were defined as:</p> <pre><code>let rec odd_half a_list =\n  match a_list with\n    | [] -&gt; []\n    | [x] -&gt; [x]  (* copy 1-element list *)\n    | h :: _ :: t -&gt; h :: odd_half t (* skip second element in list *)\n\nlet even_half a_list =\n  match a_list with\n    | [] -&gt; []\n    | _ :: t -&gt; odd_half t\n\nlet rec merge_in_order list1 list2 cmp =\n  match (list1, list2) with\n   | ([], _) -&gt; list2\n   | (_, []) -&gt; list1\n   | (h1 :: t1, h2 :: _) when cmp h1 h2 -&gt;\n       h1 :: merge_in_order t1 list2 cmp\n   | (_, h2 :: t2) -&gt;\n       h2 :: merge_in_order list1 t2 cmp\n\nlet rec merge_sort a_list cmp =\n  match a_list with\n    | []\n    | [_] -&gt; a_list\n    | _ -&gt;\n      let eh = even_half a_list in\n      let oh = odd_half a_list in\n        merge_in_order\n          (merge_sort eh cmp)\n          (merge_sort oh cmp) cmp\n</code></pre> <p>Ben\u2019s version is identical, except for the <code>merge_sort</code> function, which looks like this:</p> <pre><code>let rec merge_sort a_list cmp =\n  match a_list with\n    | [] -&gt; []\n    | _ -&gt;\n      let eh = even_half a_list in\n      let oh = odd_half a_list in\n        merge_in_order\n          (merge_sort eh cmp)\n          (merge_sort oh cmp) cmp\n</code></pre> <p>Explain in an OCaml comment why this won\u2019t work. Hint: Try it on some very simple test cases.</p>"},{"location":"assignments/3/partB_structural_generative_recursion/#4-insertion-sort-recursive-process-version","title":"4. Insertion sort: recursive process version","text":"<p>[5 points]</p> <p>The insertion sort function defined in the lectures generated a linear iterative process when run. A much shorter insertion sort can be written as a linear recursive process. Fill in the <code>&lt;??&gt;</code> section in the following code to write the linear recursive insertion sort. Is this an example of structural recursion or generative recursion? Write a comment explaining which kind of recursion this represents.</p> <pre><code>let rec insert_in_order cmp new_result a_list =\n  match a_list with\n    | [] -&gt; [new_result]\n    | h :: t when cmp new_result h -&gt; new_result :: a_list\n    | h :: t -&gt;  h :: insert_in_order cmp new_result t\n\nlet rec insertion_sort cmp a_list =\n  match a_list with\n    | [] -&gt; []\n    | h :: t -&gt; &lt;??&gt;\n</code></pre> <p>You only need to add a single line in the indicated position.</p>"},{"location":"assignments/3/partC_more_lists/","title":"Part C: Some harder problems with lists (30 points)","text":""},{"location":"assignments/3/partC_more_lists/#1-sicp-exercise-232","title":"1. (SICP exercise 2.32)","text":"<p>[5 points]</p> <p>We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <code>[1; 2; 3]</code>, then the set of all subsets is <code>[[]; [3]; [2]; [2; 3]; [1]; [1; 3]; [1; 2]; [1; 2; 3]]</code>. Complete the following definition of a function that generates the set of subsets of a set and give a clear explanation of why it works:</p> <pre><code>let rec subsets = function\n  | [] -&gt; [[]]\n  | h :: t -&gt; let rest = subsets t in\n      rest @ (List.map &lt;??&gt; rest)\n</code></pre> <p>This problem is a classic. Note that the order of elements in a set is unimportant, so the list results can come in any order (but don\u2019t duplicate anything!). (Using lists for sets is not optimal design, but we will revisit this question later.)</p> <p>Don\u2019t forget the \"clear explanation of how it works\"! Put this in an OCaml comment. (It doesn't have to be very long.)</p> <p>Examples</p> <pre><code># subsets [] ;;\n- : 'a list list = [[]]\n# subsets [1] ;;\n- : int list list = [[]; [1]]\n# subsets [1;2;3] ;;\n- : int list list = [[]; [3]; [2]; [2; 3]; [1]; [1; 3]; [1; 2]; [1; 2; 3]]\n</code></pre>"},{"location":"assignments/3/partC_more_lists/#2-sicp-exercise-233","title":"2. (SICP exercise 2.33)","text":"<p>[10 points]</p> <p>This is another classic problem (SICP is full of them!).</p> <p>Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:</p> <pre><code>let rec accumulate op initial sequence =\n  match sequence with\n    | [] -&gt; initial\n    | h :: t -&gt; op h (accumulate op initial t)\n\nlet map p sequence =\n  accumulate (fun x r -&gt; &lt;??&gt;) [] sequence\n\nlet append seq1 seq2 =\n  accumulate (fun x r -&gt; x :: r) &lt;??&gt; &lt;??&gt;\n\nlet length sequence =\n  accumulate &lt;??&gt; 0 sequence\n</code></pre> <p>Note</p> <p>The <code>accumulate</code> function is so generally useful that it is a library function in nearly all functional languages; in OCaml it\u2019s called <code>List.fold_right</code>, though the arguments are in a different order.</p> <p>Hint</p> <p>The <code>op</code> part of the problem is the most important part. Each <code>op</code> function must be a function of two arguments, the first being the current list value being looked at, and the second the rest of the list after being recursively processed by the <code>accumulate</code> function. Also, don\u2019t assume that the initial value is always |eg| the empty list. The missing parts are very short.</p>"},{"location":"assignments/3/partC_more_lists/#3-sicp-exercise-236","title":"3. (SICP exercise 2.36)","text":"<p>[5 points]</p> <p>The function <code>accumulate_n</code> is similar to <code>accumulate</code> except that it takes as its third argument a list of lists, which are all assumed to have the same number of elements. It applies the designated accumulation function to combine all the first elements of the lists, all the second elements of the lists, and so on, and returns a list of the results. For instance, if <code>s</code> is a list containing four lists, <code>[[1;2;3];[4;5;6];[7;8;9];[10;11;12]]</code>, then the value of <code>accumulate_n (+) 0 s</code> should be the list <code>[22;26;30]</code>. Fill in the missing expressions in the following definition of <code>accumulate_n</code>:</p> <pre><code>let rec accumulate_n op init seqs =\n  match seqs with\n    | [] -&gt; failwith \"empty list\"\n    | [] :: _ -&gt; []   (* assume all sublists are empty *)\n    | _ -&gt;  (* non-empty list containing non-empty sublists *)\n        accumulate op init &lt;??&gt; :: accumulate_n op init &lt;??&gt;\n</code></pre> <p>Examples</p> <pre><code># accumulate_n ( + ) 0 [[];[];[]] ;;\n- : int list = []\n# accumulate_n ( + ) 0 [[1;2;3];[4;5;6];[7;8;9];[10;11;12]] ;;\n- : int list = [22; 26; 30]\n# accumulate_n ( * ) 1 [[2;3];[4;5]] ;;\n- : int list = [8; 15]\n</code></pre> <p>Hint</p> <p><code>map</code> (or <code>List.map</code> if you prefer) is your friend. You may also find the <code>List.hd</code> (head) and <code>List.tl</code> (tail) functions to be useful. Again, the parts you need to fill in are very short .</p>"},{"location":"assignments/3/partC_more_lists/#4-sicp-exercise-237","title":"4. (SICP exercise 2.37)","text":"<p>[10 points]</p> <p>Suppose we represent vectors <code>v = (vi)</code> as lists of numbers, and matrices <code>m = (mij)</code> as lists of vectors (the rows of the matrix). For example, the 3x4 matrix:</p> <pre><code>+---------+\n| 1 2 3 4 |\n| 4 5 6 6 |\n| 6 7 8 9 |\n+---------+\n</code></pre> <p>is represented as the list of lists <code>[[1;2;3;4];[4;5;6;6];[6;7;8;9]]</code>. With this representation, we can use list operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p> <pre><code>dot_product v w\n  (* returns: the number d, where d = sum_i (v_i * w_i) *)\n\nmatrix_times_vector m v\n  (* returns: the vector t, where t_i = sum_j (m_ij * v_j) *)\n\nmatrix_times_matrix m n\n  (* returns: the matrix p, where p_ij = sum_k (m_ik * n_kj) *)\n\ntranspose m\n  (* returns: the matrix n, where n_ij = m_ji *)\n</code></pre> <p>We can define the dot product as:</p> <pre><code>let dot_product v w = accumulate (+) 0 (map2 ( * ) v w)\n</code></pre> <p>where <code>map2</code> is a version of <code>map</code> which maps a two-argument function (or operator) over two lists of equal lengths, returning a list of that length.</p> <p>Fill in the missing expressions in the following functions for computing <code>map2</code> and the other matrix operations. (The function <code>accumulate_n</code> was defined in the previous problem.)</p> <pre><code>let rec map2 f x y =\n  match (x, y) with\n    | ([], []) -&gt; []\n    | ([], _) -&gt; failwith \"unequal lists\"\n    | (_, []) -&gt; failwith \"unequal lists\"\n    | &lt;??&gt;\n\nlet matrix_times_vector m v = map &lt;??&gt; m\n\nlet transpose mat = accumulate_n &lt;??&gt; &lt;??&gt; mat\n\nlet matrix_times_matrix m n =\n  let cols = transpose n in\n     map &lt;??&gt; m\n</code></pre> <p>Examples</p> <pre><code># dot_product [] [] ;;\n- : int = 0\n# dot_product [1;2;3] [4;5;6] ;;\n- : int = 32\n# matrix_times_vector [[1;0];[0;1]] [10;20] ;;\n- : int list = [10; 20]\n# matrix_times_vector [[1;2];[3;4]] [-2;3] ;;\n- : int list = [4; 6]\n# transpose [[1;2];[3;4]] ;;\n- : int list list = [[1; 3]; [2; 4]]\n# transpose [[1;2;3];[4;5;6]] ;;\n- : int list list = [[1; 4]; [2; 5]; [3; 6]]\n# matrix_times_matrix [[1;0];[0;1]] [[1;2];[3;4]] ;;\n- : int list list = [[1; 2]; [3; 4]]\n# matrix_times_matrix [[1;2];[3;4]] [[1;2];[3;4]] ;;\n- : int list list = [[7; 10]; [15; 22]]\n# matrix_times_matrix [[1;2;3];[4;5;6]] [[1;2];[3;4];[5;6]] ;;\n- : int list list = [[22; 28]; [49; 64]]\n</code></pre> <p>Hint</p> <p>You can use the solutions of some of the functions in later functions. The missing parts are quite short, so don\u2019t do anything complicated! Finally, realize that multiplying a matrix by a matrix can be decomposed into multiplying each row of the first matrix by the entire second matrix.</p>"},{"location":"assignments/4/assignment4/","title":"Assignment 4: Data abstraction","text":""},{"location":"assignments/4/assignment4/#due-date","title":"Due date","text":"<p>This assignment is due on Thursday, Febuary 8th, at 2 AM.</p>"},{"location":"assignments/4/assignment4/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 10, corresponding to section 2.4.2 of SICP.</p>"},{"location":"assignments/4/assignment4/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab4.ml</code>. This file should be submitted to CodePost as <code>Assignment 4</code>. Do not submit any other files.</p>"},{"location":"assignments/4/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/4/ocaml_notes/#testing","title":"Testing","text":"<p>For this assignment, we are supplying you with these support files:</p> <ol> <li>a <code>.mli</code> OCaml interface file (<code>lab4.mli</code>)</li> <li>a test script (<code>tests_lab4.ml</code>)</li> <li>a <code>Makefile</code></li> </ol> <p>These files are all available on the course Canvas site in a single zip file called <code>lab4.zip</code>. Download this file and unzip it:</p> <pre><code>$ unzip lab4.zip\n</code></pre> <p>This will create a <code>lab4</code> directory with the files inside it. You should not change these files, and you should not submit them as part of your assignment submission. You should create, edit and compile the file <code>lab4.ml</code> (which you will be handing in) in the same directory.</p> <p>Compile and test the code the same way you did in previous assignments. Briefly:</p> <pre><code>$ make\n</code></pre> <p>compiles the code and runs the tests. If you just want to compile the code to check for type errors, type:</p> <pre><code>$ make compile\n</code></pre> <p>To remove all the generated files, including log files and all compiled OCaml files, type:</p> <pre><code>$ make clean\n</code></pre> <p>Of course, you can also compile your code from inside the OCaml interpreter using the <code>#use</code> directive, as we've previously described. This will check that the code compiles, but it won't check that it conforms to the <code>.mli</code> file, and it won't run the tests.</p>"},{"location":"assignments/4/ocaml_notes/#records-and-field-punning","title":"Records and field punning","text":"<p>We will be using OCaml records extensively in this assignment, so this is a good time to introduce a nifty feature (which we also mentioned in the recitation lectures) which makes writing code that uses records much easier. This feature is called field punning for reasons that will become clear shortly.</p> <p>Consider a simple record datatype for complex numbers:</p> <pre><code>type complex = { real : float; imag : float }\n</code></pre> <p>Writing code that pattern-matches against a complex number can be a bit annoying:</p> <pre><code>let magnitude { real = r; imag = i } = sqrt (r *. r +. i *. i)\n</code></pre> <p>What's annoying about this is that we have to come up with new names for the real and imaginary part of the complex number. Of course, we could do it this way without pattern matching:</p> <pre><code>let magnitude c = sqrt (c.real *. c.real +. c.imag *. c.imag)\n</code></pre> <p>because records support a \"dot syntax\" to access their components (like Python objects). However, this isn't really an improvement. Yet another way to write this would be as follows:</p> <pre><code>let magnitude { real = real; imag = imag } = sqrt (real *. real +. imag *. imag)\n</code></pre> <p>The right-hand side of this definition looks pretty good, but the left-hand side is weird. It's legal, because in OCaml you can use a field name as a variable name (they exist in different namespaces, to be technical), but it's ugly. What field punning allows you to do is to write this code like this:</p> <pre><code>let magnitude { real; imag } = sqrt (real *. real +. imag *. imag)\n</code></pre> <p>What this does is use the (variable) name <code>real</code> as the value of the (field) name <code>real</code>, and similarly for <code>imag</code>. This is a nice way to make functions which use records and which pattern-match on those records easier to write and easier to read.</p> <p>You can also use field punning when creating values of record types:</p> <pre><code># let c =\n    let real = 1.0 in\n    let imag = 3.4 in\n      { real; imag } ;;\n- : complex = {real = 1.; imag = 3.4}\n</code></pre> <p>This is a bit more confusing to read, but it works fine. Remember: field names are in a different namespace than variable names. So it's even legal to do this:</p> <pre><code>type complex = { real : float; imag : float }\nlet real = 42\nlet imag = \"this is wacky\"\n</code></pre> <p>Here, the variables <code>real</code> and <code>imag</code> aren't even floats, though the corresponding field names do refer to floats.</p> <p>You don't have to use field punning in this (or any other) assignment, but we recommend it. A good reference on OCaml records is this chapter from Real World OCaml. The OCaml manual also has a section on records in the first chapter (\"The core language\").</p>"},{"location":"assignments/4/ocaml_notes/#records-and-pattern-matching-with-missing-fields","title":"Records and pattern matching with missing fields","text":"<p>When pattern-matching on records, you don't have to include all the record fields if you don't want to. For instance:</p> <pre><code>type complex = { real : float; imag : float }\nlet real_of_complex { real } = real\n</code></pre> <p>This compiles and runs fine. But if you have certain warnings enabled (which happens when you compile the code using our <code>Makefile</code>), you'll get a warning:</p> <pre><code>Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:\nimag\nEither bind these labels explicitly or add '; _' to the pattern.\n</code></pre> <p>You should never ignore warnings!  Always fix the cause of the warning. In this case, the fix is as simple as changing the pattern by adding <code>; _</code> to the end of the pattern, as the error message indicated:</p> <pre><code>let real_of_complex { real; _ } = real\n</code></pre> <p>Now, when you compile this code, there will be no warning.</p>"},{"location":"assignments/4/ocaml_notes/#names-and-the-single-quote-character","title":"Names and the single quote character","text":"<p>Unlike most programming languages, OCaml allows identifier names to contain the single quote character (<code>'</code>) in any position except the first position. Typically, we use the single quote character at the end of names, and sometimes we use more than one single quote character. These are often used to refer to a name which is related in some way to another name but distinct. The single quote character used this way is often called a \"prime\" character, which comes from its use in mathematics. So the name <code>foo'</code> would be pronounced \"foo-prime\".</p>"},{"location":"assignments/4/ocaml_notes/#polymorphic-variants","title":"Polymorphic variants","text":"<p>Problem B.1 uses polymorphic variants, which are similar to algebraic datatypes except that you don't have to declare the type ahead of time. Polymorphic variants were discussed in lecture 10, and are discussed in The OCaml manual (chapter 5) and in Real World OCaml (chapter 6).</p>"},{"location":"assignments/4/partA_abstraction/","title":"Part A: Abstraction (60 points)","text":""},{"location":"assignments/4/partA_abstraction/#1-sicp-exercise-22","title":"1. (SICP exercise 2.2)","text":"<p>[10 points]</p> <p>Consider the problem of representing points and line segments in a plane. Points will be represented as a record type called <code>point</code>, containing two (floating-point) numbers (with field names <code>x</code> and <code>y</code>). Line segments will be represented as a record type called <code>segment</code> containing two points: a starting point (a field called <code>startp</code>) and an ending point (a field called <code>endp</code>). Define the two datatypes using OCaml <code>type</code> definitions.</p> <p>Using this representation, define the following functions:</p> <ol> <li> <p><code>midpoint_segment</code>: this function will take a single <code>segment</code> as its only argument and return a <code>point</code> which is the midpoint of the line segment.</p> </li> <li> <p><code>segment_length</code>: this function will take a single <code>segment</code> as its only argument and return a <code>float</code> which is the length of the line segment.</p> </li> <li> <p><code>print_point</code>: this function will take a single <code>point</code> as its only argument and print its representation to the terminal.</p> </li> </ol> <p>Use the <code>Printf.printf</code> function with a suitable format string to print points. Use the <code>%g</code> formatting directive to print floating-point numbers without extra trailing zeros. The output should look like this when tested in the interactive OCaml interpreter:</p> <pre><code># let p1 = ... ;; (* x = 1.0, y = 0.0 *)\n# print_point p1;;\n(1, 0)\n# let p2 = ... ;; (* x = 3.4, y = -4.5 *)\n# print_point p2;;\n(3.4, -4.5)\n</code></pre> <p>You may find the built-in functions <code>abs_float</code> and <code>sqrt</code> useful for computing segment lengths.</p> <p>Finally, write the following functions, which serve as an abstraction layer for points and segments.</p> <ol> <li> <p><code>make_point</code>: this function takes two <code>float</code> arguments (representing the <code>x</code> and <code>y</code> coordinates) and returns a <code>point</code> in your representation.</p> </li> <li> <p><code>get_coords</code>: this function takes a <code>point</code> argument and returns a two-tuple of the (x, y) coordinates.</p> </li> <li> <p><code>make_segment</code>: this function takes two <code>point</code> arguments (representing the start and endpoints) and returns a <code>segment</code> in your representation.</p> </li> <li> <p><code>get_points</code>: this function takes a <code>segment</code> argument and returns a two-tuple of the (start, end) points.</p> </li> </ol>"},{"location":"assignments/4/partA_abstraction/#2-sicp-exercise-23","title":"2. (SICP exercise 2.3)","text":"<p>[10 points]</p> <p>Implement a representation for rectangles in a plane. Create functions that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area functions will work using either representation?</p> <p>The first representation will store only a pair of points, representing the lower-left corner and the upper-right corner. The second representation will store four numbers, representing the lower and upper <code>x</code> values, and the lower and upper <code>y</code> values. Use the point and segment abstractions developed in the previous problem in your solution of this problem (you don't have to re-type that code). For both representations, define these accessors:</p> <pre><code>rectangle_lower_segment\nrectangle_upper_segment\nrectangle_left_segment\nrectangle_right_segment\n</code></pre> <p>Note</p> <p>Don't define the accessors for one representation in terms of the accessors for the other representation even if you can. Pretend that the code for each representation was written by a different programmer with no knowledge of the other representation.</p> <p>Use the point and segment abstraction layers, as needed, to define these accessors. Don't use the internal representation of either points or segments. You may also find it useful to define new point accessors <code>get_x</code> and <code>get_y</code> to extract just the X or Y coordinates of points. These should be defined in terms of the <code>get_coords</code> accessor, and not in terms of the internal representation of points.</p> <p>Then define the functions <code>rectangle_perimeter</code> and <code>rectangle_area</code> using only these accessors and functions from the point representation described above.</p> <p>Since we want to be able to test both representations, use the following names for the second representation's functions:</p> <pre><code>rectangle_lower_segment2\nrectangle_upper_segment2\nrectangle_left_segment2\nrectangle_right_segment2\nrectangle_perimeter2\nrectangle_area2\n</code></pre> <p>Note, though, that the code for <code>rectangle_perimeter</code> and <code>rectangle_perimeter2</code> will be identical except for name changes (and similarly for <code>rectangle_area</code> and <code>rectangle_area2</code>). The code for the other corresponding functions will necessarily be different, because they will use different data representations.</p> <p>Judicious use of field punning (see the \"OCaml notes\" section) will make this code much easier to write. Also, don't forget about the dot syntax for accessing record fields, as it can be useful here too.</p> <p>Finally, for testing purposes, write the following functions:</p> <ol> <li> <p><code>make_rectangle</code>: this function takes two <code>point</code> arguments and creates a rectangle using the first representation.</p> </li> <li> <p><code>make_rectangle2</code>: this function takes four <code>float</code> arguments and creates a rectangle using the second representation.</p> </li> </ol> <p>Note</p> <p>Technically, <code>make_rectangle</code> and <code>make_rectangle2</code> could take their arguments in whatever order you like. However, the test scripts expect the order to be</p> <ul> <li> <p><code>make_rectangle ll ur</code> where <code>ll</code> is the point representing the lower-left corner, and <code>ur</code> is the point representing the upper-right corner</p> </li> <li> <p><code>make_rectangle2 lx ly ux uy</code>, where <code>lx</code> is the lower <code>x</code> value, <code>ux</code> is the upper <code>x</code> value, <code>ly</code> is the lower <code>y</code> value, and <code>uy</code> is the upper <code>y</code> value.</p> </li> </ul> <p>so please define your functions that way.</p>"},{"location":"assignments/4/partA_abstraction/#3-sicp-exercise-24","title":"3. (SICP exercise 2.4)","text":"<p>[5 points]</p> <p>There are many ways to represent data types. For instance, if we want to represent pairs of values, we could write:</p> <pre><code>type ('a, 'b) pair = Pair of 'a * 'b\nlet first (Pair (x, _)) = x\nlet second (Pair (_, y)) = y\n</code></pre> <p>Note that <code>pair</code> is a polymorphic type, with two type variables <code>'a</code> and <code>'b</code>, since the same definition will work for arbitrary types. (OCaml already defines the built-in functions <code>fst</code> and <code>snd</code> to extract the first and second elements of an arbitrary two-tuple.)</p> <p>Alternatively, we could just use \"bare\" two-tuples as our representation, or some kind of record type with two fields. A more exotic representation of pairs uses a function with two arguments as the pair data type. Here is part of the code for this representation:</p> <pre><code>let make_pair x y = fun m -&gt; m x y\n(* Or, equivalently: let make_pair x y m = m x y *)\nlet first z = z (fun x y -&gt; x)\n</code></pre> <p>What is the corresponding definition of <code>second</code>? Write the code in your answer (not in a comment). Then verify (in a comment) that <code>first (make_pair x y)</code> yields <code>x</code> for any objects <code>x</code> and <code>y</code>. (You don't need to do a full substitution model evaluation; just enough to show that you get the correct answer.) Then write out (again in a comment) the full substitution model evaluation of <code>second (make_pair 1 2)</code>. (Spoiler alert: the answer should be <code>2</code>.) The evaluation isn't too long (about 25 lines).</p> <p>This representation for pairs is actually how pairs are represented in lambda calculus (LC), which adds strength to the argument that LC is in fact capable of representing arbitrary data and computations on that data.</p> <p>Note</p> <p>Depending on the warning settings, OCaml may complain about a function such as this:</p> <pre><code>fun x y -&gt; x\n</code></pre> <p>because the <code>y</code> argument isn't used. In that case, just use <code>_</code> instead:</p> <pre><code>fun x _ -&gt; x\n</code></pre>"},{"location":"assignments/4/partA_abstraction/#4-sicp-exercise-25","title":"4. (SICP exercise 2.5)","text":"<p>[5 points]</p> <p>Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair of \\(a\\) and \\(b\\) as the integer \\(2^a 3^b\\). Give the corresponding definitions of the functions <code>make_pair</code>, <code>first</code>, and <code>second</code>. To avoid name clashes with the previous problem, call them <code>make_pairi</code>, <code>firsti</code>, and <code>secondi</code>.</p> <p>Before you do this, define the following two helper functions:</p> <ol> <li> <p><code>pow</code>: This function takes two <code>int</code> arguments and returns the first raised to the power of the second. So <code>pow 2 10</code> would give <code>1024</code>. (You may have defined this in the last assignment, in which case you can re-use that definition.)</p> </li> <li> <p><code>int_log</code>: This function takes two <code>int</code> arguments and returns the integer logarithm of the second to the base of the first, which we define as being the number of times that the base can be evenly divided into the number. Examples:</p> <pre><code>int_log 2 1024 --&gt; 10\nint_log 3 1024 --&gt; 0    (* 1024 is not divisible by 3 *)\nint_log 2 3888 --&gt; 4\nint_log 3 3888 --&gt; 5    (* 3888 = 2^4 * 3^5 *)\n</code></pre> <p>In general, if <code>pow a b</code> is <code>c</code>, then <code>int_log a c</code> is <code>b</code>.</p> </li> </ol> <p>Once these functions have been defined, you can (and should) trivially define <code>make_pairi</code>, <code>firsti</code> and <code>secondi</code> in terms of them.</p> <p>You may assume that all arguments are positive integers, except that the second argument of <code>pow</code> can also be <code>0</code>.</p>"},{"location":"assignments/4/partA_abstraction/#5-unary-numbers","title":"5. Unary numbers","text":"<p>[10 points]</p> <p>A very simple representation of non-negative integers is called the \"unary number\" representation. One way to represent a non-negative integer in this representation is as follows:</p> <pre><code>0 --&gt; [blank]\n1 --&gt; 1\n2 --&gt; 11\n3 --&gt; 111\n4 --&gt; 1111\n5 --&gt; 11111\n(* etc. *)\n</code></pre> <p>Clearly, the digit <code>1</code> is just a placeholder; we could just as well use anything else. In this problem, we'll write some functions to work with unary numbers in OCaml. Our first representation will use lists: zero will be the empty list, one will be the list containing only the <code>unit</code> value (<code>[()]</code>), two will be the list containing two <code>unit</code> values (<code>[(); ()]</code>), and so on. So we have:</p> <pre><code>0 --&gt; []\n1 --&gt; [()]\n2 --&gt; [(); ()]\n3 --&gt; [(); (); ()]\n4 --&gt; [(); (); (); ()]\n5 --&gt; [(); (); (); (); ()]\n(* etc. *)\n</code></pre> <p>This can be expressed as the following OCaml code, which is our abstraction layer for working with unary integers:</p> <pre><code>let zero = []\n\nlet is_zero = function\n  | [] -&gt; true\n  | () :: _ -&gt; false\n\nlet succ u = () :: u\n</code></pre> <p>You need to define the following functions:</p> <ol> <li> <p><code>prev</code>: This function takes one argument (a unary representation of an integer) and returns a unary integer one less than the argument. If the argument is (unary) zero, use the <code>invalid_arg</code> function with a reasonable error message to raise an exception.</p> </li> <li> <p><code>integer_to_unary</code>: This function takes one argument (an OCaml <code>int</code>) and returns a unary number representation of the same integer.</p> </li> <li> <p><code>unary_to_integer</code>: This function takes one argument (a unary representation of an integer) and returns the corresponding OCaml <code>int</code>.</p> </li> <li> <p><code>unary_add</code>: This function takes two arguments, both of which are unary representations of integers. It returns the result of adding the two integers together. The return value is a unary representation of an integer, not an OCaml <code>int</code>.</p> </li> </ol> <p>We are going to insist on a few more restrictions. Only the <code>prev</code> function should use pattern matching. The rest of the functions should only use <code>if</code>/<code>then</code>/<code>else</code> statements, the abstraction layer functions (<code>zero</code>, <code>is_zero</code>, <code>succ</code>, and <code>prev</code>), recursion, integer operations where they are essential, and nothing else.</p> <p>Do not convert from unary numbers to integers to do any operations (except, obviously, in <code>unary_to_integer</code>). Similarly, do not convert integers to unary numbers to do any operations (except in <code>integer_to_unary</code>).</p> <p>Examples</p> <pre><code># prev [()];;\n- : unit list = []\n\n# prev [(); (); (); (); ()];;\n- : unit list = [(); (); (); ()]\n\n# integer_to_unary 0;;\n- : unit list = []\n\n# integer_to_unary 1;;\n- : unit list = [()]\n\n# integer_to_unary 10;;\n- : unit list = [(); (); (); (); (); (); (); (); (); ()]\n\n# unary_to_integer [(); (); (); (); (); (); (); (); ()];;\n- : int = 9\n\n# unary_to_integer [(); (); ()];;\n- : int = 3\n\n# unary_to_integer [()];;\n- : int = 1\n\n# unary_to_integer [];;\n- : int = 0\n\n# unary_add [(); (); ()] [];;\n- : unit list = [(); (); ()]\n\n# unary_add [] [(); (); ()];;\n- : unit list = [(); (); ()]\n\n# unary_add [(); ()] [(); (); ()];;\n- : unit list = [(); (); (); (); ()]\n\n# unary_to_integer\n    (unary_add (integer_to_unary 1001) (integer_to_unary 65535));;\n- : int = 66536\n</code></pre> <p>Now consider changing the the list-of-unit representation to this alternative unary representation:</p> <pre><code>type nat = Zero | Succ of nat\n\nlet zero' = Zero\n\nlet is_zero' = function\n  | Zero -&gt; true\n  | Succ _ -&gt; false\n\nlet succ' u = Succ u\n</code></pre> <p>Define <code>prev'</code> for this representation (you can use pattern matching). Do the other definitions (<code>integer_to_unary</code>, <code>unary_to_integer</code>, <code>unary_add</code>) have to change from their definitions in the previous representation (other than obvious name changes e.g. <code>is_zero</code> to <code>is_zero'</code>)? Write your answer in a comment. If the answer is yes, indicate which changes other than name changes have to be made. Write the new versions (even if they only require name changes). Try to re-use as much code as possible between the two representations.</p>"},{"location":"assignments/4/partA_abstraction/#6-sicp-exercise-26-church-numerals","title":"6. (SICP exercise 2.6 : Church numerals)","text":"<p>[10 points]</p> <p>In case representing pairs as functions wasn't mind-boggling enough, consider that, in a language that can manipulate functions as data, we can even get by without numbers (at least insofar as nonnegative integers are concerned) by implementing zero and the operation of adding one as:</p> <pre><code>(* zerof = \"functional zero\"; we call it this so as not to be confused with\n   zero or zero' previously defined. *)\n\nlet zerof = fun s -&gt; fun z -&gt; z\n  (* or equivalently: let zerof = fun s z -&gt; z *)\n  (* or equivalently: let zerof s z = z *)\n\nlet add1 n = fun s -&gt; fun z -&gt; s (n s z)\n  (* or equivalently: let add1 n = fun s z -&gt; s (n s z) *)\n  (* or equivalently: let add1 n s z = s (n s z) *)\n</code></pre> <p>Note</p> <p>If you copy this code directly into your assignment, you are likely to get warnings about unused variables, such as the <code>s</code> in <code>fun s -&gt; fun z -&gt; z</code>. Just replace these with <code>_</code> and the warnings will go away e.g. <code>fun _ -&gt; fun z -&gt; z</code>.</p> <p>This representation is known as the \"Church numeral\" representation, after its inventor, Alonzo Church, the logician who invented the lambda calculus. Conceptually, <code>s</code> means \"successor\" and <code>z</code> means \"zero\", though in reality they don't really mean anything since they are just formal arguments of functions.</p> <p>Define <code>one</code> and <code>two</code> directly (not in terms of <code>zerof</code> and <code>add1</code>). (Hint: Use substitution to evaluate <code>add1 zerof</code> and see what you get.) Continue by additionally defining all the integers from <code>three</code> to <code>ten</code> as Church numerals. Do not use <code>add1</code> or any of the smaller Church numerals to define the Church numerals. All Church numerals should have two arguments: <code>s</code> and <code>z</code> (like <code>zerof</code> does).</p> <p>Note</p> <p>Once you see the pattern, it will be very easy to define (non-negative) integers as Church numerals. You're not required to prove that your definitions are correct, but they have to be correct.</p> <p>Define an addition function called <code>add</code> for Church numerals. Don't use <code>add1</code> in this definition, and don't use regular OCaml <code>int</code>s in this function either (directly or indirectly). It should have the form:</p> <pre><code>let add m n s z = ...\n(* equivalent to: let add m n = fun s z -&gt; ... *)\n</code></pre> <p>where <code>m</code> and <code>n</code> are the Church numerals to be added. Note that when you pass Church numerals <code>m</code> and <code>n</code> to <code>add</code> you get a function of two arguments <code>s</code> and <code>z</code> as the return value; that is the Church numeral which is the sum of <code>m</code> and <code>n</code>. The definition of <code>add</code> is extremely short.</p> <p>Then define a function called <code>church_to_integer</code> which, given a Church numeral, returns the corresponding non-negative integer. This is also a very short function.</p>"},{"location":"assignments/4/partA_abstraction/#7-church-numerals-types","title":"7. Church numerals: types","text":"<p>[10 points]</p> <p>We cheated a little bit on the previous problem. Although we defined Church numerals in OCaml and were able to define useful functions on them, in fact, Church's original lambda calculus is untyped, whereas OCaml is very definitely typed, as you are well aware of by now. (Church later invented a typed lambda calculus as well, but that's not what we're referring to here.) Therefore, OCaml assigns types to all of the Church numerals (which are actually functions) as well as to the functions on Church numerals (<code>add1</code> and <code>add</code>). If you look at the <code>lab4.mli</code> interface file, you will see some types that you might not have expected:</p> <pre><code>val zerof : 'a -&gt; 'b -&gt; 'b\nval add1 : (('a -&gt; 'b) -&gt; 'c -&gt; 'a) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'b\nval one : ('a -&gt; 'b) -&gt; 'a -&gt; 'b\nval two : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval three : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval four : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval five : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval six : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval seven : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval eight : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval nine : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval ten : ('a -&gt; 'a) -&gt; 'a -&gt; 'a\nval add : ('a -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'd -&gt; 'b) -&gt; 'a -&gt; 'd -&gt; 'c\nval church_to_integer : ((int -&gt; int) -&gt; int -&gt; 'a) -&gt; 'a\n</code></pre> <p>These are the types that were automatically inferred for the functions as defined in <code>lab4.ml</code>.</p> <p>Note</p> <p>You can generate these type signatures yourself by running:</p> <pre><code>$ ocamlc -i lab4.ml\n</code></pre> <p>on your <code>lab4.ml</code> file (assuming that it's correct).</p> <p>One peculiar aspect of this is that <code>zerof</code> and <code>one</code> don't have the same types as the rest of the Church numerals. We might be OK with <code>one</code>, because it's more general than the subsequent Church numerals but compatible with them, but <code>zerof</code> is a completely different type. And <code>church_to_integer</code> doesn't even return an <code>int</code>! What is that all about? Let's compile the code and try it out:</p> <pre><code>$ ocamlc -c lab4.mli  (* the code we supplied you with *)\n$ ocamlc -c lab4.ml   (* your code *)\n$ utop\n# #load \"lab4.cmo\";;\n# open Lab4;;\n# church_to_integer;;\n- : ((int -&gt; int) -&gt; int -&gt; 'a) -&gt; 'a = &lt;fun&gt;\n# zerof;;\n- : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# one;;\n- : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;\n# church_to_integer zerof;;\n- : int = 0\n# church_to_integer one;;\n- : int = 1\n# church_to_integer ten;;\n- : int = 10\n</code></pre> <p>Somehow, it works: <code>church_to_integer</code> returns an <code>int</code> when given any of the Church numerals we defined. By assigning types to the type variables in <code>church_to_integer</code> when the argument of that function is either <code>zerof</code> or <code>one</code>, explain why both <code>church_to_integer zerof</code> and <code>church_to_integer one</code> return an integer. Write your answer as an OCaml comment.</p> <p>Hint</p> <p>Since type variables are simply arbitrary names, you can write the type of <code>church_to_integer</code> as:</p> <pre><code>val church_to_integer : ((int -&gt; int) -&gt; int -&gt; 'c) -&gt; 'c\n</code></pre> <p>so that there is no chance of confusing the <code>'a</code> in its type with the <code>'a</code> in the types of <code>zerof</code> and <code>one</code>, which could refer to different types. Similarly, the <code>'a</code> and <code>'b</code> types in <code>zerof</code> don't have to be the same as the <code>'a</code> and <code>'b</code> types in <code>one</code> for expressions involving <code>zerof</code> or <code>one</code>, and specifically for <code>church_to_integer zerof</code> and <code>church_to_integer one</code>.</p> <p>Your answer should indicate what type the type variables <code>'a</code>, <code>'b</code>, and <code>'c</code> have to be when evaluating <code>church_to_integer zerof</code> and <code>church_to_integer one</code>. They won't all be the same in both cases (which is OK because <code>church_to_integer</code> has a polymorphic type!). Then use this to argue that <code>church_to_integer zerof</code> and <code>church_to_integer one</code> both return values of type <code>int</code>.</p> <p>Also, don't forget that the \"type arrow\" (<code>-&gt;</code>) associates to the right, so the type <code>'a -&gt; 'b -&gt; 'c</code> means <code>'a -&gt; ('b -&gt; 'c)</code>. It's a very good idea to \"desugar\" type expressions in this manner before trying to compute type variable assignments.</p> <p>This process of assigning types to type variables in a consistent manner is called type unification and is one of the things that the OCaml compiler does for us.</p> <p>This is a somewhat challenging problem, so feel free to ask the TAs for help if you need it.</p>"},{"location":"assignments/4/partB_more_abstraction/","title":"Part B: More abstraction problems (20 points)","text":""},{"location":"assignments/4/partB_more_abstraction/#1-sicp-exercise-229","title":"1. (SICP exercise 2.29)","text":"<p>[10 points]</p> <p>A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile in OCaml using algebraic datatypes:</p> <pre><code>type mobile = Mobile of branch * branch  (* left and right branches *)\nand branch =\n  | Weight    of int * int     (* length and weight *)\n  | Structure of int * mobile  (* length and sub-mobile *)\n</code></pre> <p>Note that these types are mutually recursive, which is why we define them with <code>type ... and ...</code>. Note that this <code>type</code> declaration defines two types; <code>mobile</code> and <code>branch</code> are each distinct types.</p> <p>Here is an incomplete abstraction layer around these types:</p> <pre><code>let make_mobile l r = Mobile (l, r)\nlet make_weight l w = Weight (l, w)\nlet make_structure l m = Structure (l, m)\n</code></pre> <ol> <li> <p>Complete the abstraction layer by defining accessors (which SICP calls \"selectors\"). Define <code>left_branch</code> and <code>right_branch</code> to return the branches of a mobile, <code>branch_length</code> to return a branch's length, and <code>branch_structure</code> to return a branch's structure. <code>branch_structure</code> should return a polymorphic variant which will use the tag <code>`Weight</code> along with an integer weight if the structure is a weight, or <code>`Structure</code> along with a mobile if the structure is a (sub-)mobile. Neither the <code>`Weight</code> nor the <code>`Structure</code> variant should contain the length of the branch (i.e. they are not just copies of the <code>Weight</code> and <code>Structure</code> constructors of the <code>branch</code> type).</p> </li> <li> <p>Write the functions <code>branch_weight1</code> and <code>total_weight1</code> which return the weight of a branch and the total weight of a mobile, respectively. These functions should directly use the representation of the data types <code>mobile</code> and <code>branch</code>. These functions will need to be mutually recursive, so use the <code>let rec ... and ...</code> syntactic form when defining them.</p> <p>Then write new versions of these functions called <code>branch_weight2</code> and <code>total_weight2</code> which only use the abstraction layer functions. These will also be mutually recursive. Make sure you don't inadvertently call <code>branch_weight1</code> or <code>total_weight1</code> in either function!</p> <p>Clearly, <code>branch_weight1</code> and <code>branch_weight2</code> must be different functions (and similarly for the <code>total_weight1</code> and <code>total_weight2</code> functions) but they should return the same results given the same inputs.</p> </li> <li> <p>A mobile is said to be balanced if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate <code>is_balanced</code> that returns <code>true</code> if a mobile is balanced according to this criterion. This function should only use the abstraction layer functions described above. In other words, it will be independent of the internal structure of the mobile. We will be taking advantage of this fact below.</p> </li> <li> <p>Suppose we change the representation of mobiles so that the constructors are</p> <pre><code>type mobile'  = { left: branch'; right: branch' }\nand  branch'  = Branch' of int * contents\nand  contents = Weight' of int | Structure' of mobile'\n</code></pre> <p>Write a new abstraction layer around the new representation. Call the new functions <code>make_mobile'</code>, <code>make_weight'</code>, <code>make_structure'</code>, <code>left_branch'</code>, <code>right_branch'</code>, <code>branch_length'</code> and <code>branch_structure'</code>. They should return the same kinds of values as their unprimed counterparts, taking into account the new representation of mobiles and branches.</p> <p>Modify your functions <code>branch_weight2</code> and <code>total_weight2</code> so that they work with the new abstraction layer. Call the new versions <code>branch_weight'</code> and <code>total_weight'</code>. If you wrote <code>branch_weight2</code> and <code>total_weight2</code> correctly (only using the abstraction layer functions), this will be trivial (you'll just have to change the names of the abstraction layer functions in the corresponding function definitions). If not, go back and do that now! </p> <p>Finally, write a version of <code>is_balanced</code> which works with the new representation; call it <code>is_balanced'</code>. Again, if you have done everything right so far, this will be trivial (just involving name changes from the unprimed to the primed versions).</p> </li> </ol> <p>The main advantage of defining an abstraction layer is so you can rewrite the internal structure of a datatype without having to change much code. Here, for the sake of testing, we are preserving all versions of the abstraction layer functions and functions which depend on them. In a real world scenario, after changing the internal representation of mobiles we would simply change the <code>make_mobile</code>, <code>make_weight</code>, <code>make_structure</code>, <code>left_branch</code> and <code>right_branch</code> etc. functions to use the new representation. After that, all other code could remain the same.</p> <p>Note</p> <p>Later in the course we will cover modules and functors, which are OCaml language features that allows us to define multiple different implementations of data structures as well as the abstraction layers built on top of them in a very convenient way. Modules and functors have many other uses as well. Currently, only OCaml or languages related to OCaml have functors.<sup>1</sup></p> <p>Here are some test cases you should use to test both representations. (You'll have to modify the <code>make_xxx</code> names to work with the second representation.)</p> <pre><code>let m0 =\n  make_mobile\n    (make_weight 1 1)\n    (make_weight 1 1)\n\nlet m1 =\n  make_mobile\n    (make_weight 3 4)\n    (make_structure\n      4\n      (make_mobile\n        (make_weight 1 2)\n        (make_weight 2 1)))\n\nlet m2 =\n  make_mobile\n    (make_weight 1 400)\n    (make_structure\n      10\n      (make_mobile\n        (make_weight 100 1)\n        (make_weight 1 200)))\n\nlet m3 =\n  make_mobile\n    (make_weight 1 (total_weight1 m2))\n    (make_structure 1 m2)\n</code></pre> <p>For example:</p> <pre><code># total_weight m0 ;;\n- : int = 2\n# is_balanced m0 ;;\n- : bool = true\n# total_weight m1 ;;\n- : int = 7\n# is_balanced m1 ;;\n- : bool = true\n# total_weight m2 ;;\n- : int = 601\n# is_balanced m2 ;;\n- : bool = false\n# total_weight m3 ;;\n- : int = 1202\n# is_balanced m3 ;;\n- : bool = false\n</code></pre>"},{"location":"assignments/4/partB_more_abstraction/#2-sicp-exercise-230","title":"2. (SICP exercise 2.30)","text":"<p>[5 points]</p> <p>A tree is a kind of data structure. There are many different kinds of tree-like data structures used in computer programming. One example is the following:</p> <pre><code>type tree = Tree of elem list\nand elem =\n  | Num of int\n  | Sub of tree\n</code></pre> <p>This defines a tree where each component of the tree can be an integer or a subtree, and where a tree can have arbitrarily many components. Define a function called <code>square_tree</code> which will make a copy of a tree, except that all numbers in the tree will be squared. That is, <code>square_tree</code> should behave as follows:</p> <pre><code># square_tree (Tree [Num 1;\n                     Sub (Tree [Num 2; Sub (Tree [Num 3; Num 4]); Num 5]);\n                     Sub (Tree [Num 6; Num 7])])\n- : tree = Tree [Num 1;\n                 Sub (Tree [Num 4; Sub (Tree [Num 9; Num 16]); Num 25]);\n                 Sub (Tree [Num 36; Num 49])]\n</code></pre> <p>Define <code>square_tree</code> both directly (i.e., without using any higher-order functions) and also by using the <code>map</code> higher-order function (which is called <code>List.map</code> in Ocaml). Call the first function <code>square_tree</code> and the second one <code>square_tree'</code>.</p> <p>Use these tests:</p> <pre><code>let tree1 = Tree\n  [Num 10;\n   Sub (Tree [Num 20;\n              Sub (Tree [Num 42; Sub (Tree []); Num 12]);\n              Sub (Tree []);\n              Sub (Tree [Num 13; Sub (Tree [])])]);\n   Sub (Tree []);\n   Sub (Tree [Num 1; Num 2; Num 3])]\n\nlet tree2 = Tree\n  [Num 100;\n   Sub (Tree [Num 400;\n              Sub (Tree [Num 1764; Sub (Tree []); Num 144]);\n              Sub (Tree []);\n              Sub (Tree [Num 169; Sub (Tree [])])]);\n   Sub (Tree []);\n   Sub (Tree [Num 1; Num 4; Num 9])]\n\n(* Check that these are equal: *)\n(*\nsquare_tree  (Tree []) = (Tree [])\nsquare_tree' (Tree []) = (Tree [])\nsquare_tree  tree1 = tree2\nsquare_tree' tree1 = tree2\n*)\n</code></pre>"},{"location":"assignments/4/partB_more_abstraction/#3-sicp-exercise-231","title":"3. (SICP exercise 2.31)","text":"<p>[5 points]</p> <p>Abstract your answer to the previous problem to produce a function <code>tree_map</code> with the property that a version of <code>square_tree</code> could be defined as:</p> <pre><code>let square_tree'' tree = tree_map (fun n -&gt; n * n) tree\n</code></pre> <p>The solution is very short.</p> <ol> <li> <p>Many other languages (for instance, Haskell and C++) have a feature that they call \"functors\", but they are not at all like OCaml functors. It seems like every language defines the word \"functor\" to mean something completely different.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/4/partC_algebra/","title":"Part C: Miniproject: Algebraic expressions (20 points)","text":"<p>(Loosely \"derived\" from (SICP, exercise 2.56).)</p> <p>One of the best things about OCaml is how easy it is to express complicated data structures using algebraic datatypes. We will use this facility to represent algebraic expressions (real algebra, like you learned in high school) and perform interesting tasks on them.</p> <p>We will use the type <code>expr</code> to represent algebraic expressions. Its definition is:</p> <pre><code>type expr =\n  | Int of int           (* constant *)\n  | Var of string        (* variable *)\n  | Add of expr * expr   (* expr1 + expr2 *)\n  | Mul of expr * expr   (* expr1 * expr2 *)\n  | Pow of expr * int    (* expr^n *)\n</code></pre> <p>There is one non-structural constraint that we will impose on this type: the exponent in a <code>Pow</code> expression must be a non-negative integer.</p> <p>Clearly, expressions in this type can't represent all possible algebraic expressions, but they can represent a lot of cases of interest (e.g. polynomials with arbitrary numbers of variables), and it would be easy to extend this type to deal with more complex kinds of algebraic expressions.</p> <p>It's possible to write a parser from algebraic expressions written in the usual mathematical notation to this datatype, but we won't do that here. Instead, we will directly use the datatype constructors to build our expressions (we're not worrying about abstraction here either). Some example expressions written in this form would be:</p> <pre><code>42 --&gt; Int 42\n\nx --&gt; Var \"x\"\n\nx * y --&gt; Mul (Var \"x\", Var \"y\")\n\n(x - 1) * (y + x) --&gt; Mul (Add (Var \"x\", Int (-1)), Add (Var \"y\", Var \"x\"))\n\nx**3 + 6*x*y - 1 --&gt;\n  Add (Add (Pow (Var \"x\", 3), Mul (Int 6, Mul (Var \"x\", Var \"y\"))), Int (-1))\n</code></pre> <p>Once we have an algebraic expression in this form, we can do a number of interesting manipulations on it. We will do two of these in this section.</p>"},{"location":"assignments/4/partC_algebra/#1-simplification","title":"1. Simplification","text":"<p>[10 points]</p> <p>Many algebraic expressions can be converted into equivalent but simpler algebraic expressions. This process is called \"simplifying\" the algebraic expression. Simplification is a difficult problem in general, because there can be many mutually-exclusive definitions of what \"simpler\" means. However, some simplifications are universally agreed upon. For instance:</p> <ul> <li> <p>An expression which adds two integers can be replaced by a single integer (the sum of the two integers).</p> </li> <li> <p>An expression which multiplies two integers can be replaced by a single integer (the product of the two integers).</p> </li> <li> <p>An expression which takes an integer to the power of another integer can be replaced by a single integer (the power of the two integers).</p> </li> <li> <p>An expression which adds zero to another expression E is just the expression E.</p> </li> <li> <p>An expression which multiplies an expression E by 0 is just 0.</p> </li> <li> <p>An expression which multiplies an expression E by 1 is just E.</p> </li> <li> <p>An expression which raises an expression E to the power of 0 is just 1 (we are ignoring the tricky case of 0 to the power of 0 here).</p> </li> <li> <p>An expression which raises an expression E to the power of 1 is just E.</p> </li> </ul> <p>Write a function called <code>simplify1</code> which does all of these simplifications on an algebraic expression represented as a value of the type <code>expr</code>. Make sure that you consider the cases where e.g. 0 is added to an expression from the left or from the right, and similarly for other simplifications. Also, if an expression can't itself be simplified, try to recursively simplify its subexpressions.</p> <p>One thing that makes simplification difficult is that simplifying an expression can yield another expression which can itself be simplified. The best way to handle this is to repeat the simplification process until no more simplification can be performed. We are providing you with the following function <code>simplify</code> which will call your <code>simplify1</code> function to simplify an expression until no more of the simplifications described above are possible:</p> <pre><code>let rec simplify expr =\n  let e = simplify1 expr in\n    if expr = e\n      then expr\n      else simplify e\n</code></pre> <p>Technically, we say that <code>simplify</code> computes the fixpoint of <code>simplify1</code>. This makes the definition of <code>simplify1</code> simpler. For instance, if you simplify <code>E + 0</code> to just <code>E</code>, you don't then have to recurse on <code>E</code> in the <code>simplify1</code> function, because the expression <code>E</code> will be simplified again by the <code>simplify</code> function until it can't be simplified any more. On the other hand, if you have an expression <code>E + F</code> which can't be simplified by any of the rules above, you have to recursively simplify the parts (<code>E</code> and <code>F</code>), because if you don't, calling <code>simplify1</code> on this expression again won't do anything.</p> <p>Here are some expressions to test your simplifier. These represent the results after <code>simplify</code> has been called (not just <code>simplify1</code>).</p> <pre><code>Int 42 --&gt; Int 42\nVar \"x\" --&gt; Var \"x\"\nAdd (Int 32, Int 41) --&gt; Int 73\nAdd (Add (Int 1, Int 2), Add (Int 3, Int 4)) --&gt; Int 10\nAdd (Mul (Int 1, Int 2), Mul (Int 3, Int 4)) --&gt; Int 14\nMul (Mul (Int 1, Int 2), Mul (Int 3, Int 4)) --&gt; Int 24\nMul (Add (Int 1, Int 2), Mul (Int 3, Int 4)) --&gt; Int 36\nPow (Int 0, 0) --&gt; Int 1\nPow (Int 10, 2) --&gt; Int 100\nPow (Add (Int 1, Int 2), 2) --&gt; Int 9\n\nAdd (Var \"x\", Int 0) --&gt; Var \"x\"\nAdd (Int 0, Var \"x\") --&gt; Var \"x\"\nMul (Int 0, Var \"y\") --&gt; Int 0\nMul (Var \"y\", Int 0) --&gt; Int 0\nMul (Int 1, Var \"z\") --&gt; Var \"z\"\nMul (Var \"z\", Int 1) --&gt; Var \"z\"\nPow (Var \"x\", 0) --&gt; Int 1\nPow (Var \"x\", 1) --&gt; Var \"x\"\n\nPow (Add (Var \"x\", Int 0), 1) --&gt; Var \"x\"\nAdd (Add (Var \"x\", Int 0), Mul (Var \"y\", Int 0)) --&gt; Var \"x\"\n</code></pre>"},{"location":"assignments/4/partC_algebra/#2-differentiation","title":"2. Differentiation","text":"<p>[10 points]</p> <p>Another fun thing you can do with algebraic expressions represented programmatically is to symbolically differentiate them (i.e. compute their derivatives with respect to some variable). Specifically, you need to implement the following differentiation rules:</p> <ol> <li> <p>Differentiating any constant gives zero.</p> </li> <li> <p>Differentiating a variable by the same variable gives 1; for a different variable it gives zero.</p> </li> <li> <p>Differentiating a sum by a variable is done by differentiating the components of the sum separately and then adding them up.</p> </li> <li> <p>Differentiating a product by a variable uses the product rule: the derivative of \\(e_1 \\times e_2\\) by \\(x\\) is \\(\\frac{d}{dx} e_1 \\times e_2 + e_1 \\times \\frac{d}{dx} e_2\\).</p> </li> <li> <p>Differentiating an expression raised to a (positive) integer power uses the power rule: the derivative of \\(e^n\\) by \\(x\\) is \\(n \\times e^{n-1} \\times \\frac{d}{dx} e\\).</p> </li> </ol> <p>Write a function called <code>deriv</code> which implements all of these rules. It's beneficial if the expression to be differentiated is simplified before and after computing the derivative, so use this wrapper function when testing your function:</p> <pre><code>let derivative var expr =\n  let e = simplify expr in\n  let d = deriv var e in\n    simplify d\n</code></pre> <p>Examples</p> <pre><code>derivative \"x\" (Int 10) --&gt; Int 0\nderivative \"x\" (Var \"x\") --&gt; Int 1\nderivative \"x\" (Var \"y\") --&gt; Int 0\nderivative \"x\" (Add (Var \"x\", Var \"x\")) --&gt; Int 2\nderivative \"x\" (Add (Add (Var \"x\", Var \"x\"), Var \"x\")) --&gt; Int 3\nderivative \"x\" (Mul (Var \"x\", Int 42)) --&gt; Int 42\nderivative \"x\" (Mul (Var \"x\", Var \"y\")) --&gt; Var \"y\"\nderivative \"z\" (Mul (Var \"x\", Var \"y\")) --&gt; Int 0\nderivative \"x\" (Mul (Pow (Var \"x\", 2), Mul (Int 3, Var \"x\"))) --&gt;\n           Add (Mul (Mul (Int 2, Var \"x\"), Mul (Int 3, Var \"x\")),\n                Mul (Pow (Var \"x\", 2), Int 3))\nderivative \"x\" (Pow (Var \"y\", 1)) --&gt; Int 0\nderivative \"x\" (Pow (Var \"x\", 1)) --&gt; Int 1\nderivative \"x\" (Pow (Var \"x\", 2)) --&gt; Mul ((Int 2), (Var \"x\"))\nderivative \"x\" (Pow (Mul (Int 3, Var \"x\"), 3)) --&gt;\n           Mul\n            (Mul\n              (Int 3,\n                Pow (Mul (Int 3, Var \"x\"), 2)),\n              Int 3)\nderivative \"x\" (Add (Mul (Int 4, Pow (Var \"x\", 3)),\n                     Mul (Int 6, Pow (Var \"x\", 2)))) --&gt;\n           Add (Mul (Int 4, Mul (Int 3, Pow (Var \"x\", 2))),\n                Mul (Int 6, Mul (Int 2, Var \"x\")))\n</code></pre> <p>If your code produces these results, but with some of the terms rearranged (e.g. <code>Mul (Var \"x\", Int 2)</code> instead of <code>Mul (Int 2, Var \"x\")</code>, we'll accept it. However, the results should be equivalent.</p> <p>Note</p> <p>The test script may fail on correct answers in this case; don't assume that there is a bug! Instead, try the failing examples interactively and see if your result is reasonable.</p> <p>Our solution is less than ten lines long.</p>"},{"location":"assignments/5/assignment5/","title":"Assignment 5: Tags and objects","text":""},{"location":"assignments/5/assignment5/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, Febuary 23nd, at 2 AM.</p>"},{"location":"assignments/5/assignment5/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 12, as well as the material in recitation lecture 3.</p>"},{"location":"assignments/5/assignment5/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab5.ml</code>. This file should be submitted to CodePost as <code>Assignment 5</code>. Do not submit any other files.</p>"},{"location":"assignments/5/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/5/ocaml_notes/#testing","title":"Testing","text":"<p>For this assignment, we are supplying you with these support files:</p> <ul> <li>a <code>.mli</code> OCaml interface file (<code>lab5.mli</code>)</li> <li>a test script for parts A and B: (<code>tests_lab5.ml</code>)</li> <li>a test script for part C: (<code>tests_lab5c.ml</code>)</li> <li>a <code>Makefile</code></li> </ul> <p>These files are all available on the course Canvas site in a single zip file called <code>lab5.zip</code>. Download this file and use it as you've been doing with previous assignments.</p> <p>The automated tests are only for parts A and B. The test script for part C is not automated, because your results may not be identical to the ones we show below (though they should be equivalent). Instead, it will display the result of evaluating various expressions, and you can check by eye that they are correct. To run the test script for part C, type this:</p> <pre><code>$ make testc\n</code></pre> <p>Or better still:</p> <pre><code>$ make testc | more\n</code></pre> <p>so you can see the results without having to scroll back in your terminal. Hit the spacebar to page through the results.</p> <p>Note that most of the tests/examples described below are also in the test script.  However, the test script doesn't test everything (particularly in part C), so don't assume that your code is perfect if it passes the test script.</p>"},{"location":"assignments/5/ocaml_notes/#imperative-programming-and-arrays","title":"Imperative programming and arrays","text":"<p>Part A of this assignment requires you to write some code in an imperative style, and to work with OCaml's arrays. Here is a quick refresher on imperative syntax in OCaml; see recitation lecture 3 and lecture 12 for more details. Also check out this chapter in the OCaml manual as well as this chapter in Real World OCaml.</p> <p>Imperative \"variables\" are modeled in OCaml using \"reference cells\" or \"refs\" for short. We create these with the <code>ref</code> function:</p> <pre><code># ref 10 ;;\n- : int ref = {contents = 10}\n# let r = ref 42 ;;\nval r : int ref = {contents = 42}\n</code></pre> <p>A reference is just a record with one mutable field called <code>contents</code>. You can access this field's value in two ways:</p> <pre><code># r.contents ;;  (* dot syntax for accessing record fields *)\n- : int = 42\n# !r ;;          (* prefix operator ! *)\n- : int = 42\n</code></pre> <p>The second way (using the <code>!</code> operator) is much shorter and is greatly preferred.  They both do the exact same thing.</p> <p>You assign to a ref cell in one of two ways:</p> <pre><code># r.contents &lt;- 1001 ;;  (* dot syntax for mutating record fields *)\n- : unit = ()\n# r ;;\n- : int ref = {contents = 1001}\n# r := 2002 ;;           (* := operator *)\n- : unit = ()\n# r ;;\n- : int ref = {contents = 2002}\n# !r ;;\n- : int = 2002\n</code></pre> <p>Again, using the <code>:=</code> operator is shorter and is greatly preferred. And again, both ways do the same thing.</p> <p>Arrays are constructed using this notation:</p> <pre><code># [| 1; 2; 3; 4; 5 |] ;;\n- : int array = [|1; 2; 3; 4; 5|]\n</code></pre> <p>You can also use the <code>Array.make</code> function:</p> <pre><code># Array.make 5 \"foo\" ;;\n- : string array = [|\"foo\"; \"foo\"; \"foo\"; \"foo\"; \"foo\"|]\n</code></pre> <p>Array elements are fetched and changed using these syntaxes:</p> <pre><code># let arr = Array.make 5 0 ;;\nval arr : int array = [|0; 0; 0; 0; 0|]\n# arr.(0) ;;\n- : int = 0\n# arr.(0) &lt;- 42 ;;\n- : unit = ()\n# arr ;;\n- : int array = [|42; 0; 0; 0; 0|]\n</code></pre> <p>Note that arrays are always mutable, so any element in an array can be changed with the syntax given above.</p> <p>OCaml has imperative <code>while</code> and <code>for</code> loops. Examples:</p> <pre><code># let r = ref 10 ;;\nval r : int ref = {contents = 10}\n# while !r &gt; 0 do\n    Printf.printf \"%d\\n\" !r;\n    r := !r - 1\n  done ;;\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n- : unit = ()\n\n# for i = 1 to 10 do\n    Printf.printf \"%d\\n\" i\n  done ;;\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n- : unit = ()\n\n# for i = 10 downto 1 do\n  Printf.printf \"%d\\n\" i\n  done ;;\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n- : unit = ()\n</code></pre> <p>The Array module has a number of other useful functions on arrays (e.g. <code>Array.length</code>).</p> <p>That should be enough to get you through this assignment.</p>"},{"location":"assignments/5/partA_imperative/","title":"Part A: Imperative programming (20 points)","text":"<p>In this section, we are going to write a few functions using OCaml's imperative features.</p>"},{"location":"assignments/5/partA_imperative/#1-fibonacci-again","title":"1. Fibonacci again","text":"<p>[10 points]</p> <p>Write two imperative versions of the fibonacci function that takes a single <code>int</code> argument <code>n</code> and returns an <code>int</code> result, which is the <code>n</code>th fibonacci number. The first one should be called <code>fibonacci</code> and should use a <code>while</code> loop, while the second should be called <code>fibonacci2</code> and should use a <code>for</code> loop. Do not use recursion or any helper functions in either problem. The resulting functions should have \\(\\Theta(n)\\) worst-case asymptotic time complexity. The functions should store all data in reference cells (except for the argument <code>n</code> and loop indices in <code>fibonacci2</code>) and update them as necessary.</p> <p>Hint</p> <p>Write these functions basically the way you would write them in C or Python (modulo syntax, of course).</p>"},{"location":"assignments/5/partA_imperative/#2-bubble-sort","title":"2. Bubble sort","text":"<p>[10 points]</p> <p>In this problem, you will write a function called <code>bubble_sort</code> which implements an imperative sorting algorithm that works on arrays of values, sorting in-place in ascending order using the \"bubble sort\" algorithm. This function has the signature:</p> <pre><code>val bubble_sort : 'a array -&gt; unit\n</code></pre> <p>You may assume that the type <code>'a</code> is orderable i.e. that operators like <code>&lt;</code>, <code>=</code>, and <code>&gt;</code> work properly on values of that type.</p> <p>Again, do not use recursion or any helper functions in your function. Use <code>for</code> loops or <code>while</code> loops for looping.</p> <p>Imperative bubble sort works as follows. Go through the array, looking at consecutive pairs of elements. If you find one that is out of order (the second element is smaller than the first), swap the two elements in-place (you might want to use a temporary variable for this) and continue. Once you reach the end of the array, the last element of the array should be the largest. Start over and continue until all the elements are in the correct order. This algorithm has a time complexity of \\(\\Theta(n^2)\\).</p> <p>Here is a reference on bubble sort.</p> <p>You don't need to use any helper functions for this problem, and you shouldn't use any.</p> <p>Note that you can have an <code>if</code> expression without an <code>else</code> clause in OCaml as long as the type of the <code>then</code> clause is <code>unit</code> (see the ocaml_cheat_sheet.)</p>"},{"location":"assignments/5/partB_tagged_data/","title":"Part B: Tagged Data (30 points)","text":"<p>In this problem we will extend the tagged data representation of units that we explored in lecture 10.</p>"},{"location":"assignments/5/partB_tagged_data/#1-extending-get_meter","title":"1. Extending <code>get_meter</code>","text":"<p>[10 points]</p> <p>Recall the code we ended up with at the end of lecture 10:</p> <pre><code>let meters_per_foot = 0.3048\n\nlet get_meters len =\n  match len with\n    | `Meter m -&gt; m\n    | `Foot f -&gt; f *. meters_per_foot\n\nlet length_add a b = `Meter (get_meters a +. get_meters b)\n</code></pre> <p>This code is nice in that it makes it easy to add new unit types without modifying a lot of code. Show that this is right by modifying the code to work with inches (where a length in inches will be represented by the tag <code>`Inch</code> e.g. <code>`Inch 2.3</code>. You should only have to add a single line to one of the functions above. Hint: There are 12 inches in a foot. </p>"},{"location":"assignments/5/partB_tagged_data/#2-mass-and-time-abstractions","title":"2. Mass and time abstractions","text":"<p>[10 points]</p> <p>By analogy with the length abstraction given above, create a mass abstraction using tagged data. Mass units you should handle include grams, kilograms, and slugs (using the variant tags <code>`Gram</code>, <code>`Kilo</code>, and <code>`Slug`</code>, respectively). Note that a slug is 14593.903203 grams. Write a function called <code>get_grams</code> which returns the gram equivalent of any mass value as a float. Use this to write a function called <code>mass_add</code> which will add together any two kinds of masses.</p> <p>Repeat this process by defining a time abstraction using tagged data. Time units you should handle include seconds, minutes, hours, and days (using the variant tags <code>`Second</code>, <code>`Minute</code>, <code>`Hour</code>, and <code>`Day</code>, respectively). Write a function called <code>get_seconds</code> which returns the seconds equivalent of any time value as a float. (You can look up the conversion factors if you don't know them.) Use this to write a function called <code>time_add</code> which will add together any two kinds of times.</p>"},{"location":"assignments/5/partB_tagged_data/#3-adding-units","title":"3. Adding units","text":"<p>[10 points]</p> <p>Now that we have length, mass, and time abstractions, we can deepen the abstraction hierarchy and write a generic <code>unit_add</code> function which will take any two tagged data values and add them if they are compatible or signal an error (using the <code>failwith</code> function) if not.  For this, assume that every tagged data value is tagged not just with its unit tag but with a unit \"class\" tag. So a length unit wouldn't be just <code>`Meter 1.0`</code> but <code>`Length (`Meter 1.0)</code>, and similarly for other united data values. The unit class variant tags are: <code>`Length</code>, <code>`Mass</code>, and <code>`Time</code>.</p> <p>Do we get into a combinatorial explosion when adding more unit classes, at least as far as unit addition is concerned? Why or why not? Write your answer in an OCaml comment.</p>"},{"location":"assignments/5/partC_objects/","title":"Part C: Objects (50 points)","text":""},{"location":"assignments/5/partC_objects/#1-object-oriented-grams","title":"1. Object-oriented grams","text":"<p>[20 points]</p> <p>Give an object-oriented implementation of a gram unit which supports the following methods:</p> <ul> <li> <p><code>get_grams</code>: Returns a number (OCaml float) representing the mass in grams.</p> </li> <li> <p><code>get_slugs</code>: Returns a number (OCaml float) representing the mass in slugs. Note that a slug is roughly equal to 14593.903203 grams.</p> </li> <li> <p><code>unit_type</code>: Returns <code>`Gram</code>.</p> </li> <li> <p><code>compatible</code>: Returns <code>true</code> when given anything which the <code>add</code> method of the gram object supports (i.e. a gram or a slug); here is an example:</p> <pre><code>(* NOTE: You do not have to define make_slug or make_foot.\n   This is an example to show how it should work. *)\n\nlet agram = make_gram 1.0\nlet bslug = make_slug 1.0\nlet cfoot = make_foot 1.0\n\nagram#compatible agram  (* true *)\nagram#compatible bslug  (* true *)\nagram#compatible cfoot  (* false *)\n</code></pre> <p>Hint</p> <p>You can assume that both <code>make_slug</code> and <code>make_foot</code> return objects that have the <code>unit_type</code> method.</p> </li> <li> <p><code>add</code>: Adds a compatible mass, returning another mass object. Here's an example:</p> <pre><code>let agram = make_gram 1.0\nlet bslug = make_slug 1.0  (* similarly, you do not have to define make_slug *)\nlet cgram = agram#add bslug\ncgram#get_grams  (* 14594.9 (grams) *)\n</code></pre> <p>An incompatible object passed in as an argument should cause an error to be signalled using the <code>failwith</code> function.</p> </li> </ul> <p>Here is a template for your code:</p> <pre><code>let rec make_gram g =\n  let\n    ... (* internal definitions *)\n  in\n    object\n      method get_grams = ...\n      method get_slugs = ...\n      method unit_type = ...\n      method compatible other = ...\n      method add other = ...\n    end\n</code></pre> <p>Fill in the parts marked <code>...</code>. This requires less than 20 lines of code.</p> <p>Warning</p> <p>Don't use a <code>self</code> reference i.e.</p> <pre><code>object (self)\n  ...\nend\n</code></pre> <p>This isn't necessary and (unfortunately) changes the type signature to something that isn't compatible with the type signature in the <code>.mli</code> file.</p> <p>You can do this without repeating code, and you should. Put the repeated parts into the \"internal definitions\" section.</p>"},{"location":"assignments/5/partC_objects/#2-object-oriented-differentiator","title":"2. Object-oriented differentiator","text":"<p>[30 points]</p> <p>In this problem, we will consider an object-oriented implementation of the differentiator from assignment 4. In addition to taking the derivative, it will be possible to convert an expression to a string and evaluate an expression. For evaluation, we will provide a value for a variable and compute the expression (or number) that results from substituting in the number for the value (much like evaluation in the substitution model, except that we will only be giving a value to one variable at a time, so we must be able to handle symbolic expressions involving the variables which have not been given values).</p> <p>Each expression will be an OCaml object which responds to the following methods:</p> <ul> <li> <p><code>value</code>: Return the value of an expression as an OCaml <code>int</code> (only valid for expressions which represent numbers; anything else should signal an error).</p> </li> <li> <p><code>show</code>: Return a representation of the expression as a string. Operator expressions should be wrapped in parentheses so we don't have to worry about precedence.</p> </li> <li> <p><code>is_zero</code>: Return <code>true</code> if the expression is an object that represents the number 0.</p> </li> <li> <p><code>is_number</code>: Return <code>true</code> if the expression is an object that represents a number.</p> </li> <li> <p><code>derive</code>: Return the derivative of the expression with respect to the given variable. This derivative will be an OCaml object, just like the original expression was.</p> </li> <li> <p><code>evaluate</code>: Evaluate the expression for a given variable and value. Note that this will not necessarily be the most simplified version of that expression, but it must be correct.</p> </li> </ul> <p>Examples</p> <pre><code>(* g represents 5*x + x*y + 7*y *)\n# let g =\n  make_sum\n    (make_product\n      (make_number 5)\n      (make_variable \"x\"))\n    (make_sum\n      (make_product\n        (make_variable \"x\")\n        (make_variable \"y\"))\n      (make_product\n        (make_number 7)\n        (make_variable \"y\"))) ;;\nval g :\n  &lt; derive : string -&gt; 'a; evaluate : string -&gt; int -&gt; 'a; is_number :\n    bool; is_zero : bool; show : string; value : int &gt;\n  as 'a = &lt;obj&gt;\n\n# g#show ;;\n- : string = \"((5 * x) + ((x * y) + (7 * y)))\"\n(* Note that these results are not maximally simplified. *)\n\n# (g#evaluate \"x\" 2)#show ;;\n- : string = \"(10 + ((2 * y) + (7 * y)))\"\n\n# (g#evaluate \"y\" 3)#show ;;\n- : string = \"((5 * x) + ((x * 3) + 21))\"\n\n# ((g#evaluate \"x\" 2)#evaluate \"y\" 3)#show ;;\n- : string = \"37\"\n\n# (g#derive \"x\")#show ;;\n- : string = \"(5 + y)\"\n\n# (g#derive \"y\")#show ;;\n- : string = \"(x + 7)\"\n\n# (g#derive \"z\")#show ;;\n- : string = \"0\"\n\n# (((g#derive \"x\")#evaluate \"x\" 2)#evaluate \"y\" 3)#show ;;\n- : string = \"8\"\n</code></pre> <p>Here is the starting code base for the problem:</p> <pre><code>(* Define a number as a message-passing object. *)\n(* \"i\" is an int. *)\nlet rec make_number i =\n  object\n    method value = i\n    method show = string_of_int i\n    method is_zero = i = 0\n    method is_number = true\n    method evaluate _ _ = make_number i  (* must evaluate to an object *)\n    method derive _ = make_number 0  (* derivative of a number is 0 *)\n  end\n\n(* Define a variable as a message-passing object. *)\n(* \"v\" is a string. *)\nlet rec make_variable v =\n  object\n    method value = failwith \"variable has no numerical value\"\n    method show  = v\n    method is_zero = false\n    method is_number = false\n    method evaluate v' n =\n      if v = v'\n        then make_number n\n        else make_variable v\n    method derive v' =\n      if v = v'\n        then make_number 1  (* d/dx(x) = 1 *)\n        else make_number 0  (* d/dx(y) = 0 *)\n  end\n\n(* Define a sum as a message-passing object. *)\nlet rec make_sum expr1 expr2 =\n  match () with\n    | _ when expr1#is_zero -&gt; expr2  (* 0 + expr = expr *)\n    | _ when expr2#is_zero -&gt; expr1  (* expr + 0 = expr *)\n    | _ when expr1#is_number &amp;&amp; expr2#is_number -&gt;  (* add numbers *)\n          make_number (expr1#value + expr2#value)\n    | _ -&gt;  (* create a new object representing the sum *)\n          object\n            method value = failwith \"sum expression has no numerical value\"\n            method show = \"(\" ^ expr1#show ^ \" + \" ^ expr2#show ^ \")\"\n            method is_zero = false\n            method is_number = false\n            method evaluate v n =\n              make_sum (expr1#evaluate v n) (expr2#evaluate v n)\n            method derive v =\n              make_sum (expr1#derive v) (expr2#derive v)\n          end\n\n(* Evaluate a message-passing expression with a number\n   substituted for a variable. *)\nlet evaluate expr v n = expr#evaluate v n\n\n(* Return the string representation of an expression. *)\nlet show expr = expr#show\n\n(* Return the derivative of an expression. *)\nlet differentiate expr v = expr#derive v\n</code></pre> <p>You will be extending this in various ways.</p>"},{"location":"assignments/5/partC_objects/#a-make_product","title":"a. <code>make_product</code>","text":"<p>Write a function called <code>make_product</code> to create objects representing product expressions (one expression multiplied by another) in a manner analogous to <code>make_sum</code>. It should return an object representing a number when possible (i.e. when all the argument expressions given are numbers). Multiplication by the number zero should be reduced to the number zero, and multiplication of a term by 1 should return the term. You can use the <code>make_sum</code> function above as a skeleton to build your solution around, but be careful to notice the differences between sums and products (for one thing, there are more base cases with products). Note that the derivative of a product of two expressions can be computed with the following rule:</p> \\[ \\frac{d}{dx} (f(x) \\times g(x)) = \\frac{df(x)}{dx} \\times g(x) + f(x) \\times \\frac{dg(x)}{dx} \\] <p>where the derivatives are all with respect to \\(x\\).</p> <p>This function can be written in less than 30 lines.</p> <p>Note</p> <p>Make sure that the return value of <code>make_product</code> is always a message-passing object, even if it's just a wrapper around a number. If not, you may get extremely confusing type errors.</p>"},{"location":"assignments/5/partC_objects/#b-testing-the-differentiator","title":"b. Testing the differentiator","text":"<p>Demonstrate that your operations work by evaluating the following expressions in the interactive OCaml interpreter and writing down your results in OCaml comments.</p>"},{"location":"assignments/5/partC_objects/#i","title":"i.","text":"<pre><code>(* f = x^3*y + 3*x^2*y^2 + y^2 + 2 *)\n# let f =\n    make_sum\n     (make_product\n      (make_variable \"x\")\n      (make_product\n       (make_variable \"x\")\n       (make_product\n        (make_variable \"x\")\n        (make_variable \"y\"))))\n     (make_sum\n      (make_product\n       (make_number 3)\n       (make_product\n        (make_variable \"x\")\n        (make_product\n         (make_variable \"x\")\n         (make_product\n          (make_variable \"y\")\n          (make_variable \"y\")))))\n      (make_sum\n       (make_product\n        (make_variable \"y\")\n        (make_variable \"y\"))\n       (make_number 2))) ;;\n</code></pre>"},{"location":"assignments/5/partC_objects/#ii","title":"ii.","text":"<pre><code># let dfdx = differentiate f \"x\" ;;\n</code></pre>"},{"location":"assignments/5/partC_objects/#iii","title":"iii.","text":"<pre><code># show dfdx ;;\n</code></pre>"},{"location":"assignments/5/partC_objects/#iv","title":"iv.","text":"<pre><code># show (evaluate f \"x\" 3) ;;\n</code></pre>"},{"location":"assignments/5/partC_objects/#v","title":"v.","text":"<pre><code># show (evaluate (evaluate f \"x\" 3) \"y\" 4) ;;\n</code></pre>"},{"location":"assignments/5/partC_objects/#vi","title":"vi.","text":"<pre><code># show (evaluate (evaluate dfdx \"x\" 3) \"y\" 4) ;;\n</code></pre> <p>Hint</p> <p>You probably want to test your functions on some simpler expressions first. Here are some examples. You do not have to submit the results of using your functions on these values.</p> <pre><code>let n0  = make_number 0\nlet n1  = make_number 1\nlet n2  = make_number 2\nlet x   = make_variable \"x\"\nlet s1  = make_sum n1 n2\nlet s2  = make_sum n1 n0\nlet s3  = make_sum x n1\nlet s4  = make_sum (make_variable \"y\") (make_number 4)\nlet p1  = make_product n2 n2\nlet p2  = make_product x n0\nlet p3  = make_product x n2\nlet p4  = make_product x s1\nlet sl1 = make_sum p3 (make_sum p4 s3)\nlet p5  = make_product n2 p4\nlet p6  = make_product x s3\nlet ap1 = make_sum p3 p4\nlet pa1 = make_product s3 s4\nlet pl1 = make_product s2 (make_product s4 sl1)\n</code></pre>"},{"location":"assignments/6/assignment6/","title":"Assignment 6: Environmentally-friendly","text":""},{"location":"assignments/6/assignment6/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, March 1st, at 2 AM.</p>"},{"location":"assignments/6/assignment6/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 16, as well as all the material in the recitation lectures.</p>"},{"location":"assignments/6/assignment6/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab6.ml</code>. This file should be submitted to CodePost as <code>Assignment 6</code>. Do not submit any other files.</p>"},{"location":"assignments/6/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/6/ocaml_notes/#testing","title":"Testing","text":"<p>For this assignment, we are supplying you with these support files:</p> <ul> <li>a <code>.mli</code> OCaml interface file (<code>lab6.mli</code>)</li> <li>a test script: (<code>tests_lab6.ml</code>)</li> <li>a <code>Makefile</code></li> </ul> <p>These files are all available on the course Canvas site in a single zip file called <code>lab6.zip</code>. Download this file and use it as you've been doing with previous assignments.</p>"},{"location":"assignments/6/ocaml_notes/#environment-descriptions","title":"Environment descriptions","text":"<p>There is a problem in part A that requires you to write a textual description of the environments generated by evaluating some code using the environment model described in lectures 13 and 14. We'll describe this process here.</p> <p>Consider the following OCaml code:</p> <pre><code>let square x = x * x in square 100\n</code></pre> <p>We would like to evaluate this using the environment model, and in the process describe the environments created during its evaluation. This was done in lectures 13 and 14 using diagrams, but note that you can do the same thing using the following text description:</p> <pre><code>(*\n  -- Desugar expression to:\n\n  let square = fun x -&gt; x * x in square 100\n\n  -- Start with initial environment:\n\n  FRAME 0 (initial environment)\n    parent: none\n    bindings:\n      * : [primitive function *]\n\n  -- Evaluate the let expression:\n  --   Evaluate the fun expression:\n\n  FUNCTION 0 (fun x -&gt; x * x)\n    env: FRAME 0    (* the environment the function was defined in\n                       (the \"enclosing environment\") *)\n    param: x\n    body: x * x\n\n  --   Create a new frame with the name \"square\" bound to the function object:\n\n  FRAME 1 (let square = FUNCTION 0 in ...)\n    parent: FRAME 0\n    bindings:\n      square : FUNCTION 0\n\n  --   Evaluate the expression \"square 100\" in the context of FRAME 1:\n  --     100 evaluates to itself\n  --     Look up \"square\" --&gt; FUNCTION 0\n  --     Apply FUNCTION 0 to 100:\n  --       Create a new frame, binding the formal parameter of the \"square\"\n  --         function:\n\n  FRAME 2  (FUNCTION 0 applied to 100)\n    parent: FRAME 0\n    bindings:\n      x : 100\n\n  -- Note that FRAME 2's parent is FRAME 0 because FUNCTION 0's enclosing\n  -- environment is FRAME 0.\n\n  --       Evaluate \"x * x\" in the context of FRAME 2:\n  --         Look up x: 100  (from FRAME 2)\n  --         Look up *: [primitive function *]  (from FRAME 0 via FRAME 2)\n  --         Apply * to 100, 100 --&gt; 10000\n  --         RESULT: 10000\n*)\n</code></pre> <p>The environment description then would consist of all frames and functions created during this evaluation:</p> <pre><code>(*\n  FRAME 0 (initial environment)\n    parent: none\n    bindings:\n      * : [primitive function *]\n\n  FUNCTION 0 (fun x -&gt; x * x)\n    env: FRAME 0\n    param: x\n    body: x * x\n\n  FRAME 1 (let square = FUNCTION 0 in ...)\n    parent: FRAME 0\n    bindings:\n      square : FUNCTION 0\n\n  FRAME 2  (FUNCTION 0 applied to 100)\n    parent: FRAME 0\n    bindings:\n      x : 100\n*)\n</code></pre> <p>This is the kind of description we want you to produce. You don't have to describe the evaluation process step-by-step, but you need to be able to do it in your head (or on paper), or you won't get the right frame/function contents. Pay particular attention to parents of frames; it's extremely easy to get those wrong.</p> <p>Tip</p> <p>Remember: applying a function to its arguments creates a new frame whose parent frame is the same as the <code>env</code> (enclosing environment i.e. the environment in which the function was defined) of the function being applied.</p> <p>Note that primitive functions don't create frames when applied. Also, only put the primitive functions used in the evaluation into the initial environment (even though in reality there would be dozens more).</p> <p>Working through problems like this will very rapidly clarify your understanding of the environment model.</p>"},{"location":"assignments/6/ocaml_notes/#more-on-objects","title":"More on objects","text":"<p>Part B requires that you use a couple of features of OCaml's object system that haven't been needed so far: self references and private methods. They are described here. Self-references were also described in class, as they interact with the environment model (technically, they enable what is called open recursion).</p> <p>In addition, we will use actual OCaml classes for problem B.2. Classes were discussed in lecture 11.</p>"},{"location":"assignments/6/ocaml_notes/#self-references","title":"Self references","text":"<p>One common thing to want to do in any object-oriented language is to be able to call methods in an object from other methods. Typically there is a dedicated keyword for \"the current object\" (usually <code>self</code> or <code>this</code>), but OCaml has a more flexible solution. If you need to identify the current object, you just put its name in parentheses after the keyword <code>object</code>. So instead of writing:</p> <pre><code>object\n  (* method definitions *)\nend\n</code></pre> <p>you write:</p> <pre><code>object (self)\n  (* method definitions *)\nend\n</code></pre> <p>and then you can call methods in the object from within other methods in the same object using the syntax <code>self#foo</code> for a method <code>foo</code>. Note that you don't have to use the word <code>self</code>; you can write:</p> <pre><code>object (this)\n  (* method definitions *)\nend\n</code></pre> <p>if you prefer, or even:</p> <pre><code>object (fnordly)\n  (* method definitions *)\nend\n</code></pre> <p>(but if you do the latter, you will annoy your grader!). We would like you to stick with <code>self</code>, because it's what everyone else does.</p> <p>Also, note that this syntax works even inside a class definition:</p> <pre><code>class foo =\n  object (self)\n    (* method definitions *)\n  end\n</code></pre>"},{"location":"assignments/6/ocaml_notes/#private-methods","title":"Private methods","text":"<p>This feature of OCaml's OO system wasn't described in the lectures.</p> <p>It's quite common when defining objects to want some methods to be restricted to the object implementation itself. Self-references allow the calling of one method in an object from another, but to have private methods requires that the method definition be marked <code>private</code>. So instead of this:</p> <pre><code>method foo = ...\n</code></pre> <p>you would write:</p> <pre><code>method private foo = ...\n</code></pre> <p>When this is done, the method <code>foo</code> can only be called by other methods in the same object (or objects of the same class, if you are using classes).</p> <p>Note</p> <p>If inheritance is used, a private method can also be called by subclasses, but we haven't covered inheritance.</p>"},{"location":"assignments/6/ocaml_notes/#modules-and-functors","title":"Modules and functors","text":"<p>The most common use of modules is implicit: whenever you write code in a <code>.ml</code> file, that file becomes a module (much like in Python). For each <code>.ml</code> file, you typically have a <code>.mli</code> file giving the module's interface (which includes type signatures for all exported values and functions, <code>type</code> declarations for all exported types, and <code>exception</code> declarations for all exported exceptions defined in the module). As you know, not all functions defined in a <code>.ml</code> file need to be exported; functions that are only used internally won't have their signature specified in the <code>.mli</code> file. Similarly, you do not have to specify the implementation of a type in the <code>.mli</code> file, and often it is better to leave it out (which makes the type abstract, meaning that only the functions in the <code>.ml</code> file have access to its internal structure).</p> <p>In addition, you can also declare new modules inside of a <code>.ml</code> file. These are effectively \"modules within modules\", and they can be exported (specified in the <code>.mli</code> file) or not. The main reason for doing this is when we generate the modules using functors. A functor (as we discussed in recitation 4) is a kind of \"function on modules\" (not a real OCaml function, but conceptually like a function) by which we mean a way to take an existing module and create a new module which uses the existing one. Functor arguments are specified using a <code>module type</code>, which is a specification of a particular module (we'll see examples below). A very common use case for functors is to create a data structure from another data structure. For instance, the input module may represent the concrete type of a component of the data structure plus some functions on it (for instance, a function to compare values of that type for orderable types). The functor will take that input module and use it to create a new module representing a data structure containing that type.</p> <p>All this may seem a bit abstract, so let's look at an example of functors. Sets are defined in OCaml in the <code>Set</code> module, which defines a functor called <code>Set.Make</code>. This takes as its module argument a module of module type <code>Ordered_type</code> which has this signature:</p> <pre><code>module type Ordered_type =\n  sig\n    type t\n    val compare : t -&gt; t -&gt; int\n  end\n</code></pre> <p>This signature (<code>sig</code> form in OCaml) says that an ordered type is a type <code>t</code> which also has a comparison function called <code>compare</code> which takes two values of type <code>t</code> and returns an <code>int</code>: <code>0</code> if the two are \"equal\", <code>-1</code> if the first is smaller than the second, and <code>1</code> if the first is larger than the second.</p> <p>Note</p> <p>In part C, we define our own module type called <code>ORDERED_TYPE</code> which is exactly like the <code>Ordered_type</code> module type, because we want to do everything from scratch to show how it's done.</p> <p>To create a module that matches this signature, we use the <code>struct</code> form (no relation to <code>struct</code>s in C/C++!). Here's an example:</p> <pre><code>module OrderedString : Ordered_type =\n  struct\n    type t = string\n    let compare s1 s2 = Stdlib.compare s1 s2\n      (* or just: let compare = Stdlib.compare *)\n  end\n</code></pre> <p>This creates an <code>OrderedString</code> module which contains the <code>string</code> type and a function for string comparison. The <code>compare</code> function just dispatches to the OCaml built-in <code>compare</code> function, which is more specifically called <code>Stdlib.compare</code>; the <code>Stdlib</code> module is where all the built-in functions live.</p> <p>Given this, we can create a set of strings using the <code>Set.Make</code> functor as follows:</p> <pre><code>module StringSet = Set.Make(OrderedString)\n</code></pre> <p>and now we can make sets of strings! The documentation on the kind of sets made by this functor is available here. Here are some examples:</p> <pre><code># let empty = StringSet.empty;;\nval empty : StringSet.t = &lt;abstr&gt;\n# let s1 = StringSet.add \"foo\" empty;;\nval s1 : StringSet.t = &lt;abstr&gt;\n# let s2 = StringSet.add \"bar\" s1;;\nval s2 : StringSet.t = &lt;abstr&gt;\n# StringSet.mem \"foo\" s2;;\n- : bool = true\n# StringSet.mem \"bar\" s2;;\n- : bool = true\n# StringSet.mem \"baz\" s2;;\n- : bool = false\n</code></pre> <p>Notice that the set type <code>StringSet.t</code> is abstract, which means that once the set has been constructed you can only access it using functions defined in the module. Creating a set of <code>int</code>s would be very similar: you would define an <code>OrderedInt</code> module and pass it to the <code>Set.Make</code> functor to generate an <code>IntSet</code> module.</p> <p>Note that these sets are functional. You cannot change the contents of an existing set; you have to create a new one with more or fewer elements. Because of the way that sets are implemented, this can be done quite efficiently.</p> <p>Note</p> <p>To those of you who have worked with Java's generics or C++'s templates, this might seem like a very complicated way to generate sets. Why not just make the set module polymorphic on the set element type? The problem with this is that the element type is not enough; we also (at least!) have to specify an equality function between values of that type (so you can check if a value is in the set or not), and for efficient functional sets, you need the element type to be orderable (so you can implement sets using e.g. self-balancing tree types, which require orderable elements).  That's why the <code>Set.Make</code> functor requires a module argument which contains not just a type but a function which compares two values of that type for ordering. In fact, functors are very flexible; the input module (or modules) can have more than one type, as well as functions which use all the types. That's why functors have been characterized as being \"like C++ templates on steroids\".</p> <p>Also, note that modules are not like objects! In particular, a module doesn't store any data. Instead, functions in modules can return values of particular types (like sets) which do store data. Since these types are usually abstract, you can't do anything with that data except pass it to other functions in the module, some of which generally are able to extract components of the data. Thus, modules can do the same kinds of things that objects do, but they do it in a different way.</p> <p>Using functors is kind of like riding a bike; at first they seem intimidatingly abstract and weird, but eventually you come to realize that they are just a fairly simple mechanism for splitting up the definition of a module into various reusable parts. Functors are actually one of the great things about OCaml, and it's a shame other programming languages (other than close relatives of OCaml like Standard ML) don't have anything similar.</p> <p>Note</p> <p>There is a related feature in OCaml called first-class modules which is even more flexible than functors in many cases.</p>"},{"location":"assignments/6/partA_environment_model/","title":"Part A: The environment model (30 points)","text":"<p>In this section, we will explore the environment model described in lectures 13 and 14.</p>"},{"location":"assignments/6/partA_environment_model/#1-factorial","title":"1. <code>factorial</code>","text":"<p>[20 points]</p> <p>(Adapted from SICP, problem 3.9.)</p> <p>Consider this code:</p> <pre><code>let factorial n =\n  let rec iter m r =\n    if m = 0\n      then r\n      else iter (m - 1) (r * m)\n  in iter n 1\nin\n  factorial 3\n</code></pre> <p>Write a textual description of the environment (all frames and functions) created while evaluating this code according to the environment model. See the \"OCaml notes\" section for guidelines on how this is to be done.</p> <p>Note</p> <p>This is a text-based description only! Write your answer as an OCaml comment.</p> <p>To give you a head start, here is the initial environment:</p> <pre><code>(*\n\n  FRAME 0 (initial environment)\n    parent: none\n    bindings:\n      - : [primitive function -]\n      * : [primitive function *]\n\n*)\n</code></pre> <p>Note that you do not have to write out a detailed evaluation of the code (though you can if you want), just write out the frames and functions generated in its evaluation. Please indicate which code created each frame/function in parentheses beside the FRAME/FUNCTION name and number. You can use ellipses (<code>...</code>) if the code is too long to comfortably fit on the line. You can also refer to previously-defined functions as e.g. <code>FUNCTION 0</code> instead of copying the code; see the \"OCaml notes\" section for examples.</p> <p>Note also that you don't have to desugar functions of multiple arguments into their curried version (e.g. <code>fun x y -&gt; ...</code> to <code>fun x -&gt; fun y -&gt; ...</code>). Similarly, when applying a multi-argument function to its arguments you can create a single frame with bindings for all function arguments.</p> <p>When writing out function descriptions, include the enclosing environment (<code>env</code>, or <code>none</code> if it's the initial enviroment), the formal parameter(s) (<code>params</code>) and the body of the function (<code>body</code>). If the body is too long to fit on the line, use ellipses (<code>...</code>) to shorten it.</p> <p>Other notes:</p> <ul> <li> <p>There are exactly two functions and eight frames in the final solution (including FRAME 0 shown above). Include all temporary frames.</p> </li> <li> <p>Make sure to desugar function definitions to their corresponding <code>fun</code> forms. Other than that, don't desugar <code>let</code> expressions to <code>fun</code> expressions. Especially don't do this with <code>let rec</code> expressions, because it isn't valid!</p> </li> <li> <p>The final result should be 6.  You don't have to write this out, though.</p> </li> </ul>"},{"location":"assignments/6/partA_environment_model/#2-recursion-using-ref-cells","title":"2. Recursion using <code>ref</code> cells","text":"<p>[10 points]</p> <p>Ben Bitfiddle doesn't like environment model rule 4, which says how to evaluate a <code>let rec</code> expression. \"It's too complicated!\" he says. \"I can achieve the exact same thing using <code>let</code> and <code>ref</code> cells.\" He points out a typical piece of OCaml code:</p> <pre><code>let rec factorial n =\n  if n = 0 then 1 else n * factorial (n - 1)\n</code></pre> <p>Then he starts to redo it his way to eliminate the <code>let rec</code>:</p> <pre><code>let factorial =\n  let f = ref (fun _ -&gt; 0) in\n    (* to be completed *)\n</code></pre> <p>Complete Ben's code to make a working <code>factorial</code> function without using <code>let rec</code>. You only have to add a few more lines.</p> <p>Hint</p> <p>Consider the original factorial function where the recursive call is replaced by something else. This is actually similar to the way we described how <code>let rec</code> works in the environment model, with the ref cell initially holding the dummy value.</p> <p>The value <code>fun _ -&gt; 0</code> is there so that the code type checks; that function will never be applied.</p> <p>Restrictions: you may not use <code>for</code> or <code>while</code> loops or any imperative features other than references (<code>ref</code> and the <code>:=</code> and <code>!</code> operators) and you must use the <code>f</code> reference.</p> <p>The solution is only a few lines long.</p>"},{"location":"assignments/6/partB_imperative_objects/","title":"Part B: Imperative objects and classes (20 points)","text":"<p>In this section we'll work with objects that also maintain mutable state i.e. imperative objects. We will also see how to use classes to achieve the same thing.</p> <p>The mean, variance, and standard deviation are three useful statistical values often computed over a set of numeric data. (If you don't know what these terms refer to, look them up in Wikipedia.) We will be using the \"population variance\" and \"population standard deviation\" in what follows (as opposed to \"sample variance\" and \"sample standard deviation\"); in other words, divide by <code>n</code> instead of by <code>n - 1</code> in the denominators of the variance and standard deviation, where <code>n</code> is the number of data values.</p> <p>Often, when collecting data, we receive it one element at a time instead of all at once. It might, then, be useful to be able to determine the mean, variance, and standard deviation \"on-the-fly\" as we add new values to the object.</p> <p>Your job in this section is to create statistics objects to provide this functionality. You will explore OCaml's object-oriented programming features by writing variants of the statistics object. This will also give you experience with using object-oriented programming in conjunction with mutation, which is a very common programming scenario. (In fact, it could be argued that one of the main purposes of object-oriented programming is to make mutation more manageable.)</p> <p>Your statistics objects should adhere to the following interface:</p> <ul> <li> <p>You should provide a method called <code>append</code> to insert an additional data value into the object. This method takes a single argument (the new data value, which must be a <code>float</code>). It updates the internal state variables (see below) to their new values.</p> </li> <li> <p>You should provide methods to obtain the current mean, variance, and standard deviation of the numbers previously appended to the object: <code>mean</code>, <code>variance</code>, and <code>stdev</code> respectively. Calling these methods on a statistics object to which no data has been appended should result in a <code>Stat_error</code> exception being raised with an error message (you will have to define <code>Stat_error</code> as a new exception type yourself). These methods take no arguments.</p> </li> <li> <p>You should have a <code>clear</code> method which resets all state variables to their original values. This method takes no arguments.</p> </li> </ul> <p>Use the following equations to compute the mean, variance, and standard deviation given the sum, sum of squares, and number of items \\(n\\):</p> \\[ \\begin{aligned} mean &amp;= \\frac{sum}{n} \\\\ variance &amp;= \\frac{(sum\\ of\\ squares) - \\frac{sum^2}{n}}{n} \\\\ standard\\ deviation &amp;= \\sqrt{variance} \\\\ \\end{aligned} \\] <p>Note</p> <p>A key aspect of designing an object is knowing where to put the state variable(s). In this case, use <code>let</code> expressions outside of the <code>object</code> expression to store the state variables. The environment model will show you why this works. Putting the <code>let</code> inside the <code>object</code> will not work (it's a syntax error). However, see below for a discussion on <code>val mutable</code> which allows you to get the same effect as an external <code>let</code> but inside an object.</p> <p>You should have the following state variables:</p> <ul> <li><code>sum</code>: the sum of all the appended values</li> <li><code>sumsq</code>: the sum of the squares of all the appended values</li> <li><code>n</code>: the number of values that have been appended</li> </ul> <p>All state variables are initially zero. <code>sum</code> and <code>sumsq</code> are references to <code>float</code>s; <code>n</code> is a reference to an <code>int</code>. All of these are reference cells because they need to be updated as new data comes in. (It would also be possible to use a record with mutable fields, but don't do that.)</p> <p>Note that there will not be a state variable to hold all the data values that have been added to the list. This would be extremely costly in terms of space usage, and wouldn't help us to compute any of the statistics we want. Therefore, when a new value is \"appended\" to the object, all that happens is that the state variables are updated as needed; the actual data value itself is not stored.</p> <p>Note</p> <p>Do not write any helper functions for your statistics objects. This may seem counterproductive, but there is a larger point we are trying to make. This means that there will be some unavoidably duplicated code in the different object implementations.</p>"},{"location":"assignments/6/partB_imperative_objects/#1-using-plain-objects","title":"1. Using plain objects","text":"<p>[10 points]</p>"},{"location":"assignments/6/partB_imperative_objects/#a-make_stat_1","title":"a. <code>make_stat_1</code>","text":"<p>The first statistics object will be created by a call to the constructor function <code>make_stat_1</code>. This function will take a single argument of type <code>unit</code> and return an object which supports all the methods described above. This object will initially have no data.</p> <p>In this function, we don't want you to use a <code>self</code> reference in the object or private methods. This will mean that you will have to duplicate some code in some of the methods.</p> <p>Here are some example interactions with one of these statistics objects.</p> <pre><code># let mystat = make_stat_1 ();;\nval mystat :\n  &lt; append : float -&gt; unit; clear : unit; mean : float; stdev : float;\n    variance : float &gt; =\n  &lt;obj&gt;\n# mystat#mean;;\nException: Stat_error \"need at least one value for mean\".\n# mystat#variance;;\nException: Stat_error \"need at least one value for variance\".\n# mystat#stdev;;\nException: Stat_error \"need at least one value for stdev\".\n# mystat#append 1.0;;\n- : unit = ()\n# mystat#append 2.0;;\n- : unit = ()\n# mystat#append 3.0;;\n- : unit = ()\n# mystat#mean;;\n- : float = 2.\n# mystat#append 4.0;;\n- : unit = ()\n# mystat#variance;;\n- : float = 1.25\n# mystat#stdev;;\n- : float = 1.1180339887498949\n# mystat#clear;;\n- : unit = ()\n# mystat#append 1.0;;\n- : unit = ()\n# mystat#mean;;\n- : float = 1.\n# mystat#variance;;\n- : float = 0.\n# mystat#stdev;;\n- : float = 0.\n</code></pre>"},{"location":"assignments/6/partB_imperative_objects/#b-make_stat_2","title":"b. <code>make_stat_2</code>","text":"<p>Now write a different constructor function called <code>make_stat_2</code>. In this function, we will improve the code in <code>make_stat_1</code>, though the examples given above will still work and will give the same results.</p> <p>Most of this code will be identical to that in <code>make_stat_1</code>. We want you to make the following changes:</p> <ul> <li> <p>Aside from error handling and a single call to <code>sqrt</code>, the code in the <code>variance</code> and <code>stdev</code> methods is almost identical. Factor out the similar differences into a method called <code>_variance</code> that computes the variance assuming that there has been at least one number appended to the stats object (in other words, <code>_variance</code> will not do any error checking). Add a <code>self</code> reference to the <code>object</code> form (see the OCaml notes section of this assignment for details on this) and call the <code>_variance</code> method from both the <code>stdev</code> and <code>variance</code> methods to compute the variance where needed.</p> </li> <li> <p>Since the <code>_variance</code> method is not part of the object's interface, make it a <code>private</code> method.</p> </li> </ul>"},{"location":"assignments/6/partB_imperative_objects/#2-using-classes","title":"2. Using classes","text":"<p>[10 points]</p> <p>Since we are probably going to create multiple instances of our statistics objects, it's natural to define a class instead of a function which returns a new object. As an added bonus, the types of our statistics objects will be less complicated.</p> <p>Note</p> <p>An additional bonus is that we have the option to use class inheritance, but we won't need that here.</p> <p>Start with a copy of your <code>make_stat_2</code> function. Modify the outer part of this function to make it into a class declaration. It will look like this:</p> <pre><code>class stat =\n  let (* &lt;instance variable&gt; *) = (* &lt;initial value&gt; *) in\n  (* ... do for all instance variables ... *)\n    object (self)\n       (* ... method definitions ... *)\n    end\n</code></pre> <p>Notice that this is no longer a function but a class declaration. However, the method definitions will be unchanged.</p> <p>With this, you can make a statistics object like this:</p> <pre><code>let s = new stat\n</code></pre> <p>If you do this interactively, you'll see it has a nice simple type:</p> <pre><code># let s = new stat\nval s : stat = &lt;obj&gt;\n</code></pre> <p>No more complex object types! </p> <p>After that, you can use <code>s</code> in the same way you used the statistics objects of the previous problem.</p>"},{"location":"assignments/6/partB_imperative_objects/#notes-on-classes","title":"Notes on classes","text":"<p>(There is nothing for you to do in this section, but you might find this interesting nonetheless.)</p> <p>Using <code>let</code> outside of the <code>object</code> declaration is an unusual way to define instance variables. OCaml actually supports an alternative way to define instance variables, using the <code>val mutable</code> syntax:</p> <pre><code>class stat =\n  object (self)\n     val mutable &lt;instance variable&gt; = &lt;initial value&gt;\n     (* ... method definitions ... *)\n  end\n</code></pre> <p>The <code>mutable</code> keyword is only necessary if you want the instance variable to be mutable. To change it, the syntax is:</p> <pre><code>v &lt;- 10  (* change instance variable `v` to be `10` *)\n</code></pre> <p>When using mutable instance variables, you don't need the <code>!</code> or the <code>:=</code> operators, so it's a bit cleaner-looking.</p>"},{"location":"assignments/6/partC_modules_functors/","title":"Part C: Modules and functors (30 points)","text":"<p>In this section, you will work with OCaml modules and functors by implementing a data structure called a priority queue. (\"Queue\" is pronounced \"kyoo\".) The specific implementation you will create is called a leftist heap. So let's talk about these things now.</p>"},{"location":"assignments/6/partC_modules_functors/#priority-queues","title":"Priority queues","text":"<p>Note</p> <p>There is a priority queue implementation given in the OCaml manual as part of the module documentation. Please don't consult that for this assignment (the implementations are different anyway).</p> <p>A priority queue is a data structure that is ordered so that it provides fast access to its minimum element, as defined by some ordering relationship. Conceptually, you can think of that element as \"the next thing to be processed\". It also has to have an operation which deletes the minimum element and returns another priority queue (which would be useful after processing that element), as well as several other operations, which are summarized here as an OCaml module type:</p> <pre><code>module type PRIORITY_QUEUE =\n  sig\n    exception Empty\n\n    type elem      (* Abstract type of elements of queue. *)\n    type t         (* Abstract type of queue. *)\n\n    val empty      : t                (* The empty queue.         *)\n    val is_empty   : t -&gt; bool        (* Check if queue is empty. *)\n    val insert     : t -&gt; elem -&gt; t   (* Insert item into queue.  *)\n    val find_min   : t -&gt; elem        (* Return minimum element.  *)\n    val delete_min : t -&gt; t           (* Delete minimum element.  *)\n    val from_list  : elem list -&gt; t   (* Convert list to queue.   *)\n  end\n</code></pre> <p>Of these operations, note that the operation <code>from_list</code> is not fundamental to the definition of a priority queue, but it's useful.</p> <p>Note</p> <p>When we refer to \"queue\" in this section, we always mean a priority queue, not a first-in/first-out data structure which is the usual meaning of the word \"queue\" in programming. So here, \"queue\" is just short for \"priority queue\".</p> <p>Also note that we are being loose about the words \"insert\" and \"delete\". These operations are purely functional, so that when we say we \"insert\" an element into a queue, we really mean that we create a new queue which has the extra element in it; the original queue is unchanged. Similarly, when we \"delete\" an element from a queue, we really mean that we create a new queue without the offending element; the original queue is once again unchanged.</p>"},{"location":"assignments/6/partC_modules_functors/#leftist-heaps","title":"Leftist heaps","text":"<p>Now that we know how our data structure is supposed to behave, the next question is: how do we implement it? Naturally, there are lots of choices, each of which will have different trade-offs. In this section you're going to implement priority queues as leftist heaps. This is a data structure that has the following attributes:</p> <ul> <li> <p>It can either be a leaf (representing an empty heap) or a node which contains:</p> <ul> <li>a stored element</li> <li>a non-negative integer value called its \"rank\"</li> <li>a left and right subheap, each of which is also a leftist heap</li> </ul> <p>Thus, a leftist heap is a binary tree with additional rank information stored in the nodes. The tree will in general not be balanced; it will usually have more elements in the left subtree than in the right. We say that the tree \"skews to the left\".</p> </li> <li> <p>The element stored at the top of the tree is smaller (more precisely, is no larger) than any of the elements stored beneath it in either subtree.</p> </li> <li> <p>As mentioned, each node has an integer value associated with it, which is called its rank. The rank of a node is equal to the length of its right spine, which is the number of nodes in the rightmost path from the node in question to an empty (leaf) node (this will also turn out to be the shortest path to a leaf node). Thus, a leaf node has rank 0, and a heap with a right subheap which is a leaf has rank 1. However, ranks are only stored in nodes, not in leaves. Having the rank stored in the nodes makes many operations much faster.</p> </li> <li> <p>The rank of any left child is required to be at least as large as the rank of its right sibling. This is why it's called a \"leftist\" heap.</p> </li> </ul> <p>Note</p> <p>Be aware that a heap is not an ordered binary tree in the usual sense. In other words, it is not necessarily the case that all the elements in the left subheap are smaller than those in the right subheap. The only requirement is that an element in a node is smaller than elements in the left and right subheaps of that node.</p> <p>The interesting feature of leftist heaps is that they support very efficient merging of two heaps to form a combined heap. (Of course, since we're using purely functional code, you don't alter the original heaps.) Leftist heaps can be merged in \\(\\Theta(log\\ N)\\) time, where \\(N\\) is the total number of elements in the resulting heap.</p> <p>Furthermore, once the merge operation (which, you'll note, is not a required operation for priority queues) is implemented, you can easily define most of the rest of the heap operations in terms of it. Specifically, you can define the <code>insert</code> and <code>delete_min</code> operations in terms of merging, and the other operations are then trivial to define, except for the list-to-heap conversion routine. That can be done easily in \\(\\Theta(N\\ log(N))\\) time, and with more difficulty in \\(\\Theta(N)\\) time. (You're not required to find the most efficient solution, but it's a good exercise.)</p>"},{"location":"assignments/6/partC_modules_functors/#merging-leftist-heaps","title":"Merging leftist heaps","text":"<p>OK, so now we need to figure out how to merge two leftist heaps to create a new leftist heap. The basic algorithm is quite simple:</p> <ul> <li> <p>If either heap is empty, return the other heap.</p> </li> <li> <p>If the first heap's minimum element is smaller than the second heap's minimum element, make a new heap from the first heap's minimum element, the first heap's left subheap, and the result of merging the first heap's right subheap with the second heap.</p> </li> <li> <p>Otherwise, make a new heap from the second heap's minimum element, the second heap's left subheap, and the result of merging the first heap with the second heap's right subheap.</p> </li> </ul> <p>Here is how to make a new heap from a minimum element and two heaps: the resulting heap must have:</p> <ul> <li>the given minimum element</li> <li>a rank which is the smaller of the ranks of the original heaps, plus 1</li> <li>a left subheap which is the original heap with the larger rank</li> <li>a right subheap which is the original heap with the smaller rank</li> </ul> <p>This algorithm will preserve the leftist heap property in the merged heap.</p>"},{"location":"assignments/6/partC_modules_functors/#insertion-and-delete-minimum-element","title":"Insertion and delete minimum element","text":"<p>Once you have the <code>merge</code> operation, insertion and deletion of the minimum element are simple to implement.</p> <p>The minimum element will always be at the root of the tree structure (assuming the tree isn't empty). If you merge the two subtrees, their result is the priority queue that corresponds to  deleting the minimum element.</p> <p>To insert a new element into the priority queue, just create a one-element tree and merge it with the existing priority queue.</p> <p>Here are the problems.</p>"},{"location":"assignments/6/partC_modules_functors/#1-priorityqueue-module","title":"1. <code>PriorityQueue</code> module","text":"<p>[20 points]</p> <p>Write a module <code>PriorityQueue</code> which implements the <code>PRIORITY_QUEUE</code> module type. Assume that the <code>elem</code> type will be <code>int</code>. Here is a template for your code:</p> <pre><code>module PriorityQueue : (PRIORITY_QUEUE with type elem = int) =\n  struct\n    exception Empty\n\n    type elem = int\n\n    (*\n     * Data type: either\n     * -- a Leaf, or\n     * -- a Node of (rank, item, left heap, right heap).\n     *)\n    type t = Leaf | Node of int * elem * t * t\n\n    (* Your code goes here. *)\n  end\n</code></pre> <p>You will need to fill in the definitions for all the module functions (the functions whose signatures are in the <code>PRIORITY_QUEUE</code> module type). You can also write additional unexported helper functions in the module, if that will make things easier. Make sure you raise the <code>Empty</code> exception when trying to do invalid things e.g. finding the minimum value in an empty queue. Don't change the <code>PRIORITY_QUEUE</code> module type!</p> <p>Note</p> <p>Based on the discussion given above, one unexported helper function you will definitely want to implement is the <code>merge</code> function.</p> <p>Note that since the type <code>elem</code> is abstract, if you want to use a real type as the elements of your priority queue (and it would be pretty useless otherwise), you have to specify which type you want the <code>PRIORITY_QUEUE</code>'s <code>elem</code> value to represent. (This is fairly clunky syntax.) Also, you might ask why you can't just make it parametric, like a type <code>'a list</code>. You actually can in some cases, but here we need a type with an ordering relation, and there is no way to guarantee that any arbitrary type will (a) be orderable at all\u2009\u2014\u2009what if it's a function type? or (b) will be orderable using the same function (e.g. the built-in <code>compare</code> function). So it's better to write the code as it's written above. Also, this will make it easy to transform into a functor (see below).</p> <p>Here's an interesting point to ponder: why don't we also have to specify what the abstract priority queue <code>t</code> type represents in the code above? (You don't have to write down the answer in your code, but if you can't figure this out, ask a TA.)</p> <p>Use the built-in (overloaded) comparison function <code>compare</code> and/or the overloaded comparison operators (<code>&lt;</code>, <code>&gt;</code> etc.) to do whatever comparisons may need to be done. This works because OCaml's comparison operators work on any type. (We'll see a more elegant way to do this below.)</p> <p>Use your priority queue implementation to write a heap sort function called <code>heap_sort</code>. This will take a list of <code>int</code>s as its argument and will</p> <ul> <li> <p>first convert the list to a priority queue (implemented as a leftist heap) using the <code>from_list</code> function of the module</p> </li> <li> <p>successively remove the smallest element from the heap and \"cons\" it onto (i.e. place it onto the front of) a list until there are no more items in the heap</p> </li> <li> <p>reverse the list to get a sorted list in ascending order</p> </li> </ul> <p>This function should be defined outside of the <code>PriorityQueue</code> module, which means that the only functions from that module you can use are the exported ones (those whose signatures are in the <code>PRIORITY_QUEUE</code> module type).</p>"},{"location":"assignments/6/partC_modules_functors/#2-makepriorityqueue-functor","title":"2. <code>MakePriorityQueue</code> functor","text":"<p>[10 points]</p> <p>As written, the code is dependent on the built-in comparison functions. To make this more generic, let's define some types and module types:</p> <pre><code>(* Signature for ordered objects. *)\nmodule type ORDERED_TYPE =\n  sig\n    type t\n    val compare : t -&gt; t -&gt; int\n  end\n\n(* Signature for priority queues. *)\nmodule type PRIORITY_QUEUE =\n  sig\n    exception Empty\n\n    type elem\n    type t\n\n    val empty      : t\n    val is_empty   : t -&gt; bool\n    val insert     : t -&gt; elem -&gt; t\n    val find_min   : t -&gt; elem\n    val delete_min : t -&gt; t\n    val from_list  : elem list -&gt; t\n  end\n</code></pre> <p>What you have to do now is generalize your priority queue implementation into a functor that takes a module implementing the <code>ORDERED_TYPE</code> module type as its argument, and produces a priority queue (implemented using a leftist heap) which is specialized for that particular type of data. For instance, you can define a module of ordered strings like this:</p> <pre><code>module OrderedString =\n  struct\n    type t = string\n    let compare x y =\n      if x = y then 0 else if x &lt; y then -1 else 1\n  end\n</code></pre> <p>and then define your string priority queue like this:</p> <pre><code>module StringPQ = MakePriorityQueue(OrderedString)\n</code></pre> <p>Here, <code>MakePriorityQueue</code> is in fact a functor. It takes an input module (in this case, <code>OrderedString</code>), and returns an output module (in this case <code>StringPQ</code>) which is a priority queue specialized to work only on strings.</p> <p>Once you've done this, redefine your heap sort function (again, outside of the <code>StringPQ</code> module) using a <code>StringPQ</code> as the heap. Call the new function <code>heap_sort_2</code>. Note that this heap sort will only work on strings.</p> <p>To get you started, here is a skeleton of the code you should use for the functor definition:</p> <pre><code>module MakePriorityQueue (Elt : ORDERED_TYPE)\n  : (PRIORITY_QUEUE with type elem = Elt.t) =\n  struct\n    (* Your code goes here... *)\n  end\n</code></pre> <p>Note that again you have to specify what the type <code>elem</code> in the <code>PRIORITY_QUEUE</code> represents. Here, it had better be the same type as the type <code>t</code> in the <code>ORDERED_TYPE</code> argument (which we have called <code>Elt</code>).</p> <p>This code will be nearly identical to the code above. All you are really doing is repackaging that code into a functor.</p>"},{"location":"assignments/6/partD_special_topics/","title":"Part D: Special topics (20 points)","text":"<p>This section has problems relating to the special topics lectures.</p>"},{"location":"assignments/6/partD_special_topics/#1-streams","title":"1. Streams","text":"<p>[10 points]</p> <p>In lecture 15, we showed how to work with streams using the <code>lazy</code> keyword in OCaml and the <code>lazy_t</code> polymorphic datatype. However, we didn\u2019t give a definition of <code>lazy_t</code>. Define a working version of it here. In other words, fill in this code:</p> <pre><code>type 'a contents = (* TODO *)\ntype 'a lazy_t = 'a contents ref\n</code></pre> <p>Also provide a definition of a constructor and an accessor:</p> <pre><code>let make_lazy e = (* TODO *)\nlet force lz = (* TODO *)\n</code></pre> <p>The <code>make_lazy</code> function takes the place of the <code>lazy</code> syntax in OCaml; it takes an argument <code>e</code> which is a function of type <code>unit -&gt; 'a</code> and returns a value of type <code>'a lazy_t</code>. So if you have an expression <code>&lt;expr&gt;</code> and want to make it lazy, you would do this:</p> <pre><code>let lazy_expr = make_lazy (fun () -&gt; &lt;expr&gt;)\n</code></pre> <p>For instance:</p> <pre><code># let lz = make_lazy (fun () -&gt; 100 * 100 * 100);;\n# force lz;;\n- : int = 1000000\n</code></pre> <p>When you call <code>force</code> on a lazy value, it evaluates the expression (if it hasn't already been evaluated) and returns the resulting value, so <code>force</code> has type <code>'a lazy_t -&gt; 'a</code>. Also, it has to somehow store the resulting value so that it never gets recomputed again (this is what we didn\u2019t show you how to do in the lecture).</p> <p>Hint</p> <p>Remember that a lazy value can exist in two forms: unevaluated or evaluated. Furthermore, any unevaluated lazy value can be converted to the evaluated form (but not vice-versa).</p>"},{"location":"assignments/6/partD_special_topics/#2-the-y-combinator","title":"2. The Y combinator","text":"<p>[10 points]</p> <p>In lecture 16, we showed how to construct the Y combinator and how it can be used. Here are some simple (we hope) exercises involving Y. Use this definition for Y:</p> <pre><code>let y =\n  fun f -&gt;\n    (fun z -&gt; z (`Roll z))\n    (fun (`Roll w) -&gt; f (fun x -&gt; w (`Roll w) x))\n</code></pre> <p>There are no tests for the following problems, but make sure your functions actually work.</p>"},{"location":"assignments/6/partD_special_topics/#a-sum","title":"a. <code>sum</code>","text":"<p>Use the Y combinator to define a function called <code>sum</code> which returns the sum of a list of integers. Make sure that <code>sum</code> doesn\u2019t call itself!</p> <p>Hint</p> <p>Define a recursive <code>sum</code> function. Use this as a template to define an <code>almost_sum</code> function which doesn\u2019t use recursion. Then pass that function as the argument to <code>y</code> to generate the <code>sum</code> function.</p>"},{"location":"assignments/6/partD_special_topics/#b-two-argument-functions","title":"b. Two-argument functions","text":"<p>Recall the definition of a linear iterative factorial function:</p> <pre><code>let factorial n =\n  let rec iter n r =\n    if n = 0\n      then r\n      else iter (n - 1) (n * r)\n  in\n    iter n 1\n</code></pre> <p>Re-write this function by rewriting <code>iter</code> so that it doesn't use explicit recursion but does use the Y combinator. The challenge here is that Y returns a function from one value to one value, not from two values to one value like <code>iter</code>. Deal with this by changing the definition of <code>iter</code> (or what you are using in place of <code>iter</code>) so that it takes only one argument (a pair containing the numbers <code>n</code> and <code>r</code>) and returns a single number. You\u2019ll have to re-write the call to <code>iter</code> as well.</p> <p>Hint</p> <p>Rewrite <code>iter</code> first, and only then convert it into a form that <code>y</code> can use. (This isn\u2019t that hard; our solution is only 9 lines long.) Call the resulting factorial function <code>factorial2</code>.</p>"},{"location":"assignments/7/assignment7/","title":"Assignment 7: Final exam preparation","text":""},{"location":"assignments/7/assignment7/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, March 8th, at 2 AM.</p>"},{"location":"assignments/7/assignment7/#coverage","title":"Coverage","text":"<p>This assignment covers all the material in the course, except for the special topics lectures.</p>"},{"location":"assignments/7/assignment7/#note","title":"Note","text":"<p>There will be no opportunity for rework on this assignment. Submitting this assignment late may make it difficult or impossible for the TAs to grade it in a timely manner. Please make every effort to complete the assignment on time.</p>"},{"location":"assignments/7/assignment7/#overview","title":"Overview","text":"<p>This assignment is based on a previous year's final exam, and will serve as a good example of writing somewhat longer programs in OCaml, as well as being excellent preparation for the actual final exam.</p> <p>The exam is one big miniproject. You will implement a solver for a sliding-block puzzle game called Klotski.</p> <p>Even though the description of the assignment is fairly long, the total amount of code you need to write is considerably less than 200 lines (though you can write more if you want/need to).</p>"},{"location":"assignments/7/assignment7/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be in two files named <code>klotski.ml</code> and <code>gsearch.ml</code>. These files should be submitted to CodePost as <code>Assignment 7</code>. Do not submit any other files.</p>"},{"location":"assignments/7/assignment7/#supplied-code","title":"Supplied code","text":"<p>On the course Canvas site, we are providing you with a zip file called <code>lab7.zip</code> containing a number of files which you should use as-is (i.e. don't edit these files), as well as two (2) template files for the files you have to hand in (<code>klotski.ml</code> and <code>gsearch.ml</code>) which have some of the code pre-written for you and which you will need to edit. Please download the zip file, unzip it, and keep these files in the same directory.</p> <p>The files are:</p> <ul> <li> <p><code>klotski.ml</code></p> <p>This is a template version of the <code>klotski.ml</code> file you will be submitting. You should download it and edit it to create a working version of the file. There are skeleton implementations provided for all functions, with complete implementations provided for a few of the more obvious/boring/irritating functions. Each of the skeleton implementations has one or more places where the following code: <code>failwith \"TODO\"</code> is found. You should replace this code with your own code. Note that you are allowed to add more functions (e.g. helper functions) in addition to the ones already in the file, and we encourage you to do so if you find it helpful.</p> </li> <li> <p><code>klotski.mli</code></p> <p>This is the interface file for the <code>klotski.ml</code> file. Download this file, but do not edit it! This file and <code>klotski.ml</code> define the <code>Klotski</code> module. Most of the comments indicating what the various exported functions in the module do are in the <code>.mli</code> file; this is typical OCaml practice. Of course, we will describe all these functions in detail below as well.</p> </li> <li> <p><code>gsearch.ml</code></p> <p>This is a template version of the <code>gsearch.ml</code> file you will be submitting. You should download it and edit it to create a working version of the file. You only have to implement one function in this file, which is part of a functor called <code>Search</code>. We will discuss this in detail below. Again, the place where you need to add your code is indicated by the code: <code>failwith \"TODO\"</code>, which you should replace with your own code. Again, you are allowed to add more functions (e.g. helper functions) in addition to the ones already in the file.</p> </li> <li> <p><code>gsearch.mli</code></p> <p>This is the interface file for the <code>gsearch.ml</code> file. Download this file, but again, do not edit it! This file and <code>gsearch.ml</code> define the <code>Gsearch</code> module.</p> </li> <li> <p><code>klotski_boards.ml</code></p> <p>This file contains string versions of several Klotski boards, which we will use for testing.</p> </li> <li> <p><code>klotski_boards.mli</code></p> <p>This is the interface file for the <code>klotski_boards.ml</code> file. This file and <code>boards.ml</code> make up the <code>Klotski_boards</code> module. The main exported value is an array of strings representing 8 test boards.</p> </li> <li> <p><code>klotski_solve.ml</code></p> <p>This file is the main file for a program called <code>klotski_solve</code> which can automatically solve and display the solution of any of the Klotski boards in the <code>Boards</code> module. It allows you to choose between breadth-first search (BFS) and depth-first search (DFS) using command-line arguments when you run the program. (It turns out that BFS is vastly better for this problem than DFS, but implementing support for DFS in addition to BFS is so easy, due to OCaml's module system, that we couldn't resist.)</p> </li> <li> <p><code>klotski_interact.ml</code></p> <p>This file is the main file for a program called <code>klotski_interact</code> which will allow you to interactively attempt to solve any of the Klotski boards in the <code>Boards</code> module. The interface is text-based and very crude, so don't expect a great experience, but it's interesting to try to solve these puzzles, especially the harder ones. Klotski puzzles can be unbelievably difficult! Using this program is completely optional, but it's fun.</p> </li> <li> <p><code>klotski_tests.ml</code></p> <p>This is the test script for the <code>Klotski</code> module (in <code>klotski.ml</code>). Running the test script is the best way to debug your code. You will probably want to comment out tests that involve functions you haven't written yet.</p> <p>Note</p> <p>To test the board solver (in <code>gsearch.ml</code>), you should run the <code>klotski_solve</code> program described above. We'll have more to say about this below.</p> </li> <li> <p><code>dune</code> and <code>dune-project</code></p> <p>This assignment is the first one that uses the Dune compilation manager. This is the standard way to build complex OCaml applications. If you haven't already installed Dune, just type this in a terminal:</p> <pre><code>$ opam install dune\n</code></pre> <p>To use Dune with this assignment, you need two files: <code>dune</code> and <code>dune-project</code>. They are supplied to you pre-written, and you don't need to know anything about them.</p> </li> <li> <p><code>Makefile</code></p> <p>This is the <code>Makefile</code> for the assignment. There are several <code>Makefile</code> targets:</p> <ul> <li> <p>Typing <code>make</code> by itself is the same as typing <code>make build_test</code>.</p> </li> <li> <p>Typing <code>make build_test</code> will compile the   <code>klotski.ml</code> file and the <code>klotski_tests.ml</code> test script,   producing a program called <code>klotski_tests</code>,   which you can run by typing</p> <pre><code>$ ./klotski_tests\n</code></pre> <p>It will run all the tests of the <code>Klotski</code> module   and report which ones failed.</p> </li> <li> <p>Typing <code>make test</code> does what <code>make build_test</code> does,   and also runs the <code>klotski_tests</code> program for you.</p> </li> <li> <p>Typing <code>make solve</code> will compile a native-code version   of the Klotski board solving program (called <code>klotski_solve</code>).   Compiling to native code is important   because we want it to run as fast as possible.</p> </li> <li> <p>Typing <code>make interact</code> will compile the <code>klotski_interact</code> program.   This program will allow you to solve Klotski boards interactively.</p> </li> <li> <p>Typing <code>make all</code> will build all the programs   (<code>klotski_solve</code>, <code>klotski_tests</code>, and <code>klotski_interact</code>).</p> </li> <li> <p>Typing <code>make clean</code> will remove all compilation targets   (object code, executables, etc.) but leave all source code alone.</p> </li> </ul> <p>Normally, you will just want to type <code>make test</code> to compile <code>klotski.ml</code> and run the Klotski board tests, and <code>make solve</code> to compile the Klotski board solver (<code>klotski solve</code>) which you can test manually by running it on the available Klotski boards.</p> </li> </ul> <p>As mentioned above, you should download the <code>lab7.zip</code> file, unzip it, and edit just the files <code>klotski.ml</code> and <code>gsearch.ml</code>. Do not submit any of the other files.</p>"},{"location":"assignments/7/klotski_game/","title":"The \"Klotski\" sliding-block puzzle game: general notes","text":""},{"location":"assignments/7/klotski_game/#game-description","title":"Game description","text":"<p>The puzzle game Klotski is an example of a \"sliding block puzzle game\", whereby the pieces (blocks) can slide around on the game board, and the goal is to reach a desired configuration. There are a number of these games (\"Rush Hour\" is another well-known one). Klotski is both extremely simple (in terms of the rules) and extremely difficult to solve for many possible puzzles.</p> <p>The Wikipedia page for Klotski is here.</p> <p>Here are the rules of the game. The game is played on a 5x4 grid (5 rows, 4 columns) which we'll call the \"board\". The pieces are either</p> <ul> <li>1x1 blocks (1 row by 1 column),</li> <li>1x2 horizontal blocks (1 row by 2 columns),</li> <li>2x1 vertical blocks (2 rows by 1 column),</li> <li>or 2x2 blocks (2 rows by 2 columns).</li> </ul> <p>There is always exactly one 2x2 block on the board, but there can be any number (including zero) of the other kinds of blocks, except that blocks can't overlap each other, and there is only enough space for so many blocks. The game starts with a number of pieces already placed on the board, including the special 2x2 block. Once this has been done, you play the game by moving one piece per move.  Pieces can be moved in either the horizontal or vertical direction, but they can't rotate.  You can move a piece any number of spaces, as long as (a) you don't move any part of the piece off the board, and (b) no part of the piece goes over another piece or lands on another piece. The goal of the game is to move the 2x2 piece to the two bottom rows and the two middle columns. Conceptually, this puts the piece next to an \"exit door\" right below the middle two columns, so the piece can \"escape\".  The objective of the game is to get the 2x2 piece to the target location in the fewest number of moves. And that is it for rules.</p> <p>To illustrate these rules in action, see the example game in the next section.</p> <p>The name \"Klotski\" comes from the Polish word \"klocki\", which means \"wooden blocks\". The original Klotski puzzles were physical puzzles made from sliding wooden blocks. The game may have actually originated in America; versions of it were known to exist in 1909.</p>"},{"location":"assignments/7/klotski_game/#example-game","title":"Example game","text":"<p>Here is an example of what a complete game will look like when you compile the code in the file <code>klotski_interact.ml</code> (assuming that all your own code in <code>klotski.ml</code> works properly) by typing <code>make interact</code> at the command prompt (or just <code>make</code>). You run the game by typing this at the terminal prompt:</p> <pre><code>$ ./klotski_interact 0\n</code></pre> <p>This will use board number 0 (from <code>klotski_boards.ml</code>) as the starting configuration. Board numbers can range from 0 to 7, with higher numbers requiring many more moves to solve.</p> <p>Here is a transcript of an interactive game in its entirety with this input board. Pieces are displayed using letters, with the different locations of a piece represented by the same letter on adjacent locations. Empty squares are represented by a period (<code>.</code>). The goal is to get the 2x2 piece (represented on this particular board by the character <code>'f'</code>) to the bottom two rows and the middle two columns as described above.</p> <p>User input comes after the prompt <code>\"Enter move: \"</code>. User input consists of a string of three characters, which are:</p> <ol> <li>the name (label) of the piece to be moved (for instance, piece <code>c</code>),</li> <li>which direction to move it    (<code>u</code> for up, <code>d</code> for down, <code>l</code> for left, or <code>r</code> for right),</li> <li>and how far to move it (for instance, <code>1</code> or <code>2</code>).</li> </ol> <p>The distance must be a positive integer no larger than <code>4</code> (otherwise, the piece would end up off the board). You are not allowed to make a move which moves any component of a piece off the board or on top of or through another piece.</p> <pre><code>$ ./klotski_interact 0\n\naabb\n.cc.\nddee\nffgh\nffij\n\nEnter move: cl1   (* move piece \"c\" to the (l)eft one (1) location *)\n\naabb\ncc..\nddee\nffgh\nffij\n\nEnter move: eu1\n\naabb\nccee\ndd..\nffgh\nffij\n\nEnter move: gu1\n\naabb\nccee\nddg.\nff.h\nffij\n\nEnter move: gr1\n\naabb\nccee\ndd.g\nff.h\nffij\n\nEnter move: iu2\n\naabb\nccee\nddig\nff.h\nff.j\n\nEnter move: fr1\n\naabb\nccee\nddig\n.ffh\n.ffj\n\nThe board is solved!\n</code></pre> <p>Since the 2x2 <code>f</code> piece is in the final location, the board is solved. (Of course, most puzzles will require many more moves than this.)</p>"},{"location":"assignments/7/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/7/ocaml_notes/#testing","title":"Testing","text":"<p>Please run the test script (<code>klotski_tests</code>) while you are writing the code! Comment out all tests that are not relevant to the code you are working on and just run the relevant tests. You don't want to write hundreds of lines of code before starting the testing process. If you do this, you may find that you have made a fundamental mistake early on, and you'll have to rewrite most of your code. Instead, write a little code, then test a little code, then repeat until done. (This is more fun anyway.)</p> <p>The easiest way to comment out tests is in the definition of the <code>all_tests</code> function at the bottom of the <code>klotski_tests.ml</code> file. Each line in the function represents a series of tests which can be commented out simply by commenting out the line.</p>"},{"location":"assignments/7/ocaml_notes/#option-types","title":"Option types","text":"<p>There is little explicit use of exceptions in this assignment. However, a number of functions can fail, and their return types are <code>option</code> types. Recall that this family of types has this definition:</p> <pre><code>type 'a option = None | Some of 'a\n</code></pre> <p>If the function fails, it returns a <code>None</code> value. If it succeeds, it returns a <code>Some &lt;value&gt;</code> value (where <code>&lt;value&gt;</code> is the value you want to return). Note that to use that value you will need to do a pattern match, e.g.</p> <pre><code>match option_value with\n  | None -&gt; ...    (* fail *)\n  | Some x -&gt; ...  (* succeed *)\n</code></pre> <p>Functional programmers view this style of programming as being purer than code that uses exceptions, though it isn't always as convenient.</p> <p>The one use of exceptions is in code that uses OCaml's <code>Map</code> datatype, which raises <code>Not_found</code> exceptions in some cases.</p>"},{"location":"assignments/7/ocaml_notes/#design-guidelines","title":"Design guidelines","text":"<p>The main guideline we want you to follow is that all of your code (with one quasi-exception) should be purely functional. In particular, the code in <code>klotski.ml</code> is purely functional. You will not need to use references or mutable arrays in any of your code, and you should not! We will guide you in the data structures to use below; if you use them as we suggest, you won't have a problem.</p> <p>The one quasi-exception to the \"all-functional\" rule is that the search algorithms used in <code>gsearch.ml</code> will use OCaml <code>Stack</code>s and <code>Queue</code>s as fundamental components of their structure. These data structures are not purely functional; adding data to them or removing data from them causes their internal contents to change. However, all the imperative code you will need is in the OCaml standard library, so you won't have to write any yourself, other than that which is necessary to successfully interact with the stack/queue values (e.g. <code>begin</code>/<code>end</code> sequencing statements). Be aware that you do not have to use <code>ref</code> cells or imperative loops (<code>for</code>/<code>while</code> loops) in the code, and you should not.</p> <p>If you violate these guidelines (e.g. by using imperative code unnecessarily), you will lose a lot of marks.</p> <p>Note</p> <p>If you're curious: it is possible to implement stacks and queues in a purely functional way, but (at least for queues) there can be a performance penalty in doing so.</p>"},{"location":"assignments/7/ocaml_notes/#set-and-map-functors-the-klotski-board-representation","title":"Set and map functors: the Klotski board representation","text":"<p>In assignment 6, you saw how to use functors to implement interesting datatypes. Two of the most-used functors in practice are sets and maps, and we will be using both of these in this assignment. Specifically, we will be using sets of board locations (represented as pairs of integers i.e. (row, column) pairs) extensively. We will represent pieces on the Klotski board by the set of locations the piece occupies, and we will also use a set of locations to represent the unoccupied locations on the board. A set of locations is created using the <code>Set.Make</code> functor, which requires a module which conforms to the <code>OrderedType</code> module type as input:</p> <pre><code>type loc = int * int\n\nmodule LocM : Set.OrderedType with type t = loc =\n  struct\n    type t = loc\n    let compare = Stdlib.compare\n  end\n\nmodule LocSet : Set.S with type elt = loc = Set.Make(LocM)\n</code></pre> <p>The <code>Set.S with type elt = loc</code> annotation just exposes the <code>elt</code> (set element) type outside the module. Similarly, the <code>Set.OrderedType with type t = loc</code> exposes the <code>t</code> type outside the <code>LocM</code> module. Actually, it would be OK if we just defined <code>LocM</code> like this:</p> <pre><code>type loc = int * int\n\nmodule LocM =\n  struct\n    type t = loc\n    let compare = Stdlib.compare\n  end\n</code></pre> <p>because then the entire <code>LocM</code> module would be exposed. What's important is that this module implements the <code>OrderedType</code> interface (so that it can be used as the module input to the <code>Set.Make</code> functor) not that it declares that it does so (OCaml can figure this out).</p> <p>Documentation for OCaml's <code>Set</code> library is found here and here. Many of the functions on sets will be useful to you; we'll mention them as they come up.</p> <p>Note</p> <p>One <code>Set</code> function that is very useful is the <code>of_list</code> function, which creates a set from a list.</p> <p>In addition, we will be using OCaml's <code>Map.Make</code> functor to make a mapping between characters and pieces (where pieces are represented as sets of locations). A \"map\" in this context doesn't mean the higher-order <code>List.map</code> function; a map here is a purely functional version of something like Python's dictionaries. We can create a map like this:</p> <pre><code>module CharM : Map.OrderedType with type t = char =\n  struct\n    type t = char\n    let compare = Stdlib.compare\n  end\n\nmodule CharMap : Map.S with type key = char = Map.Make(CharM)\n</code></pre> <p>This is a map that uses characters (the <code>char</code> type) as keys. The <code>Map.S with type key = char</code> annotation just exposes the <code>key</code> (map key) type outside the module. Note that the argument to the <code>Map.Make</code> functor is again a module which conforms to the <code>OrderedType</code> module type. <code>Set.OrderedType</code> and <code>Map.OrderedType</code> are the same. Again, you could have written <code>CharM</code> as just:</p> <pre><code>module CharM =\n  struct\n    type t = char\n    let compare = Stdlib.compare\n  end\n</code></pre> <p>We won't bother with module type signatures with <code>OrderedType</code>s any more, since they don't really help us.</p> <p>A <code>CharMap</code> data structure maps characters (which in this case represent piece labels) to some (unspecified) value type. We will always be using pieces (which are just sets of locations) as our value type in <code>CharMap</code>s. In other words, the <code>CharMap</code> maps characters to the piece (set of locations) with that character label. All the pieces on a Klotski board will collectively be represented by a single <code>CharMap</code> of this type. The board data structure is a record with this definition:</p> <pre><code>type piece = LocSet.t\ntype t = { pieces : piece CharMap.t ; unoccupied : LocSet.t }\n</code></pre> <p>All unoccupied squares go into the <code>unoccupied</code> field of the record. The type <code>t</code> (more precisely, <code>Klotski.t</code>) is the board type.</p> <p>Note</p> <p>Don't worry: all of this code is in the template files!</p> <p>To reiterate: a Klotski board consists of two things:</p> <ol> <li> <p>a set of unoccupied locations</p> </li> <li> <p>a map between characters (which are piece labels) and sets of locations    which represent where a particular piece is located on the board.</p> </li> </ol> <p>Note that this representation doesn't enforce certain important invariants: that none of the pieces overlap each other, and that none of them contain locations that are also in the <code>unoccupied</code> set. You will have to maintain these invariants yourself in the functions you will write below.<sup>1</sup> Note that Klotski board values are originally created by the <code>read</code> function which is supplied for you; it takes a string containing 20 characters as its only argument and returns a board value. Sample \"board strings\" are given in the file <code>klotski_boards.ml</code>; these are used in the test script.</p> <p>Documentation for OCaml's <code>Map</code> library is found here and here. Again, many of the functions on maps will be very useful to you; and again, we'll mention them below as they come up.</p>"},{"location":"assignments/7/ocaml_notes/#multi-parameter-functors-the-search-functor","title":"Multi-parameter functors: the <code>Search</code> functor","text":"<p>We hope that by now you have been convinced that OCaml's functors are a powerful language feature. Actually, you don't yet realize how powerful they are! One aspect of this power that we will be using in this assignment is multi-parameter functors. These are just functors that take more than one module argument. In the file <code>gsearch.ml</code> there is a functor called <code>Search</code> with this (incomplete) definition:</p> <pre><code>module type Storage =\n  sig\n    type 'a t\n    exception Empty\n\n    val create : unit -&gt; 'a t\n    val push : 'a -&gt; 'a t -&gt; unit\n    val pop : 'a t -&gt; 'a\n    val is_empty : 'a t -&gt; bool\n  end\n\nmodule type Domain =\n  sig\n    type t\n    val show : t -&gt; string\n    val is_solved : t -&gt; bool\n    val compare : t -&gt; t -&gt; int\n    val next : t -&gt; t list\n  end\n\nmodule Search (S : Storage) (D : Domain) =\n  struct\n    module DS = Set.Make(D)\n\n    let search init = failwith \"TODO\"\n\n    let show_history hist =\n      (String.concat \"\\n----\\n\\n\" (List.map D.show (List.rev hist))) ^ \"\\n\"\n  end\n</code></pre> <p>Let's walk through this. It looks complicated but it really isn't.</p> <p>First off, we define a module type called <code>Storage</code>. This includes a polymorphic type <code>t</code> whose corresponding values are data structures that are used to store board configurations (more precisely, board configuration histories) during the search process when solving a Klotski board. It turns out that the built-in OCaml modules <code>Stack</code> and <code>Queue</code> both instantiate all the functions of this module type, so we can use either of them as <code>Storage</code> arguments to the <code>Search</code> functor. (You don't have to declare that they instantiate the <code>Storage</code> module type either; the compiler handles this for you.)</p> <p>The other argument of the <code>Search</code> functor has the module type <code>Domain</code>. This represents the thing you are searching over, which in this case are Klotski boards. Any module representing a <code>Domain</code> must have:</p> <ul> <li> <p>a data type <code>t</code>, which here represents the Klotski board type</p> </li> <li> <p>a way to convert a value of type <code>t</code> to a string, for display   purposes</p> </li> <li> <p>a way to determine if a value of type <code>t</code> is \"solved\"   (here, if the Klotski board is in its solved configuration)</p> </li> <li> <p>a way to compare two values of type <code>t</code></p> </li> <li> <p>and a way to go from a value of its data type <code>t</code>   to a list of its successors.   In this case, the successors of a Klotski board   will be the boards that can be obtained from a given board   by a single move.</p> </li> </ul> <p>Note also that we define an internal module <code>DS</code> in the <code>Search</code> functor; this represents a set of Klotski boards. We use this to store all boards that have been previously seen, so we don't search them again. Since the <code>Domain</code> module type has the <code>compare</code> function, it is a superset of the <code>OrderedType</code> module type, so it can be used as an argument to the <code>Set.Make</code> functor.</p> <p>We'll go into how to write the <code>search</code> function below. Sneak preview: it can easily be done in under 25 lines.</p> <ol> <li> <p>In addition, all of the locations in each piece should be connected, but this isn't something you need to enforce. As long as they start out connected (which they will) they will remain connected.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/7/partA_klotski_board/","title":"Part A: The <code>Klotski</code> module (70 points)","text":"<p>The code for this section will be written in the file <code>klotski.ml</code>. You have to write six functions. None of them require more than 25 lines of code in all (including helper functions), and most can be done in fewer lines.</p> <p>The Klotski board representation is described in the \"OCaml notes\" section. Please read it if you haven't already, because you will need to know it to write these functions. In the <code>klotski.ml</code> file, Klotski boards have the type <code>t</code>.</p> <p>The value of each function in points is noted in bold after the start of each function's description.</p>"},{"location":"assignments/7/partA_klotski_board/#board-locations","title":"Board locations","text":"<p>Locations are represented by the <code>loc</code> type, which is just an alias for a 2-tuple of <code>int</code>s. Locations are <code>(&lt;row index&gt;, &lt;column index&gt;)</code> tuples, where the indices start at 0. So location <code>(0, 0)</code> is the upper-left corner (row 0, column 0), location <code>(0, 1)</code> (row 0, column 1) is one to the right of <code>(0, 0)</code>, and location <code>(1, 0)</code> (row 1, column 0) is one down from <code>(0, 0)</code>.</p>"},{"location":"assignments/7/partA_klotski_board/#1-is_solved","title":"1. <code>is_solved</code>","text":"<p>[10 points]</p> <p>Write a function called <code>is_solved</code> that takes as its only argument a Klotski board and returns <code>true</code> if the board is solved, or <code>false</code> otherwise. A board is considered solved if there is a 2x2 piece on the board which occupies the four locations in the bottom two rows and the two center columns. This function can be written in a couple of lines.</p> <p>Hint</p> <p>Use the <code>equal</code> function from the <code>Set.S</code> module type and the <code>exists</code> function from the <code>Map.S</code> module type.</p>"},{"location":"assignments/7/partA_klotski_board/#2-compare","title":"2. <code>compare</code>","text":"<p>[10 points]</p> <p>Write a function called <code>compare</code> that takes two arguments, both of which are Klotski boards. It returns an <code>int</code> which represents whether the two boards are \"equal\", or one of the two is \"greater\" than the other. If the two boards are equal, return <code>0</code>. If the first board is greater than the second, return <code>1</code>. If the second board is greater than the first one, return <code>-1</code>.</p> <p>Note</p> <p>This is the common OCaml convention for comparison functions.</p> <p>The two boards are considered to be equal if both:</p> <ul> <li>the set of unoccupied locations is the same for both boards</li> <li>the set of pieces are the same for both boards</li> </ul> <p>To compare the sets of pieces, use the <code>LocSetSet</code> module we've provided for you. A value of type <code>LocSetSet.t</code> is a set of set of locations (you read that right, it's not a typo), so a set of pieces can be a value of this type, since pieces are represented as sets of locations. In the board, the pieces are stored in a <code>CharMap.t</code> value, which maps character labels to pieces. Be aware that the character labels of the pieces are not important in the comparison; if the pieces had different labels two boards would still be equivalent as long as the same kinds of pieces occupied the same locations. You can extract the pieces from the <code>CharMap.t</code> value using the <code>CharMap.bindings</code> function.</p> <p>You can use the <code>compare</code> functions of <code>LocSet</code> and <code>LocSetSet</code> to compare sets and sets of sets respectively. This will not only compare values for equality but will also do the right thing if the two values are not equal (return <code>-1</code> if the first is \"smaller\" than the second, or <code>1</code> if the first is \"larger\" than the second).</p> <p>To be absolutely clear: for the <code>compare</code> function to return <code>0</code>, both boards must have the same set of unoccupied locations and the same set of pieces (though the piece labels are irrelevant).  The criteria for the boards to be \"less than\" or \"greater than\" each other is less critical, except that for any two unequal boards, if <code>compare b1 b2</code> gives the result <code>-1</code>, then <code>compare b2 b1</code> must give the result <code>1</code>. In other words, <code>compare</code> must be a true ordering on the boards.</p> <p>This function is also quite short. It's important to get this right, because if you don't, your <code>search</code> function in part B will either be incredibly slow or won't work at all.</p> <p>Note</p> <p>Be aware that you do not have to call this function at all in your own code! The only reason for this function to exist is to make Klotski boards orderable, which means you can make sets of boards (because the implementation of sets requires that their elements be orderable). So don't feel like you are doing something wrong if you don't call this function in your code; in fact, you are doing something wrong if you do call this function in your code.</p>"},{"location":"assignments/7/partA_klotski_board/#3-remove","title":"3. <code>remove</code>","text":"<p>[10 points]</p> <p>Write a function called <code>remove</code> that takes two arguments: a character (which is a piece label) and a board. It removes the piece with the given character label from the <code>pieces</code> map of the board, updates the <code>unoccupied</code> set by adding the locations of the piece to that set, and returns the resulting board. If the piece isn't on the board, the board is returned unchanged.</p> <p>Again, this is a very short function. You may find the <code>union</code> function on sets to be useful here.</p>"},{"location":"assignments/7/partA_klotski_board/#4-add","title":"4. <code>add</code>","text":"<p>[10 points]</p> <p>Write a function called <code>add</code> which takes two arguments:</p> <ul> <li> <p>a two-tuple representing a piece.   This consists of a character label   and a set of locations that the piece occupies.</p> </li> <li> <p>a Klotski board</p> </li> </ul> <p>It places the piece on the board if possible, updates the <code>unoccupied</code> set, and returns the new board. If the piece is already on the board or can't be placed on the board because some of its locations are occupied by other pieces, return <code>None</code>. If the piece can be placed, return <code>Some &lt;new board&gt;</code>, where <code>&lt;new board&gt;</code> is the resulting board.</p> <p>Note that the new piece can only be placed on the unoccupied locations on the board.</p> <p>This is another short function. The <code>subset</code> and <code>diff</code> functions of sets may be useful to you here.</p>"},{"location":"assignments/7/partA_klotski_board/#5-make_move","title":"5. <code>make_move</code>","text":"<p>[15 points]</p> <p>Write a function called <code>make_move</code> which takes two arguments:</p> <ul> <li> <p>a three-tuple representing a move.   This consists of a character (a piece label),   a direction (one of <code>Up</code>, <code>Down</code>, <code>Left</code> or <code>Right</code>),   and an <code>int</code> representing how far to move the piece   (this should be at least 1).</p> </li> <li> <p>a Klotski board</p> </li> </ul> <p>It returns <code>None</code> if the move can't be made for any reason (including if the labeled piece is not on the board, or if the move distance is less than 1). Otherwise, it makes the move on the board, updates the character/piece map and the unoccupied set, and returns <code>Some &lt;new board&gt;</code>.</p> <p>This function is a bit harder and a bit longer than the previous ones. You may find the <code>map</code> function on sets to be useful; this is like <code>List.map</code> except for sets i.e. it applies a function to every value in a set.</p> <p>Be careful! It's not hard to remove a piece from a board, get the piece locations, move them in some direction, and add the piece back to the board, but this won't be enough in all cases. You also have to make sure that the piece doesn't go through any other pieces when it moves. This is especially important for large moves e.g. moving a 1x1 piece 4 locations up or down. One way to deal with this is to only allow a move of distance <code>n</code> if you would also allow a move of distances <code>n-1</code>, <code>n-2</code> ... <code>1</code>.</p> <p>Helper functions are your friend here. The <code>add</code> function you just defined above will also be very helpful.</p>"},{"location":"assignments/7/partA_klotski_board/#6-next","title":"6. <code>next</code>","text":"<p>[15 points]</p> <p>Write a function called <code>next</code> which takes a single argument (a Klotski board). It figures out all possible moves on the board, makes all the moves starting from the board, collects all the resulting boards into a list and returns the list.</p> <p>To give a very simple example: consider this \"board\" (represented here as a 2d array of characters, which is not how we are doing it in the program):</p> <pre><code>.aa.\n.aa.\n....\n....\n....\n</code></pre> <p>The following list of \"boards\" would be returned by this function (again representing boards as 2d character arrays, which isn't accurate, but you get the idea):</p> <pre><code>aa..\naa..\n....\n....\n....\n\n..aa\n..aa\n....\n....\n....\n\n....\n.aa.\n.aa.\n....\n....\n\n....\n....\n.aa.\n.aa.\n....\n\n....\n....\n....\n.aa.\n.aa.\n</code></pre> <p>So the result will be a list of 5 boards, each of which could be derived from the input board by moving the <code>'a'</code> piece in some direction by some number of squares.</p> <p>This function is a bit tricky. It's also the most critical function for the <code>search</code> function in part B. However, it doesn't have to be that long (we did it in less than 25 lines). The basic idea is this. Imagine if, for a particular piece on the board and a particular direction, you could compute all the possible moves with that piece in that direction and could collect all the resulting boards. Do that for all directions and for all pieces, and collect up all the boards. You can use the <code>make_move</code> function you defined above to make your life easier, but you don't have to. Once again, make sure you aren't moving a piece through another piece or on top of another piece.</p> <p>You may find the <code>List.concat</code> and <code>List.map</code> functions to be useful, or you can combine them with the <code>List.concat_map</code> function.</p>"},{"location":"assignments/7/partB_search/","title":"Part B: The <code>Search</code> functor (30 points)","text":"<p>The code for this file will be written in the file <code>gsearch.ml</code>. You only have to write one function in this section, and it can be written in less than 25 lines (including helper functions). The goal of this module is to allow you to start with a Klotski board and find a solution to the board. The solution will be a list of all the boards leading up to the final one (which has the 2x2 piece in the target location). In fact, the solution will be in reverse order, with the last board at the front of the list.</p>"},{"location":"assignments/7/partB_search/#breadth-first-and-depth-first-search","title":"Breadth-first and depth-first search","text":"<p>The code for this section is not hard to write, but first you have to understand the breadth-first and depth-first search algorithms.</p> <p>References: here for breadth-first search; here for depth-first search.</p> <p>Finding an optimal solution to a puzzle game like Klotski is an example of a tree search problem. Trees come up all the time in computer science. We can consider the starting board of a Klotski puzzle as the root node of a tree. The moves that can be made on the starting board can be applied to that board to generate new boards which are the \"children\" of the root node, and each of them can then generate more boards which are their children, and so on. A tree representing a Klotski puzzle is actually of infinite depth, because you can move the same piece back and forth as often as you want. However, it's useful when solving to stipulate that you can't have two boards (nodes) in the tree which are identical; this makes the tree finite and thus makes it feasible to search for a particular board configuration (like one in which the 2x2 piece is in the bottom two rows and the middle two columns).</p> <p>The two most basic algorithms for doing a tree search are known as \"depth-first search\" (also known as DFS) and \"breadth-first search\" (also known as BFS). Let's see how they work.</p> <p>The idea in depth-first search is to start at the root node, then (if that node isn't a solution to the problem), generate all its child nodes, pick one of the child nodes, inspect it to see if it solves the problem, then (if not) generate its child nodes, pick one of its child nodes (grandchild of the root node), inspect it, and so on until you eventually reach a node that has no children (perhaps because all of its actual children have already been visited, and so are ineligible for searching). At that point, you back up to the parent node of the current node, pick a different child node, and continue. In this way, you will eventually visit all the nodes in the tree. Basically, you search as far as possible down one branch of the tree before you back up and search a different branch. The Wikipedia article here has a picture which illustrates the order in which nodes are visited in DFS.</p> <p>In contrast, in breadth-first search, you search the entire tree level by level. First, you check the root node, then you check each of its children, and only then each of the children's children, and so on. Again, you should eliminate any nodes that are the same as nodes already seen in order to speed up the search. The Wikipedia article here has a picture which illustrates the order in which nodes are visited in BFS.</p> <p>For the Klotski problem, BFS has a tremendous advantage over DFS: the first solution found using BFS is guaranteed to be the optimal solution of a board (in the sense of requiring the fewest number of moves). That's because the number of moves it takes to get to a particular board node from the root board node is equal to the depth of the tree at that point; put differently, each new level of the tree corresponds to another move in the solution. So if there were a better solution in the tree by the time you find one solution, you would already have seen it, so the first solution found is the optimal one. In contrast, DFS will usually not find an optimal solution, as you will see below.</p> <p>A really amazing fact is that BFS and DFS can both be implemented in terms of simple data structures which can have exactly the same interface. DFS is naturally implemented in terms of a stack, which is a data structure where you push values into the stack and pop them off the stack, and the first value popped off the stack is the last value pushed onto the stack. This is called a LIFO data structure, for \"Last In, First Out\". From the perspective of a tree search, using a stack works like this:</p> <ul> <li> <p>Start with the root node (original board). Push it onto the stack.</p> </li> <li> <p>Repeat the following steps:</p> <ul> <li> <p>Pop the first node off the stack. Check to see if it solves the    problem. If so, you win!</p> </li> <li> <p>Otherwise, generate all its child nodes and push them onto the    stack as long as none of them have ever been pushed onto the    stack before.</p> </li> </ul> </li> <li> <p>If the stack empties out before a solution is found, there is no   solution.</p> </li> </ul> <p>For BFS, the process is exactly the same except that you use a queue instead of a stack to store the nodes. A queue is like a stack except that instead of \"Last In, First Out\", a queue is \"First In, First Out\" or FIFO (like a line for movie tickets). That is literally the only difference, but it means that pushing a node onto the queue puts it at the back of the queue, not the front, so all the other child nodes that were generated earlier will be inspected before the pushed node. In contrast, popping a node off the queue pops off the front of the queue (which is the same as for a stack). This difference is enough to change DFS into BFS. Pretty cool!</p> <p>Note</p> <p>Don't confuse this kind of queue with the priority queues we looked at in assignment 6. Despite the fact that both data structures use the word \"queue\", they are entirely different. These are \"plain queues\" or \"FIFO queues\".</p> <p>There are two additional wrinkles to the tree searching process.</p> <p>The first is that (as mentioned) we take care to not push nodes onto the stack/queue if they have already been inspected before.</p> <p>The second is that we don't just want to find a solution board; we want to find the entire history of the solution (the sequence of boards leading to the solution). The way we will do this is a bit clever. Instead of storing individual boards on the stack or queue, we will store lists of boards, where a particular list represents the history of boards leading to the current board. For convenience, we store it in reverse order, so that the first board in the list is the last board in the history (and thus, it's the current board after the last move was made).</p> <p>So if a board list is <code>[board3; board2; board1]</code>, this represents a history where the original board was <code>board1</code>, then <code>board2</code> is a child of <code>board1</code> (generated by making one move on <code>board1</code>) and <code>board3</code> (the current board) is a child of <code>board2</code>. We generate new histories by taking the head of the list, generating a list of child boards, and for each child board, putting it at the front of the list. So if <code>board3</code> has three children: <code>board4a</code>, <code>board4b</code>, and <code>board4c</code> (representing three possible moves on <code>board3</code>), the new histories will be:</p> <ul> <li><code>[board4a; board3; board2; board1]</code></li> <li><code>[board4b; board3; board2; board1]</code></li> <li><code>[board4c; board3; board2; board1]</code></li> </ul> <p>Each of these will get pushed onto the stack/queue.</p> <p>When we pop a history off the stack/queue, we will look at the head of the list (the most recent board in the history) to see if it solves the problem; if not (and if it hasn't been seen before), we generate new histories, push them back onto the stack/queue, and continue. Once we find a board which is a solution, we will also have all the boards that led to that solution, so it's easy to print out the solution.</p>"},{"location":"assignments/7/partB_search/#the-storage-module-type","title":"The <code>Storage</code> module type","text":"<p>The file <code>gsearch.ml</code> defines a module type called <code>Storage</code> which represents the data structure that will store the board histories. It will be either a stack or a queue. Here is the definition:</p> <pre><code>module type Storage =\n  sig\n    type 'a t\n    exception Empty\n\n    val create : unit -&gt; 'a t\n    val push : 'a -&gt; 'a t -&gt; unit\n    val pop : 'a t -&gt; 'a\n    val is_empty : 'a t -&gt; bool\n  end\n</code></pre> <p>This means that any module that has this module type defines a type <code>t</code> which is polymorphic (i.e. you can store any kind of data in the type <code>t</code>). You create a new data structure of type <code>t</code> by calling the <code>create</code> function with a unit argument:</p> <pre><code>let storage = create () in ...\n</code></pre> <p>You push a new value onto the data structure using the <code>push</code> function:</p> <pre><code>push new_history storage\n</code></pre> <p>Note: These data structures can't overflow.</p> <p>You pop a value off the data structure using the <code>pop</code> function:</p> <pre><code>let next_history = pop storage in ...\n</code></pre> <p>You can check if the storage is empty using the <code>is_empty</code> function. If you pop an empty data structure, the <code>Empty</code> exception will be raised.</p> <p>Remarkably, the <code>Stack</code> and <code>Queue</code> modules (which are part of the OCaml standard library) both implement the <code>Storage</code> module type. We'll see how to use this below.</p> <p>Note that the <code>Storage</code> module type defines an imperative storage data structure. That's why <code>push</code> and <code>pop</code> don't return an updated value of type <code>'a t</code>; instead, they mutate the input value of that type. Both the OCaml <code>Stack</code> and <code>Queue</code> modules implement imperative data structures. This is the only use of imperative programming in this assignment.</p>"},{"location":"assignments/7/partB_search/#code-to-write","title":"Code to write","text":"<p>[30 points]</p> <p>Write the <code>search</code> function in the <code>Search</code> functor.</p> <p>The <code>Search</code> functor looks like this:</p> <pre><code>module Search (S : Storage) (D : Domain) =\n  struct\n    module DS = Set.Make(D)\n\n    let search init = ...\n\n    let show_history hist = (* code supplied for you *)\n  end\n</code></pre> <p>and you have to fill in the code marked <code>...</code>. The <code>Storage</code> (<code>S</code>) argument will either be the OCaml <code>Stack</code> or <code>Queue</code> module (depending on whether you want DFS or BFS searching); you specify this when you call the functor. The <code>Domain</code> (<code>D</code>) argument will be the <code>Klotski</code> module you defined in part A in the file <code>klotski.ml</code>. (See below for how this code will actually be used.) The <code>DS</code> module will be a set of Klotski boards which represent the boards already seen; these will be used to make sure we don't push a board history onto the stack or queue whose most recent board has already been seen. Note that the <code>compare</code> function in the <code>Klotski</code> module that you wrote in part A is incredibly important here! Without it, you couldn't create a set of boards because the <code>Klotski</code> module wouldn't implement the <code>Ordered_type</code> module type. If you don't implement it correctly (the way we described above) you could still create a set of boards but the tree search may be incredibly slow (because there are too many \"distinct\" boards that aren't really distinct).</p> <p>The <code>search</code> function takes one argument, which is the starting board. It will perform a tree search starting from that board. If it finds a solution, it will return a board history (a list of boards in reverse order, with the final board at the head of the list). If it doesn't find a solution, it will raise the <code>Not_found</code> exception.</p> <p>Here's an outline of the algorithm to use:</p> <ul> <li> <p>Create a new <code>Storage</code> structure (using <code>S.create</code>).</p> </li> <li> <p>Create a history which is just a list containing the initial board.   Push it onto the storage structure.</p> </li> <li> <p>Create an empty set of visited boards (using <code>DS.empty</code>).</p> </li> <li> <p>Repeat the following steps:</p> <ul> <li> <p>If the storage structure is empty,   the search has failed,   so raise the <code>Not_found</code> exception.</p> </li> <li> <p>Otherwise, pop a history off the storage structure. Then:</p> <ul> <li> <p>Check the most recent board in the history.   If it has already been seen   (use the set of visited boards to check for this),   throw the history away and go to the next one.</p> </li> <li> <p>Otherwise, check to see if the board solves the problem.   If so, return the history and you're done!</p> </li> <li> <p>Otherwise, add the board to the set of visited boards,   find the children of the current board   (using the <code>D.next</code> function,   which will actually be the <code>next</code> function you wrote in part A),   generate the new histories,   and push them back onto the storage structure.   Then continue.</p> </li> </ul> </li> </ul> </li> </ul> <p>Remember that in this function you need to use the correct module prefix to use functions from the <code>S</code> module (of module type <code>Storage</code>) and the <code>D</code> module (of module type <code>Domain</code>), so instead of <code>create</code>, <code>push</code>, <code>pop</code> etc. from module <code>S</code>, it's <code>S.create</code>, <code>S.push</code>, <code>S.pop</code> etc. and instead of <code>is_solved</code>, <code>compare</code>, <code>next</code> from module <code>D</code>, it's <code>D.is_solved</code>, <code>D.compare</code>, and <code>D.next</code>.</p> <p>As usual, it's OK to write helper functions. You may find the <code>List.iter</code> function useful.</p>"},{"location":"assignments/7/partB_search/#how-the-search-functor-is-used","title":"How the <code>Search</code> functor is used","text":"<p>Even if you've implemented the <code>Search</code> functor correctly, you may be confused as to how it is actually used. For that, look at the <code>klotski_solve.ml</code> file. It has this code:</p> <pre><code>open Klotski\nopen Search\n\nmodule DFS = Search(Stack)\nmodule BFS = Search(Queue)\nmodule K_DFS = DFS(Klotski)\nmodule K_BFS = BFS(Klotski)\n\nlet search_and_print search show b =\n  let h = search b in\n    begin\n      print_newline ();\n      print_string (show h);\n      Printf.printf \"Solution in %d moves.\\n\\n\" (List.length h - 1)\n    end\n\n(* ... using depth-first search with initial board b ... *)\n   search_and_print K_DFS.search K_DFS.show_history b\n\n(* ... using breadth-first search with initial board b ... *)\n   search_and_print K_BFS.search K_BFS.show_history b\n</code></pre> <p>We create two functors called <code>DFS</code> and <code>BFS</code> by partially instantiating the <code>Search</code> functor (OCaml lets you do this!), giving it a <code>Stack</code> or a <code>Queue</code> module argument, respectively (these modules are part of OCaml's standard library). Then we use those (single-argument) functors to generate the <code>K_DFS</code> and <code>K_BFS</code> modules, which provide the code needed to solve the Klotski problem using depth-first search or breadth-first search, respectively. Alternatively, we could have created <code>K_DFS</code> and <code>K_BFS</code> directly like this:</p> <pre><code>module K_DFS = Search(Stack)(Klotski)\nmodule K_BFS = Search(Queue)(Klotski)\n</code></pre> <p>Then we use <code>K_DFS.search</code> to search for the solution using DFS or <code>K_BFS.search</code> to search using BFS. We use <code>K_DFS.show_history</code> or <code>K_BFS.show_history</code> to display the solution (these are actually the same).</p> <p>This is a nice illustration of how using functors can decompose code along natural boundaries. If we had a new problem that could be solved using a tree search, we could use the exact same <code>DFS</code> and <code>BFS</code> modules as those given above to solve it. We would simply have to create a new <code>Domain</code> module representing the problem like we did for the Klotski problem in part A, and pass it to the <code>DFS</code> or <code>BFS</code> functor to generate a module that could do the searching and display the solution.</p> <p>The <code>show_history</code> function defined in the <code>Search</code> module will be used as the <code>show</code> argument in the <code>search_and_print</code> function.</p>"},{"location":"assignments/7/partB_search/#running-the-board-solver","title":"Running the board solver","text":"<p>We saw above how to run the interactive Klotski program. However, for some of the boards (e.g. boards 5-7), the minimum number of moves to solve the board is so large that it's not really reasonable to expect a human to be able to do it. Therefore, let's use computers! </p> <p>Once all the code above has been written, type <code>make</code> to compile the <code>klotski_solve</code> program. You can run it like this:</p> <pre><code>$ ./klotski_solve 0\n</code></pre> <p>and it will solve board 0 and print out the solution, like this:</p> <pre><code>$ ./klotski_solve 0\n\naabb\n.cc.\nddee\nffgh\nffij\n\n----\n\naabb\ncc..\nddee\nffgh\nffij\n\n----\n\naabb\nccee\ndd..\nffgh\nffij\n\n----\n\naabb\nccee\nddg.\nff.h\nffij\n\n----\n\naabb\nccee\ndd.g\nff.h\nffij\n\n----\n\naabb\nccee\nddig\nff.h\nff.j\n\n----\n\naabb\nccee\nddig\n.ffh\n.ffj\n\nSolution in 6 moves.\n</code></pre> <p>At the end, the program prints out how many moves the solution took. You can run the solver on any board from 0 to 7.</p> <p>To time the solver, you can run the program like this:</p> <pre><code>$ /usr/bin/time ./klotski_solve 7\n\n[... solution omitted ...]\n\nSolution in 150 moves.\n\n        5.31 real         5.28 user         0.03 sys\n</code></pre> <p>This means that the solver took just over 5 seconds to find the solution.</p> <p>By default, the board solver uses a breadth-first search algorithm to find the optimal solution (i.e. the one requiring the fewest moves). You can alternatively use depth-first search by adding the <code>-dfs</code> command-line argument, but don't expect a good result! For instance:</p> <pre><code>$ ./klotski_solve -dfs 0\n\n[... solution omitted ...]\n\nSolution in 1334 moves.\n</code></pre> <p>It sure looks like breadth-first search is the way to go for this problem.</p> <p>Note</p> <p>Don't worry if your program doesn't give the exact same number of DFS moves as reported here. DFS is not guaranteed to give the minimum number of moves (as you can see), and the exact number of moves depends on the details of how the search is set up (notably, the ordering of the boards when generating the next boards from a particular board).</p>"},{"location":"assignments/7/partB_search/#efficiency-of-the-board-solver","title":"Efficiency of the board solver","text":"<p>For full marks, the board solver should be \"reasonably efficient\". This means that none of the boards should take more than (say) 30 seconds to solve. (If you've written the code well and are running it on a reasonably fast computer, it's likely that it will take considerably less time than that.)</p>"},{"location":"assignments/final/background/","title":"Background information","text":""},{"location":"assignments/final/background/#puzzle-description","title":"Puzzle description","text":"<p>The Pentomino puzzle is a classic puzzle game. Pentomino pieces are each made of five squares connected to each other (like a \"domino\" is two squares connected to each other). There are 12 different pentomino pieces. Schematically, here are the shapes, along with the label we are assigning to each shape for the purposes of this exam:</p> <ul> <li> <p>Shape F:</p> <pre><code>.XX\nXX.\n.X.\n</code></pre> </li> <li> <p>Shape I:</p> <pre><code>X\nX\nX\nX\nX\n</code></pre> </li> <li> <p>Shape L:</p> <pre><code>X.\nX.\nX.\nXX\n</code></pre> </li> <li> <p>Shape N:</p> <pre><code>.X\n.X\nXX\nX.\n</code></pre> </li> <li> <p>Shape P:</p> <pre><code>XX\nXX\nX.\n</code></pre> </li> <li> <p>Shape T:</p> <pre><code>XXX\n.X.\n.X.\n</code></pre> </li> <li> <p>Shape U:</p> <pre><code>X.X\nXXX\n</code></pre> </li> <li> <p>Shape V (not L!):</p> <pre><code>X..\nX..\nXXX\n</code></pre> </li> <li> <p>Shape W:</p> <pre><code>X..\nXX.\n.XX\n</code></pre> </li> <li> <p>Shape X:</p> <pre><code>.X.\nXXX\n.X.\n</code></pre> </li> <li> <p>Shape Y:</p> <pre><code>..X.\nXXXX\n</code></pre> </li> <li> <p>Shape Z:</p> <pre><code>XX.\n.X.\n.XX\n</code></pre> </li> </ul> <p>In these diagrams, the <code>X</code>s represent the squares that are part of the shape; the <code>.</code>s are just part of the underlying board, given to make it clear what the exact shape is. As you can see, each of the shapes consists of exactly 5 squares, all connected to each other.</p> <p>The goal of a Pentomino puzzle is to place the shapes together so that they fill up a rectangular grid (we say that the pieces \"tile\" the grid). Pieces are not allowed to overlap on the grid (they can't cover the same locations). Pieces can, however, be rotated or reflected; this is because the puzzle originally was a physical puzzle using wooden pieces that could be rotated or flipped around. (You can still buy these puzzles; here is an example.)</p> <p>Grids are allowed to have specific squares which should not be occupied. All of the shapes combined can be used to fill up a 5x12 grid, a 6x10 grid, or some subset of the shapes can be used to fill up smaller grids. In some puzzles, pieces can be duplicated, in which case you use lower-case and upper-case letters to distinguish them in the solutions. (We won't be looking at puzzles that have more than two copies of any piece). If each piece is used exactly once, it can fill up a grid of area 60, or even a larger grid if holes are allowed. For example, this picture shows a tiling of the 8x8 grid with four empty squares in the middle:</p> <p></p> <p>The goal of the program you will be writing will be to automatically find solutions given particular grid dimensions, specified hole locations (for some grids) and a specified set of pentomino pieces to use. (Not all grids will use all pieces.) Note that some grid dimensions and/or piece sets may not result in a solution. (For instance, there is no way to find a solution using any of the pieces for a 1x2 grid, since no pieces can fit in that grid.)</p> <p>When printing a solution, we use the piece labels to indicate where the piece is in the solution. (We use lower-case letters unless a piece is duplicated, in which case we use both lower- and upper-case letters for that piece.)</p> <p>For instance, one solution to the 5x12 puzzle using all the pieces is as follows:</p> <pre><code>llxuutttpppy\nlxxxuvtwppyy\nlfxuuvtwwzzy\nlffvvvnnwwzy\nffiiiiinnnzz\n</code></pre> <p>Notice that adjacent locations with the same letter are part of the same piece. This is also the way your program will display solutions.</p> <p>As mentioned above, shapes are allowed to be rotated and/or reflected when placing them into the grid. In addition, in many cases, a puzzle will have multiple solutions. (Just rotating a solution of the 8x8 grid with the 2x2 hole in the center will give three more \"solutions\".)</p>"},{"location":"assignments/final/background/#outline-of-the-solution-algorithm","title":"Outline of the solution algorithm","text":"<p>We will be solving the Pentomino problem in a somewhat roundabout way. First, we will convert a description of a given Pentomino problem into a sparse binary matrix i.e. a matrix whose elements are either 0s or 1s, but mostly 0s. What the binary matrix signifies will be discussed in detail below. Then we will apply an algorithm to the binary matrix which will select a subset of the rows of the matrix, forming a submatrix. This submatrix will have the property that every column will have exactly one 1 and all the rest of the column values will be zeroes. Once we have this subset, we will map it back to the Pentomino problem to get the solution.</p> <p>The algorithm to find subsets of rows of binary matrices can be used for much more than just the Pentomino problem. For instance, Sudoku problems can also be translated into the same kind of binary matrix representation. The technical name for this kind of problem is the \"exact cover\" problem (see the Wikipedia entry). The specific algorithm we will use to solve this problem is called \"Algorithm X\" and was described by Donald Knuth (see the Wikipedia entry here). Even though the algorithm we will use is the same as Knuth's algorithm at a high level, the details are very different; Knuth used a method he called \"dancing links\" which is an imperative algorithm<sup>1</sup></p> <p>In part A, you will write functions to manipulate binary matrices. In part B, you will write a solver for exact cover problems expressed as binary matrices. In part C, you will write functions to convert Pentomino problems to binary matrices. The supplied code will tie all this together, allowing you to solve arbitrary Pentomino problems on rectangular grids.</p>"},{"location":"assignments/final/background/#running-the-pentomino_solve-program","title":"Running the <code>pentomino_solve</code> program","text":"<p>Ultimately, if you do everything right you will be able to compile and run a program called <code>pentomino_solve</code>. This program will be able to solve specific Pentomino problems (whose definition is encoded into the program). There are 13 Pentomino problems we've encoded; they are selected by number (0 up to and including 12). All are solvable.</p> <p>To run the program, just give it the number of the problem:</p> <pre><code>$ ./pentomino_solve 3\ntyyyy\ntttyl\ntllll\n\n$ ./pentomino_solve 4\nppuuu\nppufu\nlpfff\nllllf\n\n$ ./pentomino_solve 5\nllxuutttpppy\nlxxxuvtwppyy\nlfxuuvtwwzzy\nlffvvvnnwwzy\nffiiiiinnnzz\n\n$ ./pentomino_solve 9\nllxuuvvv\nlxxxuvzz\nlfxuuvzn\nlff  zzn\nffy  wnn\nyyyywwnt\npppwwttt\nppiiiiit\n</code></pre> <p>This shows the solution for puzzles number 3, 4, 5, and 9. Puzzle 9 is the 8x8 grid with the 2x2 hole in the middle we saw above. (Notice that it's not the same solution.)</p> <p>Our code can solve these problems generally taking no more than 2 seconds per problem, though occasionally it takes a bit longer.  Your code doesn't have to be that efficient, but if it takes much longer (say, more than 15 seconds for one problem) you are probably doing something wrong, or at least very inefficiently. We will take marks off for very inefficient solutions (more than 15 seconds on a problem).</p> <p>We recommend that you concentrate on making your code pass the test scripts for the individual modules we describe below. Only try the <code>pentomino_solve</code> program after all the test scripts pass. Once they do, run the <code>run_solutions.sh</code> shell script, which will generate solutions for all the 13 puzzles we encoded. You should consider this the final test of your program.</p> <ol> <li> <p>Actually, it's one of the most imperative algorithms we have ever encountered, featuring quadruply-linked doubly-circular lists, whereas our solution will be purely functional. If you are curious, you can download Knuth's dancing links paper here. Knuth's papers are incredibly dense but invariably contain many fascinating insights.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/final/final_exam/","title":"Final exam","text":""},{"location":"assignments/final/final_exam/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, March 15th, at 6 PM.</p>"},{"location":"assignments/final/final_exam/#coverage","title":"Coverage","text":"<p>This assignment covers all the material in the course, except for the special topics lectures.</p>"},{"location":"assignments/final/final_exam/#policies","title":"Policies","text":"<ul> <li> <p>There is no time limit on this exam, except that it must be handed in on time.</p> </li> <li> <p>This is an open-book exam. You may consult either or both of the textbooks.</p> </li> <li> <p>This is an open reference exam, with this exception: you may not search for or use specific solutions of the exam problems you find online or in a book, in a previous year's exam written by another student, or anywhere else, however unlikely it may be that you would find such a thing.</p> </li> <li> <p>This is an open interpreter/compiler exam. Specifically, you are allowed to use OCaml to develop and debug your code (and we very strongly recommend that you do this).</p> </li> <li> <p>This is a no-collaboration exam. Do not discuss the exam with anyone (verbally or in writing) before the due date, even if you both have turned in your exams already. You are also forbidden to discuss the exam on internet forums. Honor code rules apply. The only exception is to request a clarification of some point in the exam; you are allowed to email the course instructor and/or the course TAs for this purpose only.  </p> </li> <li> <p>As per the usual course policies, you may not use any code hinting software (e.g. Github Copilot or ChatGPT) to help you write any of your code.</p> </li> </ul>"},{"location":"assignments/final/final_exam/#formatting","title":"Formatting","text":"<p>Here is how your exam should be formatted.</p> <p>Note</p> <p>We may deduct a significant proportion of your midterm grade (up to 1/4 of the total grade) if you violate any of these rules. If you have any questions about these rules, contact us before starting the exam and we'll clarify them.</p> <ul> <li> <p>Your final exam should all be in three plain text files:</p> <ul> <li><code>binmat.ml</code></li> <li><code>solver.ml</code></li> <li><code>pentomino.ml</code></li> </ul> <p>(these exact names, lower case). Make sure that your files are plain text files! Check this by typing the following at a Unix prompt:</p> <pre><code>$ more binmat.ml\n$ more solver.ml\n$ more pentomino.ml\n</code></pre> <p>If it prints out your files in a readable manner, they are plain text.</p> </li> <li> <p>Make sure that all of the lines in your files have no more than 80 characters in a line.</p> </li> </ul>"},{"location":"assignments/final/final_exam/#about-the-exam","title":"About the exam","text":"<p>The exam as a whole is worth 30 marks. Like the other assignments and the midterm, it is graded out of 100 points, which will be scaled to 30 marks when computing your final grade.</p> <p>The exam consists of three sections. Specific point values are listed with the problem descriptions below.</p> <p>The exam is one big miniproject. The goal of the project is to write a program which can solve a class of spatial puzzles called Pentomino puzzles.</p> <p>You will solve these puzzles by first implementing a very general constraint satisfaction algorithm using binary matrices, and then converting Pentomino puzzles into binary matrices to solve them. If you do this right, each of the example puzzles will be solvable in a few seconds. (You won't even need to use the OCaml native-code compiler; bytecode-compiled OCaml will be sufficient.)</p> <p>The description of the puzzles and the algorithm used to solve them is quite long, but please read it through carefully before beginning. Failure to do so will drastically increase the time required to finish the exam successfully. Also, failure to do things exactly as we describe below will result in lost marks! There is no time limit, so take your time. Our solution (not including the supplied code, of which there is a lot) is less than 250 lines long, so if yours is much longer, you may be doing something wrong (or at least something that could be done with much less code). We hope you enjoy this exam!</p>"},{"location":"assignments/final/final_exam/#the-final-exam-submission","title":"The final exam submission","text":"<p>Your final exam submission will be in three files:</p> <ul> <li><code>binmat.ml</code></li> <li><code>solver.ml</code></li> <li><code>pentomino.ml</code></li> </ul> <p>(those exact names; uncapitalized and without a \"<code>.txt</code>\" extension, please!).</p> <p>The exam is divided into three CodePost submissions:</p> <ul> <li><code>Final_partA</code>: submit the <code>binmat.ml</code> file.</li> <li><code>Final_partB</code>: submit the <code>solver.ml</code> file.</li> <li><code>Final_partC</code>: submit the <code>pentomino.ml</code> file.</li> </ul> <p>The parts have the following maximum points on CodePost:</p> <ul> <li><code>Final_part_A</code>: 40 points</li> <li><code>Final_part_B</code>: 30 points</li> <li><code>Final_part_C</code>: 30 points</li> </ul> <p>Given that this is an exam, not an assignment, there will be no rework.</p> <p>Note</p> <p>The reason we are dividing this up into three submissions instead of having them all in one big submission is to allow TAs to just grade a single section, which makes grading go a lot faster.</p>"},{"location":"assignments/final/final_exam/#supplied-code","title":"Supplied code","text":"<p>We are providing you with several files of code which you should use as-is (i.e. don't edit these files), as well as template files for the submitted final exam files (<code>binmat.ml</code>, <code>pentomino.ml</code> and <code>solver.ml</code>) which have some of the code pre-written for you and which you will need to edit.  We are supplying you with a zip file called <code>final.zip</code> with all the supplied code. You can find this on the course Canvas site.</p> <p>Each of the files you need to submit will have places where the following code: <code>failwith \"TODO\"</code> is found. You should replace this code with your own code. Note that you are allowed to add more functions (e.g. helper functions) in addition to the ones already in the file, and we encourage you to do so if you find it helpful.</p> <p>Again, the files you need to edit and submit are:</p> <ul> <li><code>binmat.ml</code>    (CodePost submission: <code>Final_partA</code>)</li> <li><code>solver.ml</code>    (CodePost submission: <code>Final_partB</code>)</li> <li><code>pentomino.ml</code> (CodePost submission: <code>Final_partC</code>)</li> </ul> <p>The supporting files are:</p> <ul> <li><code>Makefile</code></li> <li><code>dune</code></li> <li><code>dune-project</code></li> <li><code>run_solutions.sh</code></li> <li><code>binmat.mli</code></li> <li><code>pentomino.mli</code></li> <li><code>pentomino_boards.mli</code></li> <li><code>pentomino_pieces.mli</code></li> <li><code>pentomino_types.mli</code></li> <li><code>pentomino_utils.mli</code></li> <li><code>solver.mli</code></li> <li><code>binmat_tests.ml</code></li> <li><code>pentomino_boards.ml</code></li> <li><code>pentomino_pieces.ml</code></li> <li><code>pentomino_solve.ml</code></li> <li><code>pentomino_tests.ml</code></li> <li><code>pentomino_types.ml</code></li> <li><code>pentomino_utils.ml</code></li> <li><code>solver_tests.ml</code></li> </ul> <p>Please do not edit any of the supporting files! You will not be submitting them, so we wouldn't see your edits anyway.</p>"},{"location":"assignments/final/final_exam/#the-makefile","title":"The <code>Makefile</code>","text":"<p>One of the supplied files is a <code>Makefile</code> which you should use to compile and test your code. There are several <code>Makefile</code> targets:</p> <ul> <li> <p>Typing <code>make</code> by itself will compile all the files except the tests. It will output a program called <code>pentomino_solve</code>, which will be described in part C below.</p> </li> <li> <p>Typing <code>make run_binmat_tests</code> will compile and run the <code>binmat_tests.ml</code> test script and report all test successes/failures.</p> </li> <li> <p>Typing <code>make run_solver_tests</code> will compile and run the <code>solver_tests.ml</code> test script and report all test successes/failures.</p> </li> <li> <p>Typing <code>make run_pentomino_tests</code> will compile and run the <code>pentomino_tests.ml</code> test script and report all test successes/failures.</p> </li> <li> <p>Typing <code>make clean</code> will remove all compilation targets (object code, executables, generated test files etc.) but will leave all source code alone.</p> </li> <li> <p>Typing <code>make repl</code> will start up <code>utop</code> in a special way so that you can interactively test all the code in the exam. We will discuss this further below. This is only to help you debug your code; if you don't have many bugs, you may not need to use it.</p> </li> </ul> <p>In addition, there is the script <code>run_solutions.sh</code>, which is a Unix shell script. Once you have compiled your <code>pentomino</code> program, it will test it by asking it to find solutions of a number of Pentomino boards using various sets of pieces. You can run this program by typing</p> <pre><code>$ ./run_solutions.sh\n</code></pre> <p>at the terminal prompt (assuming that the <code>pentomino_solve</code> program is in the same directory). If this doesn't work for some reason, you can try either:</p> <pre><code>$ chmod +x run_solutions.sh\n$ ./run_solutions.sh\n</code></pre> <p>or:</p> <pre><code>$ sh run_solutions.sh\n</code></pre> <p>The program should print all of the solutions to the terminal. This is a good way to test your finished program after testing all the parts separately.</p> <p>Note</p> <p>The solver tests in <code>tests_solver.ml</code> are not very comprehensive, so it's a very good idea to run the <code>run_solutions.sh</code> script to verify that the <code>pentomino</code> program is really working correctly.</p>"},{"location":"assignments/final/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/final/ocaml_notes/#records","title":"Records","text":"<p>The code in the final exam uses OCaml records fairly heavily. Note that if you have a record and you only want to update a single field in the record, you can do this easily by using this syntax:</p> <pre><code># type rcd = { foo : int; bar : string; baz: float };;\ntype rcd = { foo : int; bar : string; baz : float; }\n\n# let r = { foo = 1; bar = \"bar\"; baz = 3.14 };;\nval r : rcd = {foo = 1; bar = \"bar\"; baz = 3.14}\n\n# let r' = { r with foo = 42 } ;;\nval r' : rcd = {foo = 42; bar = \"bar\"; baz = 3.14}\n</code></pre> <p>You can also modify more than one field:</p> <pre><code># let r'' = { r with foo = 42; baz = 1.1 };;\nval r'' : rcd = {foo = 42; bar = \"bar\"; baz = 1.1}\n</code></pre> <p>Note that these are purely functional updates; the original record is not changed, but a new record is created which shares some of the fields of the old record as well as some different ones.</p>"},{"location":"assignments/final/ocaml_notes/#testing","title":"Testing","text":"<p>Please run the test scripts while you are writing the code! We are supplying you with three test scripts (one for each section), so just run the test script corresponding to the section you are working on. In addition, comment out all tests that are not relevant to the code you are working on and just run the relevant tests. You don't want to write hundreds of lines of code before starting the testing process! If you do this, you may find that you have made a fundamental mistake early on, and you'll have to rewrite most of your code. Instead, write a little code, then test a little code, and repeat until done.</p> <p>We have written the test scripts so that it's easy to comment out tests for a particular problem just by commenting out a single line at the end of the test script. Feel free to look at the test scripts in your editor; they're just OCaml code.</p>"},{"location":"assignments/final/ocaml_notes/#design-guidelines","title":"Design guidelines","text":"<p>The main guideline we want you to follow is that all of the code you will write should be purely functional. You will not need to use references in any of your code, and you should not! There is one place where you will use arrays, but you will use them in a non-imperative way i.e. you will create the arrays with the necessary contents and never change them afterwards. You also will not need to user <code>while</code> or <code>for</code> loops anywhere. Unnecessary use of imperative code will result in lost marks. We will guide you in what data structures to use below; if you use them as we suggest, you won't have a problem.</p>"},{"location":"assignments/final/partA_binmat/","title":"Part A: The <code>Binmat</code> module (40 points)","text":"<p>The code for this section will be written in the file <code>binmat.ml</code>. The functions in this section implement the functionality of a sparse binary matrix. You have to write eight (8) functions. None of them require more than 35 lines of code in all (including helper functions), while most require substantially less. Some of the simpler functions are written for you; these are also described below.</p> <p>Inside the template code in <code>binmat.ml</code> you will see the definition of the <code>BinaryMatrix</code> module type:</p> <pre><code>module type BinaryMatrix =\nsig\ntype t\n\nval make : int -&gt; int -&gt; (int * int) list -&gt; t\n\nval nrows : t -&gt; int\nval ncols : t -&gt; int\nval rows  : t -&gt; int list\nval cols  : t -&gt; int list\n\nval get : t -&gt; int -&gt; int -&gt; bool\n\nval dump : t -&gt; unit\n\nval rows_for_col : t -&gt; int -&gt; int list\nval cols_for_row : t -&gt; int -&gt; int list\n\nval delete_row : t -&gt; int -&gt; t\nval delete_col : t -&gt; int -&gt; t\n\nval min_col_sum_index : t -&gt; int\nend\n</code></pre> <p>This module type describes the interface of a binary matrix without specifying its data representation. (The code in section B will only depend on this interface, because it will define a functor which takes a module implementing this interface as its argument.) Below this in the template file you will see this definition:</p> <pre><code>module ImplBinaryMatrix : BinaryMatrix =\nstruct\ntype t =\n{\n_nrows : int;\n_ncols : int;\n\n(* Map between row indices and sets of column indices. *)\n_rows : IntSet.t IntMap.t;\n\n(* Map between columns indices and sets of row indices. *)\n_cols : IntSet.t IntMap.t;\n}\n\n(* ... functions on the binary matrix datatype ... *)\nend\n</code></pre> <p>Your job for this section is to complete the code in the <code>ImplBinaryMatrix</code> module. We will discuss the type <code>t</code> below.</p>"},{"location":"assignments/final/partA_binmat/#data-representation","title":"Data representation","text":"<p>A binary matrix, abstractly, is a mapping between (row, column) coordinates and 0/1 values. There are a number of ways in which you could represent a binary matrix. You could have an array of int arrays, where each int array contained only 0s or 1s. Or each int array could contain boolean values, where <code>false</code> represents 0 and <code>true</code> represents 1. Neither of these representations would be functional, since OCaml arrays are imperative (they can be updated in place at any location). Or you could have a list or set of (row, column) coordinates, representing where the 1s are located in the array. This representation would be functional (lists and sets are immutable in OCaml), but it might be costly to scan through every element in order to do each operation. We will use a representation which is different from all of these.</p> <p>The binary matrices we will be working with have the property that they are very sparse, which means that the vast majority of locations in the array are going to be zeroes. Therefore, it makes sense to only represent where the 1s in the array are located. The representation we will use is as follows:</p> <pre><code>(* Set of integers. *)\nmodule IntSet = Set.Make(struct\ntype t = int\nlet compare = Stdlib.compare\nend)\n\n(* Map using ints as keys. *)\nmodule IntMap = Map.Make(struct\ntype t = int\nlet compare = Stdlib.compare\nend)\n\nmodule ImplBinaryMatrix =\nstruct\n(* The binary matrix type: *)\ntype t =\n{\n_nrows : int;\n_ncols : int;\n\n(* Map between row indices and sets of column indices. *)\n_rows : IntSet.t IntMap.t;\n\n(* Map between columns indices and sets of row indices. *)\n_cols : IntSet.t IntMap.t;\n}\n\n(* ... functions on the binary matrix datatype ... *)\nend\n</code></pre> <p>Let's walk through this code.</p> <p>The <code>IntSet</code> and <code>IntMap</code> modules represent sets of integers (<code>IntSet</code>s) and maps from integers to other datatypes (<code>IntMap</code>s). They are defined using the <code>Set.Make</code> and <code>Map.Make</code> functors, respectively. Each of these functors takes an <code>OrderedType</code> argument representing a type along with a comparison function that will work on the type. Here, the <code>OrderedType</code> instance is provided as a direct (anonymous) module argument to each functor. (You can do this!) The type of sets of integers is <code>IntSet.t</code> and the type of maps from integers to arbitrary datatypes is <code>IntMap.t</code>. <code>IntMap.t</code> is polymorphic (the keys are always <code>int</code>s, but you can use any value type), but each particular use of <code>IntMap.t</code> will have a specific value type stored at each key. In this case, the value type is <code>IntSet.t</code> (so rows and columns are both maps from integers to sets of integers), but we'll get to that in a moment.</p> <p>The datatype representing the binary matrix is just the type <code>t</code> inside the <code>ImplBinaryMatrix</code> module; outside of it it's called <code>ImplBinaryMatrix.t</code>. This is a record type with four fields:</p> <ul> <li> <p><code>_nrows</code>: the number of rows in the binary matrix</p> </li> <li> <p><code>_ncols</code>: the number of columns in the binary matrix</p> </li> <li> <p><code>_rows</code>: a map between integers (representing row indices) and sets of integers (representing all the column indices at that row)</p> </li> <li> <p><code>_cols</code>: a map between integers (representing column indices) and sets of integers (representing all the row indices at that column)</p> </li> </ul> <p>The <code>_nrows</code> and <code>_ncols</code> fields are self-explanatory. The <code>_rows</code> and <code>_cols</code> fields are slightly more complicated. The <code>_rows</code> field represents the rows of the matrix by putting a key into the <code>_rows</code> map for each nonempty row in the matrix. Each key is associated with a set of all the column indices of that row which have 1s. Similarly, the <code>_cols</code> field represents the columns of the matrix by putting a key in the <code>_cols</code> map for each nonempty column which is associated with a set of all the row indices of that column which have 1s.</p> <p>Note that this representation is redundant; when you set a particular (row, column) location to 1, you have to adjust both the <code>_rows</code> and the <code>_cols</code> maps. Similarly, to flip a 1 to a 0 at a particular (row, column) location, you have to delete values from both the the <code>_rows</code> and the <code>_cols</code> maps. Note that since all of our maps are functional (immutable), you won't be adding/deleting in-place; you will have to create a new binary matrix for each change.</p> <p>The reason for using this representation instead of e.g. a set of (row, column) locations is that it's much more efficient given the operations we will need to do on our binary matrices.</p> <p>Do not change this representation! Even if you think this representation is bad or is too confusing, you are required to use it. If you change it in any way, you will get no credit for this section.</p>"},{"location":"assignments/final/partA_binmat/#library-functionsvalues-we-used","title":"Library functions/values we used","text":"<p>For this section, we used the following library functions. You aren't restricted to just using these; you can use any functions in the <code>List</code> module, as well as any <code>IntSet</code> or <code>IntMap</code> functions. Conversely, you are not required to use any of these functions, but you are well-advised to consider using them, as they can drastically shorten the amount of code you need to write.</p> <p>To see what these functions do, see the library documentation for the List, the Set.S, and the Map.Make modules.</p> <p>Note</p> <p>The documentation for the <code>Set.S</code> and <code>Map.Make</code> \"modules\" is just the documentation for all set and map modules constructed using the set and map functors. It includes all the functions you can use on sets and maps.</p> <ul> <li><code>List.fold_left</code></li> <li> <p><code>List.map</code></p> </li> <li> <p><code>IntSet.add</code></p> </li> <li><code>IntSet.cardinal</code></li> <li><code>IntSet.elements</code></li> <li><code>IntSet.iter</code></li> <li><code>IntSet.mem</code></li> <li><code>IntSet.remove</code></li> <li> <p><code>IntSet.singleton</code></p> </li> <li> <p><code>IntMap.add</code></p> </li> <li><code>IntMap.bindings</code></li> <li><code>IntMap.empty</code></li> <li><code>IntMap.find</code></li> <li><code>IntMap.find_opt</code></li> <li><code>IntMap.iter</code></li> <li><code>IntMap.remove</code></li> </ul> <p>We very strongly recommend that you use these functions instead of writing e.g. helper functions that implement the same functionality.</p>"},{"location":"assignments/final/partA_binmat/#functions-to-write","title":"Functions to write","text":"<p>Here are the functions in the <code>ImplBinaryMatrix</code> module. Each function you need to write has its mark value listed in boldface. Some functions have been supplied for you; we describe them below, but obviously there are no marks associated with them.</p> <p>Before we get into the details of the functions, here's a testing tip. If you want to play around with these functions in the OCaml interpreter, do this:</p> <pre><code># #use \"binmat.ml\";;\n# open ImplBinaryMatrix;;\n</code></pre> <p>Now all the functions in the <code>ImplBinaryMatrix</code> module are accessible directly, e.g.:</p> <pre><code># make;;\n- : int -&gt; int -&gt; (int * int) list -&gt; ImplBinaryMatrix.t = &lt;fun&gt;\n</code></pre>"},{"location":"assignments/final/partA_binmat/#1-make","title":"1. <code>make</code>","text":"<p>[10 points]</p> <p>This function takes three arguments:</p> <ul> <li> <p><code>nrows</code>, the number of rows (a positive integer)</p> </li> <li> <p><code>ncols</code>, the number of columns (a positive integer)</p> </li> <li> <p><code>lst</code>, a list of pairs of integers (row, column coordinates), representing all the locations in the binary matrix which have 1s (the rest are assumed to all be zeros)</p> </li> </ul> <p>It constructs and returns a new binary matrix using the data representation given above. It signals errors (using the <code>invalid_arg</code> function to raise an <code>Invalid_argument</code> exception) if the numbers of rows or columns are negative or zero, or if any of the (row, column) coordinates have values that are out of range (negative or <code>&gt;=</code> to <code>_nrows</code> or <code>_ncols</code>, respectively).</p> <p>Warning</p> <p>Error checking is not optional! You will lose marks if you don't implement it as directed.</p> <p>The binary matrix returned by this function should only have non-empty sets as values in the <code>_rows</code> or <code>_cols</code> fields of the matrix. So please do not e.g. put in empty sets for each possible row or column index; doing so will result in lost marks, plus your code won't run correctly. Later, we will see that some matrix operations can result in empty set values, and this is necessary for the solution algorithm to work properly.</p> <p>In the examples below, we use the <code>nrows</code>, <code>ncols</code>, <code>get</code> and <code>dump</code> functions, all of which are given to you in the template code and described below.</p> <p>Examples</p> <pre><code># make 2 3 [(0, 1); (1, 0); (1, 2)];;\n- : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n(* This corresponds to the binary matrix:\n\n0 1 0\n1 0 1\n\ni.e. two rows and three columns, with 1s at (0, 1), (1, 0), and (1, 2)\n((row = 0, column = 1), (row = 1, column = 0), (row = 1, column = 2)).\n\nWhen we display binary matrices, row coordinates go from top to bottom,\nwith 0 on top. Column coordinates go from left to right, with 0 on the left.\n*)\n\n# make (-2) 3 [(0, 1); (1, 0); (1, 2)];;\nException: Invalid_argument \"make: nrows must be at least 1\".\n\n# make 2 0 [(0, 1); (1, 0); (1, 2)];;\nException: Invalid_argument \"make: ncols must be at least 1\".\n\n# make 2 3 [(0, 1); (1, 0); (2, 2)];;\nException: Invalid_argument \"make: invalid row/column coordinates: (2, 2)\".\n(* (row = 2, column = 2) are invalid coordinates for a board\n   of dimensions 2x3, since there is no row with index 2. *)\n\n# make 2 3 [(0, 1); (1, -1); (1, 2)];;\nException: Invalid_argument \"make: invalid row/column coordinates: (1, -1)\".\n\n# let m = make 2 3 [(0, 1); (1, 0); (1, 2)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# nrows m;;\n- : int = 2\n\n# ncols m;;\n- : int = 3\n\n# get m 0 0;;\n- : bool = false\n(* `get` returns a boolean value, not a 0 or 1 *)\n\n# get m 0 1;;\n- : bool = true\n\n# get m 0 2;;\n- : bool = false\n\n# get m 1 0;;\n- : bool = true\n\n# get m 1 1;;\n- : bool = false\n\n# get m 1 2;;\n- : bool = true\n\n# dump m;;\n(* `dump` prints out a description of the binary matrix to the terminal *)\n\n-----\nIMPL_BINARY_MATRIX: nrows = 2; ncols = 3\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 1\nrow:    1; columns: 0 2\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 1\ncolumn:    1; rows: 0\ncolumn:    2; rows: 1\n-----\n\n- : unit = ()\n</code></pre> <p>Hint</p> <p>Create an empty binary matrix, then write a helper function that adds a single (row, column) coordinate to the matrix, returning a new matrix. Apply that function successively to each coordinate in the list. (The <code>List.fold_left</code> function is helpful for problems like this.) Don't forget to update the <code>_rows</code> and <code>_cols</code> sets when adding coordinates.</p>"},{"location":"assignments/final/partA_binmat/#nrows","title":"<code>nrows</code>","text":"<p>Given a binary matrix as argument, this function returns the number of rows in the binary matrix. The code is supplied for you.</p>"},{"location":"assignments/final/partA_binmat/#ncols","title":"<code>ncols</code>","text":"<p>Given a binary matrix as argument, this function returns the number of columns in the binary matrix. The code is supplied for you.</p>"},{"location":"assignments/final/partA_binmat/#2-rows","title":"2. <code>rows</code>","text":"<p>[2 points]</p> <p>Given a binary matrix as argument, this function returns a list of all the row indices stored in the <code>_rows</code> map. (These are the keys of the map.). The indices do not have to be in any particular order.</p> <p>Examples</p> <pre><code># let m = make 2 3 [(0, 1); (1, 0); (1, 2)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# rows m;;\n- : int list = [0; 1]\n</code></pre>"},{"location":"assignments/final/partA_binmat/#3-cols","title":"3. <code>cols</code>","text":"<p>[2 points]</p> <p>Given a binary matrix as argument, this function returns a list of all the column indices stored in the <code>_cols</code> map. (These are the keys of the map.). The indices do not have to be in any particular order.</p> <p>Examples</p> <pre><code># let m = make 2 3 [(0, 1); (1, 0); (1, 2)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# cols m;;\n- : int list = [0; 1; 2]\n</code></pre>"},{"location":"assignments/final/partA_binmat/#get","title":"<code>get</code>","text":"<p>This function is supplied for you. It takes three arguments: a binary matrix, a row index, and a column index. It returns the value at that (row, column) location in the binary matrix as a <code>true</code> or <code>false</code> value. If the (row, column) locations are outside the bounds of the binary matrix, it just returns <code>false</code>. Put differently, given a row and column index, it returns <code>true</code> if there is a <code>1</code> at that row, column location in the binary matrix and <code>false</code> otherwise.</p>"},{"location":"assignments/final/partA_binmat/#dump","title":"<code>dump</code>","text":"<p>This function is supplied for you. It takes one argument (a binary matrix) and prints out a text description of the contents of the matrix. This is very useful for debugging.</p> <p>Examples</p> <pre><code># let m = make 2 3 [(0, 1); (1, 0); (1, 2)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m;;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 2; ncols = 3\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 1\nrow:    1; columns: 0 2\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 1\ncolumn:    1; rows: 0\ncolumn:    2; rows: 1\n-----\n\n- : unit = ()\n</code></pre>"},{"location":"assignments/final/partA_binmat/#4-rows_for_col","title":"4. <code>rows_for_col</code>","text":"<p>[5 points]</p> <p>This function takes two arguments: a binary matrix and a column index. It looks up the column index in the <code>_cols</code> field of the matrix and returns a list of all the row indices for that column (which are the locations of all the 1s in that column). If the column index isn't in the <code>_cols</code> map, it raises a <code>Failure</code> exception with an error message (the <code>failwith</code> function is convenient here); it does not return an empty list. (On the other hand, if the column index maps to an empty set, it does return an empty list.) The row indices in the returned list don't have to be in any particular order.</p> <p>Examples</p> <pre><code># let m = make 4 5 [(0, 0); (0, 4); (1, 1); (1, 2);\n                    (2, 0); (2, 2); (2, 3); (3, 2); (3, 4)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n(* This corresponds to the binary matrix:\n1 0 0 0 1\n0 1 1 0 0\n1 0 1 1 0\n0 0 1 0 1\n*)\n\n# dump m;;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# rows_for_col m (-1);;\nException: Failure \"rows_for_col: missing column index: -1\".\n\n# rows_for_col m 0;;\n- : int list = [0; 2]\n\n# rows_for_col m 1;;\n- : int list = [1]\n\n# rows_for_col m 2;;\n- : int list = [1; 2; 3]\n\n# rows_for_col m 3;;\n- : int list = [2]\n\n# rows_for_col m 4;;\n- : int list = [0; 3]\n\n# rows_for_col m 5;;\nException: Failure \"rows_for_col: missing column index: 5\".\n</code></pre>"},{"location":"assignments/final/partA_binmat/#5-cols_for_row","title":"5. <code>cols_for_row</code>","text":"<p>[5 points]</p> <p>This function takes two arguments: a binary matrix and a row index. It looks up the row index in the <code>_rows</code> field of the matrix and returns a list of all the column indices for that row (which are the locations of all the 1s in that row). If the row index isn't in the <code>_rows</code> map, it raises a <code>Failure</code> exception with an error message; it does not return an empty list. (On the other hand, if the row index maps to an empty set, it does return an empty list.) The column indices in the returned list don't have to be in any particular order.</p> <p>Examples</p> <pre><code># let m = make 4 5 [(0, 0); (0, 4); (1, 1); (1, 2);\n                    (2, 0); (2, 2); (2, 3); (3, 2); (3, 4)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m;;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# cols_for_row m (-1);;\nException: Failure \"cols_for_row: missing row index: -1\".\n\n# cols_for_row m 0;;\n- : int list = [0; 4]\n\n# cols_for_row m 1;;\n- : int list = [1; 2]\n\n# cols_for_row m 2;;\n- : int list = [0; 2; 3]\n\n# cols_for_row m 3;;\n- : int list = [2; 4]\n\n# cols_for_row m 4;;\nException: Failure \"cols_for_row: missing row index: 4\".\n</code></pre>"},{"location":"assignments/final/partA_binmat/#6-delete_row","title":"6. <code>delete_row</code>","text":"<p>[5 points]</p> <p>This function takes two arguments: a binary matrix and the index of a row to delete. It returns a new binary matrix without that row. (The input binary matrix is unaltered.) If the row is invalid (either it is out of range or there is no such row in the <code>_rows</code> field of the matrix), raise a <code>Failure</code> exception with an error message. Otherwise, delete the row from the <code>_rows</code> map. Also go through each column in the <code>_cols</code> map and remove the row index from all the row sets that have it.</p> <p>Note</p> <p>We need to be clear about the terminology here. When we say \"delete\" a row, we don't mean that you have to change all the row indices of all the rows after the row being deleted. The (row, column) indices of the remaining rows should stay the same. What we mean by \"deleting a row\" is that all of the entries in that row that used to be 1s are now 0s. Since only (row, column) locations that represent 1s in the matrix are stored, this is equivalent to deleting those locations. Conceptually, though, those locations are still in the matrix, but their values are 0s (and thus, they aren't stored in this representation of the matrix). We also have to make sure that the <code>_rows</code> and <code>_cols</code> maps no longer contain any of the locations that have been removed from the matrix.</p> <p>The same considerations apply when deleting columns.</p> <p>This is not a long function, but there are a couple of subtleties you should be aware of. Deleting a row index from a row set in the <code>_cols</code> field may result in an empty row set; that is not a mistake. Empty sets are not allowed in the <code>_rows</code> or <code>_cols</code> field when the binary matrix is first created using the <code>make</code> function, but it's OK if deleting a row or column causes a previously nonempty set to become empty. If a set in the <code>_cols</code> map becomes empty, do not delete it from <code>_cols</code>. This is important for the functioning of the algorithm we'll describe in the next section.</p> <p>Also, if you try to delete a row whose index is not a key in the <code>_rows</code> map, it's an error and a <code>Failure</code> exception must be raised (though it doesn't have to originate in this function).</p> <p>Hint</p> <p>The <code>cols_for_row</code> function you defined previously will be very helpful to you here. We also found the <code>List.fold_left</code> function to be useful.</p> <p>Examples</p> <pre><code># let m = make 4 5 [(0, 0); (0, 4); (1, 1); (1, 2);\n                    (2, 0); (2, 2); (2, 3); (3, 2); (3, 4)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m;;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# delete_row m (-1);;\nException: Failure \"cols_for_row: missing row index: -1\".\n\n# delete_row m 4;;\nException: Failure \"cols_for_row: missing row index: 4\".\n\n# dump (delete_row m 0);;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 3\n-----\n\n- : unit = ()\n\n# let m' = delete_row m 0;;\n# delete_row m' 0;;  (* deleting a nonexistent row fails *)\nException: Failure \"cols_for_row: missing row index: 0\".\n\n# dump (delete_row m 1);  (* delete row 1 from original matrix *)\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows:            (* empty row set! *)\ncolumn:    2; rows: 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# dump (delete_row m 2);;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 3\ncolumn:    3; rows:            (* empty row set! *)\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# dump (delete_row m 3);;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0\n-----\n\n- : unit = ()\n</code></pre> <p>As mentioned above, deleting a row can make some of the row sets in the <code>_cols</code> field of a binary matrix empty. (You can see that here.) In other words, the <code>_cols</code> map may have some column indices  mapping to empty sets after deleting a row.</p>"},{"location":"assignments/final/partA_binmat/#7-delete_col","title":"7. <code>delete_col</code>","text":"<p>[5 points]</p> <p>This function is just like <code>delete_row</code>, except that here you are deleting columns instead of rows.</p> <p>Examples</p> <pre><code># let m = make 4 5 [(0, 0); (0, 4); (1, 1); (1, 2);\n                    (2, 0); (2, 2); (2, 3); (3, 2); (3, 4)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m;;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# delete_col m (-1);;\nException: Failure \"rows_for_col: missing column index: -1\".\n\n# delete_col m 5;;\nException: Failure \"rows_for_col: missing column index: 5\".\n\n# dump (delete_col m 0);;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 4\nrow:    1; columns: 1 2\nrow:    2; columns: 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# dump (delete_col m 1);;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# dump (delete_col m 2);;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1\nrow:    2; columns: 0 3\nrow:    3; columns: 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n</code></pre>"},{"location":"assignments/final/partA_binmat/#8-min_col_sum_index","title":"8. <code>min_col_sum_index</code>","text":"<p>[6 points]</p> <p>This function takes one argument, which is a binary matrix. It returns the index of the column which has the smallest column sum i.e. the column with the fewest number of 1s of all the columns. Note: you should only consider the column indices which are keys in the <code>_cols</code> map. (This is necessary for the algorithm in the next section to work properly.) If more than one column has the minimum number of 1s, return the index of the first such column.</p> <p>Note</p> <p>The algorithm will work correctly if you return the index of any column with the minimum number of 1s. We ask that you return the first such column in order to make the tests deterministic.</p> <p>We found the functions <code>IntMap.bindings</code> and <code>IntSet.cardinal</code> to be useful in our solution.</p> <p>Examples</p> <pre><code># let m = make 4 5 [(0, 0); (0, 4); (1, 1); (1, 2);\n                    (2, 0); (2, 2); (2, 3); (3, 2); (3, 4)];;\nval m : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m;;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# min_col_sum_index m;;\n- : int = 1\n(* Columns 1 and 3 have exactly 1 \"1\".  Either is an acceptable answer. *)\n\n# let m' = delete_row m 2;;\nval m' : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m';;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 1 2\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0\ncolumn:    1; rows: 1\ncolumn:    2; rows: 1 3\ncolumn:    3; rows:\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# min_col_sum_index m';;\n- : int = 3   (* Column 3 is the only column with no \"1\"s. *)\n\n# let m'' = delete_col m 1;;\nval m'' : ImplBinaryMatrix.t = &lt;abstr&gt;\n\n# dump m'';;\n\n-----\nIMPL_BINARY_MATRIX: nrows = 4; ncols = 5\n\nROW -&gt; COLUMN SET MAP:\nrow:    0; columns: 0 4\nrow:    1; columns: 2\nrow:    2; columns: 0 2 3\nrow:    3; columns: 2 4\n\nCOLUMN -&gt; ROW SET MAP:\ncolumn:    0; rows: 0 2\ncolumn:    2; rows: 1 2 3\ncolumn:    3; rows: 2\ncolumn:    4; rows: 0 3\n-----\n\n- : unit = ()\n\n# min_col_sum_index m'';;\n- : int = 3\n\n(*\n* Column 3 has only 1 \"1\".  Column 1 has no \"1\"s at all, but it doesn't count\n* because it's been deleted and isn't in the _cols map.\n*)\n</code></pre>"},{"location":"assignments/final/partB_solver/","title":"Part B: The <code>Solver</code> module (30 points)","text":"<p>The code for this file will be written in the file <code>solver.ml</code>. You will define a functor called <code>AlgorithmX</code> which contains a single function called <code>solve</code>. This function can be written in less than 30 lines. It will allow you to \"solve\" a binary matrix, which means to find a subset of the rows where the column sums of each of the columns in the subset are all 1. The solution will be a set of integers representing the row indices from the original binary matrix.</p>"},{"location":"assignments/final/partB_solver/#1-solve","title":"1. <code>solve</code>","text":"<p>[30 points]</p> <p>Write the <code>solve</code> function in the <code>AlgorithmX</code> functor.</p> <p>The <code>AlgorithmX</code> functor looks like this:</p> <pre><code>module AlgorithmX(B : BinaryMatrix) =\n  struct\n    (* If the algorithm is successful, return a set of integers.\n     * Otherwise, return nothing. *)\n    let solve (matrix : B.t) : IntSet.t option = failwith \"TODO\"\n  end\n</code></pre> <p>and you have to fill in the code marked <code>failwith \"TODO\"</code>.</p> <p>The <code>solve</code> function takes one argument, which is a binary matrix. Because this code is inside a functor, the binary matrix doesn't have to be an <code>ImplBinaryMatrix</code>, but it has to conform to the <code>BinaryMatrix</code> module type (which <code>ImplBinaryMatrix</code> does). In fact, we will only be using it with the <code>ImplBinaryMatrix</code> module you wrote in the previous section. The <code>solve</code> function, if successful, will return a set of integers as an <code>IntSet.t option</code> value i.e. if the output set is <code>s</code>, it would return <code>Some s</code>. If the function is not successful, it will return <code>None</code>.</p> <p>Here's an outline of the algorithm to use. You start with the entire binary matrix and an initially empty set of integers representing the indices of the rows to pick. Call a helper function taking these as the arguments. In that helper function:</p> <ol> <li> <p>If there are no columns left in the matrix at all, the algorithm has terminated successfully, so return the set of row indices as <code>Some &lt;set of indices&gt;</code>.</p> </li> <li> <p>Otherwise, find the column that has the fewest number of 1s in it.</p> </li> <li> <p>Find the rows which have a 1 at that column index. If there was a column with no 1s in it at all, then there will be no rows with a 1 at that index, which means that the algorithm has terminated unsuccessfully. In that case, return <code>None</code>. Otherwise, pick a row from the ones that have a 1 at that column index, and:</p> <ol> <li> <p>for each column in that row that has a 1:</p> <ol> <li> <p>for each row in that column that has a 1 (including the row you selected!), delete the row,</p> </li> <li> <p>and then delete the column.</p> </li> </ol> <p>What this does is make sure that the row you selected is the only row that has a 1 in that column. After that, we don't care about that column anymore, so we can delete it.</p> </li> <li> <p>add the index of the row you selected to the set of row indices.</p> </li> </ol> </li> <li> <p>Recursively apply the algorithm to the reduced matrix (go to step 1). If it returns <code>None</code>, you need to go back to step 3 and try a different row which has a 1 in it. (Make sure you also go back to the matrix before it had all the rows and columns removed!) If it returns <code>Some &lt;set of indices&gt;</code>, you have a solution, so just return that. If there are no more rows to try, return <code>None</code>.</p> </li> </ol> <p>Our solution used the following functions:</p> <ul> <li><code>B.cols</code></li> <li><code>B.cols_for_row</code></li> <li><code>B.delete_col</code></li> <li><code>B.delete_row</code></li> <li><code>B.min_col_sum_index</code></li> <li><code>B.rows_for_col</code></li> <li><code>IntSet.add</code></li> <li><code>List.fold_left</code></li> </ul> <p>The <code>B.</code> functions are from whichever <code>BinaryMatrix</code> implementation is given to the functor. In our case, they will be from the <code>ImplBinaryMatrix</code> module. Our solution was about 30 lines of code. (However, we used higher-order functions like <code>List.fold_left</code> extensively. Don't feel bad if your solution is longer, as long as it works!)</p> <p>Warning</p> <p>Inside the <code>solve</code> function, do not hard-code the <code>ImplBinaryMatrix</code> module anywhere; use the <code>B</code> module, which is the functor's input argument.</p> <p>You are encouraged to define and use helper functions as you see fit. They will need to go inside the functor if they do anything with binary matrices. The trickiest part of the algorithm is removing the rows and columns correctly. That can be done in a single non-recursive helper function of less than 10 lines if you use the <code>List.fold_left</code> higher-order function for iteration through the rows and columns. (Our solution consisted of that function and two other mutually-recursive helper functions.) Note that since this is functional programming, \"removing\" a row or column from a matrix means returning a new matrix without that row or column.</p> <p>Make sure that your code is purely functional! Any use of imperative code will result in a significant penalty. Don't even use <code>while</code> or <code>for</code> loops.</p> <p>The  Wikipedia page on Algorithm X has a good description of the algorithm. We will use their example below. We strongly recommend that you read the Wikipedia page to see their walkthrough of the algorithm on this example (we could reproduce it here, but it wouldn't be any different).</p> <p>Example</p> <pre><code>(* \n\n   First compile binmat.mli and binmat.ml e.g.\n\n   $ ocamlc -c binmat.mli\n   $ ocamlc -c binmat.ml\n\n*)\n\n# #load \"binmat.cmo\";;\n# #use \"solver.ml\";;\n# open ImplBinaryMatrix;;\n\n(* Make a binary matrix. *)\n# let m = make 6 7 [(0, 0); (0, 3); (0, 6); \n                    (1, 0); (1, 3); \n                    (2, 3); (2, 4); (2, 6);\n                    (3, 2); (3, 4); (3, 5);\n                    (4, 1); (4, 2); (4, 5); (4, 6);\n                    (5, 1); (5, 6)];;\n\n(* This corresponds to this binary matrix:\n\n   1 0 0 1 0 0 1\n   1 0 0 1 0 0 0\n   0 0 0 1 1 0 1\n   0 0 1 0 1 1 0\n   0 1 1 0 0 1 1\n   0 1 0 0 0 0 1\n\n*)\n\n(* Use the AlgorithmX functor to define a module that works with the\n   ImplBinaryMatrix module you defined in the previous section. *)\n# module Alg = AlgorithmX(ImplBinaryMatrix);;\n\n(* Use the Alg module to solve the binary matrix m. *)\n# let sol = Alg.solve m;;\nval sol : Binmat.IntSet.t option = Some &lt;abstr&gt;\n\n(* Woo hoo!  We have a solution!  Let's extract it: *)\n# let (Some sol') = sol;;\nWarning 8: this pattern-matching is not exhaustive.\nHere is an example of a case that is not matched:\nNone\n(* This warning is not important. *)\nval sol' : Binmat.IntSet.t = &lt;abstr&gt;\n\n(* Now convert the set of integers into a list of integers. *)\n# IntSet.elements sol';;\n- : Binmat.IntSet.elt list = [1; 3; 5]\n\n(* \n\n   This shows us that rows 1, 3, and 5 solve the problem.  Look at the binary\n   matrix consisting only of those rows:\n\n   1 0 0 1 0 0 0\n   0 0 1 0 1 1 0\n   0 1 0 0 0 0 1\n\n   Notice how each column has exactly one 1.\n\n*)\n</code></pre>"},{"location":"assignments/final/partC_pentomino/","title":"Part C: The <code>Pentomino</code> module (30 points)","text":"<p>If everything has gone well so far, you have a way to solve problems expressed as binary matrices, but you don't have any interesting binary matrices! In this section we will show you how to convert a Pentomino problem into its binary matrix representation.</p>"},{"location":"assignments/final/partC_pentomino/#pentomino-problem-representation","title":"Pentomino problem representation","text":"<p>First, let's see how we are representing Pentomino problems in their normal representation. A Pentomino problem consists of two things: a board on which the Pentomino pieces should be placed, and a set of pieces to place.</p> <p>Note</p> <p>A rectangular \"board\" can also have designated \"holes\" in it i.e. locations where pieces shouldn't go. Conceptually, these aren't really part of the board. We will consider the board to be the set of all the locations that should be occupied when the board is solved.</p> <p>The piece and board datatypes are defined in the file <code>pentomino_types.ml</code>, and specific pieces are defined in the file <code>pentomino_pieces.ml</code>. Here is the board type definition:</p> <pre><code>type board =\n  {\n    nrows  : int ;\n    ncols  : int ;\n    member : loc -&gt; bool   (* is a location part of this board? *)\n  }\n</code></pre> <p>Boards are defined as a rectangular grid of dimensions <code>nrows</code> rows by <code>ncols</code> columns, along with a <code>member</code> function which allows us to exclude specific locations from the grid (<code>member</code> would return <code>false</code> for those locations).</p> <p>Here is the piece type definition:</p> <pre><code>type loc = int * int  (* row, column coordinates *)\n\nmodule LocSet = Set.Make(struct\n  type t = loc\n  let compare = Stdlib.compare\nend)\n\ntype piece = { label : char ; locs : LocSet.t }\n</code></pre> <p>Pieces are thus represented as a one-character label and a set of locations (row, column coordinates) that they occupy. Each Pentomino piece will have exactly 5 locations, all of which are orthogonally adjacent (but the datatype doesn't enforce that). A particular Pentomino problem will also have a set of pieces (called a <code>PieceSet</code>) where none of the pieces have the same character label.</p> <p>A string representation of all the pieces is provided in the file <code>pentomino_pieces.ml</code>. In that file, you start with a piece description like this:</p> <pre><code>let pf_s = \"\\n.XX\\nXX.\\n.X.\\n\"\n</code></pre> <p>If we printed this out, it would look like this:</p> <pre><code>.XX\nXX.\n.X.\n</code></pre> <p>which is the \"F\" pentomino piece.</p> <p>We can refer to the piece as a pair of this string and its label (i.e. <code>('f', pf_s)</code>). This will eventually be converted to the set-of-locations piece representation. We will refer to pieces represented this way as being in their \"string representation\". A number of functions accept lists of pieces in this form as one of their arguments.</p>"},{"location":"assignments/final/partC_pentomino/#binary-matrix-conversion","title":"Binary matrix conversion","text":"<p>Before we get into the details of converting a Pentomino problem (board and pieces) to a binary matrix, let's look at the problem from a high level.</p> <p>Note</p> <p>Don't skip this section! If you do, you will not understand how the algorithm works for Pentomino problems.</p> <p>The rows of a binary matrix correspond to components of the solution. In our case, they correspond to pieces, but even though there are only 12 pieces, there are usually many more than 12 rows! For a particular Pentomino problem (board and pieces), you need to compute every possible placement of all the Pentomino pieces on the board in all possible orientations. Each placement of a particular piece in a particular orientation constitutes a row of the matrix. Selecting a subset of these rows selects a set of pieces which (you hope) tiles the board exactly.</p> <p>The columns of the binary matrix correspond to constraints on the placements of the pieces. Each location on the board is one constraint, because only one piece in a particular position and orientation may occupy that location. In addition, all pieces in a solution have to have distinct letter labels to enforce the constraint that only one of each kind of piece can be on the board. So there will be one constraint per letter label. So if a board uses all 12 pieces, there will be 12 + N columns in the binary matrix, where N is the number of locations on the board. So a board with 60 locations will give rise to a binary matrix with 72 columns.</p> <p>Note that the constraints specify not only that only one piece can occupy a location, and only one piece of each type can be used, but also that all locations must be occupied, and all pieces must be used. This corresponds to picking a subset of the rows where each column (each constraint) has exactly one 1 in it (a given location is only occupied once, or a given piece is only selected once). And that's exactly what the algorithm in part B does!</p> <p>For a particular row (which is a particular piece with a particular label in a particular position and orientation), we put 1s in the columns that correspond to the locations that the piece occupies, and also a 1 in the column that corresponds to the character label of the piece. All other locations in the row will have 0s. Then we repeat this for all rows to get the full binary matrix.</p> <p>The code you will write in this section will allow you to create binary matrices given a particular board and a set of pieces. The code you have already written will be used to solve the binary matrices.</p>"},{"location":"assignments/final/partC_pentomino/#functions-to-write","title":"Functions to write","text":"<p>Here are the functions you need to write in the <code>Pentomino</code> module (in the file <code>pentomino.ml</code>). Each function you need to write has its point value listed in boldface. Several of the functions have been supplied for you; we describe them below, but obviously there are no points associated with them.</p> <p>To test these functions interactively in the OCaml interpreter, first compile these files:</p> <pre><code>$ ocamlc -c pentomino_pieces.mli\n$ ocamlc -c pentomino_pieces.ml\n$ ocamlc -c pentomino_types.mli\n$ ocamlc -c pentomino_types.ml\n</code></pre> <p>Then do this in the OCaml interpreter:</p> <pre><code># #load \"pentomino_pieces.cmo\";;\n# #load \"pentomino_types.cmo\";;\n# #use \"pentomino.ml\";;\n</code></pre> <p>Once again, the description of the functions is rather long, but none of the functions has to be. None of our functions is longer than 15 lines of code, and many are much shorter.</p>"},{"location":"assignments/final/partC_pentomino/#make_piece","title":"<code>make_piece</code>","text":"<p>This function is provided for you. It makes a piece given a two-tuple containing a character label and a list of locations. (It's really only used for testing.)</p> <p>Examples</p> <pre><code># let p = make_piece ('f', [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]) ;;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# p.label ;;\n- : char = 'f'\n\n# p.locs ;;\n- : LocSet.t = &lt;abstr&gt;\n\n# LocSet.elements p.locs ;;\n- : loc list = [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#make_piece_from_string","title":"<code>make_piece_from_string</code>","text":"<p>This function is provided for you. It makes a piece given a two-tuple containing a character label and a string that represents the piece pictorially. The piece string's non-whitespace characters are either <code>\".\"</code> (for a location which is not part of the piece) or <code>\"X\"</code> (for a location which is part of the piece).</p> <p>Examples</p> <pre><code># let pf_s = \"\\n.XX\\nXX.\\n.X.\\n\"\nval pf_s : string = \"\\n.XX\\nXX.\\n.X.\\n\"\n\n# let p = make_piece_from_string ('f', pf_s) ;;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# p.label ;;\n- : char = 'f'\n\n# p.locs ;;\n- : LocSet.t = &lt;abstr&gt;\n\n# LocSet.elements p.locs ;;\n- : loc list = [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#show_piece","title":"<code>show_piece</code>","text":"<p>This function is provided for you. It takes a piece as its argument and prints out a representation of the piece to the terminal. (This is primarily used for debugging.)</p> <p>Examples</p> <pre><code># let pf_s = \"\\n.XX\\nXX.\\n.X.\\n\";;\nval pf_s : string = \"\\n.XX\\nXX.\\n.X.\\n\"\n\n# let p = make_piece_from_string ('f', pf_s) ;;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p;;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#1-translate_piece","title":"1. <code>translate_piece</code>","text":"<p>[2 points]</p> <p>This function takes three arguments: a piece, a row coordinate change, and a column coordinate change. It returns a new piece with all the coordinates shifted by the (row, column) changes given. The piece label is unchanged.</p> <p>Examples</p> <pre><code># let p = make_piece ('f', [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]) ;;\nval p : Pentomino_types.piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p ;;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n\n# let p' = translate_piece p 2 3 ;;\nval p' : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p' ;;\nLABEL: 'f'; LOCS: (2, 4) (2, 5) (3, 3) (3, 4) (4, 4)\n- : unit = ()\n\n# let p'' = translate_piece p (-10) 200 ;;\nval p'' : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p'' ;;\nLABEL: 'f'; LOCS: (-10, 201) (-10, 202) (-9, 200) (-9, 201) (-8, 201)\n- : unit = ()\n</code></pre> <p>We found the <code>LocSet.map</code> function helpful in solving this problem, but it isn't required.</p>"},{"location":"assignments/final/partC_pentomino/#2-normalize_piece","title":"2. <code>normalize_piece</code>","text":"<p>[4 points]</p> <p>This function takes a piece as its argument and returns a new piece whose coordinates have been moved (translated) by a fixed amount in the (row, column) directions. The translation is such that the minimum row and column coordinates of the pieces are both zero. All locations get translated by the same amount in the (row, column) directions, but the row translation may not be the same as the column translation. The piece label is unchanged.</p> <p>You should probably use the <code>translate_piece</code> function in the definition of this function. We also found the <code>LocSet.fold</code> function to be useful, but it isn't required (there are other ways to do this).</p> <p>Examples</p> <pre><code># let p = make_piece ('f', [(10, 12); (10, 13); (11, 11); (11, 12); (12, 12)]);;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p;;\nLABEL: 'f'; LOCS: (10, 12) (10, 13) (11, 11) (11, 12) (12, 12)\n- : unit = ()\n\n# let p' = normalize_piece p;;\nval p' : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p';;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n\n# let p = make_piece ('f', [(-5, -9); (-5, -8); (-4, -10); (-4, -9); (-3, -9)]);;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# let p' = normalize_piece p;;\nval p' : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p';;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#3-reflect_piece","title":"3. <code>reflect_piece</code>","text":"<p>[2 points]</p> <p>This function takes a piece as its argument and returns a new piece which is \"reflected\" in the vertical direction (around the column axis) and normalized. It will do this by negating the column coordinates of all piece locations and then normalizing the piece using the <code>normalize_piece</code> function.  This is equivalent to flipping the piece over.  The piece label is unchanged.</p> <p>Examples</p> <pre><code># let p = make_piece ('f', [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]) ;;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p;;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n\n# let p' = reflect_piece p;;\nval p' : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p';;\nLABEL: 'f'; LOCS: (0, 0) (0, 1) (1, 1) (1, 2) (2, 1)\n- : unit = ()\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#4-rotate_piece","title":"4. <code>rotate_piece</code>","text":"<p>[2 points]</p> <p>This function takes a piece as its argument and returns a piece which is like the original piece except rotated clockwise and normalized. It will do this by negating the row coordinates of each location, swapping the row/column coordinates, and then normalizing the piece. (Yes, this works!) The piece label is unchanged.</p> <p>Examples</p> <pre><code># let p = make_piece ('f', [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]) ;;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p ;;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n\n# let p' = rotate_piece p;;\nval p' : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p';;\nLABEL: 'f'; LOCS: (0, 1) (1, 0) (1, 1) (1, 2) (2, 2)\n- : unit = ()\n\n# let q = make_piece ('i', [(0, 0); (1, 0); (2, 0); (3, 0); (4, 0)]);;\nval q : piece = {label = 'i'; locs = &lt;abstr&gt;}\n\n# show_piece q;;\nLABEL: 'i'; LOCS: (0, 0) (1, 0) (2, 0) (3, 0) (4, 0)\n- : unit = ()\n\n# let q' = rotate_piece q;;\nval q' : piece = {label = 'i'; locs = &lt;abstr&gt;}\n\n# show_piece q';;\nLABEL: 'i'; LOCS: (0, 0) (0, 1) (0, 2) (0, 3) (0, 4)\n- : unit = ()\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#piece_in_all_orientations","title":"<code>piece_in_all_orientations</code>","text":"<p>This function is provided for you. It takes a piece as its argument and returns a set of pieces (a <code>PieceSet</code>) with the piece in all possible (normalized) orientations. It does this by rotating the piece between 0 and 3 times and reflecting each of the rotated pieces. This gives a total of 8 orientations for a given piece. Note that all the pieces in the set have the same character label.</p>"},{"location":"assignments/final/partC_pentomino/#all_normalized_pieces","title":"<code>all_normalized_pieces</code>","text":"<p>This function is provided for you. It takes a list of pieces in their string representation (an example of this is the <code>all_pieces</code> list in <code>pentomino_pieces.ml</code>), and uses them to make a set of all the pieces in all possible orientations. All the pieces in the set are normalized.</p>"},{"location":"assignments/final/partC_pentomino/#on_board","title":"<code>on_board</code>","text":"<p>This function is provided for you. It takes two arguments: a piece and a board (the types are defined in <code>pentomino_types.ml</code>). It returns <code>true</code> if the piece can be placed on the board, and <code>false</code> otherwise. For this function to return <code>true</code>, all the piece coordinates must be in the range of the allowed board coordinates and the <code>member</code> function must return <code>true</code> for all of them.</p>"},{"location":"assignments/final/partC_pentomino/#5-translate_piece_on_board","title":"5. <code>translate_piece_on_board</code>","text":"<p>[4 points]</p> <p>This function takes two arguments: a board and a piece. It returns a set of pieces. The pieces in the set consist of all possible translations of the original piece (which is assumed to be normalized) on the board. This is done by translating the original piece (using the <code>translate_piece</code> function) by all possible (row, column) offsets between 0 and the number of (rows, columns) on the board, and then checking to see if the resulting pieces are in fact on the board (using the <code>on_board</code> function described above). Of course, all the pieces in the set have the same character label.</p> <p>You do not have to do any rotations or reflections of the pieces for this function, and you should not.</p> <p>Examples</p> <pre><code># let p = make_piece ('f', [(0, 1); (0, 2); (1, 0); (1, 1); (2, 1)]) ;;\nval p : piece = {label = 'f'; locs = &lt;abstr&gt;}\n\n# show_piece p;;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\n- : unit = ()\n\n# let brd = { nrows = 4; ncols = 4; member = fun _ -&gt; true } ;;\nval brd : board = {nrows = 4; ncols = 4; member = &lt;fun&gt;}\n\n# let ps = translate_piece_on_board brd p ;;\nval ps : PieceSet.t = &lt;abstr&gt;\n\n# let ps_list = PieceSet.elements ps ;;\nval ps_list : piece list =\n  [{label = 'f'; locs = &lt;abstr&gt;}; {label = 'f'; locs = &lt;abstr&gt;};\n   {label = 'f'; locs = &lt;abstr&gt;}; {label = 'f'; locs = &lt;abstr&gt;}]\n\n# List.iter show_piece ps_list ;;\nLABEL: 'f'; LOCS: (0, 1) (0, 2) (1, 0) (1, 1) (2, 1)\nLABEL: 'f'; LOCS: (0, 2) (0, 3) (1, 1) (1, 2) (2, 2)\nLABEL: 'f'; LOCS: (1, 1) (1, 2) (2, 0) (2, 1) (3, 1)\nLABEL: 'f'; LOCS: (1, 2) (1, 3) (2, 1) (2, 2) (3, 2)\n- : unit = ()\n(* These are the four possible positions of this piece\n on a 4x4 board without rotating or reflecting it. *)\n\n# let brd2 = { nrows = 8; ncols = 8; member = fun _ -&gt; true } ;;\nval brd2 : board = {nrows = 8; ncols = 8; member = &lt;fun&gt;}\n\n# let ps2 = translate_piece_on_board brd2 p ;;\nval ps2 : PieceSet.t = &lt;abstr&gt;\n\n# PieceSet.cardinal ps2 ;;\n- : int = 36\n(* The \"cardinal\" function on sets just returns the number of items in the set.\n This piece can have any of 36 different locations on an 8x8 board. *)\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#all_pieces_on_board","title":"<code>all_pieces_on_board</code>","text":"<p>This function is provided for you. It takes a list of pieces in their string representation, and a board, and returns a set of all possible placements of all pieces on the board. It does this by generating all possible orientations of each piece (using the <code>all_normalized_pieces</code> function) and then using the <code>translate_piece_on_board</code> function to translate these pieces with particular orientations to all their possible locations on the board.</p>"},{"location":"assignments/final/partC_pentomino/#6-make_piece_array","title":"6. <code>make_piece_array</code>","text":"<p>[4 points]</p> <p>This function takes two arguments: a list of pieces in their string representation, and a board. It uses the <code>all_pieces_on_board</code> function to generate all possible orientations and locations of the pieces on the board, and then converts the set of pieces to an array of pieces, which is returned.</p> <p>Hint</p> <p>Convert the set of pieces to a list of pieces first, then use the <code>Array.of_list</code> function to generate the array. This is a very short function.</p> <p>Note that the length of the piece array is actually the number of rows in the binary matrix we will be generating, since each row corresponds to a single piece in a particular location/orientation on a board.</p> <p>Examples</p> <pre><code># let piece_string_list = Pentomino_pieces.all_pieces;;\nval piece_string_list : (char * string) list =\n  [('f', \"\\n.XX\\nXX.\\n.X.\\n\"); ('i', \"\\nX\\nX\\nX\\nX\\nX\\n\");\n   ('l', \"\\nX.\\nX.\\nX.\\nXX\\n\"); ('n', \"\\n.X\\n.X\\nXX\\nX.\\n\");\n   ('p', \"\\nXX\\nXX\\nX.\\n\"); ('t', \"\\nXXX\\n.X.\\n.X.\\n\"); ('u', \"\\nX.X\\nXXX\\n\");\n   ('v', \"\\nX..\\nX..\\nXXX\\n\"); ('w', \"\\nX..\\nXX.\\n.XX\\n\");\n   ('x', \"\\n.X.\\nXXX\\n.X.\\n\"); ('y', \"\\n..X.\\nXXXX\\n\");\n   ('z', \"\\nXX.\\n.X.\\n.XX\\n\")]\n\n# let brd = { nrows = 5; ncols = 12; member = fun _ -&gt; true } ;;\nval brd : board = {nrows = 5; ncols = 12; member = &lt;fun&gt;}\n\n# let arr = make_piece_array piece_string_list brd ;;\nval arr : piece array =\n  [|{label = 'f'; locs = &lt;abstr&gt;}; {label = 'f'; locs = &lt;abstr&gt;};\n    {label = 'f'; locs = &lt;abstr&gt;}; {label = 'f'; locs = &lt;abstr&gt;};\n    {label = 'f'; locs = &lt;abstr&gt;}; {label = 'f'; locs = &lt;abstr&gt;};\n    ...}; ...|]\n# Array.length arr ;;\n- : int = 1936\n(* There are 1936 possible piece placements on this board. *)\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#all_locs_on_board","title":"<code>all_locs_on_board</code>","text":"<p>This function is provided for you. It takes a board as its argument and returns a list of all the locations on the board as (row, column) coordinates.</p>"},{"location":"assignments/final/partC_pentomino/#7-make_constraints_array","title":"7. <code>make_constraints_array</code>","text":"<p>[3 points]</p> <p>Now that we know what the rows of our binary matrix will correspond to, we need to work on the columns. Since the columns represent constraints, this function will generate an array of constraints given a list of pieces in their string representation, and a board. So what is a \"constraint\", anyway? Above, we mentioned that there are two kinds of constraints for this problem:</p> <ul> <li> <p>location constraints (i.e. that exactly one piece must cover each location on the board);</p> </li> <li> <p>piece constraints (i.e. that only one piece with a given character label should be placed on the board).</p> </li> </ul> <p>We need to generate an array of these constraints, so we define the following type (in <code>pentomino_types.ml</code>):</p> <pre><code>type pconstraint =\n  | Loc of loc\n  | Label of char\n</code></pre> <p>Note</p> <p>I wanted to call this type <code>constraint</code>, but <code>constraint</code> is a keyword in OCaml!</p> <p>The array that is returned from this function is a <code>pconstraint array</code>. To generate it, you need to compute all the board locations (using the <code>all_locs_on_board</code> function), make them into <code>pconstraint</code>s using the <code>Loc</code> constructor, extract all the piece labels from the list of pieces, make them into <code>pconstraint</code>s using the <code>Label</code> constructor, concatenate all of these <code>pconstraint</code>s and convert them into an array. Simple! :-) (Actually, it only takes a few lines of code.)</p> <p>Examples</p> <pre><code># let piece_string_list = Pentomino_pieces.all_pieces ;;\nval piece_string_list : (char * string) list =\n  [('f', \"\\n.XX\\nXX.\\n.X.\\n\"); ('i', \"\\nX\\nX\\nX\\nX\\nX\\n\");\n   ('l', \"\\nX.\\nX.\\nX.\\nXX\\n\"); ('n', \"\\n.X\\n.X\\nXX\\nX.\\n\");\n   ('p', \"\\nXX\\nXX\\nX.\\n\"); ('t', \"\\nXXX\\n.X.\\n.X.\\n\"); ('u', \"\\nX.X\\nXXX\\n\");\n   ('v', \"\\nX..\\nX..\\nXXX\\n\"); ('w', \"\\nX..\\nXX.\\n.XX\\n\");\n   ('x', \"\\n.X.\\nXXX\\n.X.\\n\"); ('y', \"\\n..X.\\nXXXX\\n\");\n   ('z', \"\\nXX.\\n.X.\\n.XX\\n\")]\n\n# let brd = { nrows = 5; ncols = 5; member = fun _ -&gt; true } ;;\nval brd : board = {nrows = 5; ncols = 5; member = &lt;fun&gt;}\n\n# make_constraints_array piece_string_list brd ;;\n- : pconstraint array =\n[|Loc (4, 4); Loc (4, 3); Loc (4, 2); Loc (4, 1); Loc (4, 0); Loc (3, 4);\n  Loc (3, 3); Loc (3, 2); Loc (3, 1); Loc (3, 0); Loc (2, 4); Loc (2, 3);\n  Loc (2, 2); Loc (2, 1); Loc (2, 0); Loc (1, 4); Loc (1, 3); Loc (1, 2);\n  Loc (1, 1); Loc (1, 0); Loc (0, 4); Loc (0, 3); Loc (0, 2); Loc (0, 1);\n  Loc (0, 0); Label 'f'; Label 'i'; Label 'l'; Label 'n'; Label 'p';\n  Label 't'; Label 'u'; Label 'v'; Label 'w'; Label 'x'; Label 'y'; Label 'z'|]\n\n(* Note that there is one constraint for every location on the board and\n   one for every piece label.  The order doesn't matter. *)\n</code></pre>"},{"location":"assignments/final/partC_pentomino/#8-make_constraints_map","title":"8. <code>make_constraints_map</code>","text":"<p>[3 points]</p> <p>OK, so now we have the constraints array, which we can think of as a map between integers (the indices of the array) and constraints. But (as we will see in the final problem) what we actually need is a map between constraints and indices! Fortunately, we have defined a suitable type in <code>pentomino_types.ml</code> called <code>PconstraintMap</code>:</p> <pre><code>(* Map using pconstraints as keys. *)\nmodule PconstraintMap = Map.Make(struct\n  type t = pconstraint\n  let compare = Stdlib.compare\nend)\n</code></pre> <p>An empty <code>PconstraintMap</code> would be <code>PconstraintMap.empty</code> and we can add to it like we would with any map type. So the function <code>make_constraints_map</code> will take the same arguments as <code>make_constraints_array</code> did, but it will create and return a <code>PconstraintMap</code> instead. It will do this by first calling <code>make_constraints_array</code> to get the constraints array, and then by walking through the array, adding each (constraint, array index) pair to the map. This is also a pretty simple function.</p> <p>Examples</p> <pre><code># let piece_string_list = Pentomino_pieces.all_pieces ;;\nval piece_string_list : (char * string) list =\n  [('f', \"\\n.XX\\nXX.\\n.X.\\n\"); ('i', \"\\nX\\nX\\nX\\nX\\nX\\n\");\n   ('l', \"\\nX.\\nX.\\nX.\\nXX\\n\"); ('n', \"\\n.X\\n.X\\nXX\\nX.\\n\");\n   ('p', \"\\nXX\\nXX\\nX.\\n\"); ('t', \"\\nXXX\\n.X.\\n.X.\\n\"); ('u', \"\\nX.X\\nXXX\\n\");\n   ('v', \"\\nX..\\nX..\\nXXX\\n\"); ('w', \"\\nX..\\nXX.\\n.XX\\n\");\n   ('x', \"\\n.X.\\nXXX\\n.X.\\n\"); ('y', \"\\n..X.\\nXXXX\\n\");\n   ('z', \"\\nXX.\\n.X.\\n.XX\\n\")]\n\n# let brd = { nrows = 5; ncols = 5; member = fun _ -&gt; true } ;;\nval brd : board = {nrows = 5; ncols = 5; member = &lt;fun&gt;}\n\n# let cmap = make_constraints_map piece_string_list brd ;;\nval cmap : int PconstraintMap.t = &lt;abstr&gt;\n\n# PconstraintMap.bindings cmap ;;\n- : (pconstraint * int) list =\n[(Loc (0, 0), 24); (Loc (0, 1), 23); (Loc (0, 2), 22); (Loc (0, 3), 21);\n (Loc (0, 4), 20); (Loc (1, 0), 19); (Loc (1, 1), 18); (Loc (1, 2), 17);\n (Loc (1, 3), 16); (Loc (1, 4), 15); (Loc (2, 0), 14); (Loc (2, 1), 13);\n (Loc (2, 2), 12); (Loc (2, 3), 11); (Loc (2, 4), 10); (Loc (3, 0), 9);\n (Loc (3, 1), 8); (Loc (3, 2), 7); (Loc (3, 3), 6); (Loc (3, 4), 5);\n (Loc (4, 0), 4); (Loc (4, 1), 3); (Loc (4, 2), 2); (Loc (4, 3), 1);\n (Loc (4, 4), 0); (Label 'f', 25); (Label 'i', 26); (Label 'l', 27);\n (Label 'n', 28); (Label 'p', 29); (Label 't', 30); (Label 'u', 31);\n (Label 'v', 32); (Label 'w', 33); (Label 'x', 34); (Label 'y', 35);\n (Label 'z', 36)]\n</code></pre> <p>In the example, we see how, given a location or a label, we can find the corresponding index in the constraints array. These indices will also be the column indices in our binary matrix, which leads us to the last problem!</p>"},{"location":"assignments/final/partC_pentomino/#9-make_binary_matrix_locs","title":"9. <code>make_binary_matrix_locs</code>","text":"<p>[6 points]</p> <p>Now we come to the final function, which is the point of the entire section. We want to create a binary matrix, given a list of Pentomino pieces (again in the string representation) and a board to place them on. The output will be a set of (row, column) locations in the binary matrix (which are the 1s of the binary matrix; all other locations are 0s).</p> <p>Here is an outline of the algorithm:</p> <ul> <li> <p>Make a piece array from the piece list and the board like you did above.</p> </li> <li> <p>Make a constraints map from the piece list and the board like you did above.</p> </li> <li> <p>For each piece in the piece array, you have its index, which will be the row index in the binary array. Take all the locations that the piece occupies, as well as the character label of the piece, and make constraints from them. Look these constraints up in the constraints map to get the column indices for the binary array where there are 1s for this row index. Combine the row index with the column indices to get the locations in the binary matrix which should be 1s.</p> </li> <li> <p>Concatenate all the binary matrix locations from the previous step into one big list, which contains the locations of all the 1s in the binary matrix. Convert this list into a <code>LocSet</code> and return it.</p> </li> </ul> <p>Examples</p> <pre><code># let board = { nrows = 3; ncols = 5; member = fun _ -&gt; true } ;;\nval board : board = {nrows = 3; ncols = 5; member = &lt;fun&gt;}\n\n# let pl_s = \"\\nX.\\nX.\\nX.\\nXX\\n\" ;;  (* \"L\" piece *)\nval pl_s : string = \"\\nX.\\nX.\\nX.\\nXX\\n\"\n\n# let pt_s = \"\\nXXX\\n.X.\\n.X.\\n\" ;;   (* \"T\" piece *)\nval pt_s : string = \"\\nXXX\\n.X.\\n.X.\\n\"\n\n# let py_s = \"\\n..X.\\nXXXX\\n\"  ;;     (* \"Y\" piece *)\nval py_s : string = \"\\n..X.\\nXXXX\\n\"\n\n# let pieces = [('l', pl_s); ('t', pt_s); ('y', py_s)] ;;\nval pieces : (char * string) list =\n  [('l', \"\\nX.\\nX.\\nX.\\nXX\\n\"); ('t', \"\\nXXX\\n.X.\\n.X.\\n\");\n   ('y', \"\\n..X.\\nXXXX\\n\")]\n\n# make_piece_array pieces board ;;\n- : piece array =\n[|{label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 'l'; locs = &lt;abstr&gt;}; {label = 'l'; locs = &lt;abstr&gt;};\n  {label = 't'; locs = &lt;abstr&gt;}; {label = 't'; locs = &lt;abstr&gt;};\n  {label = 't'; locs = &lt;abstr&gt;}; {label = 't'; locs = &lt;abstr&gt;};\n  {label = 't'; locs = &lt;abstr&gt;}; {label = 't'; locs = &lt;abstr&gt;};\n  {label = 't'; locs = &lt;abstr&gt;}; {label = 't'; locs = &lt;abstr&gt;};\n  {label = 't'; locs = &lt;abstr&gt;}; {label = 't'; locs = &lt;abstr&gt;};\n  {label = 't'; locs = &lt;abstr&gt;}; {label = 't'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;};\n  {label = 'y'; locs = &lt;abstr&gt;}; {label = 'y'; locs = &lt;abstr&gt;}|]\n\n# Array.length (make_piece_array pieces board) ;;\n- : int = 44\n\n# make_constraints_array pieces board ;;\n- : pconstraint array =\n[|Loc (2, 4); Loc (2, 3); Loc (2, 2); Loc (2, 1); Loc (2, 0); Loc (1, 4);\n  Loc (1, 3); Loc (1, 2); Loc (1, 1); Loc (1, 0); Loc (0, 4); Loc (0, 3);\n  Loc (0, 2); Loc (0, 1); Loc (0, 0); Label 'l'; Label 't'; Label 'y'|]\n\n# Array.length (make_constraints_array pieces board) ;;\n- : int = 18\n\n# let locs = make_binary_matrix_locs pieces board ;;\nval locs : LocSet.t = &lt;abstr&gt;\n\n# LocSet.cardinal locs ;;\n- : int = 264\n\n# LocSet.elements locs ;;\n- : loc list =\n[(0, 9); (0, 11); (0, 12); (0, 13); (0, 14); (0, 15); (1, 6); (1, 11);\n (1, 12); (1, 13); (1, 14); (1, 15); (2, 6); (2, 7); (2, 8); (2, 9);\n (2, 14); (2, 15); (3, 8); (3, 10); (3, 11); (3, 12); (3, 13); (3, 15);\n (4, 5); (4, 10); (4, 11); (4, 12); (4, 13); (4, 15); (5, 5); (5, 6);\n (5, 7); (5, 8); (5, 13); (5, 15); (6, 6); (6, 7); (6, 8); (6, 9); (6, 11);\n (6, 15); (7, 5); (7, 6); (7, 7); (7, 8); (7, 10); (7, 15); (8, 4); (8, 6);\n (8, 7); (8, 8); (8, 9); (8, 15); (9, 1); (9, 6); (9, 7); (9, 8); (9, 9);\n (9, ...); ...]\n\n(* And there they are!\n   These are the coordinates of the 1s in the binary matrix\n   that corresponds to this Pentomino problem.\n   Hand this over to the rest of the program for solving. *)\n</code></pre>"},{"location":"assignments/final/rest/","title":"The rest of the program","text":"<p>Even if you've implemented the code in all three sections correctly, you may be unclear on how all the parts of the program fit together. For that, look at the <code>pentomino_solve.ml</code> file.  It has this code:</p> <pre><code>open Final\nopen Pentomino_pieces\nopen Pentomino_types\nopen Pentomino\nopen Pentomino_utils\nopen Pentomino_boards\nopen Binmat\nopen Solver\n\nmodule FindSolutions(B: BinaryMatrix) =\n struct\n   module Alg = AlgorithmX(B)\n\n   let get_solution piece_string_list board =\n     let nrows = Array.length (make_piece_array piece_string_list board) in\n     let ncols = Array.length (make_constraints_array piece_string_list board) in\n     let coords_set = make_binary_matrix_locs piece_string_list board in\n     let coords = LocSet.elements coords_set in\n     let binmat = B.make nrows ncols coords in\n       Alg.solve binmat\n\n   let show_solution piece_string_list board =\n     match get_solution piece_string_list board with\n       | None -&gt; Printf.printf \"No solution found.\\n\"\n       | Some sol -&gt;\n           let pieces = make_piece_array piece_string_list board in\n           let indices = IntSet.elements sol in\n             if validate_solution board pieces indices\n               then Printf.printf \"%s\" (string_of_solution board pieces indices)\n               else Printf.printf \"%s\\n\" \"solution is not valid\"\n end\n\nmodule FS = FindSolutions(ImplBinaryMatrix)\nopen FS\n\nlet solve0 () = \n  let pieces = [('x', px_s)] in\n    show_solution pieces board0\n\nlet solve1 () = \n  let pieces = [('l', pl_s); ('L', pl_s)] in\n    show_solution pieces board1\n\nlet solve2 () = \n  let pieces = [('u', pu_s); ('x', px_s)] in\n    show_solution pieces board2\n\nlet solve3 () =\n  let pieces = [('l', pl_s); ('t', pt_s); ('y', py_s)] in\n    show_solution pieces board3\n\nlet solve4 () =\n  let pieces = [('f', pf_s); ('l', pl_s); ('p', pp_s); ('u', pu_s)] in\n    show_solution pieces board4\n\nlet solve5  () = show_solution all_pieces board5\nlet solve6  () = show_solution all_pieces board6\nlet solve7  () = show_solution all_pieces board7\nlet solve8  () = show_solution all_pieces board8\nlet solve9  () = show_solution all_pieces board9\nlet solve10 () = show_solution all_pieces board10\nlet solve11 () = show_solution all_pieces board11\nlet solve12 () = show_solution all_pieces board12\n\nlet solve n =\n  match n with\n    |  0 -&gt; solve0  ()\n    |  1 -&gt; solve1  ()\n    |  2 -&gt; solve2  ()\n    |  3 -&gt; solve3  ()\n    |  4 -&gt; solve4  ()\n    |  5 -&gt; solve5  ()\n    |  6 -&gt; solve6  ()\n    |  7 -&gt; solve7  ()\n    |  8 -&gt; solve8  ()\n    |  9 -&gt; solve9  ()\n    | 10 -&gt; solve10 ()\n    | 11 -&gt; solve11 ()\n    | 12 -&gt; solve12 ()\n    |  _ -&gt; failwith \"invalid problem number\"\n\n(* Plus command-line argument processing code... *)\n</code></pre> <p>We create a functor called <code>FindSolutions</code> which takes a module argument that is compatible with the <code>BinaryMatrix</code> module type. We use the actual binary matrix module <code>ImplBinaryMatrix</code> to create the module <code>FS</code>. Then we solve problems by calling the <code>show_solution</code> function, given a list of Pentomino pieces (in their string representation) and a board.</p> <p>The boards themselves are described in the <code>pentomino_boards.ml</code> file. To specify a board, you have to include the number of rows, the number of columns, and a function which takes a (row, column) location and returns <code>true</code> if that location is part of the board. (This is how you specify locations that aren't part of the board, like the central 2x2 square in board 9 we discussed above.)</p> <p>Inside the <code>FindSolutions</code> module, we first define an <code>Alg</code> module by providing the <code>AlgorithmX</code> functor with a <code>BinaryMatrix</code> argument. The <code>show_solution</code> function calls the <code>get_solution</code> function to convert the Pentomino problem to a binary matrix and then solve the matrix version of the problem. Then <code>show_solution</code> uses the matrix solution to validate the solution using the <code>validate_solution</code> function (from <code>pentomino_utils.ml</code>), and if it's valid converts the solution to a string using the <code>string_of_solution</code> function (also in <code>pentomino_utils.ml</code>), which is then printed out. The <code>validate_solution</code> and <code>string_of_solution</code> functions are provided for you, so the conversion from the solution of the binary matrix back to a solution of the Pentomino problem is not something that you are responsible for.</p>"},{"location":"assignments/midterm/","title":"Midterm exam","text":""},{"location":"assignments/midterm/#dates-and-policies","title":"Dates and policies","text":"<ul> <li> <p>This exam is due Friday, February 16th, at 6 PM. Please submit your text answers electronically as the CodePost assignment called <code>Midterm</code>.</p> </li> <li> <p>The exam will cover the material in the course up to (but not including) lecture 12.</p> </li> <li> <p>There is no time limit on this exam, except that it must be handed in on time.</p> </li> <li> <p>This is an open-book exam. You may consult either or both of the textbooks.</p> </li> <li> <p>This is an open reference exam, with this exception: you may not search for or use specific solutions of the exam problems you find online or in a book, in a previous year's exam written by another student, or anywhere else, however unlikely it may be that you would find such a thing.</p> </li> <li> <p>This is an open interpreter/compiler exam. Specifically, you are allowed to use OCaml to develop and debug your code (and we very strongly recommend that you do this).</p> </li> <li> <p>This is a no-collaboration exam. Do not discuss the exam with anyone (verbally or in writing) before the due date, even if you both have turned in your exams already. You are also forbidden to discuss the exam on internet forums. Honor code rules apply. The only exception is to request a clarification of some point in the exam; you are allowed to email the course instructor and/or the course TAs for this purpose only.  </p> </li> </ul>"},{"location":"assignments/midterm/#formatting","title":"Formatting","text":"<p>Here is how your exam should be formatted.</p> <p>Note</p> <p>We may deduct a significant proportion of your midterm grade (up to 1/4 of the total grade) if you violate any of these rules. If you have any questions about these rules, contact us before starting the exam and we'll clarify them.</p> <ul> <li> <p>Your midterm exam should all be in a single plain text file called <code>midterm.ml</code> (that exact name, lower case; not <code>cs4midterm</code>, <code>midterm</code>, <code>mymidterm</code>, <code>Midterm.txt</code> or anything else). You should write your full name and your email address in comments in the first two lines of the file. Make sure that your file is a plain text file! Check this by typing the following at a Unix prompt:</p> <pre><code>$ more midterm.ml\n</code></pre> <p>If it prints out your file in a readable manner, it's plain text.</p> </li> <li> <p>Write the file as a file of OCaml code. Any questions that require non-code answers should have these answers written as OCaml comments.</p> </li> <li> <p>Make sure that all of the lines in your midterm file have no more than 80 characters in a line.</p> </li> </ul>"},{"location":"assignments/midterm/#grading","title":"Grading","text":"<p>The exam will receive a grade between <code>0</code> and <code>100</code>, based on your performance across all of the problems. This grade will be scaled down to your final midterm grade, which is a maximum of 20 points.</p>"},{"location":"assignments/midterm/#other-notes","title":"Other notes","text":"<ul> <li> <p>There is no collaboration. (We mentioned this above, but it bears repeating.)</p> </li> <li> <p>There is no rework.</p> </li> <li> <p>If you need a clarification of anything on the exam after you've started writing it, you may send email to Mike or to one of the TAs.</p> </li> </ul>"},{"location":"assignments/midterm/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/midterm/ocaml_notes/#testing","title":"Testing","text":"<p>For this exam, we are supplying you with these support files:</p> <ul> <li>an OCaml interface file: <code>midterm.mli</code></li> <li>a test script: <code>tests_midterm.ml</code></li> <li>a <code>Makefile</code></li> </ul> <p>These files are all available on the course Canvas site in a single zip file called <code>midterm.zip</code>. Download this file and unzip it:</p> <pre><code>$ unzip midterm.zip\n</code></pre> <p>This will create a <code>midterm</code> directory with the files inside it. You should not change these files, and you should not submit them as part of your exam submission. You should create, edit and compile the file <code>midterm.ml</code> (which you will be submitting) in the same directory.</p> <p>Once your exam is done, you should compile it and check that it conforms to the interface file by entering this command:</p> <pre><code>$ make\n</code></pre> <p>Of course, you can also compile your code from inside the OCaml interpreter using the <code>#use</code> directive, as we've previously described. (This is recommended for quick feedback when writing the code, but be sure to compile it using <code>make</code> later to check that the types of your functions match those in the <code>midterm.mli</code> file.)</p> <p>To run the test script, type this:</p> <pre><code>$ make test\n</code></pre> <p>This will compile the <code>tests_midterm.ml</code> file (which contains the unit tests) and output an executable program called <code>tests_midterm</code>. Then it will run that program and report all test failures.</p> <p>If you want to compile the code and immediately run the test script (useful during development/debugging), type:</p> <pre><code>$ make all\n</code></pre> <p>Running the tests generates some log files; to get rid of them (as well as all compiled OCaml files), type:</p> <pre><code>$ make clean\n</code></pre> <p>Note that almost all the tests/examples described here are also in the test script.</p> <p>While writing the midterm, one trick that you will probably want to use is to comment out the tests in <code>tests_midterm.ml</code> corresponding to parts of the midterm you haven't attempted yet. This will allow you to just test those parts of the midterm you've completed.</p>"},{"location":"assignments/midterm/ocaml_notes/#things-not-to-do","title":"Things not to do","text":"<p>We would like your functions not to be gratuitously inefficient, so if you write a function in a very inefficient way and there is a simple way to write it efficiently, you will lose marks. However, we don't require all your functions to be tail-recursive unless specifically stated.</p> <p>In general, don't use library functions unless we explicitly say you can. Exception: you can use the <code>List.rev</code> function to reverse a list where appropriate, and you can use the <code>@</code> operator to append lists where appropriate. If in doubt, email Mike or post to the course Piazza page.</p> <p>Please do not use any imperative constructs (<code>ref</code> cells, the <code>!</code> dereference operator, or the <code>:=</code> assignment operator) unless we specifically say it's allowed. By default, your code should be purely functional. (You will lose marks if you violate this rule.)</p>"},{"location":"assignments/midterm/ocaml_notes/#option-types","title":"Option types","text":"<p>Some of the code below uses <code>option</code> types, which were briefly mentioned in recitation lecture 3. Here is the definition:</p> <pre><code>type 'a option = \n  | None \n  | Some of 'a\n</code></pre> <p>This type can be used when a function may or may not return a successful result. If it fails, it returns <code>None</code>; if it succeeds, it returns <code>Some x</code> for the successful value <code>x</code>. Option types are widely used in OCaml.</p> <p>You don't have to add the <code>option</code> type definition to your submission, since option types are built in to OCaml.</p>"},{"location":"assignments/midterm/partA_complexity/","title":"Part A: Asymptotic time complexity (30 points)","text":"<p>In this section, we're going to look at asymptotic time complexity. First, we will show you some functions, ask you to deduce their asymptotic complexities, and explain your answer. Then there is a more open-ended question at the end of the section.</p> <p>For each of the following functions:</p> <ul> <li> <p>Deduce its (worst-case) asymptotic time complexity with respect to one (or more) of the function arguments. Use big-O notation, but give the tightest bound you can (in other words, write the answer using big-O but really give the big-Theta value), unless otherwise indicated. Indicate which function argument (or what function of which argument or arguments e.g. the length of a list argument) the complexity refers to. For instance, a function of two variables <code>x</code> and <code>y</code> might be <code>O(x)</code> or <code>O(y)</code> (or some function of <code>x</code> and <code>y</code>)). Be clear about this (don't just write \"linear\" or \"exponential\" or you'll lose marks). If there are functions with exponential complexity you should indicate what the base of the exponential is (but not for functions with logarithmic complexity, as we explained in class).</p> </li> <li> <p>Explain the reasoning you used to deduce the asymptotic time complexity. This should be only a couple of sentences, or at most a short paragraph (don't get carried away; just give us the general idea).</p> </li> <li> <p>You may assume that all built-in arithmetic functions are <code>O(1)</code> i.e. take a constant maximum time to execute irrespective of the size of the arguments.</p> </li> </ul>"},{"location":"assignments/midterm/partA_complexity/#1-6-points","title":"1. [6 points]","text":"<pre><code>let f n =\n  let rec aux n r =\n    match n with\n      | 0 -&gt; r\n      | _ -&gt; aux (n - 1) (n * 250 + n - r)\n  in\n    aux n 0\n</code></pre>"},{"location":"assignments/midterm/partA_complexity/#2-6-points","title":"2. [6 points]","text":"<pre><code>let rec bounce m n =\n  if m = n\n    then 0\n    else\n      if m &lt; n\n        then 1 + bounce (m + 1) n\n        else 1 + bounce (m - 1) n\n</code></pre> <p>Hint</p> <p>How many steps will it take this function to terminate, as a function of both <code>m</code> and <code>n</code>?</p>"},{"location":"assignments/midterm/partA_complexity/#3-6-points","title":"3. [6 points]","text":"<p>Here is a variant of the iterative fibonacci function shown in the lectures. The sequence it generates is known as the \"tribonacci sequence\" for reasons that should be obvious.</p> <pre><code>let trib n =\n  let rec iter a b c n =\n    if n = 0 then\n      a\n    else\n      iter b c (a + b + c) (n - 1)\n  in\n    iter 0 0 1 n\n</code></pre>"},{"location":"assignments/midterm/partA_complexity/#4-6-points","title":"4. [6 points]","text":"<pre><code>let rec weird n =\n  match () with\n    | _ when n &lt;= 1 -&gt; 1\n    | _ when n mod 3 = 0 -&gt; weird (n / 3)\n    | _ when n mod 3 = 1 -&gt; weird (n - 1)\n    | _ -&gt; weird (n - 2)\n</code></pre> <p>Note</p> <p>This <code>match () ... when ...</code> idiom is one way to get the effect of <code>if ... else if ... else if ...</code> in OCaml.</p> <p>Recall that the <code>/</code> operator on integers throws away remainders, and the <code>mod</code> operator computes the remainder after division.</p> <p>You don't need to do a mathematical analysis here, but make a plausible argument.</p>"},{"location":"assignments/midterm/partA_complexity/#5-6-points","title":"5. [6 points]","text":"<p>Consider the following innocent-looking function:</p> <pre><code>let rec f n =\n  match () with\n    | _ when n &lt; 1 -&gt; failwith \"bad\"\n    | _ when n = 1 -&gt; 1\n    | _ when n mod 2 = 0 -&gt; f (n / 2)\n    | _ -&gt; f (3 * n + 1)\n</code></pre> <p>We do not actually know if this function even terminates for arbitrary <code>n</code>, much less what its asymptotic time complexity would be. (This is known as the \"Collatz Conjecture\". If you could prove that this function terminates on all inputs, you would be famous. Fortunately, we're not asking you to do that.) What aspect or aspects of this function makes it impossible to analyze by the methods we've shown you in this course?</p> <p>Note</p> <p>Of course, you don't have to state the asymptotic complexity of this function, since nobody knows what it is.</p>"},{"location":"assignments/midterm/partB_lists_hofs/","title":"Part B: Lists and higher-order functions (30 points)","text":"<p>In this section, you'll write some function involving lists and higher-order functions.</p>"},{"location":"assignments/midterm/partB_lists_hofs/#1-is_subsequence-6-points","title":"1. <code>is_subsequence</code> [6 points]","text":"<p>For this problem, you will write two functions:</p> <ul> <li> <p><code>is_prefix</code>: This function takes as its arguments two lists of <code>int</code>s and returns <code>true</code> if the first is a prefix of the second (and otherwise returns <code>false</code>). Here, \"prefix\" means that the second list elements are identical to those of the first list up to the last element of the first list; after that, they can be anything.</p> </li> <li> <p><code>is_subsequence</code>: This function also takes two lists of <code>int</code>s as its arguments and returns <code>true</code> if the first list is a subsequence of the second (and otherwise returns <code>false</code>). Here, \"subsequence\" means that there is a location in the second list where the first list would be the prefix of the list starting from that location.</p> </li> </ul> <p>Hint</p> <p>Use <code>is_prefix</code> in the definition of <code>is_subsequence</code>.</p> <p>Examples</p> <pre><code># is_prefix [] [] ;;\n- : bool = true\n\n# is_prefix [] [1;2;3;4;5] ;;\n- : bool = true\n\n# is_prefix [1] [] ;;\n- : bool = false\n\n# is_prefix [1] [1] ;;\n- : bool = true\n\n# is_prefix [1] [2] ;;\n- : bool = false\n\n# is_prefix [1;2;3] [1] ;;\n- : bool = false\n\n# is_prefix [1;2;3] [1;2] ;;\n- : bool = false\n\n# is_prefix [1;2;3] [1;2;3] ;;\n- : bool = true\n\n# is_prefix [1;2;3] [1;2;3;4;5] ;;\n- : bool = true\n\n# is_prefix [1;2;3] [0;1;2;3;4;5] ;;\n- : bool = false\n\n# is_prefix [5;1;4] [0;1;5;1;4;5] ;;\n- : bool = false\n\n# is_subsequence [] [] ;;\n- : bool = true\n\n# is_subsequence [] [1;2;3;4;5] ;;\n- : bool = true\n\n# is_subsequence [1] [] ;;\n- : bool = false\n\n# is_subsequence [1] [1] ;;\n- : bool = true\n\n# is_subsequence [1] [5;4;3;2;1] ;;\n- : bool = true\n\n# is_subsequence [1;2;3] [1;2;3;5;4;3;2;1] ;;\n- : bool = true\n\n# is_subsequence [1;2;3] [1;2;1;2;3;2;1] ;;\n- : bool = true\n</code></pre>"},{"location":"assignments/midterm/partB_lists_hofs/#2-is_embedded-6-points","title":"2. <code>is_embedded</code> [6 points]","text":"<p>Write a function called <code>is_embedded</code> that takes as its arguments two lists of <code>int</code>s and returns <code>true</code> if the first is \"embedded\" in the second, and <code>false</code> otherwise. By \"embedded\", we mean that all the elements of the first list are found in the second list in the same order, but not necessarily consecutively.</p> <p>Examples</p> <pre><code># is_embedded [] [] ;;\n- : bool = true\n\n# is_embedded [] [1;2;3] ;;\n- : bool = true\n\n# is_embedded [1] [] ;;\n- : bool = false\n\n# is_embedded [1;2;3] [1;2;3;4] ;;\n- : bool = true\n\n# is_embedded [1;2;3] [0;1;0;2;0;3;0;4;0] ;;\n- : bool = true\n\n# is_embedded [1;2;3;4] [0;1;4;3;2;4;3;0;4;0] ;;\n- : bool = true\n\n# is_embedded [1;2;3] [3;0;1;0;2;0;4] ;;\n- : bool = false\n\n# is_embedded [1;2;3] [3;0;1;0;2;0;4;3] ;;\n- : bool = true\n\n# is_embedded [4;3;3;5] [1;2;3;4;3;5;3;5] ;;\n- : bool = true\n</code></pre>"},{"location":"assignments/midterm/partB_lists_hofs/#3-same_elements-6-points","title":"3. <code>same_elements</code> [6 points]","text":"<ul> <li> <p>Write a function called <code>remove_first</code> which takes an element (an <code>int</code>) and a list of <code>int</code>s and removes the first occurrence of the <code>int</code> from the list if possible. (This is functional programming, so it doesn't alter the input list.) If the element is not in the list, it returns <code>None</code>. If it is, it returns <code>Some &lt;new list&gt;</code>, where <code>&lt;new list&gt;</code> is like the input list but without the first occurrence of the element.</p> </li> <li> <p>Write a function called <code>same_elements</code> which takes two arguments (both lists of <code>int</code>s) and returns <code>true</code> if they have the same elements and <code>false</code> if not. Two lists having the same elements means that all the <code>int</code>s in the first list are present in the second list, with the same number of repeats. So if the first list has five <code>1</code>s, the second must too. The order of the elements is irrelevant. You are not allowed to sort either list in your solution. You are not allowed to use the <code>List.mem</code> function, or to define a similar function in this problem.</p> </li> </ul> <p>Hint</p> <p>Use <code>remove_first</code> in the definition of <code>same_elements</code>.</p> <p>Examples</p> <pre><code># remove_first 1 []\n- : int list option = None\n\n# remove_first 1 [1]\n- : int list option = Some []\n\n# remove_first 1 [2]\n- : int list option = None\n\n# remove_first 1 [1;1;1;1;1]\n- : int list option = Some [1;1;1;1]\n\n# remove_first 1 [1;2;3;4;5]\n- : int list option = Some [2;3;4;5]\n\n# remove_first 1 [5;4;3;2;1;2;3;4;5]\n- : int list option = Some [5;4;3;2;2;3;4;5]\n\n# remove_first 1 [5;4;3;2;1;2;1;3;1;4;1;5]\n- : int list option = Some [5;4;3;2;2;1;3;1;4;1;5]\n\n# same_elements [] [] ;;\n- : bool = true\n\n# same_elements [1] [] ;;\n- : bool = false\n\n# same_elements [] [1] ;;\n- : bool = false\n\n# same_elements [1;2] [1;2;3] ;;\n- : bool = false\n\n# same_elements [1;2;3] [1;2] ;;\n- : bool = false\n\n# same_elements [1;2;3] [1;2;3] ;;\n- : bool = true\n\n# same_elements [1;2;3] [3;2;1] ;;\n- : bool = true\n\n# same_elements [1;2;3] [3;2;3] ;;\n- : bool = false\n\n# same_elements [1;2;3] [3;2;1;2] ;;\n- : bool = false\n\n# same_elements [1;2;3;3] [3;1;1;2] ;;\n- : bool = false\n\n# same_elements [1;2;3;3] [3;1;3;2] ;;\n- : bool = true\n</code></pre>"},{"location":"assignments/midterm/partB_lists_hofs/#4-any-all-repeated-6-points","title":"4. <code>any</code>, <code>all</code>, <code>repeated</code> [6 points]","text":"<p>For this problem you'll write several functions, some of which are higher-order functions, and some of which use higher-order functions. Do not use any library functions in your functions, with the exception of <code>List.rev</code>, which you can use if you like.</p> <ul> <li> <p>Write a function called <code>repeated</code> that takes two arguments: an <code>int</code> and a list of <code>int</code>s. It returns <code>true</code> if the <code>int</code> argument is found in at least two places in the list, and otherwise returns <code>false</code>.</p> <p>Hint</p> <p>You are allowed to use the <code>remove_first</code> functions you defined above in the definition of this function. You don't need to use recursion.</p> </li> <li> <p>Write a higher-order polymorphic function called <code>any</code> which takes two arguments: a function from <code>'a</code> to <code>bool</code> and a list of <code>'a</code>s. It returns <code>true</code> if applying the function to any of the elements of the list would return <code>true</code>; otherwise it returns <code>false</code>.</p> </li> <li> <p>Write a higher-order polymorphic function called <code>all</code> which takes the same arguments as <code>any</code> but returns <code>true</code> only if applying the function argument to all of the list elements would return <code>true</code>.</p> </li> <li> <p>Use the <code>any</code> and <code>repeated</code> functions you just wrote to write a function called <code>any_repeated</code> which takes a list of <code>int</code>s and returns <code>true</code> if the list has any repeated elements. Do not use recursion or helper functions. This is a very short function.</p> </li> <li> <p>Use the <code>all</code> and <code>repeated</code> functions you just wrote to write a function called <code>all_repeated</code> which takes a list of <code>int</code>s and returns <code>true</code> if all the elements in the list are repeated elements. Do not use recursion or helper functions. This is a very short function.</p> </li> </ul> <p>Examples</p> <pre><code># repeated 1 [] ;;\n- : bool = false\n\n# repeated 1 [1] ;;\n- : bool = false\n\n# repeated 1 [1;1] ;;\n- : bool = true\n\n# repeated 1 [1;1;1] ;;\n- : bool = true\n\n# repeated 1 [1;0;1] ;;\n- : bool = true\n\n# repeated 1 [0;1;0;0;2;0] ;;\n- : bool = false\n\n# repeated 1 [0;1;0;0;1;0] ;;\n- : bool = true\n\n\n# let zeros x = x = 0 ;;\nzeros : int -&gt; bool = &lt;fun&gt;\n\n\n# any zeros [] ;;\n- : bool = false\n\n# any zeros [1] ;;\n- : bool = false\n\n# any zeros [1;2;3] ;;\n- : bool = false\n\n# any zeros [0] ;;\n- : bool = true\n\n# any zeros [0;0] ;;\n- : bool = true\n\n# any zeros [0;0;0] ;;\n- : bool = true\n\n# any zeros [0;1;2;3] ;;\n- : bool = true\n\n# any zeros [0;1;0;2;0;3] ;;\n- : bool = true\n\n\n# all zeros [] ;;\n- : bool = true\n\n# all zeros [1] ;;\n- : bool = false\n\n# all zeros [1;2;3] ;;\n- : bool = false\n\n# all zeros [0] ;;\n- : bool = true\n\n# all zeros [0;0] ;;\n- : bool = true\n\n# all zeros [0;0;0] ;;\n- : bool = true\n\n# all zeros [0;1;2;3] ;;\n- : bool = false\n\n# all zeros [0;1;0;2;0;3] ;;\n- : bool = false\n\n\n# any_repeated [] ;;\n- : bool = false\n\n# any_repeated [1] ;;\n- : bool = false\n\n# any_repeated [1;2;3] ;;\n- : bool = false\n\n# any_repeated [1;2;3;1] ;;\n- : bool = true\n\n# any_repeated [1;1;1;1] ;;\n- : bool = true\n\n# any_repeated [0;2;3;1;4;6;2;4] ;;\n- : bool = true\n\n# any_repeated [2;1;3;1;4;1;2;1;3;2;4;1] ;;\n- : bool = true\n\n\n# all_repeated [] ;;\n- : bool = true\n\n# all_repeated [1] ;;\n- : bool = false\n\n# all_repeated [1;2;3] ;;\n- : bool = false\n\n# all_repeated [1;2;3;1] ;;\n- : bool = false\n\n# all_repeated [1;1;1;1] ;;\n- : bool = true\n\n# all_repeated [0;2;3;1;4;6;2;4] ;;\n- : bool = false\n\n# all_repeated [2;1;3;1;4;1;2;1;3;2;4;1] ;;\n- : bool = true\n</code></pre>"},{"location":"assignments/midterm/partB_lists_hofs/#5-compose_all-6-points","title":"5. <code>compose_all</code> [6 points]","text":"<p>In one of the assignments you defined a <code>compose</code> function.  In this problem you need to write a <code>compose_all</code> function which composes a list of functions together.  So, for instance:</p> <pre><code>compose_all [f1; f2; f3]\n</code></pre> <p>means the same as</p> <pre><code>fun x -&gt; f1 (f2 (f3 x))\n</code></pre> <p>This problem is split into three parts:</p> <ul> <li> <p>Define <code>compose_all</code> using recursion, without using any higher-order functions.</p> </li> <li> <p>Define <code>compose_all2</code> using the library higher-order function <code>List.fold_right</code>. See the OCaml documentation here for more information on how this function works. This definition should be a one-liner and should not use recursion or helper functions. <code>compose_all</code> and <code>compose_all2</code> should do exactly the same thing.</p> </li> <li> <p>Explain why the type signatures of <code>compose_all</code> and <code>compose_all2</code> have to be</p> <pre><code>('a -&gt; 'a) list -&gt; ('a -&gt; 'a)\n</code></pre> <p>This can also be written as:</p> <pre><code>('a -&gt; 'a) list -&gt; 'a -&gt; 'a\n</code></pre> <p>Why can't you use it on functions with more general types i.e. <code>'a -&gt; 'b</code> where <code>'a</code> and <code>'b</code> are different?</p> </li> </ul> <p>Hint</p> <p>You should define a <code>compose</code> function and use it in both the <code>compose_all</code> and <code>compose_all2</code> functions.  (You can copy it from your assignment version.) You will probably also want to define an <code>id</code> function i.e.</p> <pre><code>let id x = x\n</code></pre> <p>and use that as well.</p> <p>Examples</p> <pre><code># let f1 x = x + 1 ;;\nval f1 : int -&gt; int = &lt;fun&gt;\n\n# let f2 x = x * 2 ;;\nval f2 : int -&gt; int = &lt;fun&gt;\n\n# let f3 x = x - 3 ;;\nval f3 : int -&gt; int = &lt;fun&gt;\n\n# f1 (f2 (f3 10)) ;;\n- : int = 15\n\n# (compose_all [f1; f2; f3]) 10 ;;\n- : int = 15\n\n# (compose_all2 [f1; f2; f3]) 10 ;;\n- : int = 15\n</code></pre>"},{"location":"assignments/midterm/partC_data_structures/","title":"Part C: Data structures: Weight-balanced trees (40 points)","text":""},{"location":"assignments/midterm/partC_data_structures/#introduction","title":"Introduction","text":"<p>In this section, we are going to implement a non-trivial data structure called a \"weight-balanced tree\", or WB tree for short. The main reason for this is to demonstrate that even fairly complex data structures can often be implemented simply using OCaml's algebraic datatypes.</p> <p>WB trees are an example of a \"self-balancing binary search tree\". There are a number of other self-balancing binary search tree datatypes, including red-black trees, AVL trees, 2-3 trees etc. WB trees are interesting because they contain parameters that allow you to tune the tree implementation for faster lookup or faster insertion (but not both!).</p> <p>Note</p> <p>The discussion of this data structure will be fairly lengthy, because it's rather complicated. However, don't be intimidated: the amount of code you need to write is quite small. Most of the code for the algorithm is supplied to you; your job will be to fill in the implementation of a few critical points of the algorithm. We will be very clear about what you need to do, so even if you find the algorithm confusing, you should still understand what code you need to write.</p> <p>Before we get into the details of this data structure, let's explain why such a thing is desirable. Many practical applications of interest require set-like or map-like collections of values which have (at least!) the following requirements:</p> <ul> <li> <p>You have to be able to find a particular value in the collection as quickly as possible (or report that it isn't there).</p> </li> <li> <p>You have to be able to add a new value to the collection as quickly as possible.</p> </li> <li> <p>The collection mustn't duplicate the values searched over.</p> </li> </ul> <p>The difference between a set and a map is that sets are just the values in the collection, while maps have an associated value for each \"key\" value in the map. Our WB trees will implement sets of integers, which is about as simple as it gets.</p> <p>Note</p> <p>Don't confuse \"maps\" as described here with the <code>List.map</code> function, which is a completely different kind of thing. The \"maps\" we're talking about here are key-value mappings, kind of like Python dictionaries. (That's all we're going to say about maps from here on.)</p> <p>If we didn't care about efficiency, we can easily implement a set of integers using a list of integers. To find whether a particular integer is in the set, we just have to search through the list. This is an \\(O(N)\\) operation, where \\(N\\) is the length of the list, so it's rather slow. To add a value to the list (making sure there are no duplicates), we can just search for the value in the list; if it's found, there is no need to add it, and if not, we can add it to the front of the list. This is also \\(O(N)\\). (If we don't mind repeated elements, we can just add it to the front of the list without searching, which is \\(O(1)\\).)</p> <p>Somewhere along the line, someone realized that if we arranged the data in a binary tree-like data structure, we can potentially get much faster searches (\\(O(log\\ N)\\) instead of \\(O(N)\\)) and also get \\(O(log\\ N)\\) insertions. To do this, we create nodes containing three things: a data value, a left subtree, and a right subtree. A subtree can be a leaf (no data) or another node. In OCaml, such a data structure would look like this:</p> <pre><code>(* Assume we are storing only integers in the tree. *)\ntype tree =\n  | Leaf\n  | Node of int * tree * tree   (* data value, left subtree, right subtree *)\n</code></pre> <p>We further stipulate that all the elements in the left subtree of a node are strictly less than the value at the node, and all the elements in the right subtree are strictly greater than the value at the node (this makes the tree an ordered binary tree). Clearly, this will only work if the values stored in the tree are orderable (like integers).</p> <p>Note</p> <p>Unfortunately, OCaml's type system isn't powerful enough to express the ordering constraint, so we have to enforce it in the functions we write that add values to the tree.</p> <p>Searching through a tree like this is easy (you'll write the code below). Insertion is also easy: you simply walk down the tree until you reach a leaf where the new value ought to go, and then replace the leaf with a node whose two subtrees are leaves.</p> <p>Note</p> <p>Since we are implementing this data structure in a purely functional manner, we aren't really replacing anything. Instead, we create a new tree which has a different node in place of the one we want to \"replace\". Because most of the tree can be shared between the old and new versions, this is quite efficient.</p> <p>If the tree is roughly balanced (the left and right subtrees of all nodes are about the same size), then looking up a value in the tree or inserting a value into the tree is \\(O(log\\ N)\\), where \\(N\\) is the number of values stored in the tree. That's because on average, going to a left or right subtree of a node gets rid of about half of the values in the tree, and after \\(log_2(N)\\) divisions by two you will end up at a leaf.</p> <p>Unfortunately, if you add elements to the tree naively, you can easily end up with an unbalanced tree, where some branches of the tree are empty and others have large numbers of nodes. In the worst case, the tree will only have nodes on one side (left or right) and then it's no better than a linked list. This means that searching through the tree will be \\(O(N)\\), not \\(O(log\\ N)\\).</p> <p>There needs to be some way to make sure that the tree stays balanced when you add new values to it. If you can guarantee that the tree stays balanced, you can guarantee that searching for values in the tree and adding new values to the tree are \\(O(log\\ N)\\) operations, which is acceptably fast for many applications.</p> <p>Self-balancing binary trees generally have additional data in each node which helps in the balancing operation. In the case of WB trees, this data is called a \"size\" and is an integer &gt;= 0. Leaves have a size of zero (this does not need to be stored explicitly in the tree), while nodes have sizes &gt; 0. The size of a node is simply the number of nodes (not leaves) in the subtree rooted at the node. So, for instance, a node with two leaves as children has a size of 1, while a node with one leaf child and one node child which itself has two leaf children has size 2, etc.</p> <p>Some terminology we'll use:</p> <ul> <li> <p>The \"root node\" of a tree is the topmost node of the tree.</p> </li> <li> <p>A \"child node\" of a node is the root node of one of its subtrees.</p> </li> <li> <p>A \"parent node\" of a node is the node which has the original node as one of its child nodes. Note that root nodes have no parent node.</p> </li> <li> <p>A \"grandparent node\" is the parent node of a node's parent node.</p> </li> <li> <p>\"Naively adding\" a value to a tree is adding a node containing the value to the tree without worrying about whether the tree becomes unbalanced or not.</p> </li> </ul> <p>For the purposes of these terms, a leaf is considered a kind of node.</p> <p>Here is the definition of the WB tree datatype:</p> <pre><code>type tree =\n  | Leaf\n  | Node of int * int * tree * tree   (* size, value, left/right subtrees *)\n</code></pre> <p>This is the same as the definition of <code>tree</code> given above, except that there is an extra <code>int</code> value stored at each node representing the size of the node. Note that the first <code>int</code> value in the node is the size and the second one is the integer value being stored at the node. After that comes the left and right subtrees of the node, which can be <code>Leaf</code> nodes or not.</p> <p>A WB tree must satisfy the following invariants:</p> <ol> <li> <p>A node's value must be strictly larger than any value stored in its left subtree and strictly smaller than any value stored in its right subtree. (This is the order invariant that all ordered binary trees must have.)</p> </li> <li> <p>The data values stored in the tree must contain no duplicates.</p> </li> <li> <p>The size of a <code>Leaf</code> is zero.</p> </li> <li> <p>The size of a <code>Node</code> is the sum of the sizes of its children, plus 1.</p> </li> <li> <p>Subtrees of a <code>Node</code> must satisfy a balancing condition, which is parameterized around a positive constant called <code>delta</code>. Specifically, the condition is:</p> <pre><code>(size(L) + 1) &lt;= delta * (size(R) + 1)\n(size(R) + 1) &lt;= delta * (size(L) + 1)\n</code></pre> <p>(We will use a value of 3 for <code>delta</code>.) What this condition means is roughly that neither subtree of a node is allowed to have a size more than <code>delta</code> times the size of the other subtree. If this is true, the tree will be balanced enough to support \\(O(log\\ N)\\) lookups and insertions.</p> </li> </ol> <p>Note that some of these invariants can (and will) be violated temporarily while inserting new values into an WB tree, but then the tree must be readjusted so that the invariants again apply.</p> <p>The WB trees we will be working with are purely functional, so (for instance) inserting an integer into a tree will yield a new tree instead of changing the old one.</p>"},{"location":"assignments/midterm/partC_data_structures/#examples","title":"Examples","text":"<p>Let's look at some WB trees. We'll add some integers between 1 and 100 to an empty WB tree and see what the resulting trees look like. In some cases, adding a number to a tree in a \"naive\" way would result in an unbalanced tree (which is not a valid WB tree); in that case, after adding the node we will have to rebalance the tree to preserve the invariants. We will look at the tree before and after rebalancing, so you can get an idea of what the balancing operations do before we describe the code you will need to write. We will mention which rebalancing operations we are using; the details of these operations will be discussed in the next section.</p> <p></p> <p>This is a leaf node (which is also an empty tree). It doesn't store any data. It has size 0. There's not much else to say about it.</p> <p></p> <p>Adding the number <code>2</code> creates a node whose two subtrees are both leaves. The <code>2</code> in the node label is the value stored in the node. The <code>(S 1)</code> says that this node has size 1. This has to be the case because its subtrees are both leaves, which have size 0, and the size of a node is always exactly one higher than the sum of the sizes of its subtrees.</p> <p></p> <p>Adding the number <code>66</code> creates a new node on the right subtree of the node containing <code>2</code>. The new node has size 1 (as all new nodes must have). No rebalancing is necessary.</p> <p></p> <p>Adding the number <code>36</code> creates a new node on the left subtree of the node containing <code>66</code>. Again, no rebalancing is necessary.</p> <p></p> <p>Adding the number <code>85</code> creates a new node on the right subtree of the node containing <code>66</code>. At this point, we have to rebalance the tree because the size of the tree rooted at 66 is 3 whereas the size of the other child of node 2 is 0. Invariant #5 says that adding 1 to both sizes gives a ratio of 1 to 4, which is more than <code>delta</code> (3).</p> <p></p> <p>The rebalancing operation we do is called a single left rotation of the tree rooted at 2 (i.e. the entire tree). This is one of four different kinds of primitive tree balancing operations; we will describe it in the next section. Note that the tree now looks balanced and is still ordered (invariant #1).</p> <p></p> <p>Adding the number <code>96</code> doesn't cause the tree to become unbalanced (at least, not by the criteria of invariant #5, which is good enough for us).</p> <p></p> <p>Adding the number <code>7</code> doesn't cause the tree to become unbalanced either.</p> <p></p> <p>Adding the number <code>26</code> gives an unbalanced tree. Invariant #5 is violated at the subtree starting from the node with <code>2</code>; its left subtree has size 0 and its right subtree has size 3, so the ratio is (3 + 1) to (0 + 1) which is 4 to 1 (more than <code>delta</code>). Therefore, we have to rebalance.</p> <p></p> <p>This is the result after rebalancing. The rebalancing operation here is called a double left rotation and is more complicated than the single left rotation we saw previously. In addition to the parameter <code>delta</code>, there is a second parameter <code>gamma</code> which decides, when a rebalancing operation needs to occur, whether a single or double rotation needs to happen. You don't need to worry about the details of this, because the code that handles this will be supplied to you (your job will be to implement the rotations).</p> <p></p> <p>Adding the number <code>12</code> doesn't cause the tree to become unbalanced.</p> <p></p> <p>Adding the number <code>62</code> doesn't cause the tree to become unbalanced.</p> <p></p> <p>Adding the number <code>38</code> doesn't cause the tree to become unbalanced, but it's clear we can't keep this up forever. The subtree rooted at <code>7</code> is starting to look like it might need a rotation soon.</p> <p></p> <p>Adding the number <code>14</code> makes the tree rooted at <code>7</code> unbalanced (why?). We need to rebalance.</p> <p></p> <p>We do a single left rotation at the tree rooted at <code>7</code>, and this restores the balance. Notice that the balance criteria at the root node makes the tree just barely balanced there (<code>(8+1) / (2+1)</code> is a ratio of 3 to 1); adding anything to the left subtree will certainly make it unbalanced again.</p> <p></p> <p>Adding the number <code>23</code> indeed makes the tree unbalanced. First, the node with <code>26</code> is unbalanced. This requires a double right rotation around that node. Even when this happens, the root node (with the number <code>66</code>) is also unbalanced; that will require a single right rotation to rebalance it.</p> <p>It's important to realize that rebalancing a tree after adding a new node can require more than one rotation. We work from the outermost parts of the tree inward, rebalancing as needed.</p> <p></p> <p>After all these rebalancings, the tree is once again in good shape. At this point, we have seen all four of the tree rotations we will need for rebalancing.</p> <p>This concludes the WB tree examples. We hope you now have a clearer idea of how WB trees work and how they stay balanced.</p>"},{"location":"assignments/midterm/partC_data_structures/#tree-rotations","title":"Tree rotations","text":"<p>In the examples given above, we've seen that there are a number of balancing operations or \"rotations\" that are done to make an unbalanced tree balanced. Be aware that we don't require that the tree be exactly 100% balanced. In the case of WB trees, the balance criteria ensure that subtrees of a node can't contain more than about 3 times the nodes of each other (if <code>delta</code> is 3), which is enough to preserve the \\(O(log\\ N)\\) lookup and insert properties we want. What the rotations do is rebalance a tree while preserving the order invariant. What kind of rotation you do depends on the way in which the tree is unbalanced. We've seen that WB trees have four different kinds of rotations:</p> <ul> <li>single left rotation</li> <li>single right rotation</li> <li>double left rotation</li> <li>double right rotation</li> </ul> <p>When you do these rotations in the appropriate circumstances, the tree will become balanced and the order invariant will be preserved.</p> <p>Here is what a single left rotation looks like. Starting from this:</p> <p></p> <p>We go to this:</p> <p></p> <p>In these diagrams, <code>a</code> and <code>c</code> are nodes while <code>X</code>, <code>Y</code> and <code>Z</code> are subtrees. See if you can convince yourself that this will not violate the order invariant.</p> <p>Here is what a single right rotation looks like. Starting from this:</p> <p></p> <p>We go to this:</p> <p></p> <p>Note that a single right rotation simply undoes a single left rotation.</p> <p>Here is what a double left rotation looks like. Starting from this:</p> <p></p> <p>We go to this:</p> <p></p> <p>In these diagrams, <code>a</code>, <code>b</code>, <code>c</code> represent nodes while <code>X</code>, <code>Y0</code>, <code>Y1</code> and <code>Z</code> represent subtrees.</p> <p>Here is what a double right rotation looks like.  Starting from this:</p> <p></p> <p>We go to this:</p> <p></p> <p>Notice that the starting point of the double right rotation is the mirror-image of the starting point of the double left rotation, and that both rotations end up with the same tree.</p> <p>That's all we have to say about rotations!</p>"},{"location":"assignments/midterm/partC_data_structures/#inserting-into-a-wb-tree","title":"Inserting into a WB tree","text":"<p>Once you can do rotations, it's fairly easy to implement insertions into a tree so as to keep the tree balanced. Here is an outline of the algorithm.</p> <p>Note</p> <p>You don't have to implement this algorithm, since it's implemented for you (see below). You just have to implement the rotations.</p> <p>First, insert the new value into the tree by following the branches based on the value to be inserted and the values at the nodes. If the new value is smaller than the node value, insert it into the left subtree, if it's larger, insert it into the right subtree, and if it's the same, then the new value is already in the tree so do nothing. Once you get to a leaf, replace it with a new node with the new value and two leaves as children. Of course, we want to do this functionally, so we aren't really replacing anything; we are building up a new tree as we go along out of the parts of the old tree. Therefore, the \"replacement\" step is to put in a new node with the new value in place of what was a leaf in the original tree; this new node has leaves for children.</p> <p>Now that we have the new value in the tree, we need to make sure that the tree is balanced, and if not, we need to balance it. The new node we just created is obviously balanced (it has two leaves as children, both of which have depth 0), so we look at the parent of that node, and then the parent of that node, and so on until we reach an unbalanced node or until we reach the root of the tree. We use the <code>delta</code> parameter and invariant #5 to tell us if the tree is unbalanced. If we reach the root of the tree, we're done! If we find an unbalanced node, we have to decide what kind of rebalancing operation is needed. If we added to a left subtree, we need to do a right rotation, and vice versa. Whether we do a single or double rotation depends upon the <code>gamma</code> parameter we mentioned above. The criterion is:</p> \\[ weight(T_A) &lt; \\Gamma\\cdot weight(T_B) \\] <p>(where \\(\\Gamma\\) is <code>gamma</code>, \\(T_A\\) is subtree \"A\", and \\(T_B\\) is subtree \"B\".) If \\(weight(T_A)\\) is less than \\(\\Gamma\\cdot weight(T_B)\\), do a single rotation; otherwise, do a double rotation.</p> <p>We use a value of 2 for <code>gamma</code>; this has been proved to work correctly and to be decently efficient. The details of how this works are beyond the scope of this discussion, but the code is supplied for you.</p> <p>Once we rebalance around a node, we have to go up to the parent of the node and again check to see if we need to rebalance that node, and so on up to the root of the tree.</p> <p>That completes our description of WB trees. Now we have to implement this in OCaml!</p>"},{"location":"assignments/midterm/partC_data_structures/#ocaml-implementation-and-template-code","title":"OCaml implementation and template code","text":"<p>Everything in this implementation (and, indeed, in this entire midterm) must be purely functional. Do not use imperative code anywhere. So don't use <code>ref</code>, or the <code>:=</code> or <code>!</code> operators. (There is one exception: we provide a <code>debug</code> variable which is <code>true</code> by default; it may help you with debugging. Feel free to set it to <code>false</code> if you don't need it, but don't remove it.)</p> <p>Use the following code as a template for your solution.  Don't leave anything out, because the proper functioning of the data structure and the test scripts require it.  Your job is to fill in the code where it's marked <code>failwith \"TODO\"</code> as well as construct the missing patterns where it's marked <code>&lt;??&gt;</code>.</p> <p>Note</p> <p>You can copy the entire block of code to your computer's clipboard by clicking on the icon in the upper-right corner of the code block.</p> <pre><code>(* Implementation of weight-balanced trees in OCaml. *)\n\nlet tree_debug = ref true\n\n(* Parameters.\n * - delta is used to decide if any rotation needs to be made at all\n * - gamma is used to decide between a single and a double rotation\n *)\nlet delta = 3\nlet gamma = 2\n\ntype tree =\n  | Leaf\n  | Node of int * int * tree * tree  (* size, value, left/right subtrees *)\n\nlet get_size = function\n  | Leaf -&gt; 0\n  | Node (s, _, _, _) -&gt; s\n\nlet empty = Leaf\n\nlet singleton v = Node (1, v, Leaf, Leaf)\n\n(* Build a node with the correct weight\n   from a value `v`, a left subtree `l`,\n   and a right subtree `r`. *)\nlet node v l r =\n  let w = get_size l + get_size r + 1 in\n    Node (w, v, l, r)\n\n(* Are two subtrees balanced with respect to each other\n * i.e. \"relatively balanced\"?\n * Criterion:\n *   The \"weight\" of subtree b is &lt;=\n *   delta times the \"weight\" of subtree a.\n *   \"weight\" is just the size + 1.\n *)\nlet rel_balanced a b =\n  let wa = get_size a + 1 in\n  let wb = get_size b + 1 in\n    wb &lt;= delta * wa\n\n(* Is a single rotation indicated?\n * Criterion:\n *   The weight of subtree a is less than gamma times\n *   the weight of subtree b.\n *)\nlet need_single_rot a b =\n  let wa = get_size a + 1 in\n  let wb = get_size b + 1 in\n    wa &lt; gamma * wb\n\n(* Find the minimum element in a tree.\n * This assumes that the tree is ordered. *)\nlet rec min_tree = function\n  | Leaf -&gt; None\n  | Node (_, i, l, _) -&gt;\n    begin\n      match min_tree l with\n        | None -&gt; Some i\n        | Some l' -&gt; Some l'\n    end\n\n(* Find the maximum element in a tree.\n * This assumes that the tree is ordered. *)\nlet rec max_tree = function\n  | Leaf -&gt; None\n  | Node (_, i, _, r) -&gt;\n    begin\n      match max_tree r with\n        | None -&gt; Some i\n        | Some r' -&gt; Some r'\n    end\n\n(* Is a tree ordered? *)\nlet rec ordered = function\n  | Leaf -&gt; true\n  | Node (_, i, l, r) -&gt;\n    begin\n      ordered l &amp;&amp;\n      ordered r &amp;&amp;\n      match (max_tree l, min_tree r) with\n        | (None, None) -&gt; true\n        | (Some l', None) -&gt; l' &lt; i\n        | (None, Some r') -&gt; i &lt; r'\n        | (Some l', Some r') -&gt; l' &lt; i &amp;&amp; i &lt; r'\n    end\n\n(* Is a tree balanced with respect to the weight criteria? *)\nlet rec balanced = function\n  | Leaf -&gt; true\n  | Node (_, _, l, r) -&gt;\n      rel_balanced l r &amp;&amp;\n      rel_balanced r l &amp;&amp;\n      balanced l &amp;&amp;\n      balanced r\n\n(* ----------------------------------------------------------------------\n * Tree rotations and rebalancing.\n * ---------------------------------------------------------------------- *)\n\nlet single_l v l r =\n  if !tree_debug then\n    Printf.printf \"- single_l at tree rooted at %d\\n\" v;\n  match r with\n    | Leaf -&gt; invalid_arg \"single_l\"\n    | Node &lt;??&gt; -&gt; failwith \"TODO\"\n\nlet double_l v l r =\n  if !tree_debug then\n    Printf.printf \"- double_l at tree rooted at %d\\n\" v;\n  match r with\n    | Leaf\n    | Node (_, _, Leaf, _) -&gt; invalid_arg \"double_l\"\n    | Node &lt;??&gt; -&gt; failwith \"TODO\"\n\nlet rotate_l v l r =\n  if !tree_debug then\n    Printf.printf \"rotate_l at tree rooted at %d\\n\" v;\n  match r with\n    | Leaf -&gt; invalid_arg \"rotate_l\"\n    | Node (_, _, rl, rr) -&gt;\n      if need_single_rot rl rr then\n        single_l v l r\n      else\n        double_l v l r\n\nlet single_r v l r =\n  if !tree_debug then\n    Printf.printf \"- single_r at tree rooted at %d\\n\" v;\n  match l with\n    | Leaf -&gt; invalid_arg \"single_r\"\n    | Node &lt;??&gt; -&gt; failwith \"TODO\"\n\nlet double_r v l r =\n  if !tree_debug then\n    Printf.printf \"- double_r at tree rooted at %d\\n\" v;\n  match l with\n    | Leaf\n    | Node (_, _, _, Leaf) -&gt; invalid_arg \"double_r\"\n    | Node &lt;??&gt; -&gt; failwith \"TODO\"\n\nlet rotate_r v l r =\n  if !tree_debug then\n    Printf.printf \"rotate_r at tree rooted at %d\\n\" v;\n  match l with\n    | Leaf -&gt; invalid_arg \"rotate_r\"\n    | Node (_, _, ll, lr) -&gt;\n      if need_single_rot lr ll then\n        single_r v l r\n      else\n        double_r v l r\n\n(* ----------------------------------------------------------------------\n * Membership testing.\n * ---------------------------------------------------------------------- *)\n\n(* Is a value a member of a tree? *)\nlet rec tree_member v t = failwith \"TODO\"\n\n(* ----------------------------------------------------------------------\n * Inserting values into trees.\n * ---------------------------------------------------------------------- *)\n\nlet balance_l v l r =\n  if rel_balanced l r then\n    node v l r\n  else\n    rotate_l v l r\n\nlet balance_r v l r =\n  if rel_balanced r l then\n    node v l r\n  else\n    rotate_r v l r\n\n(* Insert a value into a tree with rebalancing. *)\nlet rec insert v t =\n  match t with\n    | Leaf -&gt; singleton v\n    | Node (_, v', _, _) when v = v' -&gt; t\n    | Node (_, v', l, r) -&gt;\n        if v &lt; v' then\n          (* Adding to the left means you may have to rotate to the right. *)\n          balance_r v' (insert v l) r\n        else\n          (* Adding to the right means you may have to rotate to the left. *)\n          balance_l v' l (insert v r)\n</code></pre> <p>Here are the functions you need to implement:</p>"},{"location":"assignments/midterm/partC_data_structures/#1-8-points-tree_member","title":"1. [8 points] <code>tree_member</code>","text":"<p>Write a function called <code>tree_member</code> that takes two arguments: an <code>int</code> and a <code>tree</code>, and returns <code>true</code> if the <code>int</code> is present in the tree, or <code>false</code> otherwise. You can assume that the tree is ordered i.e. it satisfies the order invariant (invariant #1 above).</p>"},{"location":"assignments/midterm/partC_data_structures/#2-8-points-single_l","title":"2. [8 points] <code>single_l</code>","text":"<p>Fill in the code for the <code>single_l</code> function, which implements a single left rotation as described above. Note that the interface of the function is:</p> <pre><code>(* arguments: value, left subtree, right subtree *)\nlet single_l v l r = ...\n</code></pre> <p>and not:</p> <pre><code>(* argument: a tree *)\nlet single_l t = ...\n</code></pre> <p>What this means is that instead of taking a complete tree as its only argument, it takes a tree which has been separated into its components: value, left subtree, and right subtree. This is just for convenience; it means that you don't have to consider the case of rotation of a leaf node, which wouldn't make sense. (The same applies to the code for the other rotations.)</p> <p>You will want to use OCaml's pattern-matching capabilities on <code>Node</code> constructors. Remember that pattern-matches on recursive datatypes can be more than one level. For instance, a pattern match on a <code>Node</code> constructor doesn't have to be just:</p> <pre><code>  ...\n  | Node (sz, v, left, right) -&gt;\n  ...\n</code></pre> <p>If <code>left</code> and/or <code>right</code> are also <code>Node</code>s, you can put them right into the pattern-match.  For instance:</p> <pre><code>  ...\n  | Node (sz, v, Node (sz2, v2, ll, lr), Node (sz3, v3, rl, rr)) -&gt;\n  ...\n</code></pre> <p>Here, if the subtrees are not both <code>Node</code>s, the pattern won't match. Of course, you don't have to do this sort of thing, but it can shorten the code you need to write.</p> <p>When you convert the diagrams given above to the rotation code, make sure to notice which parts of the trees change and which parts don't. This can also shorten the code.</p> <p>We've only included a few examples for these rotations, because the test script provides far more realistic examples. The examples given here also print out debugging messages, which can be silenced by setting <code>tree_debug := false</code>. (See below for the definition of <code>tree_of_list</code>.)</p> <p>Example</p> <pre><code># tree_of_list [1;2;3;4;5] ;;\nrotate_l at tree rooted at 1\n- single_l at tree rooted at 1\n- : tree =\nNode (5, 2, Node (1, 1, Leaf, Leaf),\n Node (3, 3, Leaf, Node (2, 4, Leaf, Node (1, 5, Leaf, Leaf))))\n</code></pre>"},{"location":"assignments/midterm/partC_data_structures/#3-8-points-single_r","title":"3. [8 points] <code>single_r</code>","text":"<p>Fill in the code for the <code>single_r</code> function.</p> <p>Example</p> <pre><code># tree_of_list [5;4;3;2;1] ;;\nrotate_r at tree rooted at 5\n- single_r at tree rooted at 5\n- : tree =\nNode (5, 4, Node (3, 3, Node (2, 2, Node (1, 1, Leaf, Leaf), Leaf), Leaf),\n Node (1, 5, Leaf, Leaf))\n</code></pre>"},{"location":"assignments/midterm/partC_data_structures/#4-8-points-double_l","title":"4. [8 points] <code>double_l</code>","text":"<p>Fill in the code for the <code>double_l</code> function.</p> <p>Example</p> <pre><code># tree_of_list [1;2;3;6;5;4] ;;\nrotate_l at tree rooted at 1\n- single_l at tree rooted at 1\nrotate_l at tree rooted at 3\n- double_l at tree rooted at 3\n- : tree =\nNode (6, 2, Node (1, 1, Leaf, Leaf),\n Node (4, 5, Node (2, 3, Leaf, Node (1, 4, Leaf, Leaf)),\n  Node (1, 6, Leaf, Leaf)))\n</code></pre>"},{"location":"assignments/midterm/partC_data_structures/#5-8-points-double_r","title":"5. [8 points] <code>double_r</code>","text":"<p>Fill in the code for the <code>double_r</code> function.</p> <p>Example</p> <pre><code># tree_of_list [6;5;4;1;2;3] ;;\nrotate_r at tree rooted at 6\n- single_r at tree rooted at 6\nrotate_r at tree rooted at 4\n- double_r at tree rooted at 4\n- : tree =\nNode (6, 5,\n Node (4, 2, Node (1, 1, Leaf, Leaf),\n  Node (2, 4, Node (1, 3, Leaf, Leaf), Leaf)),\n Node (1, 6, Leaf, Leaf))\n</code></pre>"},{"location":"assignments/midterm/partC_data_structures/#testing","title":"Testing","text":"<p>Use the test script to check if your code runs correctly. The test script includes the tree constructed in the Examples section above. In addition, it provides randomized tests where random integers are inserted into a tree and the tree is checked after each insertion to make sure that the ordering invariant and the balancing invariant are not violated. If your code has bugs, these tests should catch them. In that case, a list will be printed out; this represents the values that were added to an empty tree that ended up causing a bug. You can try interactively adding the list's elements to an empty tree yourself and checking when the invariants are violated.</p> <p>All of the tests are labeled, so if a test fails you can use the label to check which specific test in the test script failed. Don't be afraid to look at the test script!</p>"},{"location":"assignments/midterm/partC_data_structures/#additional-useful-functions-for-debuggingtesting","title":"Additional useful functions for debugging/testing","text":"<p>We are supplying you with some additional functions which you should include in your exam code. Some of these are used by the test script, and they will also be useful for testing your code interactively.</p> <pre><code>(* Convert a list into a tree *)\nlet tree_of_list lst =\n  List.fold_left (fun t x -&gt; insert x t) empty lst\n\n(* Seed the random number generator. *)\nlet _ = Random.self_init ()\n\n(* Generate a list of random integers.\n * Pick `n` random ints between `0` and `imax - 1`. *)\nlet random_list n imax =\n  let rec iter n lst =\n    if n = 0 then\n      lst\n    else\n      iter (n - 1) (Random.int imax :: lst)\n  in\n    iter n []\n\n(* Generate a tree of random integers.\n * Pick `n` random ints between `0` and `imax - 1`\n * and add them to the tree one after another. *)\nlet random_tree n imax = tree_of_list (random_list n imax)\n\n(* Pretty-print a tree. *)\nlet print_tree tree =\n  let blanks n = String.make n ' ' in\n  let rec aux tree indent =\n    let ind = blanks indent in\n      match tree with\n        | Leaf -&gt; Printf.printf \"%sLeaf\\n\" ind\n        | Node (d, v, l, r) -&gt;\n          begin\n            Printf.printf \"%sNode[(%d) [size %d]\\n\" ind v d;\n            aux l (indent + 2);\n            Printf.printf \"%s  ----\\n\" ind;\n            aux r (indent + 2);\n            Printf.printf \"%s]\\n\" ind;\n          end\n  in\n    aux tree 0\n</code></pre> <p>Here are some examples of how to use these functions:</p> <pre><code>(* Debugging code is enabled. *)\n\n# tree_of_list [10;20;30;45;55;79];;\nrotate_l at tree rooted at 10\n- single_l at tree rooted at 10\nrotate_l at tree rooted at 30\n- single_l at tree rooted at 30\n- : tree =\nNode (6, 20, Node (1, 10, Leaf, Leaf),\n Node (4, 45, Node (1, 30, Leaf, Leaf),\n  Node (2, 55, Leaf, Node (1, 79, Leaf, Leaf))))\n\n# random_tree 10 100 ;;\n- : tree =\nNode (10, 16, Node (2, 8, Leaf, Node (1, 14, Leaf, Leaf)),\n Node (7, 48, Node (3, 44, Node (2, 25, Leaf, Node (1, 43, Leaf, Leaf)), Leaf),\n  Node (3, 50, Leaf, Node (2, 84, Node (1, 76, Leaf, Leaf), Leaf))))\n\n# random_tree 20 1000 ;;\nrotate_r at tree rooted at 960\n- single_r at tree rooted at 960\nrotate_r at tree rooted at 960\n- single_r at tree rooted at 960\nrotate_r at tree rooted at 488\n- single_r at tree rooted at 488\nrotate_r at tree rooted at 468\n- single_r at tree rooted at 468\nrotate_r at tree rooted at 166\n- single_r at tree rooted at 166\n- : tree =\nNode (20, 771,\n Node (10, 208,\n  Node (4, 116, Node (1, 89, Leaf, Leaf),\n   Node (2, 166, Node (1, 125, Leaf, Leaf), Leaf)),\n  Node (5, 468,\n   Node (3, 352, Node (1, 326, Leaf, Leaf), Node (1, 461, Leaf, Leaf)),\n   Node (1, 488, Leaf, Leaf))),\n Node (9, 947,\n  Node (5, 848, Node (1, 775, Leaf, Leaf),\n   Node (3, 862, Leaf, Node (2, 939, Node (1, 874, Leaf, Leaf), Leaf))),\n  Node (3, 960, Leaf, Node (2, 973, Node (1, 961, Leaf, Leaf), Leaf))))\n\n# let pt lst = print_tree (tree_of_list lst) ;;\nval pt : int list -&gt; unit = &lt;fun&gt;\n\n# pt [] ;;\nLeaf\n- : unit = ()\n\n# pt [50;40;30] ;;\nNode[(50) [size 3]\n  Node[(40) [size 2]\n    Node[(30) [size 1]\n      Leaf\n      ----\n      Leaf\n    ]\n    ----\n    Leaf\n  ]\n  ----\n  Leaf\n]\n- : unit = ()\n\n# pt [50;40;30;33;36;60;70;65;62;64] ;;\nrotate_r at tree rooted at 50\n- single_r at tree rooted at 50\nrotate_l at tree rooted at 50\n- single_l at tree rooted at 50\nrotate_r at tree rooted at 70\n- single_r at tree rooted at 70\nNode[(40) [size 10]\n  Node[(30) [size 3]\n    Leaf\n    ----\n    Node[(33) [size 2]\n      Leaf\n      ----\n      Node[(36) [size 1]\n        Leaf\n        ----\n        Leaf\n      ]\n    ]\n  ]\n  ----\n  Node[(60) [size 6]\n    Node[(50) [size 1]\n      Leaf\n      ----\n      Leaf\n    ]\n    ----\n    Node[(65) [size 4]\n      Node[(62) [size 2]\n        Leaf\n        ----\n        Node[(64) [size 1]\n          Leaf\n          ----\n          Leaf\n        ]\n      ]\n      ----\n      Node[(70) [size 1]\n        Leaf\n        ----\n        Leaf\n      ]\n    ]\n  ]\n]\n- : unit = ()\n</code></pre> <p>[End of midterm exam]</p>"},{"location":"intro/history/","title":"History","text":"<p>The history of functional programming, OCaml, and this course is described here. You aren't required to know any of this, but I think the history is quite interesting (and convoluted), so if you're curious and have a few minutes to spare, read on!</p>"},{"location":"intro/history/#a-brief-history-of-functional-programming","title":"A brief history of functional programming","text":"<p>The ideas which eventually turned into functional programming date back to the 1920s and 1930s, when many people were working on the foundations of mathematics and computation. Moses Sch\u00f6nfinkel and Haskell Curry (see also here) developed combinatory logic, which (despite the name) is a model of computation that uses very simple functions called combinators which can be combined to create a full programming language.<sup>1</sup> Alonzo Church developed the lambda calculus, which can be viewed as the simplest possible programming language and also as the simplest functional programming language.<sup>2</sup></p> <p>Fun fact</p> <p>Alan Turing was Alonzo Church's Ph.D. student. Both lambda calculus and Turing machines can express arbitrary computations, which is known as the Church-Turing thesis. Nevertheless, Turing's formulation of the process of computation is much better known, which is why you learn about Turing machines in CS 21 instead of lambda calculus.</p> <p>Both Church and Curry continued to develop their systems. In particular, Church extended his lambda calculus (which is now called \"untyped lambda calculus\") into a typed version which is the ultimate predecessor of all typed functional programming languages, including OCaml.</p> <p>The systems of Church and Curry were purely formal systems, since there were no computers at the time. Once computers were developed in the 1940s and 1950s, there was interest in using them for symbolic manipulation tasks (as opposed to numerical computations, which was what computers were mainly used for at the time). One of the pioneers of this was John McCarthy, who developed the Lisp programming language starting around 1958. This language had an extremely simple syntax made of \"S-expressions\", which are basically just lists of symbols surrounded by parentheses. More importantly for us, Lisp was the first computer language that had both recursion and anonymous functions (known as \"lambda expressions\" in Lisp). Therefore, Lisp can be considered to be the first real functional programming language. Lisp was used primarily for artificial intelligence applications for many decades, and is still used for this. Lisp spawned a number of variants, including Common Lisp and Scheme, both of which are still in use today. Later, many other functional programming languages, including OCaml and Haskell, were developed. These later languages were notable for introducing static type checking to functional programming, as well as many other features.</p>"},{"location":"intro/history/#a-brief-history-of-ocaml","title":"A brief history of OCaml","text":"<p>One of the applications that early artificial intelligence researchers were interested in was using computers to prove mathematical theorems. The original work on this topic concentrated on fully-automatic theorem proving programs. However, the large number of choices at any point in a proof made this intractable except for proofs in very narrow domains. Then interest shifted to \"proof assistants\", which are programs where a human user guides the computer to a proof using \"tactics\", which automate routine steps. One of the earlier proof assistants (though not the earliest) was called LCF, which stood for \"logic for computable functions\". It was developed first at Stanford and then at the University of Edinburgh by Robin Milner and his collaborators in the early 1970s. Early versions of LCF used Lisp as the \"meta-language\" in which proof tactics could be written. However, the proof assistant would sometimes derive incorrect proofs, so the implementors invented a \"typed Lisp\" which they called \"ML\" for \"Meta-Language\" which contained a type checker that wouldn't permit the generation of incorrect proofs.<sup>3</sup> They then implemented LCF in ML. ML was originally implemented as an interpreter written in Lisp, but standalone compiled implementations were soon developed. Along the way, it was eventually realized that ML was a full-fledged programming language that could be used for any kind of application, not just as the implementation language for proof assistants.</p> <p>Interest in proof assistants spread to INRIA in France in the 1980s, where an ML dialect called \"CAML\"<sup>4</sup> was developed by Gerard Huet, Xavier Leroy, and others. CAML went through a number of versions, including \"Caml light\" and finally \"Objective Caml\" (also known as \"OCaml\"), which appeared in 1996. OCaml included object-oriented features, making it a multi-paradigm language (functional, imperative, and object-oriented), though it is mainly used as a functional language. In parallel with the development of Caml dialects, the proof assistant Coq was developed at INRIA, and one of the main motivations for the development of OCaml at INRIA was to serve as the implementation language for Coq.</p> <p>Note</p> <p>If you are interested in proof assistants, you should take CS 128, which is a course on interactive theorem proving using Coq.</p> <p>OCaml is currently an extremely popular language in computer science education, especially for courses on functional programming and compilers. OCaml has also spread beyond academia, and is now used a lot in financial institutions such as Jane Street Capital, who have also been very active in improving the OCaml infrastructure. OCaml has also been used for compiler development by many groups, including Facebook (the Hack language) and the Rust developers; both the Hack and Rust compilers were originally written in OCaml. Other industrial users of OCaml are listed on this page. While the core language of OCaml is extremely stable, OCaml is still under heavy development; version 5 of the language was recently released, containing new support for parallel programming and an innovative effect handling system.</p>"},{"location":"intro/history/#a-brief-history-of-cs-4","title":"A brief history of CS 4","text":"<p>In the early 2000s, Andre Dehon took over the Caltech CS 1 course and based it on the MIT 6.001 course, which used SICP as the textbook and Scheme (a Lisp dialect) as the programming language. Mike Vanier took over this course after a few years, first with Ben Brantley co-teaching, then by himself. This version of CS 1 was never broadly popular; though some students liked it a lot, most felt that it was too difficult and abstract for a course aimed at freshmen, many of whom had little programming experience. In 2009, CS 1 was completely overhauled (by Mike) to use Python as its programming language. Mike still wanted to keep teaching the old CS 1 material, though, so CS 4 was created. Originally, CS 4 still used Scheme as the language and SICP as the textbook, but more advanced material was soon incorporated.<sup>5</sup> After a few years, Mike got tired of using Scheme because he found it difficult to debug due to the syntax, the lack of type checking, and the unstructured kind of object-oriented programming that is used in many parts of SICP. Mike had been programming a lot in OCaml and Haskell at that time, and had already been giving a couple of lectures introducing OCaml at the end of CS 4. In 2016, Mike switched the entire course over to OCaml. Fortunately, most of the SICP exercises used in the course were not Scheme-specific and worked fine in OCaml.<sup>6</sup> Unexpectedly, switching to OCaml had the effect of raising the average grade significantly! We think this is because the OCaml type checker tends to refuse to pass code until it is either correct or much closer to correct than would be the case in a dynamically-typed language like Scheme. Since then, the course has evolved steadily to incorporate new material and refine old material.</p> <ol> <li> <p>The Haskell functional programming language is named after Haskell Curry.\u00a0\u21a9</p> </li> <li> <p>This depends on what your definition of \"simple\" is.  In some ways, the combinatory logic systems of Sch\u00f6nfinkel and Curry are simpler than lambda calculus.\u00a0\u21a9</p> </li> <li> <p>The use of the acronym \"ML\" to mean \"Machine Learning\" is a much more recent development.\u00a0\u21a9</p> </li> <li> <p>The name \"CAML\" originally meant \"Categorical Abstract Machine Language\", which means something in the context of the original implementation.  However, that implementation was replaced by a different one, so the name \"CAML\" survives for historical reasons only.\u00a0\u21a9</p> </li> <li> <p>Such as the Y Combinator lecture, which is Mike's favorite lecture.\u00a0\u21a9</p> </li> <li> <p>In fact, many were significantly improved in OCaml due to OCaml's better facilities for type definition.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/motivation/","title":"Motivation","text":"<p>Here we'll talk about why we think you should learn the material in this course, and what you can hope to gain from taking it.</p>"},{"location":"intro/motivation/#what-are-the-goals-of-this-course","title":"What are the goals of this course?","text":"<p>Very broadly speaking, I would say that the goals of this course are:</p> <ol> <li>to make you a better programmer,</li> <li>to deepen your understanding of programming,</li> <li>to teach you to think about programming at a higher level,</li> <li>and to learn some beautiful ideas.</li> </ol> <p>We also hope that you have fun doing it, because programming should be fun! If it isn't fun, we're doing something wrong, and you should complain.<sup>1</sup></p> <p>The goals just given can be approached in many different ways. Programming is a big field, and there is no shortage of useful information on how to improve yourself as a programmer. Similarly, there are lots of beautiful ideas in programming, and we can't cover all of them in this course! What we can do is cover interesting and useful programming methods and ideas that most of you haven't encountered before. Some of these ideas are unfamiliar even to professional programmers who have been programming for a living for decades.</p> <p>If we can open your eyes to some of these ideas, if we help you see that there is more to programming than just grinding out solutions to problems, that programs can be beautiful as well as (ahem) functional, then we've done our job.</p> <p>Our way of approaching these goals will be to teach you a new way of writing programs, a way that is usually referred to as \"functional programming\".</p>"},{"location":"intro/motivation/#what-is-functional-programming","title":"What is functional programming?","text":"<p>What functional programming is will take many lectures to describe fully, but we can say a few things about it here.</p> <p>It's important to realize that functional programming isn't a yes/no proposition. There are many aspects of functional programming, and some languages support some of them but not others. Even languages that call themselves functional programming languages can have significant differences in how they implement these ideas. Conversely, languages that do not call themselves functional programming languages can still support many features of functional languages. Python is one such language; if you want to, you can program in a functional style in Python, for the most part. However, real \"functional languages\" make this style of programming more convenient and more efficient than languages that aren't specifically functional.</p> <p>The overall goal of functional programming is to make programming easier. This has two interrelated aspects. Compared to programs written in non-functional languages:</p> <ul> <li>programs are shorter</li> <li>programs have fewer bugs</li> </ul> <p>Some important aspects of functional languages that contribute to these goals include the following.</p> <ul> <li> <p>Functions are data,   and functions can be passed as arguments to other functions,   returned from functions,   created on-the-fly,   and stored into and retrieved from data structures.   Functions that take or return functions   are referred to as higher-order functions,   and they are massively useful!   They can drastically cut down on the amount of repeated code in programs,   which lets programs be shorter.   Also, since programming patterns can be captured in higher-order functions   and re-used in many different contexts,   once you've debugged a higher-order function   it will work correctly in many different contexts,   which means your programs will have fewer bugs.</p> </li> <li> <p>Functional programming emphasizes immutable data,   which means data that doesn't change.   Functional programmers prefer to compute new data than change old data.   So even things as basic as variables   (names whose values change as the program evolves) are discouraged,   which means that we need to find new ways to do   what we previously did with variables.   Functional languages also discourage mutable data structures like arrays   (where you can change the contents of a part of the data structure),   preferring immutable data structures   like singly-linked lists and immutable maps and sets   (where you can't change the contents of the data structure,   but you can create new ones that extend the old ones).   It turns out that avoiding variables and using immutable data structures   gets rid of large classes of potential bugs.</p> <p>Note</p> <p>Don't panic! Just because functional programming languages discourage the use of mutable variables and mutable data structures doesn't mean the languages don't have them.<sup>2</sup> It's just that you usually reserve them for situations where they really are the best choice, instead of just using them everywhere.</p> </li> <li> <p>Functional languages discourage the use of looping constructs,   preferring to use recursion or higher-order functions   to achieve the same effect.   This heavy use of recursion is quite startling   to new functional programmers,   but after a while it becomes as natural as using loops.   Also, unlike loops, recursive functions   are much less likely to have subtle off-by-one errors,   which means fewer bugs.</p> <p>Note</p> <p>Once again, \"discourage\" doesn't mean that looping constructs don't exist (at least, they exist in OCaml). But you never need them, so you almost never use them.</p> <p>Also, one hidden benefit of this course is that by the end of it, you will understand recursion completely, even if you're a bit fuzzy on it at the beginning.</p> </li> <li> <p>Most, but not all, functional languages are statically typed,   which means that they make sure that code has no type errors   before it executes.   Many non-functional languages are also statically typed   (for instance, C, C++, and Java),   but the type system of functional languages is much more powerful   (able to express more features of data in the type system),   and also easier to use   (because of type inference,   which means you rarely have to declare types in your code).   Most functional languages   also provide a very powerful pattern matching feature   that works with the type system;   this can lead to very concise code   which expresses the intent of the programmer in a clean and natural style.</p> <p>A powerful static type system, coupled with pattern matching, allows code to be shorter and have fewer bugs.</p> <p>Note</p> <p>In fact, some people will tell you that in functional languages, \"if it compiles, it works!\". Sadly, this isn't always true, but it's surprising how often this is the case.</p> </li> </ul>"},{"location":"intro/motivation/#why-learn-functional-programming","title":"Why learn functional programming?","text":"<p>We learn functional programming because:</p> <ul> <li>we want to write less code,</li> <li>we want our code to be correct,</li> <li>we want to think at a higher level,</li> <li>and we want our code to be beautiful!</li> </ul> <p>We've talked above about how functional programming contributes to the first two goals. Why should functional programs be more \"beautiful\" than code written in non-functional languages? How can functional languages allow us to think at a higher level? What does \"higher level\" even mean?</p> <p>These are aesthetic judgments, and reasonable people can disagree on this. In fact, you might be wondering why we should even care about how \"beautiful\" code is. I think a good point of comparison is with mathematical proofs. Most true statements in mathematics can be proved in more than one way. However, good mathematicians definitely favor certain kinds of proofs, which they call more \"beautiful\" or \"elegant\" than others. The mathematician Paul Erd\u00f6s used to talk about \"the Book\", which was where God kept the most perfect proofs of each theorem. There is even a whole book of such proofs, called, not surprisingly, Proofs from the Book.<sup>3</sup> And since computer programs are in some sense concrete crystallizations of mathematical ideas, if you can accept that some proofs are more \"beautiful\" than others, then it's also likely that some ways of writing code are more \"beautiful\" than others. But what would this elusive concept of \"code beauty\" entail?</p> <p>I think one important aspect of beautiful code is that it's lean \u2014 it has nothing superfluous in it. It's concise without being cryptic. It expresses the essence of a computation in as straightforward and clear a way as it can be expressed.</p> <p>The problem with this criterion is that what is \"straightforward\" and \"clear\" depends greatly on the way you've been taught to think about programming. And this is where the \"higher level thinking\" comes in. For example, Python is often praised as a language in which code is extremely clear and readable, and that's true, if you restrict yourself only to the kind of programming idioms that are found in Python (and in most other languages). But functional languages introduce a whole new set of idioms, and once you understand them, you can think at a higher level. And because of this, you can write better code.</p> <p>Here's a simple example. Let's write a function that takes a list of integers and returns a new list, where the new list has all the same numbers as the original list, but multiplied by 2. Also, the original list shouldn't be altered.</p> <p>In Python, you might write this function as follows:</p> <pre><code>def double_list(lst):\n    new_lst = lst[:]\n    for i in range(len(new_lst)):\n        new_lst[i] *= 2\n    return new_lst\n</code></pre> <p>This is pretty straightforward. You copy the list, and then go through each element of the new list, multiplying the element by 2 and storing the new value in place of the old value. Then you return the new list.</p> <p>In OCaml, you could write this function like this:</p> <pre><code>let double_list lst = List.map (fun x -&gt; x * 2) lst\n</code></pre> <p>In fact, you can write it even more concisely:</p> <pre><code>let double_list = List.map (fun x -&gt; x * 2)\n</code></pre> <p>What this is saying is \"take a function which doubles its argument (<code>fun x -&gt; x * 2</code>) and apply (map) it to each element of a list, collecting all the values in a new list\". This includes two ideas which are fundamental to functional languages: anonymous functions (the doubling function doesn't have a name), and mapping a function over a list (although other data structures can also be mapped over). The <code>map</code> function is also a \"higher-order\" function, since its first argument is itself a function. And once you understand these ideas, you can write more elegant code. In this case, we took five lines of Python and reduced them to one line of OCaml.</p> <p>I can't leave this without also mentioning that you can write this code in a functional style in Python as well:</p> <pre><code>def double_list(lst): return list(map(lambda x: x * 2, lst))\n</code></pre> <p>It's not quite as simple as the OCaml code, but it's pretty close.<sup>4</sup> (On the other hand, the OCaml code is type checked, but the Python code isn't.)</p> <p>So Python supports some (but not all) ideas from functional programming.<sup>5</sup> But a lot of Python programmers are unaware of this. So one benefit of learning functional programming is that you'll be able to use some of the functional programming ideas you learn in the languages you already know! In fact, it may totally change the way you write code even in non-functional languages. And the new code you write will be shorter and more elegant than the code you used to write.</p> <p>This is just a very simple example. CS 4 will show you many more kinds of beautiful code, and (more importantly) will teach you how to think about computational processes at a higher level, which will make the code you write better no matter what language you use.</p>"},{"location":"intro/motivation/#is-functional-programming-better-than-other-kinds-of-programming","title":"Is functional programming better than other kinds of programming?","text":"<p>It depends on the application.</p> <p>We love functional programming, but we are not zealots. Functional programming is a great fit for a lot of different programming tasks, but it isn't right for everything. Furthermore, in practice, language choice is usually much more likely to be made because of the availability of libraries than because of any intrinsic quality of the language.</p> <p>For instance, if you are programming graphical user interfaces (GUIs), you would probably be better off using Java than OCaml, because Java has more and better GUI libraries than OCaml does, and object-oriented programming has proven to be a good fit for this task. Or if you are doing numerical computations for machine learning or data science, you might be better off using Python with NumPy and Pandas, because those libraries are better suited for those tasks than anything in OCaml (at least currently).</p> <p>On the other hand, if you're doing anything that involves very complex algorithms, symbolic manipulations, or are writing an interpreter (e.g. if you take CS 131) or a compiler (e.g. if you take CS 164), functional programming and OCaml are a great fit. It takes time to learn which kinds of problems are best suited to which languages, but having a functional language in your toolkit is a good idea, not least because other languages (even Java!) keep borrowing ideas from functional languages.</p>"},{"location":"intro/motivation/#why-are-we-using-ocaml","title":"Why are we using OCaml?","text":"<p>There are a number of programming languages that are usually considered to be \"functional programming languages\". Why are we choosing to use OCaml instead of another one (say, Haskell)?</p> <p>There are three reasons for this:</p> <ol> <li> <p>OCaml contains all the features one would expect to have in a full-fledged functional programming language.</p> </li> <li> <p>OCaml is easier to learn than many other functional languages. In particular, it's easier to learn than Haskell. (But after learning OCaml, Haskell is a lot easier to learn; take CS 115 if you're interested in Haskell.)</p> </li> <li> <p>OCaml is not dogmatic. In addition to its functional features, OCaml also fully supports imperative and object-oriented programming, and sometimes, those features are exactly what you need in order to write the best code.</p> </li> </ol> <p>In addition to being a great on-ramp to the world of functional programming, OCaml is a useful language in its own right, and is used as a production language in a number of companies, including Jane Street Capital, Bloomberg, and Facebook.</p>"},{"location":"intro/motivation/#going-further","title":"Going further","text":"<p>If you want to go deeper into the world of functional programming after taking this course, take CS 115 and you'll learn Haskell and how it differs from the ideas you'll learn in CS 4. In some ways, Haskell is a \"super-OCaml\" which pushes functional programming ideas to their limits. In other ways (notably the module system and its multi-paradigm nature) OCaml still has the edge.</p> <p>Recently, the Rust programming language has become quite popular. Rust is a systems-level language which does not use garbage collection and which is used for computationally-intensive tasks. The Rust compiler was originally written in OCaml, but more interesting to us is that the Rust language has borrowed many features from OCaml, including algebraic datatypes, pattern matching and an emphasis on immutable data. If you want to learn Rust, learning OCaml is an excellent starting point. In fact, Rust is basically as close to a functional language as you can get without having garbage collection.</p> <p>Note</p> <p>There is a CS 11 Rust track which is taught in the Spring term, so take that if you are interested in Rust.</p> <p>In addition to Rust, there are other languages that are even closer to OCaml, including F#, which is a language very similar to OCaml for the .NET platform, and ReScript and ReasonML, which are OCaml dialects which compile to Javascript. All of these languages are used for very practical purposes (including web development), so they aren't just academic languages. And there are many other functional languages that share many features with OCaml, including Lisp dialects (Common Lisp, Scheme, Racket, and Clojure), Erlang dialects (Erlang itself and Elixir), and many others.</p> <p>Learning OCaml will make it much easier to learn any of these languages.</p> <ol> <li> <p>That is, except for the substitution model evaluations. Those aren't much fun, but we think that they're worth doing \u2014 once.\u00a0\u21a9</p> </li> <li> <p>At least, OCaml has them. Haskell, another well-known functional language, kind-of has them, but the story is more complicated. Take CS 115 to learn all about Haskell.\u00a0\u21a9</p> </li> <li> <p>However, to the best of our knowledge, God was not directly involved in the preparation of this book.\u00a0\u21a9</p> </li> <li> <p>You can make the Python code even shorter using list comprehensions:</p> <pre><code>def double_list(lst): return [x * 2 for x in lst]\n</code></pre> <p>OCaml doesn't have list comprehensions, though other functional languages (like Haskell) do. In fact, Python borrowed the idea of list comprehensions from Haskell.\u00a0\u21a9</p> </li> <li> <p>One very important idea from functional programming is called tail call optimization, which we'll be learning about. People have been begging Guido van Rossum (the author of Python) to add tail call optimization to Python for a long time, but so far he has vetoed it.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/welcome/","title":"Welcome to CS 4!","text":"<p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about the material.  In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>coding notes and tips</li> <li>readings on particular topics</li> </ul> <p>and anything else we consider useful. Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>lecture slides</li> <li>code supplied to students for assignments</li> <li>exams (midterm and final)</li> <li>some administrative information e.g. contact information</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"intro/welcome/#instructor-and-course-staff","title":"Instructor and course staff","text":"<p>The course instructor is Mike Vanier (mvanier@cms.caltech.edu).</p> <p>The teaching assistants are listed in the syllabus. Their contact information will be posted on the course Canvas page.</p>"},{"location":"intro/welcome/#what-this-course-is-about","title":"What this course is about","text":"<p>This course is officially titled \"Fundamentals of Computer Programming\", but that's a vague name that says basically nothing about what the course is about. What this course actually is is an introduction to functional programming using the OCaml programming language.</p> <p>More importantly, this is a course on teaching you a new, better, and more enjoyable way of programming.<sup>1</sup> What this means will be fleshed out in the lectures and in the assignments.</p> <p>This course will be a bit disorienting and even mind-bending at times, but our primary goal is to expose you to new ideas, new ways of programming, and for you to have an enjoyable time learning. If you aren't having fun, we aren't doing our job right, so let us know what you don't like so we can improve it!</p> <p>For more general information about the course, please read the motivation and history pages.</p> <ol> <li> <p>All opinions expressed are the views of the instructor and do not necessarily reflect the views of other instructors, other professors in the Caltech CMS department, or the majority of programmers  and employers of programmers in the world.\u00a0\u21a9</p> </li> </ol>"},{"location":"readings/ocaml_cheat_sheet/","title":"OCaml syntax cheat sheet","text":"<p>OCaml is a great language, but its syntax is not its best feature. More importantly, the syntax is probably quite different from any other language you know, so getting comfortable with it will take some time.</p> <p>In this document we describe aspects of OCaml syntax that are most likely to be confusing and/or counterintuitive, as well as some other features which may trip you up. This document is not a complete description of OCaml syntax. For that, consult the lectures and the online OCaml documentation. We also refer you to the official OCaml cheat sheet which is here.</p> <p>Along the way, we will also sometimes mention non-syntactic aspects of OCaml that are confusing to new OCaml programmers.</p>"},{"location":"readings/ocaml_cheat_sheet/#operators","title":"Operators","text":""},{"location":"readings/ocaml_cheat_sheet/#operator-underloading","title":"Operator underloading","text":"<p>OCaml doesn't overload most of its operators. Notably, arithmetic operators like <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> are not overloaded. Instead, they are considered to be exclusively integer operators. The corresponding operators on floating-point numbers have an extra dot (<code>.</code>) at the end e.g. <code>+.</code>, <code>-.</code>, <code>*.</code> and <code>/.</code>. Confusingly, the floating-point power operator (<code>**</code>) doesn't have a dot at the end.</p> <pre><code># let sumsq x y = x *. x +. y *. y;;\nval sumsq : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre> <p>This is by far the most annoying aspect of OCaml's syntax. The reason for it is so that every operator has a very specific type, which makes type inference much simpler.</p>"},{"location":"readings/ocaml_cheat_sheet/#operator-overloading","title":"Operator overloading","text":"<p>On the other hand, OCaml does overload some operators. The comparison/equality operators (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) are all polymorphic, which means they work on arbitrary OCaml datatypes. (This is also true of the <code>max</code> and <code>min</code> functions.) One exception: you are not allowed to compare functional values, though you can check identity:</p> <pre><code># abs;;\n- : int -&gt; int = &lt;fun&gt;\n# abs == abs;;\n- : bool = true\n# abs = abs;;\nException: Invalid_argument \"compare: functional value\".\n# max abs abs;;\nException: Invalid_argument \"compare: functional value\".\n</code></pre> <p>We'll discuss equality comparisons and identity comparisons below.</p>"},{"location":"readings/ocaml_cheat_sheet/#operators-as-functions","title":"Operators as functions","text":"<p>This is a good feature, but it can be confusing as well. Operators can be converted into two-argument functions by wrapping parentheses around them. For instance, the operator <code>+</code> can be made into the two-argument function <code>(+)</code>.</p> <pre><code># (+);;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 + 3;;\n- : int = 5\n# (+) 2 3;;\n- : int = 5\n</code></pre> <p>The only time this causes problems is with the multiplication operators (<code>*</code>) and (<code>*.</code>), because if the left parenthesis is next to the asterisk OCaml thinks it's the start of a comment:</p> <pre><code># (*);;\nLine 1, characters 0-3:\n1 | (*);;\n    ^^^\nWarning 1: this `(*' is the start of a comment.\nHint: Did you forget spaces when writing the infix operator `( * )'?\n* *);;\n# ( * ) ;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# ( *);;\nLine 1, characters 2-4:\n1 | ( *);;\n      ^^\nWarning 2: this is not the end of a comment.\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>(Notice that after the first error the prompt changed to <code>*</code> (which means that OCaml thinks we're still inside a comment) and we had to manually insert a <code>*)</code> to close the comment.)</p> <p>Fortunately, here OCaml is smart enough to catch this problem and issue a warning. However, this doesn't always happen (see below).</p>"},{"location":"readings/ocaml_cheat_sheet/#equalityinequality-operators","title":"Equality/inequality operators","text":"<p>OCaml has two different equality operators and two different inequality operators:</p> <ul> <li>equality: <code>=</code> and <code>==</code></li> <li>inequality: <code>&lt;&gt;</code> and <code>!=</code></li> </ul> <p>Almost always, you want to use the <code>=</code> operator for equality testing and the <code>&lt;&gt;</code> operator for inequality testing. They test for structural equality i.e. whether one operand is equivalent to the other (or \"has the same contents\"). The <code>==</code> and <code>!=</code> operators check for identity i.e. whether two things are the exact same thing in memory. Even though this may sometimes work, it can lead to very difficult-to-find bugs. (It's unfortunate that the operators you shouldn't use in OCaml are the ones you should use in most other languages.)</p> <pre><code># \"foo\" = \"bar\";;\n- : bool = false\n# \"foo\" = \"foo\";;\n- : bool = true\n# \"foo\" == \"foo\";;\n- : bool = false   (* not the same object in memory! *)\n# \"foo\" &lt;&gt; \"bar\";;\n- : bool = true\n# \"foo\" != \"bar\";;\n- : bool = true\n# \"foo\" &lt;&gt; \"foo\";;\n- : bool = false\n# \"foo\" != \"foo\";;\n- : bool = true\n</code></pre> <p>Here, the two <code>\"foo\"</code>s are different objects in memory.</p> <pre><code># let x = \"foo\";;\nval x : string = \"foo\"\n# x = x;;\n- : bool = true\n# x == x;;\n- : bool = true\n</code></pre> <p>Here, <code>x</code> is equal to itself and is also the same object in memory as itself.</p>"},{"location":"readings/ocaml_cheat_sheet/#word-operators","title":"Word operators","text":"<p>OCaml has a number of infix operators which are words. Here they are:</p> Operator Description <code>mod</code> integer remainder (modulus) <code>asr</code> arithmetic shift right <code>lsr</code> logical shift right <code>lsl</code> logical shift left <code>land</code> logical (bitwise) AND <code>lor</code> logical (bitwise) OR <code>lxor</code> logical (bitwise) XOR <code>lnot</code> logical (bitwise) NOT <p>You probably won't need any of these except the <code>mod</code> operator, which is handy:</p> <pre><code># 5 mod 2;;\n- : int = 1\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#unusual-operators","title":"Unusual operators","text":"<p>The built-in OCaml operators are described in the documentation for the <code>Stdlib</code> library, which is here.</p> <p>Note especially the following operators:</p> Operator Description <code>^</code> string concatenation <code>^^</code> format string concatenation <code>@</code> list concatenation <code>~-</code> unary negation <code>~-.</code> unary float negation <code>@@</code> function application (<code>f @@ x</code> is the same as <code>f x</code>) <code>|&gt;</code> reverse function application (<code>x |&gt; f</code> is the same as <code>f x</code>) <code>!</code> dereference a <code>ref</code> cell <code>:=</code> assignment into a <code>ref</code> cell <p>Note that unary negation can also be indicated by a <code>-</code> or <code>-.</code> operator without a left-hand operand, if there is no ambiguity. The <code>~-</code> and <code>~-.</code> operators are strictly unary operators and can work in contexts where conventional unary negation doesn't:</p> <pre><code># -1;;\n- : int = -1\n# abs (-1);;\n- : int = 1\n# abs -1;;\nLine 1, characters 0-3:\n1 | abs -1;;\n    ^^^\nError: This expression has type int -&gt; int\n       but an expression was expected of type int\n</code></pre> <p>OCaml is telling you you can't subtract 1 from the <code>abs</code> function.</p> <pre><code># ~-1;;\n- : int = -1\n# abs ~-1;;\n- : int = 1\n</code></pre> <p>This works. Here's another example where these operators are handy:</p> <pre><code># List.map (~-) [1;2;3;4;5];;\n- : int list = [-1; -2; -3; -4; -5]\n</code></pre> <p>Nevertheless, most people don't bother with the unary negation operators and just add extra parentheses if needed.</p> <p>The function application operators are interesting. The reverse function application operator <code>|&gt;</code> is nearly always used to chain together a series of computations, each taking the result of the previous one:</p> <pre><code># open List;;\n# map (fun x -&gt; x * 2) [1; 2; 3; 4; 5];;\n- : int list = [2; 4; 6; 8; 10]\n# filter (fun x -&gt; x &gt; 5) (map (fun x -&gt; x * 2) [1; 2; 3; 4; 5]);;\n- : int list = [6; 8; 10]\n# List.fold_left max 0\n    (filter (fun x -&gt; x &gt; 5) (map (fun x -&gt; x * 2) [1; 2; 3; 4; 5]));;\n- : int = 10\n# [1; 2; 3; 4; 5]\n    |&gt; map (fun x -&gt; x * 2)\n    |&gt; filter (fun x -&gt; x &gt; 5)\n    |&gt; List.fold_left max 0;;\n- : int = 10\n</code></pre> <p>I'd argue that the last expression is much more readable than the second-last one. You read it as \"take the list from 1 to 5, double all the numbers, keep only the numbers that are greater than 5, and find the maximum\". (You don't have to line up the <code>|&gt;</code> operators, but it looks good that way.)</p> <p>The function call after a <code>|&gt;</code> gets one less argument than usual, which is supplied by the result of evaluating the expression before the <code>|&gt;</code>.</p> <p>The <code>@@</code> operator might seem useless since <code>f @@ x</code> is the same as <code>f x</code>. However, its precedence is extremely low, so the expression to the right of the <code>@@</code> will be evaluated before calling the function. This can allow us to drop some parentheses:</p> <pre><code># abs (-2 + 1);;\n- : int = 1\n# abs @@ (-2 + 1);;\n- : int = 1\n# abs @@ -2 + 1;;\n- : int = 1\n</code></pre> <p>Note that the expression <code>-2 + 1</code> is evaluated in the last case before calling the <code>abs</code> function. This can be useful if you have a lot of functions acting on the result of other functions. (Note that this is just like the <code>|&gt;</code> operator except that the function calls are arranged right-to-left instead of left-to-right.) Another example:</p> <pre><code># List.rev (List.sort compare [4;2;5;2;7;5;4;1;3;9;0]);;\n- : int list = [9; 7; 5; 5; 4; 4; 3; 2; 2; 1; 0]\n# List.rev @@ List.sort compare [4;2;5;2;7;5;4;1;3;9;0];;\n- : int list = [9; 7; 5; 5; 4; 4; 3; 2; 2; 1; 0]\n</code></pre> <p>One of the least-used operators is the <code>^^</code> operator, which concatenates strings used as format strings. We will talk about this below.</p> <p>Note that some libraries define their own operators (see below). For instance, the <code>Num</code> library defines operators on rational numbers: <code>+/</code>, <code>-/</code>, <code>*/</code>, and <code>//</code>. (These also work with arbitrary-precision integers, since the <code>Num</code> data type contains both these and arbitrary-precision rationals.)</p>"},{"location":"readings/ocaml_cheat_sheet/#defining-new-operators","title":"Defining new operators","text":"<p>Unusually for programming languages, OCaml allows you to define your own operators. All user-defined operators must be made from \"operator characters\" and get their operator precedence and associativity from the first character of the operator (if it is itself an operator).</p> <pre><code># let (++) x y = x * y;;\nval ( ++ ) : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 ++ 3;;\n- : int = 6\n# 1 + 2 ++ 3;;\n- : int = 9\n</code></pre> <p>Note that the <code>++</code> operator has the same precedence as the <code>+</code> operator, so the expression <code>1 + 2 ++ 3</code> is evaluated from left to right. Let's try this with a new operator that starts with the <code>*</code> character instead:</p> <pre><code># let (*+) x y = x * y;;\n* *);;\nLine 2, characters 2-4:\n2 | *);;\n      ^^\nError: Syntax error\n</code></pre> <p>Oops! We forgot that the <code>(*</code> characters will be interpreted as the start of a comment. Notice that we didn't even get an error message; the prompt just turned to a <code>*</code> (indicating that OCaml thought we were still in a comment). When we added the <code>*)</code> to terminate the comment, we got an unhelpful error message.</p> <pre><code># let ( *+ ) x y = x * y;;\nval ( *+ ) : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 *+ 3;;\n- : int = 6\n# 1 + 2 *+ 3;;\n- : int = 7\n</code></pre> <p>Now we see that the <code>*+</code> operator has the same precedence as the <code>*</code> operator.</p> <p>Tip</p> <p>When defining new operators, it's always a good idea to put a blank space after the <code>(</code> and before the <code>)</code> characters that surround the operator.</p> <p>You can even define unary prefix operators, as long as they start with the <code>!</code> character:</p> <pre><code># let ( !++ ) x = x := !x + 1;;\nval ( !++ ) : int ref -&gt; unit = &lt;fun&gt;\n# let r = ref 0;;\nval r : int ref = {contents = 0}\n# !++ r;;\n- : unit = ()\n# !r;;\n- : int = 1\n</code></pre> <p>We will have more to say about <code>ref</code> types below.</p>"},{"location":"readings/ocaml_cheat_sheet/#printf-and-format-strings","title":"<code>printf</code> and format strings","text":"<p>OCaml has a <code>printf</code> function (technically, <code>Printf.printf</code>) which has a number of pecularities. Check this out:</p> <pre><code># Printf.printf;;\n- : ('a, out_channel, unit) format -&gt; 'a = &lt;fun&gt;\n# Printf.printf \"%d\\n\";;\n- : int -&gt; unit = &lt;fun&gt;\n# \"%d\\n\";;\n- : string = \"%d\\n\"\n</code></pre> <p>So even though <code>\"%d\\n\"</code> appears to be just a string, somehow it can also be the first argument of <code>Printf.printf</code>, where it is somehow compatible with the type <code>('a, out_channel, unit) format</code>. What is actually happening is that OCaml is turning a literal string into a something that does not have the <code>string</code> type, but is instead something called a format string. You can actually convert strings to format strings manually, but do not expect to understand the process:</p> <pre><code># format_of_string;;\n- : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n&lt;fun&gt;\n# let fs = format_of_string \"%d\\n\";;\nval fs :\n  (int -&gt; '_weak5, '_weak6, '_weak7, '_weak8, '_weak8, '_weak5) format6 =\n  CamlinternalFormatBasics.Format\n   (CamlinternalFormatBasics.Int (CamlinternalFormatBasics.Int_d,\n     CamlinternalFormatBasics.No_padding,\n     CamlinternalFormatBasics.No_precision,\n     CamlinternalFormatBasics.Char_literal ('\\n',\n      CamlinternalFormatBasics.End_of_format)),\n   \"%d\\n\")\n# Printf.printf fs;;\n- : int -&gt; unit = &lt;fun&gt;\n# Printf.printf fs 10;;\n10\n- : unit = ()\n</code></pre> <p>Note</p> <p>Another peculiarity is that <code>format_of_string</code> only works when the string argument is a literal string; its first argument is not actually a string. Don't worry about any of this!</p> <p>Regardless of the weird types that format strings have, when you give a (literal) format string as the first argument of <code>Printf.printf</code>, the result will have the correct type (here, <code>int -&gt; unit</code> because it takes an <code>int</code> and returns a value of type <code>unit</code>).</p> <p>Since format strings aren't strings, this doesn't work:</p> <pre><code># let fs = \"%d\\n\";;\nval fs : string = \"%d\\n\"\n# Printf.printf fs 10;;\nLine 1, characters 14-16:\n1 | Printf.printf fs 10;;\n                  ^^\nError: This expression has type string but an expression was expected of type\n         ('a -&gt; 'b, out_channel, unit) format =\n           ('a -&gt; 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n</code></pre> <p>One issue with format strings is that sometimes you would like to be able to divide them over multiple lines. However, you can't just concatenate them as if they were strings:</p> <pre><code># Printf.printf (\"int: %d\\t\" ^ \"string: %s\\n\") 10 \"foo\";;\nLine 1, characters 14-44:\n1 | Printf.printf (\"int: %d\\t\" ^ \"string: %s\\n\") 10 \"foo\";;\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a -&gt; 'b -&gt; 'c, out_channel, unit) format =\n           ('a -&gt; 'b -&gt; 'c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n</code></pre> <p>Instead, you have to use the special format string concatenation operator <code>(^^)</code> to do the job:</p> <pre><code># Printf.printf (\"int: %d\\t\" ^^ \"string: %s\\n\") 10 \"foo\";;\nint: 10 string: foo\n- : unit = ()\n# (^^) ;;\n- : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt;\n    ('f, 'b, 'c, 'e, 'g, 'h) format6 -&gt; ('a, 'b, 'c, 'd, 'g, 'h) format6\n= &lt;fun&gt;\n# \"int: %d\\t\" ^^ \"string: %s\\n\";;\n- : (int -&gt; string -&gt; '_weak9, '_weak10, '_weak11, '_weak12, '_weak12,\n     '_weak9)\n    format6\n=\nCamlinternalFormatBasics.Format\n (CamlinternalFormatBasics.String_literal (\"int: \",\n   CamlinternalFormatBasics.Int (CamlinternalFormatBasics.Int_d,\n    CamlinternalFormatBasics.No_padding,\n    CamlinternalFormatBasics.No_precision,\n    CamlinternalFormatBasics.Char_literal ('\\t',\n     CamlinternalFormatBasics.String_literal (\"string: \",\n      CamlinternalFormatBasics.String (CamlinternalFormatBasics.No_padding,\n       CamlinternalFormatBasics.Char_literal ('\\n',\n        CamlinternalFormatBasics.End_of_format)))))),\n \"int: %d\\t%,string: %s\\n\")\n</code></pre> <p>You probably won't need this operator much, if at all.</p>"},{"location":"readings/ocaml_cheat_sheet/#lists","title":"Lists","text":"<p>There are three important things you need to remember about lists in OCaml:</p> <ol> <li>All the elements of a list must be of the same type.</li> <li>You can't change the elements of a list.</li> <li>Elements are separated with semicolons (<code>;</code>), not commas.</li> </ol> <p>A very common pitfall is to use commas instead of semicolons, which not only doesn't do what you expect but sometimes seems to work only to fail later while giving hilariously obscure type errors. We will see why in the section on tuples below. Remember: OCaml's syntax is different from Python's!</p> <p>There is a List module with many useful functions on lists.</p>"},{"location":"readings/ocaml_cheat_sheet/#arrays","title":"Arrays","text":"<p>Syntactically, arrays are exactly like lists except that they use different delimiters. Instead of <code>[</code> and <code>]</code> arrays use <code>[|</code> and <code>|]</code>. Here is a literal array:</p> <pre><code># let my_array = [| 1; 2; 3; 4; 5 |];;\nval my_array : int array = [|1; 2; 3; 4; 5|]\n</code></pre> <p>Notice that the array has type <code>int array</code>; the type of the elements is part of the type of the array.</p> <p>Accessing elements from arrays uses the unusual <code>&lt;array&gt;.(&lt;index&gt;)</code> syntax:</p> <pre><code># my_array.(0);;\n- : int = 1\n# my_array.(4);;\n- : int = 5\n# my_array.(5);;\nException: Invalid_argument \"index out of bounds\".\n</code></pre> <p>Mutating (changing) elements in an array also uses an unusual syntax:</p> <pre><code># my_array;;\n- : int array = [|1; 2; 3; 4; 5|]\n# my_array.(0) &lt;- 42;;\n- : unit = ()\n# my_array;;\n- : int array = [|42; 2; 3; 4; 5|]\n</code></pre> <p>There is an Array module with many useful functions on arrays.</p>"},{"location":"readings/ocaml_cheat_sheet/#tuples","title":"Tuples","text":"<p>A fundamental data type in OCaml is the tuple (pronounced \"too-ple\" or \"tup-ple\" depending on your preference; I prefer \"too-ple\"). It is nothing more than a sequence of arbitrary OCaml values wrapped in parentheses, separated by commas. Tuples can (and usually do) contain data of different types.</p> <p>Note</p> <p>Tuples exist in Python too, but in that language they are almost superfluous, being basically a restricted form of lists. In OCaml, tuples are necessary because lists can only contain one type of data.</p>"},{"location":"readings/ocaml_cheat_sheet/#type-notation","title":"Type notation","text":"<p>The notation for tuple types is a bit weird; they are written as the product of the individual types:</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n</code></pre> <p>This tuple has the type <code>int * string * float</code>, which is a type-theoretic \"product\" of the individual types. This notion of \"product\" is basically the same as the set-theoretic notion, but don't worry about that. Just make sure you realize that this use of the <code>*</code> operator doesn't represent multiplication.</p>"},{"location":"readings/ocaml_cheat_sheet/#implicit-parentheses","title":"Implicit parentheses","text":"<p>Unfortunately, OCaml (like Python) allows you to omit the parentheses in many situations:</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n# 1, \"foo\", 3.14;;\n- : int * string * float = (1, \"foo\", 3.14)\n# let tup = (1, \"foo\", 3.14);;\nval tup : int * string * float = (1, \"foo\", 3.14)\n# let tup = 1, \"foo\", 3.14;;\nval tup : int * string * float = (1, \"foo\", 3.14)\n</code></pre> <p>\"So what?\", you say. \"What's the big deal?\" Well, look at this code:</p> <pre><code># [1; 2; 3];;\n- : int list = [1; 2; 3]\n</code></pre> <p>This is the correct way to write a list, using semicolons as separators. A common error is to write lists with commas, which gives this:</p> <pre><code># [1, 2, 3];;\n- : (int * int * int) list = [(1, 2, 3)]\n</code></pre> <p>Note that this is not a syntax error! Instead, OCaml has interepreted the commas as meaning a tuple, so it thinks you want a list with a single element which is a 3-tuple. Then, when you try to use this list, it will not do what you expect, and the error messages will probably not be very helpful.</p> <p>We recommend that you never write a tuple without explicit parentheses. However, this will not fix the problem above, because OCaml will still interpret the wrongly-written \"list\" as a list of N-tuples. Ultimately, you just have to be able to recognize this problem for what it is, and learn to write lists the right way.</p>"},{"location":"readings/ocaml_cheat_sheet/#commas-vs-semicolons","title":"Commas vs. semicolons","text":"<p>What about the opposite problem: writing a tuple with semicolons as separators instead of using commas?</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n# (1; \"foo\"; 3.14);;\nLine 1, characters 1-2:\n1 | (1; \"foo\"; 3.14);;\n     ^\nWarning 10: this expression should have type unit.\nLine 1, characters 4-9:\n1 | (1; \"foo\"; 3.14);;\n        ^^^^^\nWarning 10: this expression should have type unit.\n- : float = 3.14\n</code></pre> <p>A parenthesized expression with semicolon separators is a sequence expression, which is mainly used in imperative code. (You can also write them with <code>begin</code>/<code>end</code> delimiters instead of parentheses, which we prefer.) In a sequence expression, all but the last subexpression should have type <code>unit</code>, or you get warnings (as you see above). You probably won't run into this pitfall, but you should be aware of it. We will talk about sequence expressions more below when we discuss imperative programming.</p>"},{"location":"readings/ocaml_cheat_sheet/#records","title":"Records","text":"<p>Records are basically a generalization of tuples where each component of the record has a name (called a \"field name\", so each component is a \"field\" of the record). You need to define a record type before using a record.</p> <pre><code>type my_record = { foo : int; bar : string }\n</code></pre> <p>Then you can create records by giving the field names and the values like this:</p> <pre><code>let a_record = { foo = 10; bar = \"ten\" }\n</code></pre> <p>You can extract the contents of a record using the \"dot notation\" as in most programming languages:</p> <pre><code>Printf.printf \"foo field: %d\\n\" a_record.foo\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#pattern-matching-and-field-punning","title":"Pattern matching and field punning","text":"<p>To pattern match on a record, you give the field names and corresponding variable names that you choose.</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x = x_coord; y = y_coord } = x_coord + y_coord\n</code></pre> <p>Note that <code>x</code> and <code>y</code> are field names here, and <code>x_coord</code> and <code>y_coord</code> are variable names you chose for this function.</p> <p>Note that the field names don't have to come in any particular order:</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { y = y_coord; x = x_coord } = x_coord + y_coord\n</code></pre> <p>A shortcut is to use the field name as a variable name. This is called field punning.</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x; y } = x + y\n(* Also OK: let sum_xy { y; x } = x + y *)\n</code></pre> <p>This is exactly equivalent to:</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x = x; y = y } = x + y\n</code></pre> <p>but shorter.</p>"},{"location":"readings/ocaml_cheat_sheet/#matching-a-part-of-a-record","title":"Matching a part of a record","text":"<p>Often, we only need part of a record. You could write code like this:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x = x_coord; y = y_coord } = x_coord\n</code></pre> <p>but you might get a warning about unused variable names. The solution is to use the <code>_</code> syntax:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x = x_coord; _ } = x_coord\n</code></pre> <p>The <code>_</code> means \"all other fields in the record\".</p> <p>With field punning, this becomes:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x; _ } = x\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#strings","title":"Strings","text":"<p>Strings are pretty standard in OCaml, except that the notation for accessing characters in a string is weird:</p> <pre><code># let s = \"this is a string\";;\nval s : string = \"this is a string\"\n# s.[0];;\n- : char = 't'\n# s.[9];;\n- : char = ' '\n</code></pre> <p>OCaml treats strings like a kind of specialized array. Up until recently, strings were mutable (you could change the characters in a string). Thankfully, that is no longer the case. (There is a mutable string type called <code>bytes</code> if you really need it.)</p>"},{"location":"readings/ocaml_cheat_sheet/#conditionals","title":"Conditionals","text":""},{"location":"readings/ocaml_cheat_sheet/#if-expressions","title":"<code>if</code> expressions","text":"<p>In most programming languages, <code>if</code> is a statement, but in functional languages like OCaml, <code>if</code> is an expression. This means that an <code>if</code> expression returns a value. This is nice in that you can use <code>if</code> expressions anywhere an expression is desired. For instance, this function computes the ratio of the maximum and minimum of two floats:</p> <pre><code>let scale x y = (if x &gt; y then x else y) /. (if x &gt; y then y else x)\n</code></pre> <p>(Note the <code>/.</code> operator for float division.) This is not the most elegant way to write this function, but it illustrates that <code>if</code> expressions can be embedded in larger expressions.</p> <p>Since <code>if</code> is an expression, <code>if</code> expressions must have a specific type regardless of whether the test clause of the <code>if</code> returns <code>true</code> or <code>false</code>. Therefore, both branches of the <code>if</code> (the <code>then</code> branch and the <code>else</code> branch) must be expressions which have the exact same type. Something like this is not legal:</p> <pre><code># let a = 10;;\nval a : int = 10\n# let b = 20;;\nval b : int = 20\n# if a &gt; b then \"success\" else 0;;\nLine 1, characters 29-30:\n1 | if a &gt; b then \"success\" else 0;;\n                                 ^\nError: This expression has type int but an expression was expected of type\n         string\n</code></pre> <p>This is easy to understand, but things are not always so clear, as we will see.</p>"},{"location":"readings/ocaml_cheat_sheet/#if-without-else","title":"<code>if</code> without <code>else</code>","text":"<p>OCaml allows you to have an <code>if</code> expression without an <code>else</code> clause, but if you do that, the <code>then</code> clause must have type <code>unit</code>.</p> <pre><code># let a = 10;;\nval a : int = 10\n# if a &gt; 5 then Printf.printf \"big!\\n\";;\nbig!\n- : unit = ()\n</code></pre> <p>This works because <code>printf</code> has a return type of <code>unit</code>. But this won't work:</p> <pre><code># let b = if a &gt; 5 then 10;;\nLine 1, characters 22-24:\n1 | let b = if a &gt; 5 then 10;;\n                          ^^\nError: This expression has type int but an expression was expected of type\n         unit\n       because it is in the result of a conditional with no else branch\n</code></pre> <p>Both branches of a conditional must have the same type, and if you leave out the <code>else</code> branch, its type is assumed to be <code>unit</code>. In other words, <code>if</code> without <code>else</code> is desugared as follows. This:</p> <pre><code>if &lt;bool expr&gt; then &lt;then expr&gt;\n</code></pre> <p>is equivalent to this:</p> <pre><code>if &lt;bool expr&gt; then &lt;then expr&gt; else ()\n</code></pre> <p>When you think about it, this makes perfect sense. Normally you would only want to do an <code>if</code>-without-<code>else</code> if you are writing imperative code in the <code>then</code> clause (see below).</p>"},{"location":"readings/ocaml_cheat_sheet/#else-if","title":"<code>else if</code>","text":"<p>Technically, OCaml doesn't have an <code>else if</code> construct. However, if you're careful you can use it anyway:</p> <pre><code># let abs x =\n  if x &lt; 0 then\n    -x\n  else if x &gt; 0 then\n    x\n  else 0;;\nval abs : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>What's actually happening is that there are two nested <code>if</code> expressions:</p> <pre><code># let abs x =\n  if x &lt; 0 then\n    -x\n  else\n    (if x &gt; 0 then\n       x\n     else 0);;\n</code></pre> <p>As long as you can write your code as a sequence of nested <code>if</code> expressions like this, it will work as you expect. But if you put something more complicated in one of the <code>then</code> or <code>else</code> clauses (like another <code>if</code> expression) you may have to wrap parentheses or a <code>begin</code>/<code>end</code> pair around the inner expression:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\"\n    (* no else! *)\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\nval test : int -&gt; unit = &lt;fun&gt;\n# test 15;;\ninner if\n- : unit = ()\n# test 9;;\n- : unit = ()\n</code></pre> <p>Note that <code>test 9</code> doesn't print anything, though we might expect it to print <code>\"outer if 1\"</code>. The code above is parsed as follows:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      (if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\"\n       else if n mod 3 = 0 then\n         Printf.printf \"outer if 1\\n\"\n       else\n         Printf.printf \"outer if 2\\n\")\n  ;;\n</code></pre> <p>which is probably not what was intended. To fix it, insert either parentheses or a <code>begin</code>/<code>end</code> pair to disambiguate it:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      (if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\")\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\nval test : int -&gt; unit = &lt;fun&gt;\n# test 15;;\ninner if\n- : unit = ()\n# test 9;;\nouter if 1\n- : unit = ()\n# test 8;;\nouter if 2\n- : unit = ()\n</code></pre> <p>With <code>begin</code>/<code>end</code> it looks like this:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      begin\n        if n mod 3 = 0 then\n          Printf.printf \"inner if\\n\"\n      end\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\n</code></pre> <p>Either are acceptable.</p> <p>If OCaml's <code>else if</code> situation makes you uneasy, there is a perfectly reasonable alternative... that will probably also make you uneasy! It's a way of using OCaml's <code>match</code> form that is like a sequence of <code>if</code>/<code>else if</code>/<code>else</code> forms. Example:</p> <pre><code>let abs n =\n  match () with\n    | _ when n &gt; 0 -&gt; n\n    | _ when n &lt; 0 -&gt; -n\n    | _ -&gt; 0\n</code></pre> <p>We match against <code>()</code> because we don't care about the value matched; that's also why we use the <code>_</code> in each clause of the match. Instead, we're using the <code>match</code> form solely because of the ability to use <code>when</code> pattern guards; these contain the actual logic. This can often be a bit more concise and clean than an actual <code>else if</code>, but be careful: if you need to do another <code>match</code> in the expression following the right arrow (<code>-&gt;</code>) you may have to wrap it in parentheses or a <code>begin</code>/<code>end</code> form (see below for why).</p>"},{"location":"readings/ocaml_cheat_sheet/#functions","title":"Functions","text":"<p>OCaml is a functional language, so functions are fundamental. There are a number of unusual features of OCaml functions.</p>"},{"location":"readings/ocaml_cheat_sheet/#syntax-and-currying","title":"Syntax and currying","text":"<p>Unlike most conventional languages, OCaml doesn't require you to put parentheses around the arguments to a function. In fact, if you do, you change the meaning! Consider this innocent-looking function:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n# add 2 3;;\n- : int = 5\n# add (2 + 3) (3 + 4);;\n- : int = 12\n</code></pre> <p>OK, so we can get by without parentheses around the arguments. (The parentheses in the last line are to create the arguments, not to surround them for the function call.) What if we use them anyway?</p> <pre><code># add (2, 3);;\nLine 1, characters 4-10:\n1 | add (2, 3);;\n        ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n</code></pre> <p>Nope, that isn't correct. The error message may confuse you. Let's see a variation:</p> <pre><code># let add' (x, y) = x + y;;\nval add' : int * int -&gt; int = &lt;fun&gt;\n# add' (2, 3);;\n- : int = 5\n</code></pre> <p>(Note that in OCaml, you can use the <code>'</code> character (pronounced \"prime\") in identifiers.)</p> <p>If we define the function with parentheses, we have to call it with parentheses. If not:</p> <pre><code># add' 2 3;;\nLine 1, characters 0-4:\n1 | add' 2 3;;\n    ^^^^\nError: This function has type int * int -&gt; int\n       It is applied to too many arguments; maybe you forgot a `;'.\n</code></pre> <p>Huh. What is really going on here?</p> <p>Look at the second version again:</p> <pre><code># let add' (x, y) = x + y;;\nval add' : int * int -&gt; int = &lt;fun&gt;\n</code></pre> <p>Look at the type signature. The <code>int * int</code> part says that the input to the function is a single argument which must be a two-tuple (a tuple with two elements), where both elements are <code>int</code>s. If you leave the arguments \"naked\", they don't form a two-tuple, and there are two arguments, not one. This explains the error message. Now look at the first version:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>The type signature is a bit odd. Since the <code>-&gt;</code> type operator associates to the right, this is equivalent to:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; (int -&gt; int) = &lt;fun&gt;\n</code></pre> <p>This is an example of what's called currying. What the type signature means is that the <code>add</code> function actually only takes a single argument (an <code>int</code>) and returns a function of type <code>int -&gt; int</code>. If you call the function with both arguments, the function returned by applying <code>add</code> to the first argument (which has type <code>int -&gt; int</code>) is immediately applied to the second argument (of type <code>int</code>) to give the result, which is an <code>int</code>. So this function call:</p> <pre><code># add 2 3;;\n- : int = 5\n</code></pre> <p>is actually this:</p> <pre><code># (add 2) 3;;\n- : int = 5\n</code></pre> <p>And if we leave out the second argument, we get this:</p> <pre><code># add 2;;\n- : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>which shows currying in action. We can use this function:</p> <pre><code># let add2 = add 2;;\nval add2 : int -&gt; int = &lt;fun&gt;\n# add2 3;;\n- : int = 5\n</code></pre> <p>Curried functions are often useful to create a partially-evaluated function whose final value will be supplied later. For instance:</p> <pre><code># List.map (add 2) [1; 2; 3; 4; 5]\n- : int list = [3; 4; 5; 6; 7]\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#anonymous-functions","title":"Anonymous functions","text":"<p>Functions are a kind of data in functional languages like OCaml, and you can define function values directly using the <code>fun</code> expression. So instead of writing:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>we could write the definition like this:</p> <pre><code># let add = fun x y -&gt; x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>The meaning is exactly the same. We say that the first form is syntactic sugar for the latter form. We can even use a <code>fun</code> expression without giving it a name at all:</p> <pre><code># (fun x y -&gt; x + y) 2 3;;\n- : int = 5\n</code></pre> <p>Therefore, we say that the <code>fun</code> form defines an anonymous function. Anonymous functions are often used with higher-order functions (functions that take functions as input and/or return functions as output).</p> <p>Note also that because of currying, the function</p> <pre><code>fun x y -&gt; x + y\n</code></pre> <p>is the same as:</p> <pre><code>fun x -&gt; fun y -&gt; x + y\n</code></pre> <p>You should think of the first form as syntactic sugar for the second.</p>"},{"location":"readings/ocaml_cheat_sheet/#unused-arguments","title":"Unused arguments","text":"<p>If you define a function which doesn't use one (or more) of its arguments, and strict warning settings are enabled (as they are in the <code>Makefile</code>s for most assignments, but not by default in <code>utop</code>) you will get a warning. You can even see this in <code>utop</code> if you enable warnings:</p> <pre><code>$ utop -w A\n# let f s z = z;;\nWarning 27 [unused-var-strict]: unused variable s.\nval f : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n</code></pre> <p>(The <code>-w A</code> argument to <code>utop</code> turns on all compiler warnings.)</p> <p>The way to fix this is simply to replace each unused argument with <code>_</code>:</p> <pre><code>$ utop -w A\n# let f _ z = z;;\nval f : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n</code></pre> <p>Now the warning has disappeared.</p>"},{"location":"readings/ocaml_cheat_sheet/#match-expressions","title":"<code>match</code> expressions","text":"<p>OCaml <code>match</code> expressions are pretty straightforward. They have a couple of subtleties you should know about.</p>"},{"location":"readings/ocaml_cheat_sheet/#optional-before-first-match","title":"Optional <code>|</code> before first match","text":"<p>In a <code>match</code> expression, the alternatives are separated by a vertical bar character (<code>|</code>). You can also (optionally) put a vertical bar character before the first pattern to be matched. This often makes the code look cleaner. Compare:</p> <pre><code>let rec sum_list lst =\n  match lst with\n      [] -&gt; []\n    | h :: t -&gt; h + sum_list t\n</code></pre> <p>with</p> <pre><code>let rec sum_list lst =\n  match lst with\n    | [] -&gt; []\n    | h :: t -&gt; h + sum_list t\n</code></pre> <p>These two functions are identical in terms of their functionality, but the code for the second looks cleaner because of the extra <code>|</code> before the first match.</p>"},{"location":"readings/ocaml_cheat_sheet/#nested-match-expressions","title":"Nested match expressions","text":"<p>It's not uncommon to want to put a <code>match</code> expression inside another <code>match</code> expression. If you do, you have to be careful with the inner <code>match</code> expression so that its clauses aren't confused with the outer <code>match</code>'s clauses. Here's an example from the internet:</p> <pre><code>let rec filter exp =\n  match exp with\n    | Var v -&gt; Var v\n    | Sum(e1, e2) -&gt; Sum(e1, e2)\n    | Prod(e1, e2) -&gt; Prod(e1, e2)\n    | Diff(e1, e2) -&gt;\n      match e2 with  (* nested match *)\n        | Sum(e3, e4) -&gt; filter (diffRule e2)\n        | Diff(e3, e4) -&gt; filter (diffRule e2)\n        | _ -&gt; filter e2\n    (* Oops! These following clauses should belong to the outer match, but\n       they actually belong to the inner match. *)\n    | Quot(e1, e2) -&gt;\n        match e2 with\n        | Quot(e3, e4) -&gt; filter (quotRule e2)\n        | Prod(e3, e4) -&gt; filter (quotRule e2)\n        | _ -&gt; filter e2\n</code></pre> <p>The solution is to wrap the inner <code>match</code> using parentheses or <code>begin</code>/<code>end</code>. For instance:</p> <pre><code>let rec filter exp =\n  match exp with\n    | Var v -&gt; Var v\n    | Sum(e1, e2) -&gt; Sum(e1, e2)\n    | Prod(e1, e2) -&gt; Prod(e1, e2)\n    | Diff(e1, e2) -&gt;\n      begin\n        match e2 with  (* nested match *)\n          | Sum(e3, e4) -&gt; filter (diffRule e2)\n          | Diff(e3, e4) -&gt; filter (diffRule e2)\n          | _ -&gt; filter e2\n      end\n    | Quot(e1, e2) -&gt;\n        match e2 with\n        | Quot(e3, e4) -&gt; filter (quotRule e2)\n        | Prod(e3, e4) -&gt; filter (quotRule e2)\n        | _ -&gt; filter e2\n</code></pre> <p>Now it will do what it's supposed to.</p>"},{"location":"readings/ocaml_cheat_sheet/#function-expressions","title":"<code>function</code> expressions","text":"<p>This kind of pattern is extremely common:</p> <pre><code>let rec &lt;function name&gt; &lt;arg&gt; =\n  match &lt;arg&gt; with\n    | &lt;pattern 1&gt; -&gt; ...\n    | &lt;pattern 2&gt; -&gt; ...\n    ...\n</code></pre> <p>For instance, the <code>sum_list</code> function above is an example of this pattern. The essence of this pattern is that you pattern match on the last argument. Sometimes you have more arguments:</p> <pre><code>let rec &lt;function name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; =\n  match &lt;argN&gt; with\n    | &lt;pattern 1&gt; -&gt; ...\n    | &lt;pattern 2&gt; -&gt; ...\n    ...\n</code></pre> <p>Whenever you have a function that pattern matches on its last argument, you can rewrite it using the <code>function</code> keyword. This is like an automatic <code>match</code> on the last argument. The patterns above would be written like this using <code>function</code>:</p> <pre><code>let rec &lt;function name&gt; = function (* leave off &lt;arg&gt; *)\n  | &lt;pattern 1&gt; -&gt; ...\n  | &lt;pattern 2&gt; -&gt; ...\n  ...\n\nlet rec &lt;function name&gt; &lt;arg1&gt; &lt;arg2&gt; ... = function (* leave off &lt;argN&gt; *)\n  | &lt;pattern 1&gt; -&gt; ...\n  | &lt;pattern 2&gt; -&gt; ...\n  ...\n</code></pre> <p>Rewriting <code>sum_list</code> using <code>function</code> gives this:</p> <pre><code>let rec sum_list = function (* leave off &lt;arg1&gt; *)\n  | [] -&gt; []\n  | h :: t -&gt; h + sum_list t\n</code></pre> <p>This way of writing functions has advantages and disadvantages. The advantage is that it's more concise. The disadvantage is that you have to remember that the <code>function</code> keyword means that the function you are defining has an extra argument that doesn't have a name. Also, if you do need the name of the argument inside the body of the function, you can't use <code>function</code>. <code>function</code> is mostly used for simple functions of a simple argument where the only thing you do with the argument is pattern match on it. It's never necessary, though, so feel free to write all your code without it if you don't like it.</p>"},{"location":"readings/ocaml_cheat_sheet/#the-fragile-pattern-match-compiler-warning","title":"The \"fragile pattern match\" compiler warning","text":"<p>We like to compile OCaml code with most of the warning settings enabled. This provides a lot of suggestions for fixing problematic code which is still technically correct. You can turn on all compiler warnings by compiling with the <code>-w A</code> (<code>A</code> means \"all\") command-line option. This works both for <code>ocamlc</code> and for the interactive interpreters <code>ocaml</code> and <code>utop</code>.</p> <p>Note</p> <p>We don't necessarily recommend the <code>-w A</code> option for routine use with interactive interpreters, because some warnings would cause problems with normal use of interpreters, such as redefining datatypes.</p> <p>One particular compiler warning can be very confusing. Consider this code:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n\nlet get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | _ -&gt; 0\n</code></pre> <p>With warnings enabled, this gives this warning:</p> <pre><code>Warning 4 [fragile-match]: this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type foo.\nval get_foo_int : foo -&gt; int = &lt;fun&gt;\n</code></pre> <p>What this is complaining about is the last line in the <code>get_foo_int</code> function: <code>| _ -&gt; 0</code>. The intent of this line is to say that for all constructors except the <code>Bar</code> constructor, return the integer <code>0</code>. This is not incorrect code! On the other hand, let's say we modified the <code>foo</code> type to have another constructor that contained an <code>int</code> value:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n  | Boom of int\n</code></pre> <p>but we forgot to change the <code>get_foo_int</code> function. The function will still work, but it won't do the right thing. You would probably want to change it to this:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Boom i -&gt; i\n    | _ -&gt; 0\n</code></pre> <p>so that any constructor with an <code>int</code> value has the <code>int</code> value returned. But since the old code is still correct, you won't know that you need to make this change.</p> <p>This is what a \"fragile pattern match\" means: it's a catch-all case that matches more than one constructor, so if you happen to add more constructors to the datatype, it will match those as well.  What you would like it to do is to warn you: \"Hey!  I've never seen the <code>Boom</code> case before, and you're not handling it, so that's probably an error!\" The way to do this is to explicitly handle all constructors in the original function.</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo -&gt; 0\n    | Baz _ -&gt; 0\n</code></pre> <p>Then the warning will go away. On the other hand, it's annoying to have to write the same value (here, <code>0</code>) for two cases. In this case, we can use the \"fall through\" mechanism of pattern matching to make the code simpler:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo   (* no `-&gt;` so fall through to next case *)\n    | Baz _ -&gt; 0\n</code></pre> <p>And we can write all the catch-all cases on one line:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo | Baz _ -&gt; 0\n</code></pre> <p>Now, if we add the <code>Boom</code> constructor, we will have to add a case for that:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n  | Boom of int   (* new constructor *)\n\nlet get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Boom i -&gt; i   (* new case *)\n    | Foo | Baz _ -&gt; 0\n</code></pre> <p>If we left out the <code>Boom</code> case, we would get a warning about a non-exhaustive pattern-match, and we would know just what to fix.</p> <p>Writing out catch-all cases like this is a bit tedious at times, but if you don't do it, you can sometimes get bugs that are extremely hard to track down.<sup>1</sup></p>"},{"location":"readings/ocaml_cheat_sheet/#let-expressions","title":"<code>let</code> expressions","text":""},{"location":"readings/ocaml_cheat_sheet/#explicit-recursion","title":"Explicit recursion","text":"<p>OCaml requires you to say <code>let rec</code> when defining a recursive function.</p> <p>You can easily define mutually recursive functions by using the</p> <pre><code>let rec f x =\n  ...  (* expression using g *)\nand g y =\n  ...  (* expression using f *)\n</code></pre> <p>syntax for top-level mutually-recursive functions, or the</p> <pre><code>let rec f x =\n  ...  (* expression using g *)\nand g y =\n  ...  (* expression using f *)\nin\n  ...\n</code></pre> <p>syntax for mutually-recursive functions inside an expression.  Leaving out the <code>rec</code> is one of the commonest mistakes beginning OCaml programmers make.  Conversely, don't use the <code>rec</code> unless the function is actually recursive! (This will rarely cause problems, but it's poor style, and it may generate a warning.)</p>"},{"location":"readings/ocaml_cheat_sheet/#imperative-programming","title":"Imperative programming","text":""},{"location":"readings/ocaml_cheat_sheet/#references","title":"References","text":"<p>OCaml doesn't have \"variables\" in the sense that most programming languages do.  Instead, it has references, which are basically records with a single mutable field.  These are effectively the same as variables except that you have to explicitly dereference them to get the value they contain.  I'm not going to lie to you, this is a pain in highly imperative code! However, it is extremely explicit and it allows you to define useful functions on references.</p> <pre><code># let r = ref 0;;  (* r is a reference *)\nval r : int ref = {contents = 0}\n# r;;\n- : int ref = {contents = 0}\n# (!);;      (* ! is the dereference operator *)\n- : 'a ref -&gt; 'a = &lt;fun&gt;\n# !r;;\n- : int = 0\n# (:=);;     (* := is the assignment operator *)\n- : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;\n# r := 42;;\n- : unit = ()\n# r;;\n- : int ref = {contents = 42}\n# !r;;\n- : int = 42\n# incr;;     (* incr is a function on references *)\n- : int ref -&gt; unit = &lt;fun&gt;\n# incr r;;\n- : unit = ()\n# !r;;\n- : int = 43\n</code></pre> <p>Fun fact: we could have defined the <code>!</code> and <code>:=</code> operators ourselves, and we could have defined the <code>incr</code> function as well:</p> <pre><code># let ( ! ) r = r.contents;;\nval ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;\n# let ( := ) r v = r.contents &lt;- v;;\nval ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;\n# let incr r = r.contents &lt;- !r + 1;;\nval incr : int ref -&gt; unit = &lt;fun&gt;\n</code></pre> <p>This works because references (<code>ref</code> cells) are records with a single field called <code>contents</code>, so the record accessing and mutating syntax can be used on them.</p>"},{"location":"readings/ocaml_cheat_sheet/#sequence-expressions","title":"Sequence expressions","text":"<p>When you are doing imperative programming, it's often necessary to have a notion of sequencing, as in do-this-then-do-that etc. In OCaml, this requires a sequence expression, which has two forms:</p> <ul> <li>a series of statements separated by semicolons    and wrapped with <code>begin</code>/<code>end</code></li> <li>the same, but using parentheses instead of <code>begin</code>/<code>end</code></li> </ul> <p>The choice between using <code>begin</code>/<code>end</code> or parentheses is a style decision. I prefer parentheses for very short (one-liner) sequence expressions and <code>begin</code>/<code>end</code> for sequence expressions that span multiple lines.</p> <p>Here's an example of an (inefficient) imperative function to compute greatest common denominators (GCDs):</p> <pre><code>let gcd m n =\n  let p = ref m in\n  let q = ref n in\n    begin\n      while !p &lt;&gt; !q do\n          if !p &gt; !q then\n            p := !p - !q\n          else\n            q := !q - !p\n      done;\n      !p\n    end\n</code></pre> <p>This also shows the use of an imperative <code>while</code> loop. It also shows how annoying imperative programming is in OCaml <code>!</code> because <code>!</code> of <code>!</code> all <code>!</code> the <code>!</code> exclamation <code>!</code> points!</p>"},{"location":"readings/ocaml_cheat_sheet/#weakly-polymorphic-types","title":"Weakly polymorphic types","text":"<p>OCaml's type system has some peculiarities.  One that you are likely to run into when you do imperative programming is that there are types that are \"weakly polymorphic\".  A truly polymorphic type can be parameterized on one or more type variables, which are written with a leading quote i.e. <code>'a</code>, <code>'b</code> etc. But some types are not actually polymorphic, they are \"write-once\" types.  Look at this:</p> <pre><code># let r = ref [];;\nval r : '_weak1 list ref = {contents = []}\n# !r;;\n- : '_weak1 list = []\n# r := [1; 2; 3];;\n- : unit = ()\n# r;;\n- : int list ref = {contents = [1; 2; 3]}\n# !r;;\n- : int list = [1; 2; 3]\n</code></pre> <p>The initial type of <code>r</code> is <code>'_weak1 list ref</code>, which is pretty odd. You might expect it to be <code>'a list ref</code> i.e. that <code>r</code> is a reference which can contain any kind of list.  But this would not be type-safe; if <code>r</code> holds a list of <code>int</code>s at one time and a list of <code>bool</code>s at another, then all the types are not known at compile-time, and you might as well be writing Python code.</p> <p>Instead, what this odd type means is that <code>r</code> is a reference containing a list of currently unspecified type.  That's what the <code>'_weak1 list ref</code> means.  Since <code>r</code> was initialized with an empty list, which could have any element type, you can't say any more.  Once you reassign a list of known type to <code>r</code>, it then has a concrete type (<code>int list</code> in this case), and the type is fixed thereafter.</p> <p>OK, so what if you aren't using references or imperative features? Unfortunately, you can still get weakly polymorphic types if you partially apply a function.  Here's a trivial example:</p> <pre><code># let const x y = y ;;\nval const : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# let f = const () ;;  (* partial application of the const function *)\nval f : '_weak1 -&gt; '_weak1 = &lt;fun&gt;\n</code></pre> <p>This is purely functional code, but you still get a weak type! The reasons for this are quite involved (see the references below), but one trick that will work in most cases is to change the partial application to a full application by adding arguments:</p> <pre><code># let const x y = y ;;\nval const : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# let f x = const () x ;;  (* no longer a partial application of the const function *)\nval f : 'a -&gt; 'a = &lt;fun&gt;\n</code></pre> <p>Now <code>f</code> has the expected type.  This trick (called \"eta expansion\") is definitely worth remembering.</p> <p>For more on this issue (really far more than you need to know at this point), here are some good references:</p> <ul> <li>https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html</li> <li>https://ocamlverse.github.io/content/weak_type_variables.html</li> </ul> <p>However, don't stress too much about it. This is expert-level stuff, and at this point in your OCaml learning process, the main reason we're bringing this up is in case you encounter this in practice and want to have an idea about what's going on. Sophisticated type systems like OCaml are quite involved, and few people have completely mastered all of the details.</p> <ol> <li> <p>In the CS 164 course (Compilers), which uses OCaml, this kind of situation comes up quite frequently, because many of the compilers start with compiler passes from a simpler compiler and extend them to handle new constructors.\u00a0\u21a9</p> </li> </ol>"},{"location":"readings/subst/","title":"The substitution model","text":"<p>This reading is a summary of the rules of the substitution model, discussed starting in lecture 2.</p>"},{"location":"readings/subst/#overview","title":"Overview","text":"<p>The substitution model is a way of manually evaluating OCaml expressions. It's similar to, but not identical to, what the computer does when it evaluates OCaml code. The point of learning the model is so that you have a good mental framework for how OCaml code evaluates.</p> <p>Note</p> <p>At some point, this model will not be sufficient to explain all the features of OCaml that we will use (for instance, updating variables in imperative programming), so we will define a new model: the environment model. That model will share many features with the substitution model, but its handling of name lookup will be much more precise.</p> <p>The substitution model is adequate to understand the purely functional subset of OCaml we will use for the first half of the course.</p>"},{"location":"readings/subst/#desugaring-and-precedence","title":"Desugaring and precedence","text":"<p>Before evaluating any OCaml code using the substitution model, the code should first be desugared, and then operator precedence should be made explicit using parentheses.</p>"},{"location":"readings/subst/#desugaring","title":"Desugaring","text":"<p>The main kind of desugaring we need is to replace expressions of this form:</p> <pre><code>let f x y = ...\n</code></pre> <p>with this:</p> <pre><code>let f = fun x y -&gt; ...\n</code></pre> <p>After desugaring, all <code>let</code> expressions are \"simple\" i.e. they bind a single name (here, <code>f</code>) to a value (the result of evaluating the expression on the right-hand side of the <code>=</code>; here, <code>fun x y -&gt; ...</code>).</p> <p>Note</p> <p>If we are really being picky, we could desugar this further to:</p> <pre><code>let f = fun x -&gt; fun y -&gt; ...\n</code></pre> <p>but we don't require that.  This is because of function currying, which is the way that OCaml interprets functions with multiple arguments.</p> <p>We recommend that you don't do this in your written evaluations, unless you have to for some reason.</p>"},{"location":"readings/subst/#precedence","title":"Precedence","text":"<p>Operator precedence should be made explicit by wrapping parentheses around nested operator expressions. For instance, this code:</p> <pre><code>1 + 2 * 7\n</code></pre> <p>would become:</p> <pre><code>1 + (2 * 7)\n</code></pre> <p>The full precedence table of OCaml operators is here. In most cases, it will be what you would expect.</p> <p>This step is done so that there is never any question about what the operands of an operator are.</p>"},{"location":"readings/subst/#the-basic-rule","title":"The basic rule","text":"<p>To evaluate an OCaml expression:</p> <ol> <li>evaluate the operands of the expression</li> <li>evaluate the operator or function of the expression</li> <li>apply the operator/function to the evaluated operands</li> </ol> <p>Note</p> <p>OCaml actually evaluates operands from right-to-left, in contrast to most languages, which evaluate operands from left-to-right. Evaluation order is not part of the substitution model, and shouldn't make any difference.</p> <p>Similarly, you can evaluate the operator/function before or after evaluating the operands, and it won't make any difference in this model.</p> <p>The basic rule is used when evaluating a function call or an operator expression. Other expressions (such as <code>let</code>, <code>fun</code> and <code>if</code> expressions) do not use the basic rule; they have their own evaluation rules. Such expressions are called special forms.</p>"},{"location":"readings/subst/#specific-cases-of-the-basic-rule","title":"Specific cases of the basic rule","text":"<ul> <li> <p>Numbers evaluate to themselves: <code>10</code> \u2192 <code>10</code>   (In fact, any literal data value evaluates to itself;   that's why it's called \"literal\".   For now, we are mostly working with numbers.)</p> </li> <li> <p>Primitive (built-in) functions evaluate   to the corresponding internal procedure.   We can write this as either:   <code>+</code> \u2192 <code>[primitive function +]</code>   or just <code>+</code> \u2192 <code>+</code></p> </li> <li> <p>Variables that have been previously defined   are \"looked up\" (in some unspecified way)   and evaluate to the value that they were previously bound to.   (If they weren't bound to a value previously, it's an error.)</p> </li> </ul>"},{"location":"readings/subst/#let-bound-names","title":"<code>let</code>-bound names","text":"<p>There are two kinds of <code>let</code>-bound names: top-level and in-expression. They evaluate differently.</p>"},{"location":"readings/subst/#top-level-let-expressions","title":"Top-level <code>let</code> expressions","text":"<p>A top-level <code>let</code> expression<sup>1</sup> looks like this:</p> <pre><code>let &lt;var&gt; = &lt;expr&gt;\n</code></pre> <p>for some variable name <code>&lt;var&gt;</code> and some expression <code>&lt;expr&gt;</code>. For instance:</p> <pre><code>let x = 2 + 3\n</code></pre> <p>To evaluate this, you</p> <ul> <li> <p>evaluate the expression to the right of the <code>=</code> sign   (here, <code>2 + 3</code>, which evaluates to <code>5</code>);</p> </li> <li> <p>\"make an association\" or \"bind\" the name (<code>x</code> here)   to the value of the evaluated expression (<code>5</code>).   The details of how to make this association aren't important for now,   though we'll revisit this later.</p> </li> </ul> <p>In this case, we make an association between the name <code>x</code> and the value <code>5</code>. We can also say that we bind <code>x</code> to <code>5</code>.</p> <p>After this expression is evaluated, the name <code>x</code> will be bound to the value <code>5</code> for the rest of the evaluated code, unless <code>x</code> is given a new binding with a new top-level <code>let</code> expression.</p> <p>Note</p> <p>A new binding for <code>x</code> would be something like:</p> <pre><code>let x = 42\n</code></pre> <p>From then on, any reference to <code>x</code> would get the new value. This is not the same as assignment in an imperative language, because it doesn't overwrite the old binding. Instead, this code creates a new binding to <code>x</code> which \"shadows\" the old binding, but the old binding still exists, and in some cases can still have effects.</p>"},{"location":"readings/subst/#local-let-expressions","title":"Local <code>let</code> expressions","text":"<p>A \"local\" <code>let</code> expression is a <code>let</code> expression where a name is bound to a value and then immediately used in another expression, such as this:</p> <pre><code>let x = 2 + 3 in x * x\n</code></pre> <p>In this case, the name <code>x</code> has a meaning inside the body of the expression (the <code>x * x</code> part) but not outside. To evaluate this, you:</p> <ul> <li> <p>evaluate the binding expression   (here, <code>2 + 3</code>, which evaluates to <code>5</code>),</p> </li> <li> <p>bind the name to the value (here, bind <code>x</code> to <code>5</code>),</p> </li> <li> <p>and evaluate the body expression (here, <code>x * x</code>).</p> </li> </ul> <p>In the body expression, of course, you can use the name <code>x</code>, which has a value (<code>5</code>). Outside of this expression, the name <code>x</code> either has no value (if it wasn't bound before) or has the value it previously had (if it was). Remember: you aren't changing a previous binding (to <code>x</code>), you're creating a new one that is used only in a single expression.</p>"},{"location":"readings/subst/#if-expressions","title":"<code>if</code> expressions","text":"<p><code>if</code> expressions consist of three subexpressions:</p> <ul> <li>the test subexpression (between the <code>if</code> and the <code>then</code> keywords)</li> <li>the <code>then</code> subexpression (between the <code>then</code> and the <code>else</code> keywords)</li> <li>the <code>else</code> subexpression (everything following the <code>else</code> keyword)</li> </ul> <p>They have the following evaluation rule.</p> <ol> <li>Evaluate the test subexpression.</li> <li>If the test subexpression evaluates to <code>true</code>,    evaluate the <code>then</code> subexpression.</li> <li>If the test subexpression evaluates to <code>false</code>,    evaluate the <code>else</code> subexpression.</li> </ol> <p>One consequence of this is that you never evaluate both the <code>then</code> and <code>else</code> subexpressions. This is why <code>if</code> can't be a function (it's not just the syntax!)<sup>2</sup></p>"},{"location":"readings/subst/#if-without-else","title":"<code>if</code> without <code>else</code>","text":"<p>When writing purely functional code in OCaml, <code>if</code> expressions always have both a <code>then</code> subexpression and an <code>else</code> subexpression. (These are sometimes called the \"then clause\" and the \"else clause\".) With respect to the substitution model, we will always have <code>else</code> subexpressions in <code>if</code> expressions.</p> <p>To learn more about how <code>if</code> expressions without <code>else</code> subexpressions work, see the OCaml cheat sheet.</p>"},{"location":"readings/subst/#fun-expressions","title":"<code>fun</code> expressions","text":"<p>A <code>fun</code> expression (like <code>fun x y -&gt; x + y</code>) represents an anonymous function. In the substitution model, a <code>fun</code> expression is usually the result of desugaring a regular function definition, like</p> <pre><code>let f x y = x + y\n</code></pre> <p>which desugars to:</p> <pre><code>let f = fun x y -&gt; x + y\n</code></pre> <p><code>fun</code> expressions consist of two parts:</p> <ul> <li>the formal parameters of the function (here, <code>x</code> and <code>y</code>),</li> <li>the body of the function (here, <code>x + y</code>).</li> </ul> <p><code>fun</code> expressions are trivial to evaluate: you basically just leave them alone. For this reason, in written evaluations you can write:</p> <pre><code>fun x y -&gt; x + y  --&gt;  fun x y -&gt; x + y\n</code></pre> <p>or just:</p> <pre><code>fun x y -&gt; x + y  --&gt;  itself\n</code></pre>"},{"location":"readings/subst/#function-application","title":"Function application","text":"<p>Function application is at the heart of the substitution model. There are two cases.</p>"},{"location":"readings/subst/#applying-built-in-functions-or-operators","title":"Applying built-in functions or operators","text":"<p>Applying a built-in function or operator is simple: you just do it. For instance:</p> <pre><code>Evaluate: 2 + 3\n  2 --&gt; 2\n  3 --&gt; 3\n  + --&gt; [primitive function +]\n  apply + to 2, 3 --&gt; 5\n\nEvaluate: abs (-10)\n  -10 --&gt; -10\n  abs --&gt; [primitive function abs]\n  apply abs to -10 --&gt; 10\n</code></pre> <p>In some cases we'll allow you to shorten lines like</p> <pre><code>abs --&gt; [primitive function abs]\n</code></pre> <p>to just:</p> <pre><code>abs --&gt; abs\n</code></pre> <p>Don't do this unless we explicitly say it's OK.</p>"},{"location":"readings/subst/#applying-user-defined-functions-substitution","title":"Applying user-defined functions: substitution","text":"<p>Now we come to the \"substitution\" part of the substitution model. It happens when you are applying a user-defined function (which means a <code>fun</code> expression, or a function which gets desugared to a <code>fun</code> expression) to its arguments (which have already been evaluated to values, so they aren't expressions anymore).</p> <p>The rules for applying user-defined functions are:</p> <ol> <li> <p>Substitute the function argument variables (formal parameters)    with the values given in the call    everywhere they occur in the function body.</p> </li> <li> <p>Evaluate the resulting expression.</p> </li> </ol> <p>For the most part, the substitution process is straightforward. For each function parameter, you substitute the argument value for the function parameter name in the function body to get the substituted expression, which you then evaluate. For instance, this expression:</p> <pre><code>(fun x y -&gt; x + y) 2 3\n</code></pre> <p>evaluates as follows:</p> <pre><code>Evaluate: (fun x y -&gt; x + y) 2 3\n  2 --&gt; 2\n  3 --&gt; 3\n  (fun x y -&gt; x + y) --&gt; itself\n  apply (fun x y -&gt; x + y) to 2, 3\n    substitute 2 for x, 3 for y in x + y --&gt; 2 + 3\n    evaluate: 2 + 3\n      2 --&gt; 2\n      3 --&gt; 3\n      + --&gt; [primitive function +]\n      apply + to 2, 3 --&gt; 5\n</code></pre> <p>You can even evaluate inside a complex expression (for instance, an <code>if</code> expression):</p> <pre><code>Evaluate (fun x y -&gt; if x &gt; y then x + y else x - y) 2 3\n  2 --&gt; 2\n  3 --&gt; 3\n  (fun x y -&gt; ...) --&gt; itself\n  apply (fun x y -&gt; ...) to 2, 3\n    substitute 2 for x, 3 for y in if x &gt; y then x + y else x - y\n    --&gt; if 2 &gt; 3 then 2 + 3 else 2 - 3\n    evaluate: if 2 &gt; 3 then 2 + 3 else 2 - 3\n      if is a special form; evaluate 2 &gt; 3\n        2 --&gt; 2\n        3 --&gt; 3\n        &gt; --&gt; [primitive function &gt;]\n        apply &gt; to 2, 3 --&gt; false\n      For false case, evaluate else clause: 2 - 3\n        2 --&gt; 2\n        3 --&gt; 3\n        - --&gt; [primitive function -]\n        apply - to 2, 3 --&gt; -1\n</code></pre> <p>Notice that the substitution goes right inside the <code>if</code> expression, regardless of which branch of the <code>if</code> will eventually end up being evaluated. (Here we also see that for long <code>fun</code> expression bodies, we can abbreviate them with <code>...</code>.)</p> <p>Note</p> <p>On the other hand, we can't substitute inside a nested <code>fun</code> expression in all cases.  See below for more details.</p>"},{"location":"readings/subst/#recursion","title":"Recursion","text":"<p>Recursion doesn't require any special treatment in the substitution model, except that you have to replace a function name with the correct definition of that function when looking up the name. This is usually obvious, and probably won't cause you any problems. It can get weird in pathological cases where you redefine a name. Here's a silly example:</p> <pre><code>let factorial n = 0   (* obviously wrong *)\n\n(* Redefine factorial. *)\nlet factorial n =     (* oops, forgot the \"rec\" *)\n  if n = 0 then\n    1\n  else\n    n * factorial (n - 1)\n</code></pre> <p>When evaluating this function, the \"recursive\" call to <code>factorial</code> will actually pick up the previous definition of <code>factorial</code>, and <code>factorial</code> will return <code>0</code> for any input but <code>0</code>. The solution is to include the <code>rec</code> in the second definition:</p> <pre><code>let factorial n = 0   (* obviously wrong *)\n\n(* Redefine factorial. *)\nlet rec factorial n =\n  if n = 0 then\n    1\n  else\n    n * factorial (n - 1)\n</code></pre> <p>Now everything will work correctly because the <code>rec</code> tells OCaml that any references to <code>factorial</code> inside the body of <code>factorial</code> represent the function being defined.<sup>3</sup></p> <p>Of course, this normally doesn't come up because you normally don't redefine functions in a file, but something like this could happen when defining functions interactively inside the OCaml interpreter. This can lead to very peculiar bugs.</p>"},{"location":"readings/subst/#nested-fun-expressions-and-shielding","title":"Nested <code>fun</code> expressions and shielding","text":"<p>The substitution model has to be adjusted to deal with nested <code>fun</code> expressions. Here's a simple example:</p> <pre><code>let f x =\n  fun x -&gt; x + x\n</code></pre> <p>How would you evaluate <code>f 3</code>? Here's a first (wrong) attempt:</p> <pre><code>Evaluate (f 3)\n  3 --&gt; 3\n  f --&gt; fun x -&gt; fun x -&gt; x + x\n  apply (fun x -&gt; fun x -&gt; x + x) to 3\n    substitute 3 for x in (fun x -&gt; x + x)\n    --&gt; fun 3 -&gt; 3 + 3  (* ??? *)\n</code></pre> <p>at which point it seems clear that something has gone wrong.</p> <p>You might think that <code>fun 3 -&gt; 3 + 3</code> is a syntax error, but that isn't actually the case in OCaml! The <code>fun</code> form uses pattern-matching to decide what to do with the arguments, so <code>fun 3 -&gt; 3 + 3</code> is a function that can only take as its input the integer <code>3</code>, and will always return 6. Clearly, this isn't going to be useful, and is not what was intended.</p> <p>Note</p> <p>If you type in <code>fun 3 -&gt; 3 + 3</code> into the OCaml interpreter, you'll get a warning about non-exhaustive pattern matches, as you'd expect.</p> <p>OK, so it seems that naively doing substitution in cases like this (where you have nested <code>fun</code> expressions that use the same argument name) doesn't work properly. So how can we fix our model so it can handle situations like this?</p> <p>The key is to realize that the problems started with this line:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n</code></pre> <p>Normally, we are substituting a value for a free variable, which is one that isn't being bound by a <code>fun</code> expression. However, in the expression <code>fun x -&gt; x + x</code>, there are two different <code>x</code>s:</p> <ul> <li> <p>the first <code>x</code>, which is in the binding position of the <code>fun</code> expression</p> </li> <li> <p>the second two <code>x</code>s, which are both bound variables, which means that their value is determined by the (eventual) value passed to the <code>fun</code> expression as its <code>x</code> argument.</p> </li> </ul> <p>Neither case corresponds to a free variable. And, as it turns out, we can't substitute into either of them.</p> <p>We've already seen that when we allow substituting into the binding position of a <code>fun</code> expression, strange things like <code>fun 3 -&gt; 3 + 3</code> result. So it's perfectly reasonable to add an extra rule to the substitution model which says \"don't allow substitutions into the binding position of <code>fun</code> expressions\".  So let's do that:</p> <p>Extra rule for the substitution model</p> <p>Don't allow substituting into the binding position of a <code>fun</code> expression.</p> <p>If we go back to the substitution that gave us grief:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n</code></pre> <p>then we could do the substitution with the extra rule to get:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n--&gt; fun x -&gt; 3 + 3\n</code></pre> <p>This isn't as obviously broken as the previous attempt, but something is still funny here. It doesn't seem reasonable that we would want to generate a function that, given an arbitrary argument <code>x</code>, would always return <code>6</code>.</p> <p>In fact, the expression <code>fun x -&gt; x + x</code> is completely self-contained (other than the <code>+</code> symbol). It only has one reasonable interpretation: a function which doubles its input. So we should disallow substitution into the <code>x</code>s that come after the arrow (<code>-&gt;</code>) in the <code>fun</code> expression too. Our rationale for this is that the <code>x</code> in the binding position \"shields\" the other <code>x</code>s (which we refer to as being bound by the <code>x</code> in the binding position) from substitution. So we have yet another rule for the substitution model:</p> <p>Second extra rule for the substitution model</p> <p>Don't allow substituting into a variable which is shielded by the same variable in the binding position of a <code>fun</code> expression.</p> <p>We can combine both rules into a single rule:</p> <p>Shielding rule for the substitution model</p> <p>Don't allow substituting into a variable when it is either in the binding position of a <code>fun</code> expression or when it is a bound variable of a <code>fun</code> expression. We say that the variable in the binding position shields the bound variables from substitution.</p> <p>That's basically it for the substitution model. We will find eventually that this model has limitations that can only be overcome by switching to a new mode (the environment model), which we shall discuss later in the course.</p> <ol> <li> <p>Technically speaking, this isn't a true expression, since it doesn't return a value. It would be more accurate to call this a top-level <code>let</code> binding.\u00a0\u21a9</p> </li> <li> <p>In a lazy functional language like Haskell, <code>if</code> could be a function, except for the syntax.\u00a0\u21a9</p> </li> <li> <p>This would make an awesome assignment problem, but I'm not quite that mean.\u00a0\u21a9</p> </li> </ol>"}]}