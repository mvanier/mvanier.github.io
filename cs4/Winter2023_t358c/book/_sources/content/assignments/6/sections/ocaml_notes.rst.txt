OCaml notes
===========

Testing
-------

For this assignment, we are supplying you with these support files:

- a ``.mli`` OCaml interface file (``lab6.mli``)
- a test script: (``tests_lab6.ml``)
- a ``Makefile``

These files are all available on the course Canvas site
in a single zip file called ``lab6.zip``.
Download this file and use it as you've been doing with previous assignments.


Environment descriptions
------------------------

There is a problem in part A
that requires you to write a textual description
of the environments generated by evaluating some code
using the environment model described in lecture 13.
We’ll describe this process here.

Consider the following OCaml code:

.. code-block:: ocaml

   let square x = x * x in square 100

We would like to evaluate this using the environment model, and in the
process describe the environments created during its evaluation. This
was done in lecture 13 using diagrams, but note that you can do the same
thing using the following text description:

.. code-block:: ocaml

   (*
     -- Desugar expression to:

     let square = fun x -> x * x in square 100

     -- Start with initial environment:

     FRAME 0 (initial environment)
       parent: none
       bindings:
         * : [primitive function *]

     -- Evaluate the let expression:
     --   Evaluate the fun expression:

     FUNCTION 0 (fun x -> x * x)
       env: FRAME 0    (* environment function was defined in
                          AKA enclosing environment *)
       param: x
       body: x * x

     --   Create a new frame with the name "square" bound to the function object:

     FRAME 1 (let square = FUNCTION 0 in ...)
       parent: FRAME 0
       bindings:
         square : FUNCTION 0

     --   Evaluate the expression "square 100" in the context of FRAME 1:
     --     100 evaluates to itself
     --     Look up "square" --> FUNCTION 0
     --     Apply FUNCTION 0 to 100:
     --       Create a new frame, binding the formal parameter of the "square"
     --         function:

     FRAME 2  (FUNCTION 0 applied to 100)
       parent: FRAME 0
       bindings:
         x : 100

     -- Note that FRAME 2's parent is FRAME 0 because FUNCTION 0's enclosing
     -- environment is FRAME 0.

     --       Evaluate "x * x" in the context of FRAME 2:
     --         Look up x: 100  (from FRAME 2)
     --         Look up *: [primitive function *]  (from FRAME 0 via FRAME 2)
     --         Apply * to 100, 100 --> 10000
     --         RESULT: 10000
   *)

The environment description then would consist of all frames and
functions created during this evaluation:

.. code-block:: ocaml

  (*
    FRAME 0 (initial environment)
      parent: none
      bindings:
        * : [primitive function *]

    FUNCTION 0 (fun x -> x * x)
      env: FRAME 0
      param: x
      body: x * x

    FRAME 1 (let square = FUNCTION 0 in ...)
      parent: FRAME 0
      bindings:
        square : FUNCTION 0

    FRAME 2  (FUNCTION 0 applied to 100)
      parent: FRAME 0
      bindings:
        x : 100
  *)

This is the kind of description we want you to produce. You don’t have
to describe the evaluation process step-by-step, but you need to be able
to do it in your head (or on paper), or you won’t get the right
frame/function contents. Pay particular attention to parents of frames;
it’s extremely easy to get those wrong.

.. tip::

   Remember: applying a function to its arguments
   creates a new frame whose parent frame
   is the same as the ``env`` (enclosing environment)
   of the function being applied.

Note that primitive functions don’t create frames when applied. Also,
only put the primitive functions used in the evaluation into the initial
environment (even though in reality there would be dozens more).

Working through problems like this will very rapidly clarify your
understanding of the environment model.


More on objects
---------------

Part B requires that you use a couple of features of OCaml’s object
system that haven’t been needed so far: self references and private
methods. They are described here.
Self-references were also described in class,
as they interact with the environment model
(technically, they enable what is called *open recursion*).


Self references
~~~~~~~~~~~~~~~

One common thing to want to do in any object-oriented language
is to be able to call methods in an object from other methods.
Typically there is a dedicated keyword for "the current object"
(usually ``self`` or ``this``), but OCaml has a more flexible solution.
If you need to identify the current object,
you just put its name in parentheses after the keyword ``object``.
So instead of writing:

.. code-block:: ocaml

   object
     (* method definitions *)
   end

you write:

.. code-block:: ocaml

   object (self)
     (* method definitions *)
   end

and then you can call methods in the object from within other methods in
the same object using the syntax ``self#foo`` for a method ``foo``.
Note that you don’t have to use the word ``self``; you can write:

.. code-block:: ocaml

   object (this)
     (* method definitions *)
   end

if you prefer, or even:

.. code-block:: ocaml

   object (fnordly)
     (* method definitions *)
   end

(but if you do the latter, you will annoy your grader!).
We would like you to stick with ``self``,
because it’s what everyone else does.


Private methods
~~~~~~~~~~~~~~~

This feature of OCaml’s OO system wasn’t described in the lectures.

It’s quite common when defining objects to want some methods to be
restricted to the object implementation itself. Self-references allow
the calling of one method in an object from another, but to have private
methods requires that the method definition be marked ``private``.
So instead of this:

.. code-block:: ocaml

   method foo = ...

you would write:

.. code-block:: ocaml

   method private foo = ...

When this is done, the method ``foo`` can only be called
by other methods in the same class
(unless inheritance is used,
in which case it can also be called by subclasses,
but we haven’t covered inheritance).


Modules and functors
--------------------

The most common use of modules is implicit: whenever you write code in a
``.ml`` file, that file becomes a module (much like in Python). For each
``.ml`` file, you typically have a ``.mli`` file giving the module’s interface
(which includes type signatures for all exported values and functions, ``type``
declarations for all exported types, and ``exception`` declarations for all
exported exceptions defined in the module). As you know, not all functions
defined in a ``.ml`` file need to be exported; functions that are only used
internally won’t have their signature specified in the ``.mli`` file.
Similarly, you do not have to specify the implementation of a type in the
``.mli`` file, and often it is better to leave it out (which makes the type
*abstract*, meaning that only the functions in the ``.ml`` file have access to
its internal structure).

In addition, you can also declare new modules inside of a ``.ml`` file.
These are effectively "modules within modules", and they can be exported
(specified in the ``.mli`` file) or not. The main reason for doing this
is when we generate the modules using *functors*. A functor (as we
discussed in recitation 4) is a kind of "function on modules" (not a
real OCaml function, but conceptually like a function) by which we mean
a way to take an existing module and create a new module which uses the
existing one. Functor arguments are specified using a ``module type``,
which is a specification of a particular module (we’ll see examples
below). A very common use case for functors is to create a data
structure from another data structure. For instance, the input module
may represent the concrete type of a component of the data structure
plus some functions on it (for instance, a function to compare values of
that type for orderable types). The functor will take that input module
and use it to create a new module representing a data structure
containing that type.

All this may seem a bit abstract, so let’s look at an example of
functors. Sets are defined in OCaml in the ``Set`` module, which defines
a functor called ``Set.Make``. This takes as its module argument a
module of module type ``Ordered_type`` which has this signature:

.. code-block:: ocaml

   module type Ordered_type =
     sig
       type t
       val compare : t -> t -> int
     end

This signature (``sig`` form in OCaml) says that an ordered type is a
type ``t`` which also has a comparison function called ``compare`` which
takes two values of type ``t`` and returns an ``int``: ``0`` if the two
are "equal", ``-1`` if the first is smaller than the second, and ``1``
if the first is larger than the second.

.. note::

   In part C, we define our own module type called ``ORDERED_TYPE``
   which is exactly like the ``Ordered_type`` module type,
   because we want to do everything from scratch to show how it's done.

To create a module that matches this signature, we use the ``struct`` form (no
relation to ``struct``\s in C/C++!). Here’s an example:

.. code-block:: ocaml

   module OrderedString : Ordered_type =
     struct
       type t = string
       let compare s1 s2 = Stdlib.compare s1 s2
         (* or just: let compare = Stdlib.compare *)
     end

This creates an ``OrderedString`` module which contains the ``string``
type and a function for string comparison. The ``compare`` function just
dispatches to the OCaml built-in ``compare`` function, which is more
specifically called ``Stdlib.compare``; the ``Stdlib`` module is where
all the built-in functions live.

Given this, we can create a set of strings using the ``Set.Make``
functor as follows:

.. code-block:: ocaml

   module StringSet = Set.Make(OrderedString)

and now we can make sets of strings!
The documentation on the kind of sets made by this functor is available
`here <https://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.S.html>`__.
Here are some examples:

.. code-block:: ocaml

   # let empty = StringSet.empty;;
   val empty : StringSet.t = <abstr>
   # let s1 = StringSet.add "foo" empty;;
   val s1 : StringSet.t = <abstr>
   # let s2 = StringSet.add "bar" s1;;
   val s2 : StringSet.t = <abstr>
   # StringSet.mem "foo" s2;;
   - : bool = true
   # StringSet.mem "bar" s2;;
   - : bool = true
   # StringSet.mem "baz" s2;;
   - : bool = false

Notice that the set type ``StringSet.t`` is abstract, which means that
once the set has been constructed you can only access it using functions
defined in the module. Creating a set of ``int``\s would be very
similar: you would define an ``OrderedInt`` module and pass it to the
``Set.Make`` functor to generate an ``IntSet`` module.

Note that these sets are *functional*. You cannot change the contents of
an existing set; you have to create a new one with more or fewer
elements. Because of the way that sets are implemented, this can be done
quite efficiently.

.. note::

   To those of you who have worked with Java’s generics or C++'s
   templates, this might seem like a very complicated way to generate
   sets. Why not just make the set module polymorphic on the set element
   type? The problem with this is that the element type is not enough;
   we also (at least!) have to specify an equality function between
   values of that type (so you can check if a value is in the set or
   not), and for efficient functional sets, you need the element type to
   be orderable (so you can implement sets using |eg| self-balancing
   tree types, which require orderable elements). That’s why the
   ``Set.Make`` functor requires a module argument which contains not
   just a type but a function which compares two values of that type for
   ordering. In fact, functors are very flexible; the input module (or
   modules) can have more than one type, as well as functions which use
   all the types. That’s why functors have been characterized as begin
   "like C++ templates on steroids".

Also, note that modules are *not* like objects! In particular, **a
module doesn’t store any data**. Instead, functions in modules can
return values of particular types (like sets) which do store data. Since
these types are usually abstract, you can’t do anything with that data
except pass it to other functions in the module, some of which generally
are able to extract components of the data. Thus, modules can do the
same kinds of things that objects do, but they do it in a different way.

Using functors is kind of like riding a bike; at first they seem
intimidatingly abstract and weird, but eventually you come to realize
that they are just a fairly simple mechanism for splitting up the
definition of a module into various reusable parts. Functors are
actually one of the great things about OCaml, and it’s a shame other
programming languages (other than close relatives of OCaml like Standard
ML) don’t have anything similar.

