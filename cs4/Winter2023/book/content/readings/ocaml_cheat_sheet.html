
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>OCaml syntax cheat sheet &#8212; The CS 4 book</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="The substitution model" href="subst.html" />
    <link rel="prev" title="Readings" href="index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">The CS 4 book</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents:
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../admin/index.html">
   Administrative information
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../admin/Syllabus.html">
     Syllabus
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../admin/Collaboration_policies.html">
     Collaboration policies
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Motivation.html">
   Motivation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../History.html">
   History
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../assignments/index.html">
   Assignments
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../assignments/0/Assignment0.html">
     Assignment 0: Getting set up
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../assignments/1/index.html">
     Assignment 1: Evaluation and recursion
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/1/sections/Preamble.html">
       Preamble
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/1/sections/ocaml_notes.html">
       OCaml notes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/1/sections/partA_exercises.html">
       Part A: Basic exercises
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/1/sections/partB_evaluation.html">
       Part B: Evaluation
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/1/sections/partC_recursion.html">
       Part C: Recursion
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../assignments/2/index.html">
     Assignment 2: Asymptotic complexity and higher-order functions
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/2/sections/Preamble.html">
       Preamble
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/2/sections/ocaml_notes.html">
       OCaml notes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/2/sections/partA_orders_of_growth.html">
       Part A: Orders of growth
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/2/sections/partB_evaluation.html">
       Part B: Evaluation
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/2/sections/partC_higher_order_functions.html">
       Part C. Higher-order functions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/2/sections/partD_additional_problems.html">
       Part D: Additional problems
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../assignments/3/index.html">
     Assignment 3: Lists
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/3/sections/Preamble.html">
       Preamble
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/3/sections/ocaml_notes.html">
       OCaml notes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/3/sections/partA_lists.html">
       Part A: Working with lists
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/3/sections/partB_structural_generative_recursion.html">
       Part B: Structural and generative recursion
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../assignments/3/sections/partC_more_lists.html">
       Part C: Some harder problems with lists
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="index.html">
   Readings
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     OCaml syntax cheat sheet
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="subst.html">
     The substitution model
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operators">
   Operators
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operator-underloading">
     Operator underloading
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operator-overloading">
     Operator overloading
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operators-as-functions">
     Operators as functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#equality-inequality-operators">
     Equality/inequality operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#word-operators">
     Word operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unusual-operators">
     Unusual operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-new-operators">
     Defining new operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#printf-and-format-strings">
     <code class="docutils literal notranslate">
      <span class="pre">
       printf
      </span>
     </code>
     and format strings
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lists">
   Lists
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#arrays">
   Arrays
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tuples">
   Tuples
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#type-notation">
     Type notation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#implicit-parentheses">
     Implicit parentheses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#commas-vs-semicolons">
     Commas
     <em>
      vs.
     </em>
     semicolons
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strings">
   Strings
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conditionals">
   Conditionals
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#if-expressions">
     <code class="docutils literal notranslate">
      <span class="pre">
       if
      </span>
     </code>
     expressions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#if-without-else">
     <code class="docutils literal notranslate">
      <span class="pre">
       if
      </span>
     </code>
     without
     <code class="docutils literal notranslate">
      <span class="pre">
       else
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#else-if">
     <code class="docutils literal notranslate">
      <span class="pre">
       else
      </span>
      <span class="pre">
       if
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#functions">
   Functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#syntax-and-currying">
     Syntax and currying
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anonymous-functions">
     Anonymous functions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#match-expressions">
   <code class="docutils literal notranslate">
    <span class="pre">
     match
    </span>
   </code>
   expressions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optional-before-first-match">
     Optional
     <code class="docutils literal notranslate">
      <span class="pre">
       |
      </span>
     </code>
     before first match
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nested-match-expressions">
     Nested match expressions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#function-expressions">
     <code class="docutils literal notranslate">
      <span class="pre">
       function
      </span>
     </code>
     expressions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#let-expressions">
   <code class="docutils literal notranslate">
    <span class="pre">
     let
    </span>
   </code>
   expressions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#explicit-recursion">
     Explicit recursion
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#imperative-programming">
   Imperative programming
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#references">
     References
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sequence-expressions">
     Sequence expressions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weakly-polymorphic-types">
     Weakly polymorphic types
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>OCaml syntax cheat sheet</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operators">
   Operators
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operator-underloading">
     Operator underloading
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operator-overloading">
     Operator overloading
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operators-as-functions">
     Operators as functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#equality-inequality-operators">
     Equality/inequality operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#word-operators">
     Word operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unusual-operators">
     Unusual operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-new-operators">
     Defining new operators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#printf-and-format-strings">
     <code class="docutils literal notranslate">
      <span class="pre">
       printf
      </span>
     </code>
     and format strings
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lists">
   Lists
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#arrays">
   Arrays
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tuples">
   Tuples
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#type-notation">
     Type notation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#implicit-parentheses">
     Implicit parentheses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#commas-vs-semicolons">
     Commas
     <em>
      vs.
     </em>
     semicolons
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strings">
   Strings
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conditionals">
   Conditionals
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#if-expressions">
     <code class="docutils literal notranslate">
      <span class="pre">
       if
      </span>
     </code>
     expressions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#if-without-else">
     <code class="docutils literal notranslate">
      <span class="pre">
       if
      </span>
     </code>
     without
     <code class="docutils literal notranslate">
      <span class="pre">
       else
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#else-if">
     <code class="docutils literal notranslate">
      <span class="pre">
       else
      </span>
      <span class="pre">
       if
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#functions">
   Functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#syntax-and-currying">
     Syntax and currying
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anonymous-functions">
     Anonymous functions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#match-expressions">
   <code class="docutils literal notranslate">
    <span class="pre">
     match
    </span>
   </code>
   expressions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optional-before-first-match">
     Optional
     <code class="docutils literal notranslate">
      <span class="pre">
       |
      </span>
     </code>
     before first match
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nested-match-expressions">
     Nested match expressions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#function-expressions">
     <code class="docutils literal notranslate">
      <span class="pre">
       function
      </span>
     </code>
     expressions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#let-expressions">
   <code class="docutils literal notranslate">
    <span class="pre">
     let
    </span>
   </code>
   expressions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#explicit-recursion">
     Explicit recursion
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#imperative-programming">
   Imperative programming
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#references">
     References
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sequence-expressions">
     Sequence expressions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weakly-polymorphic-types">
     Weakly polymorphic types
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="ocaml-syntax-cheat-sheet">
<span id="ocaml-cheat-sheet"></span><h1>OCaml syntax cheat sheet<a class="headerlink" href="#ocaml-syntax-cheat-sheet" title="Permalink to this headline">#</a></h1>
<p>OCaml is a great language, but its syntax is not its best feature.
More importantly, the syntax is quite different from any other language
you’ve probably learned already,
so getting comfortable with it will take some time.</p>
<p>In this document we describe aspects of OCaml syntax that are most likely to be
confusing and/or counterintuitive, as well as some other features which may
trip you up. This document is <strong>not</strong> a complete description of OCaml syntax.
For that, consult the lectures and/or the online documentation. We also refer
you to the official OCaml cheat sheet which is <a class="reference external" href="http://alhassy.com/OCamlCheatSheet/CheatSheet.pdf">here</a>.</p>
<section id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">#</a></h2>
<section id="operator-underloading">
<h3>Operator underloading<a class="headerlink" href="#operator-underloading" title="Permalink to this headline">#</a></h3>
<p>OCaml doesn’t overload most of its operators. Notably, arithmetic
operators like <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> are not overloaded.
Instead, they are considered to be exclusively integer operators. The
corresponding operators on floating-point numbers have an extra dot
(<code class="docutils literal notranslate"><span class="pre">.</span></code>) at the end <em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">+.</span></code>, <code class="docutils literal notranslate"><span class="pre">-.</span></code>, <code class="docutils literal notranslate"><span class="pre">*.</span></code> and <code class="docutils literal notranslate"><span class="pre">/.</span></code>.
Confusingly, the floating-point power operator (<code class="docutils literal notranslate"><span class="pre">**</span></code>) doesn’t have a
dot at the end.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">sumsq</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*.</span> <span class="n">x</span> <span class="o">+.</span> <span class="n">y</span> <span class="o">*.</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">sumsq</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This is by far the most annoying aspect of OCaml’s syntax. The reason
for it is so that every operator has a very specific type, which makes
type inference much simpler.</p>
</section>
<section id="operator-overloading">
<h3>Operator overloading<a class="headerlink" href="#operator-overloading" title="Permalink to this headline">#</a></h3>
<p>On the other hand, OCaml <em>does</em> overload some operators. The
comparison/equality operators (<code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) are
all <em>polymorphic</em>, which means they work on arbitrary OCaml datatypes.
(This is also true of the <code class="docutils literal notranslate"><span class="pre">max</span></code> and <code class="docutils literal notranslate"><span class="pre">min</span></code> functions.) One exception:
you are not allowed to compare functional values, though you can check
identity:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">abs</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">abs</span> <span class="o">==</span> <span class="n">abs</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">abs</span> <span class="o">=</span> <span class="n">abs</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nc">Invalid_argument</span> <span class="s2">&quot;compare: functional value&quot;</span><span class="o">.</span>
<span class="o">#</span> <span class="n">max</span> <span class="n">abs</span> <span class="n">abs</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nc">Invalid_argument</span> <span class="s2">&quot;compare: functional value&quot;</span><span class="o">.</span>
</pre></div>
</div>
<p>We’ll discuss equality comparisons and identity comparisons below.</p>
</section>
<section id="operators-as-functions">
<h3>Operators as functions<a class="headerlink" href="#operators-as-functions" title="Permalink to this headline">#</a></h3>
<p>This is a good feature, but it can be confusing as well. Operators can
be converted into two-argument functions by wrapping parentheses around
them. For instance, the operator <code class="docutils literal notranslate"><span class="pre">+</span></code> can be made into the two-argument
function <code class="docutils literal notranslate"><span class="pre">(+)</span></code>.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(+);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="o">(+)</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The only time this causes problems is with the multiplication operators
(<code class="docutils literal notranslate"><span class="pre">*</span></code>) and (<code class="docutils literal notranslate"><span class="pre">*.</span></code>), because if the left parenthesis is next to the
asterisk OCaml thinks it’s the start of a comment:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># (*);;
Line 1, characters 0-3:
1 | (*);;
    ^^^
Warning 1: this `(*&#39; is the start of a comment.
Hint: Did you forget spaces when writing the infix operator `( * )&#39;?
* *);;
# ( * ) ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# ( *);;
Line 1, characters 2-4:
1 | ( *);;
      ^^
Warning 2: this is not the end of a comment.
- : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
<p>(Notice that after the first error the prompt changed to <code class="docutils literal notranslate"><span class="pre">*</span></code> (which
means that OCaml thinks we’re still inside a comment) and we had to
manually insert a <code class="docutils literal notranslate"><span class="pre">*)</span></code> to close the comment.)</p>
<p>Fortunately, here OCaml is smart enough to catch this problem and issue
a warning. However, this doesn’t always happen (see below).</p>
</section>
<section id="equality-inequality-operators">
<h3>Equality/inequality operators<a class="headerlink" href="#equality-inequality-operators" title="Permalink to this headline">#</a></h3>
<p>OCaml has two different equality operators and two different inequality
operators:</p>
<ul class="simple">
<li><p>equality: <code class="docutils literal notranslate"><span class="pre">=</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code></p></li>
<li><p>inequality: <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code></p></li>
</ul>
<p>Almost always, you want to use the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator for equality testing
and the <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> operator for inequality testing. They test for structural
equality <em>i.e.</em> whether one operand is equivalent to the other (or “has
the same contents”). The <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> operators check for identity
<em>i.e.</em> whether two things are the exact same thing in memory. Even
though this may sometimes work, it can lead to very difficult-to-find
bugs. (It’s unfortunate that the operators you shouldn’t use in OCaml
are the ones you should use in most other languages.)</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">==</span> <span class="s2">&quot;foo&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">&lt;&gt;</span> <span class="s2">&quot;bar&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">!=</span> <span class="s2">&quot;bar&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">&lt;&gt;</span> <span class="s2">&quot;foo&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="s2">&quot;foo&quot;</span> <span class="o">!=</span> <span class="s2">&quot;foo&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div>
</div>
<p>Here, the two <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code>s are different objects in memory.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">x</span></code> is equal to itself and is also the same object in memory as
itself.</p>
</section>
<section id="word-operators">
<span id="id1"></span><h3>Word operators<a class="headerlink" href="#word-operators" title="Permalink to this headline">#</a></h3>
<p>OCaml has a number of infix operators which are words. Here they are:</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mod</span></code></p></td>
<td><p>integer remainder (modulus)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">asr</span></code></p></td>
<td><p>arithmetic shift right</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lsr</span></code></p></td>
<td><p>logical shift right</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lsl</span></code></p></td>
<td><p>logical shift left</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">land</span></code></p></td>
<td><p>logical (bitwise) AND</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lor</span></code></p></td>
<td><p>logical (bitwise) OR</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lxor</span></code></p></td>
<td><p>logical (bitwise) XOR</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lnot</span></code></p></td>
<td><p>logical (bitwise) NOT</p></td>
</tr>
</tbody>
</table>
<p>You probably won’t need any of these except the <code class="docutils literal notranslate"><span class="pre">mod</span></code> operator, which
is handy:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="mi">5</span> <span class="ow">mod</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="unusual-operators">
<h3>Unusual operators<a class="headerlink" href="#unusual-operators" title="Permalink to this headline">#</a></h3>
<p>The built-in OCaml operators are described in the documentation
for the <code class="docutils literal notranslate"><span class="pre">Stdlib</span></code> library, which is
<a class="reference external" href="https://v2.ocaml.org/api/Stdlib.html">here</a>.</p>
<p>Note especially the following:</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>string concatenation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^^</span></code></p></td>
<td><p>format string concatenation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;</span></code></p></td>
<td><p>list concatenation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">~-</span></code></p></td>
<td><p>unary negation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">~-.</span></code></p></td>
<td><p>unary float negation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code></p></td>
<td><p>function application (<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&#64;&#64;</span> <span class="pre">x</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">|&gt;</span></code></p></td>
<td><p>reverse function application (<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|&gt;</span> <span class="pre">f</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">!</span></code></p></td>
<td><p>dereference a <code class="docutils literal notranslate"><span class="pre">ref</span></code> cell</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p>assignment into a <code class="docutils literal notranslate"><span class="pre">ref</span></code> cell</p></td>
</tr>
</tbody>
</table>
<p>Note that unary negation can also be indicated by a <code class="docutils literal notranslate"><span class="pre">-</span></code> or <code class="docutils literal notranslate"><span class="pre">-.</span></code>
operator without a left-hand operand, if there is no ambiguity. The
<code class="docutils literal notranslate"><span class="pre">~-</span></code> and <code class="docutils literal notranslate"><span class="pre">~-.</span></code> operators are strictly unary operators and can work
in contexts where conventional unary negation doesn’t:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># -1;;
- : int = -1
# abs (-1);;
- : int = 1
# abs -1;;
Line 1, characters 0-3:
1 | abs -1;;
    ^^^
Error: This expression has type int -&gt; int
       but an expression was expected of type int
</pre></div>
</div>
<p>OCaml is telling you you can’t subtract 1 from the <code class="docutils literal notranslate"><span class="pre">abs</span></code> function.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">~-</span><span class="mi">1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">#</span> <span class="n">abs</span> <span class="o">~-</span><span class="mi">1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This works. Here’s another example where these operators are handy:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(~-)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">;</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="o">-</span><span class="mi">3</span><span class="o">;</span> <span class="o">-</span><span class="mi">4</span><span class="o">;</span> <span class="o">-</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
<p>Nevertheless, most people don’t bother with the unary negation operators
and just add extra parentheses if needed.</p>
<p>The function application operators are interesting. The reverse function
application operator <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> is nearly always used to chain together a
series of computations, each taking the result of the previous one:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">List</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">10</span><span class="o">]</span>
<span class="o">#</span> <span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">10</span><span class="o">]</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">max</span> <span class="mi">0</span>
    <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">]));;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">]</span>
  <span class="o">|&gt;</span> <span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">max</span> <span class="mi">0</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>I’d argue that the last expression is more readable than the second-last one.
You read it as “take the list from 1 to 5,
double all the numbers,
keep only the numbers that are greater than 5,
and find the maximum”.
(You don’t have to line up the <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> operators, but it looks good that way.)</p>
<p>The function call after a <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> gets one less argument than usual,
which is supplied by the result of evaluating the expression before the
<code class="docutils literal notranslate"><span class="pre">|&gt;</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> operator might seem useless since <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&#64;&#64;</span> <span class="pre">x</span></code> is the same as
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>. However, its precedence is extremely low, so the expression to
the right of the <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> will be evaluated before calling the function.
This can allow us to drop some parentheses:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">abs</span> <span class="o">(-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">abs</span> <span class="o">@@</span> <span class="o">(-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">abs</span> <span class="o">@@</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Note that the expression <code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">+</span> <span class="pre">1</span></code> is evaluated in the last case before
calling the <code class="docutils literal notranslate"><span class="pre">abs</span></code> function. This can be useful if you have a lot of
functions acting on the result of other functions. (Note that this is
just like the <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> operator except that the function calls are
arranged right-to-left instead of left-to-right.) Another example:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">7</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">1</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">9</span><span class="o">;</span><span class="mi">0</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">0</span><span class="o">]</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">7</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">1</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">9</span><span class="o">;</span><span class="mi">0</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">9</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">0</span><span class="o">]</span>
</pre></div>
</div>
<p>One of the least-used operators is the <code class="docutils literal notranslate"><span class="pre">^^</span></code> operator, which
concatenates strings used as format strings. We will talk about this
below.</p>
<p>Note that some libraries define their own operators (see below). For
instance, the <code class="docutils literal notranslate"><span class="pre">Num</span></code> library defines operators on rational numbers:
<code class="docutils literal notranslate"><span class="pre">+/</span></code>, <code class="docutils literal notranslate"><span class="pre">-/</span></code>, <code class="docutils literal notranslate"><span class="pre">*/</span></code>, and <code class="docutils literal notranslate"><span class="pre">//</span></code>. (These also work with
arbitrary-precision integers, since the <code class="docutils literal notranslate"><span class="pre">Num</span></code> data type contains both
these and arbitrary-precision rationals.)</p>
</section>
<section id="defining-new-operators">
<h3>Defining new operators<a class="headerlink" href="#defining-new-operators" title="Permalink to this headline">#</a></h3>
<p>Unusually for programming languages, OCaml allows you to define your own
operators. All user-defined operators must be made from “operator
characters” and get their operator precedence and associativity from the
first character of the operator (if it is itself an operator).</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(++)</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="o">(</span> <span class="o">++</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="mi">2</span> <span class="o">++</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="o">#</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">++</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">++</span></code> operator has the same precedence as the <code class="docutils literal notranslate"><span class="pre">+</span></code>
operator, so the expression <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">++</span> <span class="pre">3</span></code> is evaluated from left to
right. Let’s try this with a new operator that starts with the <code class="docutils literal notranslate"><span class="pre">*</span></code>
character instead:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let (*+) x y = x * y;;
* *);;
Line 2, characters 2-4:
2 | *);;
      ^^
Error: Syntax error
</pre></div>
</div>
<p>Oops! We forgot that the <code class="docutils literal notranslate"><span class="pre">(*</span></code> characters will be interpreted as the
start of a comment. Notice that we didn’t even get an error message; the
prompt just turned to a <code class="docutils literal notranslate"><span class="pre">*</span></code> (indicating that OCaml thought we were
still in a comment). When we added the <code class="docutils literal notranslate"><span class="pre">*)</span></code> to terminate the comment,
we got an unhelpful error message.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(</span> <span class="o">*+</span> <span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="o">(</span> <span class="o">*+</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="mi">2</span> <span class="o">*+</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="o">#</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*+</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
<p>Now we see that the <code class="docutils literal notranslate"><span class="pre">*+</span></code> operator has the same precedence as the <code class="docutils literal notranslate"><span class="pre">*</span></code>
operator.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When defining new operators, it’s always a good idea to put a blank
space after the <code class="docutils literal notranslate"><span class="pre">(</span></code> and before the <code class="docutils literal notranslate"><span class="pre">)</span></code> characters that surround
the operator.</p>
</div>
<p>You can even define unary prefix operators, as long as they start with
the <code class="docutils literal notranslate"><span class="pre">!</span></code> character:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(</span> <span class="o">!++</span> <span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="o">(</span> <span class="o">!++</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">0</span><span class="o">}</span>
<span class="o">#</span> <span class="o">!++</span> <span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We will have more to say about <code class="docutils literal notranslate"><span class="pre">ref</span></code> types below.</p>
</section>
<section id="printf-and-format-strings">
<h3><code class="docutils literal notranslate"><span class="pre">printf</span></code> and format strings<a class="headerlink" href="#printf-and-format-strings" title="Permalink to this headline">#</a></h3>
<p>OCaml has a <code class="docutils literal notranslate"><span class="pre">printf</span></code> function (technically, <code class="docutils literal notranslate"><span class="pre">Printf.printf</span></code>) which
has a number of pecularities. Check this out:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="n">out_channel</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">format</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>So even though <code class="docutils literal notranslate"><span class="pre">&quot;%d\n&quot;</span></code> appears to be just a string, somehow it can
also be the first argument of <code class="docutils literal notranslate"><span class="pre">Printf.printf</span></code>, where it is somehow
compatible with the type <code class="docutils literal notranslate"><span class="pre">('a,</span> <span class="pre">out_channel,</span> <span class="pre">unit)</span> <span class="pre">format</span></code>. What is
actually happening is that OCaml is turning a <em>literal</em> string into a
something that does <em>not</em> have the <code class="docutils literal notranslate"><span class="pre">string</span></code> type, but is instead
something called a <em>format string</em>. You can actually convert strings to
format strings manually, but do not expect to understand the process:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">format_of_string</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">d</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">e</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">f</span><span class="o">)</span> <span class="n">format6</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">d</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">e</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">f</span><span class="o">)</span> <span class="n">format6</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">format_of_string</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fs</span> <span class="o">:</span>
  <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak5</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak6</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak7</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak8</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak8</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak5</span><span class="o">)</span> <span class="n">format6</span> <span class="o">=</span>
  <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Format</span>
   <span class="o">(</span><span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Int</span> <span class="o">(</span><span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Int_d</span><span class="o">,</span>
     <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">No_padding</span><span class="o">,</span>
     <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">No_precision</span><span class="o">,</span>
     <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Char_literal</span> <span class="o">(</span><span class="sc">&#39;\n&#39;</span><span class="o">,</span>
      <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">End_of_format</span><span class="o">)),</span>
   <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="n">fs</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="n">fs</span> <span class="mi">10</span><span class="o">;;</span>
<span class="mi">10</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Another peculiarity is that <code class="docutils literal notranslate"><span class="pre">format_of_string</span></code> only works when the
string argument is a literal string; its first argument is not
actually a string. Don’t worry about any of this!</p>
</div>
<p>Regardless of the weird types that format strings have, when you give a
(literal) format string as the first argument of <code class="docutils literal notranslate"><span class="pre">Printf.printf</span></code>, the
result will have the correct type (here, <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">unit</span></code> because it
takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> and returns a value of type <code class="docutils literal notranslate"><span class="pre">unit</span></code>).</p>
<p>Since format strings aren’t strings, this doesn’t work:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let fs = &quot;%d\n&quot;;;
val fs : string = &quot;%d\n&quot;
# Printf.printf fs 10;;
Line 1, characters 14-16:
1 | Printf.printf fs 10;;
                  ^^
Error: This expression has type string but an expression was expected of type
         (&#39;a -&gt; &#39;b, out_channel, unit) format =
           (&#39;a -&gt; &#39;b, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6
</pre></div>
</div>
<p>One issue with format strings is that sometimes you would like to be
able to divide them over multiple lines. However, you can’t just
concatenate them as if they were strings:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Printf.printf (&quot;int: %d\t&quot; ^ &quot;string: %s\n&quot;) 10 &quot;foo&quot;;;
Line 1, characters 14-44:
1 | Printf.printf (&quot;int: %d\t&quot; ^ &quot;string: %s\n&quot;) 10 &quot;foo&quot;;;
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type string but an expression was expected of type
         (&#39;a -&gt; &#39;b -&gt; &#39;c, out_channel, unit) format =
           (&#39;a -&gt; &#39;b -&gt; &#39;c, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6
</pre></div>
</div>
<p>Instead, you have to use the special <em>format string concatenation
operator</em> <code class="docutils literal notranslate"><span class="pre">(^^)</span></code> to do the job:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="o">(</span><span class="s2">&quot;int: %d</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">^^</span> <span class="s2">&quot;string: %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="mi">10</span> <span class="s2">&quot;foo&quot;</span><span class="o">;;</span>
<span class="kt">int</span><span class="o">:</span> <span class="mi">10</span> <span class="kt">string</span><span class="o">:</span> <span class="n">foo</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">(^^)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">d</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">e</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">f</span><span class="o">)</span> <span class="n">format6</span> <span class="o">-&gt;</span>
    <span class="o">(</span><span class="k">&#39;</span><span class="n">f</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">e</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">g</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">h</span><span class="o">)</span> <span class="n">format6</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">d</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">g</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">h</span><span class="o">)</span> <span class="n">format6</span>
<span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="s2">&quot;int: %d</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">^^</span> <span class="s2">&quot;string: %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak9</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak10</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak11</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak12</span><span class="o">,</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak12</span><span class="o">,</span>
     <span class="k">&#39;</span><span class="o">_</span><span class="n">weak9</span><span class="o">)</span>
    <span class="n">format6</span>
<span class="o">=</span>
<span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Format</span>
 <span class="o">(</span><span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">String_literal</span> <span class="o">(</span><span class="s2">&quot;int: &quot;</span><span class="o">,</span>
   <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Int</span> <span class="o">(</span><span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Int_d</span><span class="o">,</span>
    <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">No_padding</span><span class="o">,</span>
    <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">No_precision</span><span class="o">,</span>
    <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Char_literal</span> <span class="o">(</span><span class="sc">&#39;\t&#39;</span><span class="o">,</span>
     <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">String_literal</span> <span class="o">(</span><span class="s2">&quot;string: &quot;</span><span class="o">,</span>
      <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">String</span> <span class="o">(</span><span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">No_padding</span><span class="o">,</span>
       <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">Char_literal</span> <span class="o">(</span><span class="sc">&#39;\n&#39;</span><span class="o">,</span>
        <span class="nn">CamlinternalFormatBasics</span><span class="p">.</span><span class="nc">End_of_format</span><span class="o">)))))),</span>
 <span class="s2">&quot;int: %d</span><span class="se">\t</span><span class="s2">%,string: %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>You probably won’t need this operator much, if at all.</p>
</section>
</section>
<section id="lists">
<h2>Lists<a class="headerlink" href="#lists" title="Permalink to this headline">#</a></h2>
<p>There are three important things you need to remember about lists in
OCaml:</p>
<ol class="arabic simple">
<li><p>All the elements of a list must be of the same type.</p></li>
<li><p>You can’t change the elements of a list.</p></li>
<li><p>Elements are separated with semicolons (<code class="docutils literal notranslate"><span class="pre">;</span></code>), not commas.</p></li>
</ol>
<p>A very common pitfall is to use commas instead of semicolons, which not
only doesn’t do what you expect but sometimes seems to work only to fail
later while giving hilariously obscure type errors. We will see why in
the section on tuples below. Remember: OCaml’s syntax is different from
Python’s!</p>
<p>There is a <a class="reference external" href="https://v2.ocaml.org/api/List.html">List</a>
module with many useful functions on lists.</p>
</section>
<section id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">#</a></h2>
<p>Syntactically, arrays are exactly like lists except that they use
different delimiters. Instead of <code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code> arrays use <code class="docutils literal notranslate"><span class="pre">[|</span></code> and
<code class="docutils literal notranslate"><span class="pre">|]</span></code>. Here is a literal array:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">my_array</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span> <span class="o">|];;</span>
<span class="k">val</span> <span class="n">my_array</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">|]</span>
</pre></div>
</div>
<p>Notice that the array has type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">array</span></code>; the type of the elements
is part of the type of the array.</p>
<p>Accessing elements from arrays uses the unusual <code class="docutils literal notranslate"><span class="pre">&lt;array&gt;.(&lt;index&gt;)</span></code>
syntax:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">my_array</span><span class="o">.(</span><span class="mi">0</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">my_array</span><span class="o">.(</span><span class="mi">4</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">my_array</span><span class="o">.(</span><span class="mi">5</span><span class="o">);;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nc">Invalid_argument</span> <span class="s2">&quot;index out of bounds&quot;</span><span class="o">.</span>
</pre></div>
</div>
<p>Mutating (changing) elements in an array also uses an unusual syntax:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">my_array</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">|]</span>
<span class="o">#</span> <span class="n">my_array</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="mi">42</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">my_array</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">42</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">|]</span>
</pre></div>
</div>
<p>There is an <a class="reference external" href="https://v2.ocaml.org/api/Array.html">Array</a>
module with many useful functions on arrays.</p>
</section>
<section id="tuples">
<span id="id2"></span><h2>Tuples<a class="headerlink" href="#tuples" title="Permalink to this headline">#</a></h2>
<p>A fundamental data type in OCaml is the <em>tuple</em> (pronounced “too-ple” or
“tup-ple” depending on your preference; I prefer “too-ple”). It is
nothing more than a sequence of arbitrary OCaml values wrapped in
parentheses, separated by commas. Tuples can (and usually do) contain
data of different types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Tuples exist in Python too, but in that language they are almost
superfluous, being basically a restricted form of lists. In OCaml,
tuples are necessary because lists can only contain one type of data.</p>
</div>
<section id="type-notation">
<span id="id3"></span><h3>Type notation<a class="headerlink" href="#type-notation" title="Permalink to this headline">#</a></h3>
<p>The notation for tuple types is a bit weird; they are written as the
<em>product</em> of the individual types:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">)</span>
</pre></div>
</div>
<p>This tuple has the type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">string</span> <span class="pre">*</span> <span class="pre">float</span></code>, which is a
type-theoretic “product” of the individual types. This notion of
“product” is basically the same as the set-theoretic notion, but don’t
worry about that. Just make sure you realize that this use of the <code class="docutils literal notranslate"><span class="pre">*</span></code>
operator doesn’t represent multiplication.</p>
</section>
<section id="implicit-parentheses">
<h3>Implicit parentheses<a class="headerlink" href="#implicit-parentheses" title="Permalink to this headline">#</a></h3>
<p>Unfortunately, OCaml (like Python) allows you to omit the parentheses in
many situations:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">)</span>
<span class="o">#</span> <span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">tup</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">tup</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">tup</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">tup</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s2">&quot;foo&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14</span><span class="o">)</span>
</pre></div>
</div>
<p>“So what?”, you say. “What’s the big deal?” Well, look at this code:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
<p>This is the correct way to write a list, using semicolons as separators.
A common error is to write lists with commas, which gives this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)]</span>
</pre></div>
</div>
<p>Note that this is <em>not</em> a syntax error! Instead, OCaml has interepreted
the commas as meaning a tuple, so it thinks you want a list with a
single element which is a 3-tuple. Then, when you try to use this list,
it will not do what you expect, and the error messages will probably not
be very helpful.</p>
<p>We recommend that you <em>never</em> write a tuple without explicit
parentheses. However, this will not fix the problem above, because OCaml
will still interpret the wrongly-written “list” as a list of N-tuples.
Ultimately, you just have to be able to recognize this problem for what
it is, and learn to write lists the right way.</p>
</section>
<section id="commas-vs-semicolons">
<h3>Commas <em>vs.</em> semicolons<a class="headerlink" href="#commas-vs-semicolons" title="Permalink to this headline">#</a></h3>
<p>What about the opposite problem: writing a tuple with semicolons as
separators instead of using commas?</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># (1, &quot;foo&quot;, 3.14);;
- : int * string * float = (1, &quot;foo&quot;, 3.14)
# (1; &quot;foo&quot;; 3.14);;
Line 1, characters 1-2:
1 | (1; &quot;foo&quot;; 3.14);;
     ^
Warning 10: this expression should have type unit.
Line 1, characters 4-9:
1 | (1; &quot;foo&quot;; 3.14);;
        ^^^^^
Warning 10: this expression should have type unit.
- : float = 3.14
</pre></div>
</div>
<p>A parenthesized expression with semicolon separators is a <em>sequence
expression</em>, which is mainly used in imperative code. (You can also
write them with <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> delimiters instead of parentheses,
which we prefer.) In a sequence expression, all but the last
subexpression should have type <code class="docutils literal notranslate"><span class="pre">unit</span></code>, or you get warnings (as you see
above). You probably won’t run into this pitfall, but you should be
aware of it. We will talk about sequence expressions more below when we
discuss imperative programming.</p>
</section>
</section>
<section id="strings">
<h2>Strings<a class="headerlink" href="#strings" title="Permalink to this headline">#</a></h2>
<p>Strings are pretty standard in OCaml, except that the notation for
accessing characters in a string is weird:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;this is a string&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;this is a string&quot;</span>
<span class="o">#</span> <span class="n">s</span><span class="o">.[</span><span class="mi">0</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">char</span> <span class="o">=</span> <span class="sc">&#39;t&#39;</span>
<span class="o">#</span> <span class="n">s</span><span class="o">.[</span><span class="mi">9</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">char</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span>
</pre></div>
</div>
<p>OCaml treats strings like a kind of specialized array. Up until
recently, strings were mutable (you could change the characters in a
string). Thankfully, that is no longer the case. (There is a mutable
string type called <code class="docutils literal notranslate"><span class="pre">bytes</span></code> if you really need it.)</p>
</section>
<section id="conditionals">
<h2>Conditionals<a class="headerlink" href="#conditionals" title="Permalink to this headline">#</a></h2>
<section id="if-expressions">
<h3><code class="docutils literal notranslate"><span class="pre">if</span></code> expressions<a class="headerlink" href="#if-expressions" title="Permalink to this headline">#</a></h3>
<p>In most programming languages, <code class="docutils literal notranslate"><span class="pre">if</span></code> is a statement, but in functional
languages like OCaml, <code class="docutils literal notranslate"><span class="pre">if</span></code> is an expression. This means that an <code class="docutils literal notranslate"><span class="pre">if</span></code>
expression returns a value. This is nice in that you can use <code class="docutils literal notranslate"><span class="pre">if</span></code>
expressions anywhere an expression is desired. For instance, this
function computes the ratio of the maximum and minimum of two floats:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">scale</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="o">)</span> <span class="o">/.</span> <span class="o">(</span><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">y</span> <span class="k">else</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
<p>(Note the <code class="docutils literal notranslate"><span class="pre">/.</span></code> operator for float division.) This is not the most
elegant way to write this function, but it illustrates that <code class="docutils literal notranslate"><span class="pre">if</span></code>
expressions can be embedded in larger expressions.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">if</span></code> is an expression, <code class="docutils literal notranslate"><span class="pre">if</span></code> expressions must have a specific
type regardless of whether the test clause of the <code class="docutils literal notranslate"><span class="pre">if</span></code> returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>. Therefore, both branches of the <code class="docutils literal notranslate"><span class="pre">if</span></code> (the
<code class="docutils literal notranslate"><span class="pre">then</span></code> branch and the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch) must be expressions which have
the exact same type. Something like this is not legal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let a = 10;;
val a : int = 10
# let b = 20;;
val b : int = 20
# if a &gt; b then &quot;success&quot; else 0;;
Line 1, characters 29-30:
1 | if a &gt; b then &quot;success&quot; else 0;;
                                 ^
Error: This expression has type int but an expression was expected of type
         string
</pre></div>
</div>
<p>This is easy to understand, but things are not always so clear, as we
will see.</p>
</section>
<section id="if-without-else">
<h3><code class="docutils literal notranslate"><span class="pre">if</span></code> without <code class="docutils literal notranslate"><span class="pre">else</span></code><a class="headerlink" href="#if-without-else" title="Permalink to this headline">#</a></h3>
<p>OCaml allows you to have an <code class="docutils literal notranslate"><span class="pre">if</span></code> expression without an <code class="docutils literal notranslate"><span class="pre">else</span></code>
clause, but if you do that, the <code class="docutils literal notranslate"><span class="pre">then</span></code> clause <em>must</em> have type
<code class="docutils literal notranslate"><span class="pre">unit</span></code>.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">#</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="k">then</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;big!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="n">big</span><span class="o">!</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>
</div>
<p>This works because <code class="docutils literal notranslate"><span class="pre">printf</span></code> has a return type of <code class="docutils literal notranslate"><span class="pre">unit</span></code>. But this
won’t work:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let b = if a &gt; 5 then 10;;
Line 1, characters 22-24:
1 | let b = if a &gt; 5 then 10;;
                          ^^
Error: This expression has type int but an expression was expected of type
         unit
       because it is in the result of a conditional with no else branch
</pre></div>
</div>
<p>Both branches of a conditional must have the same type, and if you leave
out the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch, its type is assumed to be <code class="docutils literal notranslate"><span class="pre">unit</span></code>. In other
words, <code class="docutils literal notranslate"><span class="pre">if</span></code> without <code class="docutils literal notranslate"><span class="pre">else</span></code> is desugared as follows.  This:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">expr</span><span class="o">&gt;</span> <span class="k">then</span> <span class="o">&lt;</span><span class="k">then</span> <span class="n">expr</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>is equivalent to this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">expr</span><span class="o">&gt;</span> <span class="k">then</span> <span class="o">&lt;</span><span class="k">then</span> <span class="n">expr</span><span class="o">&gt;</span> <span class="k">else</span> <span class="bp">()</span>
</pre></div>
</div>
<p>When you think about it, this makes perfect sense. Normally you would
only want to do an <code class="docutils literal notranslate"><span class="pre">if</span></code>-without-<code class="docutils literal notranslate"><span class="pre">else</span></code> if you are writing imperative
code in the <code class="docutils literal notranslate"><span class="pre">then</span></code> clause (see below).</p>
</section>
<section id="else-if">
<h3><code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code><a class="headerlink" href="#else-if" title="Permalink to this headline">#</a></h3>
<p>Technically, OCaml doesn’t have an <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> construct. However, if
you’re careful you can use it anyway:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">abs</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="o">-</span><span class="n">x</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="n">x</span>
  <span class="k">else</span> <span class="mi">0</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">abs</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>What’s actually happening is that there are two nested <code class="docutils literal notranslate"><span class="pre">if</span></code>
expressions:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">abs</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="o">-</span><span class="n">x</span>
  <span class="k">else</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span>
       <span class="n">x</span>
     <span class="k">else</span> <span class="mi">0</span><span class="o">);;</span>
</pre></div>
</div>
<p>As long as you can write your code as a sequence of nested <code class="docutils literal notranslate"><span class="pre">if</span></code>
expressions like this, it will work as you expect. But if you put
something more complicated in one of the <code class="docutils literal notranslate"><span class="pre">then</span></code> or <code class="docutils literal notranslate"><span class="pre">else</span></code> clauses
(like another <code class="docutils literal notranslate"><span class="pre">if</span></code> expression) you may have to wrap parentheses or a
<code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> pair around the inner expression:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">test</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">5</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
        <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;inner if</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="c">(* no else! *)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 1</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">else</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 2</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">test</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">test</span> <span class="mi">15</span><span class="o">;;</span>
<span class="n">inner</span> <span class="k">if</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">test</span> <span class="mi">9</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">test</span> <span class="pre">9</span></code> doesn’t print anything, though we might expect it
to print <code class="docutils literal notranslate"><span class="pre">&quot;outer</span> <span class="pre">if</span> <span class="pre">1&quot;</span></code>. The code above is parsed as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">test</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">5</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="o">(</span><span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
        <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;inner if</span><span class="se">\n</span><span class="s2">&quot;</span>
       <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 1</span><span class="se">\n</span><span class="s2">&quot;</span>
       <span class="k">else</span>
         <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
  <span class="o">;;</span>
</pre></div>
</div>
<p>which is probably not what was intended. To fix it, insert either
parentheses or a <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> pair to disambiguate it:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">test</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">5</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="o">(</span><span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
        <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;inner if</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 1</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">else</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 2</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">test</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">test</span> <span class="mi">15</span><span class="o">;;</span>
<span class="n">inner</span> <span class="k">if</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">test</span> <span class="mi">9</span><span class="o">;;</span>
<span class="n">outer</span> <span class="k">if</span> <span class="mi">1</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">test</span> <span class="mi">8</span><span class="o">;;</span>
<span class="n">outer</span> <span class="k">if</span> <span class="mi">2</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> it looks like this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">test</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">5</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="k">begin</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
          <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;inner if</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 1</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">else</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;outer if 2</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="o">;;</span>
</pre></div>
</div>
<p>Either are acceptable.</p>
<p>If OCaml’s <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> situation makes you uneasy, there is a perfectly
reasonable alternative…​ that will probably also make you uneasy! It’s a
way of using OCaml’s <code class="docutils literal notranslate"><span class="pre">match</span></code> form that is like a sequence of
<code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">else</span></code> forms. Example:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">abs</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">match</span> <span class="bp">()</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">_</span> <span class="k">when</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">n</span>
    <span class="o">|</span> <span class="o">_</span> <span class="k">when</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="n">n</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>We match against <code class="docutils literal notranslate"><span class="pre">()</span></code> because we don’t care about the value matched;
that’s also why we use the <code class="docutils literal notranslate"><span class="pre">_</span></code> in each clause of the match. Instead,
we’re using the <code class="docutils literal notranslate"><span class="pre">match</span></code> form solely because of the ability to use
<code class="docutils literal notranslate"><span class="pre">when</span></code> pattern guards; these contain the actual logic. This can often
be a bit more concise and clean than an actual <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code>, but be
careful: if you need to do another <code class="docutils literal notranslate"><span class="pre">match</span></code> in the expression following
the right arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) you may have to wrap it in parentheses or a
<code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> form (see below for why).</p>
</section>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">#</a></h2>
<p>OCaml is a functional language, so functions are fundamental. There are
a number of unusual features of OCaml functions.</p>
<section id="syntax-and-currying">
<h3>Syntax and currying<a class="headerlink" href="#syntax-and-currying" title="Permalink to this headline">#</a></h3>
<p>Unlike most conventional languages, OCaml doesn’t require you to put
parentheses around the arguments to a function. In fact, if you do, you
change the meaning! Consider this innocent-looking function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">add</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">add</span> <span class="o">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
<p>OK, so we can get by without parentheses around the arguments. (The
parentheses in the last line are to create the arguments, not to
surround them for the function call.) What if we use them anyway?</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># add (2, 3);;
Line 1, characters 4-10:
1 | add (2, 3);;
        ^^^^^^
Error: This expression has type &#39;a * &#39;b
       but an expression was expected of type int
</pre></div>
</div>
<p>Nope, that isn’t correct. The error message may confuse you. Let’s see a
variation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add&#39;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add&#39;</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">add&#39;</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>(Note that in OCaml, you can use the <code class="docutils literal notranslate"><span class="pre">'</span></code> character (pronounced
“prime”) in identifiers.)</p>
<p>If we define the function with parentheses, we have to call it with
parentheses. If not:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># add&#39; 2 3;;
Line 1, characters 0-4:
1 | add&#39; 2 3;;
    ^^^^
Error: This function has type int * int -&gt; int
       It is applied to too many arguments; maybe you forgot a `;&#39;.
</pre></div>
</div>
<p>Huh. What is really going on here?</p>
<p>Look at the second version again:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add&#39;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add&#39;</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Look at the type signature. The <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">int</span></code> part says that the input
to the function is a <em>single</em> argument which must be a two-tuple (a
tuple with two elements), where both elements are <code class="docutils literal notranslate"><span class="pre">int</span></code>s. If you
leave the arguments “naked”, they don’t form a two-tuple, and there are
two arguments, not one. This explains the error message. Now look at the
first version:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The type signature is a bit odd. Since the <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> type operator
associates to the right, this is equivalent to:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This is an example of what’s called <em>currying</em>. What the type signature
means is that the <code class="docutils literal notranslate"><span class="pre">add</span></code> function actually only takes a <em>single</em>
argument (an <code class="docutils literal notranslate"><span class="pre">int</span></code>) and returns a <em>function</em> of type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>.
If you call the function with both arguments, the function returned by
applying <code class="docutils literal notranslate"><span class="pre">add</span></code> to the first argument (which has type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>)
is immediately applied to the second argument (of type <code class="docutils literal notranslate"><span class="pre">int</span></code>) to give
the result, which is an <code class="docutils literal notranslate"><span class="pre">int</span></code>. So this function call:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">add</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>is actually this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(</span><span class="n">add</span> <span class="mi">2</span><span class="o">)</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>And if we leave out the second argument, we get this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">add</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>which shows currying in action. We can use this function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add2</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">2</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add2</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">add2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
</section>
<section id="anonymous-functions">
<h3>Anonymous functions<a class="headerlink" href="#anonymous-functions" title="Permalink to this headline">#</a></h3>
<p>Functions are a kind of data in functional languages like OCaml, and you
can define function values directly using the <code class="docutils literal notranslate"><span class="pre">fun</span></code> expression. So
instead of writing:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>we could write the definition like this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">add</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The meaning is exactly the same. We say that the first form is
<em>syntactic sugar</em> for the latter form. We can even use a <code class="docutils literal notranslate"><span class="pre">fun</span></code>
expression without giving it a name at all:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Therefore, we say that the <code class="docutils literal notranslate"><span class="pre">fun</span></code> form defines an <em>anonymous function</em>.
Anonymous functions are often used with higher-order functions
(functions that take functions as input and/or return functions as
output).</p>
</section>
</section>
<section id="match-expressions">
<h2><code class="docutils literal notranslate"><span class="pre">match</span></code> expressions<a class="headerlink" href="#match-expressions" title="Permalink to this headline">#</a></h2>
<p>OCaml <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions are pretty straightforward. They have a
couple of subtleties you should know about.</p>
<section id="optional-before-first-match">
<h3>Optional <code class="docutils literal notranslate"><span class="pre">|</span></code> before first match<a class="headerlink" href="#optional-before-first-match" title="Permalink to this headline">#</a></h3>
<p>In a <code class="docutils literal notranslate"><span class="pre">match</span></code> expression, the alternatives are separated by a vertical
bar character (<code class="docutils literal notranslate"><span class="pre">|</span></code>). You can also (optionally) put a vertical bar
character before the first pattern to be matched. This often makes the
code look cleaner. Compare:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">sum_list</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
      <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="n">sum_list</span> <span class="n">t</span>
</pre></div>
</div>
<p>with</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">sum_list</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="n">sum_list</span> <span class="n">t</span>
</pre></div>
</div>
<p>These two functions are identical in terms of their functionality, but
the code for the second looks cleaner because of the extra <code class="docutils literal notranslate"><span class="pre">|</span></code> before
the first match.</p>
</section>
<section id="nested-match-expressions">
<h3>Nested match expressions<a class="headerlink" href="#nested-match-expressions" title="Permalink to this headline">#</a></h3>
<p>It’s not uncommon to want to put a <code class="docutils literal notranslate"><span class="pre">match</span></code> expression inside another
<code class="docutils literal notranslate"><span class="pre">match</span></code> expression. If you do, you have to be careful with the inner
<code class="docutils literal notranslate"><span class="pre">match</span></code> expression so that its clauses aren’t confused with the outer
<code class="docutils literal notranslate"><span class="pre">match</span></code>’s clauses. Here’s an <a class="reference external" href="https://stackoverflow.com/questions/257605/ocaml-match-expression-inside-another-one">example from the
internet</a>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">filter</span> <span class="n">exp</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">exp</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Var</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="nc">Var</span> <span class="n">v</span>
    <span class="o">|</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Diff</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="n">e2</span> <span class="k">with</span>  <span class="c">(* nested match *)</span>
        <span class="o">|</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">diffRule</span> <span class="n">e2</span><span class="o">)</span>
        <span class="o">|</span> <span class="nc">Diff</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">diffRule</span> <span class="n">e2</span><span class="o">)</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="n">e2</span>
    <span class="c">(* Oops! These following clauses should belong to the outer match, but</span>
<span class="c">       they actually belong to the inner match. *)</span>
    <span class="o">|</span> <span class="nc">Quot</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="k">match</span> <span class="n">e2</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Quot</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">quotRule</span> <span class="n">e2</span><span class="o">)</span>
        <span class="o">|</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">quotRule</span> <span class="n">e2</span><span class="o">)</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="n">e2</span>
</pre></div>
</div>
<p>The solution is to wrap the inner <code class="docutils literal notranslate"><span class="pre">match</span></code> using parentheses or
<code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code>. For instance:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">filter</span> <span class="n">exp</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">exp</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Var</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="nc">Var</span> <span class="n">v</span>
    <span class="o">|</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Diff</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">match</span> <span class="n">e2</span> <span class="k">with</span>  <span class="c">(* nested match *)</span>
          <span class="o">|</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">diffRule</span> <span class="n">e2</span><span class="o">)</span>
          <span class="o">|</span> <span class="nc">Diff</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">diffRule</span> <span class="n">e2</span><span class="o">)</span>
          <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="n">e2</span>
      <span class="k">end</span>
    <span class="o">|</span> <span class="nc">Quot</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="k">match</span> <span class="n">e2</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Quot</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">quotRule</span> <span class="n">e2</span><span class="o">)</span>
        <span class="o">|</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">e4</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="o">(</span><span class="n">quotRule</span> <span class="n">e2</span><span class="o">)</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">filter</span> <span class="n">e2</span>
</pre></div>
</div>
<p>Now it will do what it’s supposed to.</p>
</section>
<section id="function-expressions">
<h3><code class="docutils literal notranslate"><span class="pre">function</span></code> expressions<a class="headerlink" href="#function-expressions" title="Permalink to this headline">#</a></h3>
<p>This kind of pattern is extremely common:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="o">&lt;</span><span class="k">function</span> <span class="n">name</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">arg</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">&lt;</span><span class="n">arg</span><span class="o">&gt;</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>For instance, the <code class="docutils literal notranslate"><span class="pre">sum_list</span></code> function above is an example of this
pattern. The essence of this pattern is that you pattern match on the
last argument. Sometimes you have more arguments:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="o">&lt;</span><span class="k">function</span> <span class="n">name</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">arg1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">arg2</span><span class="o">&gt;</span> <span class="o">...</span> <span class="o">&lt;</span><span class="n">argN</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">&lt;</span><span class="n">argN</span><span class="o">&gt;</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Whenever you have a function that pattern matches on its last argument,
you can rewrite it using the <code class="docutils literal notranslate"><span class="pre">function</span></code> keyword. This is like an
automatic <code class="docutils literal notranslate"><span class="pre">match</span></code> on the last argument. The patterns above would be
written like this using <code class="docutils literal notranslate"><span class="pre">function</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="o">&lt;</span><span class="k">function</span> <span class="n">name</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">function</span> <span class="c">(* leave off &lt;arg&gt; *)</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
  <span class="o">...</span>

<span class="k">let</span> <span class="k">rec</span> <span class="o">&lt;</span><span class="k">function</span> <span class="n">name</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">arg1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">arg2</span><span class="o">&gt;</span> <span class="o">...</span> <span class="o">=</span> <span class="k">function</span> <span class="c">(* leave off &lt;argN&gt; *)</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">pattern</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">...</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Rewriting <code class="docutils literal notranslate"><span class="pre">sum_list</span></code> using <code class="docutils literal notranslate"><span class="pre">function</span></code> gives this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">sum_list</span> <span class="o">=</span> <span class="k">function</span> <span class="c">(* leave off &lt;arg1&gt; *)</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="n">sum_list</span> <span class="n">t</span>
</pre></div>
</div>
<p>This way of writing functions has advantages and disadvantages. The
advantage is that it’s more concise. The disadvantage is that you have
to remember that the <code class="docutils literal notranslate"><span class="pre">function</span></code> keyword means that the function you
are defining has an extra argument that doesn’t have a name. Also, if
you do need the name of the argument inside the body of the function,
you can’t use <code class="docutils literal notranslate"><span class="pre">function</span></code>. <code class="docutils literal notranslate"><span class="pre">function</span></code> is mostly used for simple
functions of a simple argument where the only thing you do with the
argument is pattern match on it. It’s never necessary, though, so feel
free to write all your code without it.</p>
</section>
</section>
<section id="let-expressions">
<h2><code class="docutils literal notranslate"><span class="pre">let</span></code> expressions<a class="headerlink" href="#let-expressions" title="Permalink to this headline">#</a></h2>
<section id="explicit-recursion">
<h3>Explicit recursion<a class="headerlink" href="#explicit-recursion" title="Permalink to this headline">#</a></h3>
<p>OCaml requires you to say <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span></code> when defining a recursive
function.</p>
<p>You can easily define mutually recursive functions by using the</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>
  <span class="o">...</span>  <span class="c">(* expression using g *)</span>
<span class="ow">and</span> <span class="n">g</span> <span class="n">y</span> <span class="o">=</span>
  <span class="o">...</span>  <span class="c">(* expression using f *)</span>
</pre></div>
</div>
<p>syntax for top-level mutually-recursive functions, or the</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>
  <span class="o">...</span>  <span class="c">(* expression using g *)</span>
<span class="ow">and</span> <span class="n">g</span> <span class="n">y</span> <span class="o">=</span>
  <span class="o">...</span>  <span class="c">(* expression using f *)</span>
<span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>syntax for mutually-recursive functions inside an expression. Leaving
out the <code class="docutils literal notranslate"><span class="pre">rec</span></code> is one of the commonest mistakes beginning OCaml
programmers make. Conversely, don’t use the <code class="docutils literal notranslate"><span class="pre">rec</span></code> unless the function
is actually recursive! (This will rarely cause problems but it’s poor
style.)</p>
</section>
</section>
<section id="imperative-programming">
<h2>Imperative programming<a class="headerlink" href="#imperative-programming" title="Permalink to this headline">#</a></h2>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>OCaml doesn’t have “variables” in the sense that most programming
languages do. Instead, it has <em>references</em>, which are basically records
with a single mutable field. These are effectively the same as variables
except that you have to explicitly dereference them to get the value
they contain. I’m not going to lie to you, this is a pain in highly
imperative code! However, it is extremely explicit and it allows you to
define useful functions on references.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">;;</span>  <span class="c">(* r is a reference *)</span>
<span class="k">val</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">0</span><span class="o">}</span>
<span class="o">#</span> <span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">0</span><span class="o">}</span>
<span class="o">#</span> <span class="o">(!);;</span>      <span class="c">(* ! is the dereference operator *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="o">!</span><span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="o">(:=);;</span>     <span class="c">(* := is the assignment operator *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">42</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">42</span><span class="o">}</span>
<span class="o">#</span> <span class="o">!</span><span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">42</span>
<span class="o">#</span> <span class="n">incr</span><span class="o">;;</span>     <span class="c">(* incr is a function on references *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">incr</span> <span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">43</span>
</pre></div>
</div>
<p>Fun fact: we could have defined the <code class="docutils literal notranslate"><span class="pre">!</span></code> and <code class="docutils literal notranslate"><span class="pre">:=</span></code> operators
ourselves, and we could have defined the <code class="docutils literal notranslate"><span class="pre">incr</span></code> function as well:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(</span> <span class="o">!</span> <span class="o">)</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span><span class="o">;;</span>
<span class="k">val</span> <span class="o">(</span> <span class="o">!</span> <span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="o">(</span> <span class="o">:=</span> <span class="o">)</span> <span class="n">r</span> <span class="n">v</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="o">;;</span>
<span class="k">val</span> <span class="o">(</span> <span class="o">:=</span> <span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">incr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">incr</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This works because references (<code class="docutils literal notranslate"><span class="pre">ref</span></code> cells) are records with a single
field called <code class="docutils literal notranslate"><span class="pre">contents</span></code>, so the record accessing and mutating syntax
can be used on them.</p>
</section>
<section id="sequence-expressions">
<h3>Sequence expressions<a class="headerlink" href="#sequence-expressions" title="Permalink to this headline">#</a></h3>
<p>When you are doing imperative programming, it’s often necessary to have
a notion of sequencing, as in do-this-then-do-that <em>etc.</em> In OCaml, this
requires a <em>sequence expression</em>, which has two forms:</p>
<ul class="simple">
<li><p>a series of statements separated by semicolons and wrapped with
<code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code></p></li>
<li><p>the same, but using parentheses instead of <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code></p></li>
</ul>
<p>The choice between using <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> or parentheses is a style
decision. I prefer parentheses for very short (one-liner) sequence
expressions and <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> for sequence expressions that span
multiple lines.</p>
<p>Here’s an example of an (inefficient) imperative function to compute
greatest common denominators (GCDs):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">gcd</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">m</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">n</span> <span class="k">in</span>
    <span class="k">begin</span>
      <span class="k">while</span> <span class="o">!</span><span class="n">p</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">q</span> <span class="k">do</span>
          <span class="k">if</span> <span class="o">!</span><span class="n">p</span> <span class="o">&gt;</span> <span class="o">!</span><span class="n">q</span> <span class="k">then</span>
            <span class="n">p</span> <span class="o">:=</span> <span class="o">!</span><span class="n">p</span> <span class="o">-</span> <span class="o">!</span><span class="n">q</span>
          <span class="k">else</span>
            <span class="n">q</span> <span class="o">:=</span> <span class="o">!</span><span class="n">q</span> <span class="o">-</span> <span class="o">!</span><span class="n">p</span>
      <span class="k">done</span><span class="o">;</span>
      <span class="o">!</span><span class="n">p</span>
    <span class="k">end</span>
</pre></div>
</div>
<p>This also shows the use of an imperative <code class="docutils literal notranslate"><span class="pre">while</span></code> loop. It also shows
how annoying imperative programming is in OCaml <code class="docutils literal notranslate"><span class="pre">!</span></code>because <code class="docutils literal notranslate"><span class="pre">!</span></code>of
<code class="docutils literal notranslate"><span class="pre">!</span></code>all <code class="docutils literal notranslate"><span class="pre">!</span></code>the <code class="docutils literal notranslate"><span class="pre">!</span></code>exclamation <code class="docutils literal notranslate"><span class="pre">!</span></code>points!</p>
</section>
<section id="weakly-polymorphic-types">
<h3>Weakly polymorphic types<a class="headerlink" href="#weakly-polymorphic-types" title="Permalink to this headline">#</a></h3>
<p>OCaml’s type system has some peculiarities. One that you are likely to
run into when you do imperative programming is that there are types that
are “weakly polymorphic”. A truly polymorphic type can be parameterized
on one or more type variables, which are written with a leading quote
<em>i.e.</em> <code class="docutils literal notranslate"><span class="pre">'a</span></code>, <code class="docutils literal notranslate"><span class="pre">'b</span></code> <em>etc.</em> But some types are not actually
polymorphic, they are “write-once” types. Look at this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">r</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak1</span> <span class="kt">list</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span>
<span class="o">#</span> <span class="o">!</span><span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak1</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>
<span class="o">#</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]}</span>
<span class="o">#</span> <span class="o">!</span><span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
<p>The initial type of <code class="docutils literal notranslate"><span class="pre">r</span></code> is <code class="docutils literal notranslate"><span class="pre">'_weak1</span> <span class="pre">list</span> <span class="pre">ref</span></code>, which is pretty odd.
You might expect it to be <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">list</span> <span class="pre">ref</span></code> <em>i.e.</em> that <code class="docutils literal notranslate"><span class="pre">r</span></code> is a
reference which can contain any kind of list. But this would not be
type-safe; if <code class="docutils literal notranslate"><span class="pre">r</span></code> holds a list of <code class="docutils literal notranslate"><span class="pre">int</span></code>s at one time and a list of
<code class="docutils literal notranslate"><span class="pre">bool</span></code>s at another, then all the types are not known at
compile-time, and you might as well be writing Python code.</p>
<p>Instead, what this odd type means is that <code class="docutils literal notranslate"><span class="pre">r</span></code> is a reference
containing a list <em>of currently unspecified type</em>. That’s what the
<code class="docutils literal notranslate"><span class="pre">'_weak1</span> <span class="pre">list</span> <span class="pre">ref</span></code> means. Since <code class="docutils literal notranslate"><span class="pre">r</span></code> was initialized with an empty
list, which could have any element type, you can’t say any more. Once
you reassign a list of known type to <code class="docutils literal notranslate"><span class="pre">r</span></code>, it then has a concrete type
(<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">list</span></code> in this case), and the type is fixed thereafter.</p>
<p>OK, so what if you aren’t using references or imperative features?
Unfortunately, you can still get weakly polymorphic types if you
partially apply a function. Here’s a trivial example:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">const</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">const</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">const</span> <span class="bp">()</span> <span class="o">;;</span>  <span class="c">(* partial application of the const function *)</span>
<span class="k">val</span> <span class="n">f</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak1</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This is purely functional code, but you still get a weak type! The
reasons for this are quite involved (see the references below), but one
trick that will work in most cases is to change the partial application
to a full application by adding arguments:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">const</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">const</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">const</span> <span class="bp">()</span> <span class="n">x</span> <span class="o">;;</span>  <span class="c">(* no longer a partial application of the const function *)</span>
<span class="k">val</span> <span class="n">f</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">f</span></code> has the expected type. This trick (called “eta expansion”) is
definitely worth remembering.</p>
<p>For more on this issue (really far more than you need to know at this
point), here are some good references:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html">https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html</a></p></li>
<li><p><a class="reference external" href="https://ocamlverse.github.io/content/weak_type_variables.html">https://ocamlverse.github.io/content/weak_type_variables.html</a></p></li>
</ul>
</section>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="index.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Readings</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="subst.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">The substitution model</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Michael Vanier<br/>
  
      &copy; Copyright 2023, Michael C. Vanier. All rights reserved.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>