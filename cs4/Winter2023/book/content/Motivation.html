<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Motivation &mdash; The CS 4 book 0.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="History" href="History.html" />
    <link rel="prev" title="Collaboration policies" href="admin/Collaboration_policies.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> The CS 4 book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="admin/index.html">Administrative information</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Motivation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-are-the-goals-of-this-course">What are the goals of this course?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-is-functional-programming">What is functional programming?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-learn-functional-programming">Why learn functional programming?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#is-functional-programming-better-than-other-kinds-of-programming">Is functional programming better than other kinds of programming?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-are-we-using-ocaml">Why are we using OCaml?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#going-further">Going further</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="History.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="assignments/index.html">Assignments</a></li>
<li class="toctree-l1"><a class="reference internal" href="readings/index.html">Readings</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The CS 4 book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Motivation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="motivation">
<span id="id1"></span><h1>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading"></a></h1>
<p>Here we’ll talk about why we think you should learn the material in this
course, and what you can hope to gain from taking it.</p>
<div class="section" id="what-are-the-goals-of-this-course">
<h2>What are the goals of this course?<a class="headerlink" href="#what-are-the-goals-of-this-course" title="Permalink to this heading"></a></h2>
<p>Very broadly speaking, I would say that the goals of this course are:</p>
<ol class="arabic simple">
<li><p>to teach you to become a better programmer,</p></li>
<li><p>to deepen your understanding of programming,</p></li>
<li><p>to teach you to think about programming at a higher level,</p></li>
<li><p>and to learn some beautiful ideas.</p></li>
</ol>
<p>We also hope that you have fun doing it, because programming should be fun!
If it isn’t fun, we’re doing something wrong, and you should complain. <a class="footnote-reference brackets" href="#id7" id="id2">1</a></p>
<p>The goals just given can be approached in many different ways.
Programming is a big field, and there is no shortage of useful information
on how to improve yourself as a programmer.
Similarly, there are lots of beautiful ideas in programming,
and we can’t cover all of them in this course!
What we <em>can</em> do is cover interesting and useful
programming methods and ideas
that most of you haven’t encountered before.
Some of these ideas are unfamiliar even to professional programmers
who have been programming for a living for decades.</p>
<p>If we can open your eyes to some of these ideas,
if we help you see that there is more to programming than just
grinding out solutions to problems,
that programs can be beautiful as well as (<em>ahem</em>) functional,
then we’ve done our job.</p>
<p>Our way of approaching these goals will be to teach you a new way
of writing programs, a way that is usually referred to as
“functional programming”.</p>
</div>
<div class="section" id="what-is-functional-programming">
<h2>What is functional programming?<a class="headerlink" href="#what-is-functional-programming" title="Permalink to this heading"></a></h2>
<p>What functional programming is will take many lectures to describe fully,
but we can say a few things about it here.</p>
<p>It’s important to realize that functional programming
isn’t a yes/no proposition.
There are many aspects of functional programming, and some languages
support some of them but not others.  Even languages that call themselves
functional programming languages can have significant differences
in how they implement these ideas.
Conversely, languages that do not call themselves functional programming
languages can still support many features of functional languages.
Python is one such language; if you want to,
you can program in a functional style in Python, for the most part.
However, real “functional languages” make this style
of programming more convenient and more efficient than languages that
aren’t specifically functional.</p>
<p><strong>The overall goal of functional programming is to make programming easier</strong>.
This has two interrelated aspects.  Compared to programs written
in non-functional languages:</p>
<ul class="simple">
<li><p>programs are shorter;</p></li>
<li><p>programs have fewer bugs.</p></li>
</ul>
<p>Some important aspects of functional languages that contribute to these goals
include the following.</p>
<ul>
<li><p>Functions are <em>data</em>, and functions can be passed as arguments to
other functions, returned from functions, created on-the-fly,
and stored into and retrieved from data structures.
Functions that take or return functions are referred to as
<em>higher-order functions</em>, and they are massively useful!
They can drastically cut down on the amount of repeated code in
programs, which lets programs be shorter.
Also, since programming patterns can be captured in higher-order
functions and re-used in many different contexts,
once you’ve debugged a higher-order function it will work
correctly in many different contexts, which means programs
have fewer bugs.</p></li>
<li><p>Functional programming emphasizes <em>immutable</em> data, which means data
that doesn’t change.  Functional programmers prefer to compute new
data than change old data.
So even things as basic as variables (names whose values change as the
program evolves) are discouraged, which means that we need to find
new ways to do what we previously did with variables.
Functional languages also discourage <em>mutable</em> data structures like arrays
(where you can change the contents of a part of the data structure),
preferring <em>immutable</em> data structures like singly-linked lists and
immutable maps and sets (where you can’t change the contents of the data
structure, but you can create new ones that extend the old ones).
It turns out that avoiding variables and using immutable data structures
gets rid of large classes of potential bugs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t panic!  Just because functional languages discourage
variables and mutable data structures doesn’t mean they don’t exist. <a class="footnote-reference brackets" href="#id8" id="id3">2</a>
It’s just that you usually reserve them for situations where
they really are the best choice, instead of just using them
everywhere.</p>
</div>
</li>
<li><p>Functional languages discourage looping constructs,
preferring to use recursion or higher-order functions to achieve
the same effect.  This heavy use of recursion is very startling
to new functional programmers, but after a while it becomes
as natural as using loops.  Also, unlike loops, recursive functions
are much less likely to have subtle off-by-one errors,
which means fewer bugs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once again, “discourage” doesn’t mean that looping constructs
don’t exist (at least, they exist in OCaml).  But you never
need them, so you almost never use them.</p>
<p>Also, one hidden benefit of this course is that by the end of it,
you will understand recursion completely,
even if you’re a bit fuzzy on it at the beginning.</p>
</div>
</li>
<li><p>Most, but not all, functional languages are <em>statically typed</em>,
which means that they make sure that code has no type errors
before it executes.  Many non-functional languages are also
statically typed (for instance, C, C++, and Java), but the type
system of functional languages is much more powerful
(able to express more features of data in the type system),
and also easier to use (because of <em>type inference</em>, which means
you rarely have to declare types in your code).  Most functional
languages also provide a very powerful <em>pattern matching</em> feature
that works with the type system; this can lead to very concise code
which expresses the intent of the programmer in a clean and natural style.</p>
<p>A powerful static type system, coupled with pattern matching,
allows code to be shorter and have fewer bugs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In fact, some people will tell you that in functional languages,
“if it compiles, it works!”.  Sadly, this isn’t always true,
but it’s surprising how often this is the case.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="why-learn-functional-programming">
<h2>Why learn functional programming?<a class="headerlink" href="#why-learn-functional-programming" title="Permalink to this heading"></a></h2>
<p>We learn functional programming because:</p>
<ul class="simple">
<li><p>we want to write less code,</p></li>
<li><p>we want our code to be correct,</p></li>
<li><p>we want to think at a higher level,</p></li>
<li><p>and we want our code to be beautiful!</p></li>
</ul>
<p>We’ve talked above about how functional programming contributes to the first
two goals.  Why should functional programs be more “beautiful” than code
written in non-functional languages?  How can functional languages allow us to
think at a higher level?  What does “higher level” even mean?</p>
<p>These are aesthetic judgments, and reasonable people can disagree on this.
In fact, you might be wondering why we should even care about how “beautiful”
code is.  I think a good point of comparison is with mathematical
proofs.  Most true statements in mathematics can be proved in more than one
way.  However, good mathematicians definitely favor certain kinds of proofs,
which they call more “beautiful” or “elegant” than others.  The mathematician
Paul Erdös used to talk about “the Book”, which was where God kept the most
perfect proofs of each theorem.
There is even a whole book of such proofs, called, not surprisingly,
<a class="reference external" href="https://en.wikipedia.org/wiki/Proofs_from_THE_BOOK">Proofs from the Book</a>. <a class="footnote-reference brackets" href="#id9" id="id4">3</a>
And since computer programs are in some sense concrete crystallizations
of mathematical ideas, if you can accept that some proofs are more
“beautiful” than others, then it’s also likely that some ways of writing code
are more “beautiful” than others.  But what would this elusive concept of
“code beauty” entail?</p>
<p>I think one important aspect of beautiful code is that it’s <em>lean</em>; it has
nothing superfluous in it.  It’s concise without being cryptic. It expresses
the essence of a computation in as straightforward and clear a way as it can be
expressed.</p>
<p>The problem with this criterion is that what is “straightforward” and “clear”
depends greatly on the way you’ve been taught to think about programming.
And this is where the “higher level thinking” comes in.
For example, Python is often praised as a language
in which code is extremely clear and readable, and that’s true,
if you restrict yourself only to the kind of programming idioms
that are found in Python (and in most other languages).
But functional languages introduce a whole <em>new</em> set of idioms, and once
you understand them, you can think at a higher level.
And because of this, you can write better code.</p>
<p>Here’s a simple example.  Let’s write a function that takes a list of
integers and returns a new list, where the new list has all the same
numbers as the original list, but multiplied by 2.  Also, the original
list shouldn’t be altered.</p>
<p>In Python, you might write this function as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">double_list</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">new_lst</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_lst</span><span class="p">)):</span>
        <span class="n">new_lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">new_lst</span>
</pre></div>
</div>
<p>This is pretty straightforward.  You copy the list, and then go through
each element of the new list, multiplying the element by 2 and storing
the new value in place of the old value.  Then you return the new list.</p>
<p>In OCaml, you would write this function like this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">double_list</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="n">lst</span>
</pre></div>
</div>
<p>In fact, you can write it even more concisely:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">double_list</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>
</div>
<p>What this is saying is “take a function which doubles its argument
(<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">2</span></code>) and apply it to each element of a list,
collecting all the values in a new list.  This includes two ideas which are
fundamental to functional languages: anonymous functions
(the doubling function doesn’t have a name), and mapping a function
over a list (although other data structures can also be mapped over).
The <code class="docutils literal notranslate"><span class="pre">map</span></code> function is also a higher-order function,
since its first argument is itself a function.
And once you understand these ideas, you can write more elegant code.
In this case, we took five lines of Python and reduced them to one line
of OCaml.</p>
<p>I can’t leave this without also mentioning that you can write this code
in a functional style in Python as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">double_list</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span> <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">lst</span><span class="p">))</span>
</pre></div>
</div>
<p>It’s not <em>quite</em> as simple as the OCaml code, but it’s pretty close. <a class="footnote-reference brackets" href="#id10" id="id5">4</a>
(On the other hand, the OCaml code is type checked,
but the Python code isn’t.)</p>
<p>So Python supports some (but not all) ideas from functional programming. <a class="footnote-reference brackets" href="#id11" id="id6">5</a>
But a lot of Python programmers are unaware of this.
So at least one benefit of learning functional programming is that
you’ll be able to use some of the functional programming ideas you learn
in the languages you already know!  In fact, it may totally change the way
you write code even in non-functional languages.  And the new code you write
will be shorter and more elegant than the code you used to write.</p>
<p>This is just a very simple example.  CS 4 will show you many more
kinds of beautiful code, and (more importantly) will teach you how to think
about computational processes at a higher level, which will make the code
you write better no matter what language you use.</p>
</div>
<div class="section" id="is-functional-programming-better-than-other-kinds-of-programming">
<h2>Is functional programming better than other kinds of programming?<a class="headerlink" href="#is-functional-programming-better-than-other-kinds-of-programming" title="Permalink to this heading"></a></h2>
<p>It depends on the application.</p>
<p>We love functional programming, but we are not zealots.  Functional programming
is a great fit for a lot of different programming tasks, but it isn’t right
for everything.  Furthermore, language choice is usually much more likely to be
made because of the availability of libraries than for any intrinsic quality of
the language.</p>
<p>For instance, if you are programming graphical user interfaces (GUIs),
you would probably be better off using Java than OCaml,
because Java has more and better GUI libraries than OCaml does,
and object-oriented programming has proven to be a good fit for this task.  Or
if you are doing numerical computations for machine learning or data science,
you might be better off using Python with NumPy and Pandas, because those
libraries are better suited for those tasks than anything in OCaml (that we
know of).</p>
<p>On the other hand, if you’re doing anything that involves very complex
algorithms, symbolic manipulations, or are writing a compiler (like you’ll do
if you take CS 164), functional programming and OCaml are a great fit.
It takes time to learn which kinds of problems are best suited to which
languages, but having a functional language in your toolkit is a good idea,
not least because other languages (even Java!) keep borrowing ideas
from functional languages.</p>
</div>
<div class="section" id="why-are-we-using-ocaml">
<h2>Why are we using OCaml?<a class="headerlink" href="#why-are-we-using-ocaml" title="Permalink to this heading"></a></h2>
<p>There are a number of languages that are usually considered to be “functional
programming languages”.  Why are we choosing to use OCaml instead of another
one (say, Haskell)?</p>
<p>There are three reasons for this:</p>
<ol class="arabic simple">
<li><p>OCaml contains all the features one would expect to have in a full-fledged
functional programming language.</p></li>
<li><p>OCaml is easier to learn than many other functional languages.  In
particular, it’s easier to learn than Haskell. (But after learning OCaml,
Haskell is a lot easier to learn; take CS 115 if you’re interested in
Haskell.)</p></li>
<li><p><strong>OCaml is not dogmatic.</strong> In addition to its functional features,
OCaml also fully supports imperative and object-oriented programming,
and sometimes, those features are exactly what you need to write the
best code.</p></li>
</ol>
<p>In addition to being a great on-ramp to the world of functional programming,
OCaml is a useful language in its own right, and is used as a production
language in a number of companies, including <a class="reference external" href="https://www.janestreet.com/">Jane Street Capital</a>,
<a class="reference external" href="https://www.bloomberg.com/">Bloomberg</a>, and <a class="reference external" href="https://facebook.com/">Facebook</a>.</p>
</div>
<div class="section" id="going-further">
<h2>Going further<a class="headerlink" href="#going-further" title="Permalink to this heading"></a></h2>
<p>If you want to go deeper into the world of functional programming after taking
this course, take CS 115 and you’ll learn <a class="reference external" href="https://www.haskell.org/">Haskell</a> and how it differs from (and
in some ways extends) the ideas you’ll learn in CS 4.  In some ways, Haskell is
a “super-OCaml” which pushes functional programming ideas to their limit.  In
other ways (notably the module system and its multi-paradigm nature) OCaml
still has the edge.</p>
<p>Recently, the <a class="reference external" href="https://www.rustlang.org/">Rust</a> programming language has become quite popular.
Rust is a systems-level language which does not use garbage collection
and which is used for computationally-intensive tasks.  The Rust compiler
was originally written in OCaml, but more interesting to us is that
the Rust language has borrowed many features from OCaml, including
algebraic datatypes, pattern matching and an emphasis on immutable data.
If you want to learn Rust, learning OCaml is an excellent starting point.
In fact, Rust is basically as close to a functional language as you can get
without having garbage collection.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a CS 11 Rust track which is taught in the Winter term,
so take that if you are interested in Rust.</p>
</div>
<p>In addition to Rust, there are other languages that are even closer to
OCaml, including <a class="reference external" href="https://fsharp.org/">F#</a>,
which is a language very similar to OCaml for the .NET platform,
and <a class="reference external" href="https://rescript-lang.org/">ReScript</a> and <a class="reference external" href="https://reasonml.github.io/">ReasonML</a>,
which are OCaml dialects which compile to Javascript.
All of these languages are used for very practical purposes
(including web development), so they aren’t just academic languages.
And there are many other functional languages that share features
with OCaml, including Lisp dialects (Common Lisp, Scheme, <a class="reference external" href="https://racket-lang.org">Racket</a>, and
<a class="reference external" href="https://clojure.org">Clojure</a>), Erlang dialects (<a class="reference external" href="https://erlang.org">Erlang</a> itself and <a class="reference external" href="https://elixir-lang.org">Elixir</a>), and many others.
Learning OCaml will make it much easier to learn any of these languages.</p>
<hr class="docutils" />
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>That is, except for the substitution model evaluations.
Those aren’t much fun, but we think that they’re worth doing – once.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>At least, they exist in OCaml.  In Haskell, they kind-of exist,
but the story is more complicated.  Take CS 115 to learn all about
Haskell.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>However, to the best of our knowledge, God was not directly
involved in the preparation of the book.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>You can make the Python code even shorter using list comprehensions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">double_list</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
</pre></div>
</div>
<p>OCaml doesn’t have list comprehensions, though other functional languages
(like Haskell) do.  In fact, Python borrowed the idea of list comprehensions
from Haskell.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p>One idea from functional programming is <em>tail call optimization</em>,
which we’ll be learning about.  People have been begging Guido van Rossum
to add tail call optimization to Python for a long time,
but so far he has vetoed it.</p>
</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="admin/Collaboration_policies.html" class="btn btn-neutral float-left" title="Collaboration policies" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="History.html" class="btn btn-neutral float-right" title="History" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Michael C. Vanier. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>