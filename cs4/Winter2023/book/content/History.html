<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>History &mdash; The CS 4 book 0.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Assignments" href="assignments/index.html" />
    <link rel="prev" title="Motivation" href="Motivation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> The CS 4 book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="admin/index.html">Administrative information</a></li>
<li class="toctree-l1"><a class="reference internal" href="Motivation.html">Motivation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-brief-history-of-functional-programming">A brief history of functional programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-brief-history-of-ocaml">A brief history of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-brief-history-of-cs-4">A brief history of CS 4</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="assignments/index.html">Assignments</a></li>
<li class="toctree-l1"><a class="reference internal" href="readings/index.html">Readings</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The CS 4 book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">History</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="history">
<span id="id1"></span><h1>History<a class="headerlink" href="#history" title="Permalink to this heading"></a></h1>
<p>The history of functional programming, OCaml, and this course is described
here.  You aren’t required to know any of this, but I think the history
is quite interesting (and convoluted), so if you’re curious and have a few
minutes to spare, read on!</p>
<section id="a-brief-history-of-functional-programming">
<h2>A brief history of functional programming<a class="headerlink" href="#a-brief-history-of-functional-programming" title="Permalink to this heading"></a></h2>
<p>The ideas which eventually turned into functional programming
date back to the 1920s and 1930s,
when many people were working on the foundations of mathematics and computation.
<a class="reference external" href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">Moses Schönfinkel</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>
(see also <a class="reference external" href="https://wiki.haskell.org/Haskell_Brooks_Curry">here</a>)
developed combinatory logic,
which (despite the name) is a model of computation
that uses very simple functions called <em>combinators</em>
which can be combined to create a full programming language. <a class="footnote-reference brackets" href="#id8" id="id2">1</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a> developed the <a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>,
which can be viewed as the simplest possible programming language
and also as the simplest functional programming language. <a class="footnote-reference brackets" href="#id9" id="id3">2</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Fun fact</strong>: Alan Turing was Alonzo Church’s Ph.D. student.
Both lambda calculus and Turing machines can express
arbitrary computations, which is known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a>.
Nevertheless, Turing’s formulation of the process of computation
is much better known, which is why you learn about Turing machines
in CS 21 instead of lambda calculus.</p>
</div>
<p>Both Church and Curry continued to develop their systems.  In particular,
Church extended lambda calculus (now called “untyped lambda calculus”)
into a typed version which is the ultimate predecessor of all typed
functional programming languages, including OCaml.</p>
<p>The systems of Church and Curry were purely formal systems,
since there were no computers at the time.
Once computers were developed in the 1940s and 1950s,
there was interest in using them for symbolic manipulation tasks
(as opposed to numerical computations,
which was what computers were mainly used for at the time).
One of the pioneers of this was <a class="reference external" href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a>,
who developed the <a class="reference external" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> programming language starting around 1958.
This language had an extremely simple syntax called “S-expressions”,
which are basically just lists of symbols surrounded by parentheses.
More importantly for us, Lisp was the first computer language
that had both recursion and anonymous functions
(known as “lambda expressions” in Lisp).
Therefore, Lisp can be considered to be the first real
functional programming language.
Lisp was used primarily for artificial intelligence applications
for many decades, and is still used for this.
Lisp spawned a number of variants, including Common Lisp and Scheme,
both of which are still in use today.
Later, many other functional programming languages, including
OCaml and Haskell, were developed.  These languages were notable
for introducing static type checking to functional programming,
as well as many other features.</p>
</section>
<section id="a-brief-history-of-ocaml">
<h2>A brief history of OCaml<a class="headerlink" href="#a-brief-history-of-ocaml" title="Permalink to this heading"></a></h2>
<p>One of the applications that early artificial intelligence researchers were
interested in was using computers to prove mathematical theorems. The original
work on this topic concentrated on fully-automatic theorem proving programs.
However, the large number of choices at any point in a proof made this
intractable except for proofs in very narrow domains.  Then interest shifted to
“proof assistants”, which are programs where a human user guides the computer
to a proof using “tactics”, which automate routine steps. One of the earlier
proof assistants (though not the earliest) was called <a class="reference external" href="https://en.wikipedia.org/wiki/Logic_for_Computable_Functions">LCF</a>, which stood for
“logic for computable functions”.  It was developed first at Stanford and then
at the University of Edinburgh by <a class="reference external" href="https://en.wikipedia.org/wiki/Robin_Milner">Robin Milner</a> and his collaborators in the
early 1970s.  Early versions of LCF used Lisp as the “meta-language” in which
proof tactics could be written.  However, the proof assistant would sometimes
derive incorrect proofs, so the implementors invented a “typed Lisp” which they
called “ML” for “Meta-Language” which contained a type checker that wouldn’t
permit the generation of incorrect proofs. <a class="footnote-reference brackets" href="#id10" id="id4">3</a>
They then implemented LCF in ML.
ML was originally implemented as an interpreter written in Lisp,
but standalone compiled implementations were soon developed.
Along the way, it was eventually realized that ML was a
full-fledged programming language that could be used for any kind of
application, not just as the implementation language for proof assistants.</p>
<p>Interest in proof assistants spread to INRIA in France in the 1980s,
where an ML dialect called “CAML” <a class="footnote-reference brackets" href="#id11" id="id5">4</a> was developed
by Gerard Huet, Xavier Leroy, and others.
CAML went through a number of versions,
including “Caml light” and finally “Objective Caml”, also known as “OCaml”,
which appeared in 1996.
OCaml included object-oriented features, making it a multi-paradigm
language (functional, imperative, and object-oriented), though it is mainly
used as a functional language.  In parallel with the development of Caml
dialects, the proof assistant <a class="reference external" href="https://coq.inria.fr/">Coq</a> was developed at INRIA, and one of the main
motivations for the development of OCaml at INRIA was to serve as the
implementation language for Coq.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are interested in proof assistants, you should take
CS 128, which is a course on interactive theorem proving using Coq.</p>
</div>
<p>OCaml is currently an extremely popular language in computer science
education, especially for courses on functional programming and compilers.
OCaml has also spread beyond academia, and is now used
a lot in financial institutions such as <a class="reference external" href="https://www.janestreet.com/">Jane Street Capital</a>,
who have also been very active in improving the OCaml infrastructure.
OCaml has also been used for compiler development by many groups,
including Facebook (the <a class="reference external" href="https://hacklang.org/">Hack</a> language) and the <a class="reference external" href="https://www.rustlang.org/">Rust</a> developers;
both the Hack and Rust compilers were originally written in OCaml.
Other industrial users of OCaml are listed on <a class="reference external" href="https://ocaml.org/industrial-users">this page</a>.
While the core language of OCaml is extremely stable,
OCaml is still under heavy development; version 5.0 of the language
has just been released, containing new support for <a class="reference external" href="https://v2.ocaml.org/releases/5.0/manual/parallelism.html">parallel programming</a>
and an innovative <a class="reference external" href="https://v2.ocaml.org/releases/5.0/manual/effects.html">effect handling system</a>.</p>
</section>
<section id="a-brief-history-of-cs-4">
<h2>A brief history of CS 4<a class="headerlink" href="#a-brief-history-of-cs-4" title="Permalink to this heading"></a></h2>
<p>In the early 2000s, Andre Dehon took over the Caltech CS 1 course and based it
on the MIT 6.001 course, which used <a class="reference external" href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-4.html">SICP</a> as the textbook and Scheme (a Lisp
dialect) as the programming language.  Mike Vanier took over this course after
a few years, first with Ben Brantley co-teaching, then by himself.  This
version of CS 1 was never broadly popular; though some students liked it a lot,
most felt that it was too difficult and abstract for a course aimed at
freshmen, many of whom had little programming experience.  In 2009, CS 1 was
completely overhauled (by Mike) to use Python as its programming language.
Mike still wanted to keep teaching the old CS 1 material, though,
so CS 4 was created.
Originally, CS 4 still used Scheme as the language and <a class="reference external" href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-4.html">SICP</a> as the textbook,
but more advanced material was soon incorporated. <a class="footnote-reference brackets" href="#id12" id="id6">5</a>
After a few years, Mike got tired of using Scheme because he
found it difficult to debug due to the syntax, the lack of type checking, and the
unstructured kind of object-oriented programming that is used in many parts of
<a class="reference external" href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-4.html">SICP</a>.  Mike had been programming a lot in OCaml and Haskell at that time, and
had already been giving a couple of lectures introducing OCaml at the end of
the course. In 2016, Mike switched the entire course over to OCaml.
Fortunately, most of the SICP exercises used in the course were not
Scheme-specific and worked fine in OCaml. <a class="footnote-reference brackets" href="#id13" id="id7">6</a>  Unexpectedly, switching to
OCaml had the effect of raising the average grade significantly.  We think this
is because the OCaml type checker tends to refuse to pass code until it is
either correct or much closer to correct than would be the case in a
dynamically-typed language like Scheme. Since then, the course has evolved
steadily to incorporate new material and refine old material.</p>
<hr class="docutils" />
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>The Haskell functional programming language is named after Haskell Curry.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>This depends on what your definition of “simple” is.  In some ways,
the combinatory logic systems of Schönfinkel and Curry are simpler than
lambda calculus.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>The use of the acronym “ML” to mean “Machine Learning” is a much more
recent development.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>The name “CAML” originally meant “Categorical Abstract Machine
Language”, which means something in the context of the original
implementation.  However, that implementation was replaced by a different
one, so the name “CAML” survives for historical reasons only.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p>Such as the Y Combinator lecture, which is Mike’s favorite lecture.</p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id7">6</a></span></dt>
<dd><p>In fact, many were significantly improved in OCaml due to OCaml’s
better facilities for type definition.</p>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Motivation.html" class="btn btn-neutral float-left" title="Motivation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="assignments/index.html" class="btn btn-neutral float-right" title="Assignments" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Michael C. Vanier. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>