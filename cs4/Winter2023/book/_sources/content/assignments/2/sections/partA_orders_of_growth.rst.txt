Part A: Orders of growth
========================

This section will feature problems relating to estimating
time and space complexity in OCaml functions.
As usual, write essay-type answers as OCaml comments.


1. Fibonacci again
------------------

[**1**] (20 minutes)

Consider the tree-recursive fibonacci function discussed in class:

.. code-block:: ocaml

   let rec fib n =
     if n < 2
        then n
        else fib (n - 1) + fib (n - 2)

You know that the time complexity for this function is :math:`{O(2^n)}`.

.. note::

   More specifically, it is :math:`{\Theta(g^n)}`,
   where :math:`g` is the golden ratio (:math:`1.618...`).
   See :sicp_sect_11:`1.2.2` and :sicp_11:`1.13` for more on this.

If we assume that OCaml is using applicative-order evaluation
(the normal OCaml evaluation rule),
then what is its *space* complexity?
Explain why this is different from the time complexity.

*Hint:* consider what the largest number of pending
operations would have to be when evaluating ``fib 7``. You may assume
that once an expression is fully evaluated, all the memory used in
evaluating that expression is returned to the system.

.. note::

   You are not required to state what the effect of normal-order
   evaluation is on the space requirements of the ``fib`` function,
   though it is interesting! |smile|


2. :sicp_11:`1.15`
------------------

[**1.5**] (30 minutes)

The sine of an angle (specified in radians) can be computed by making
use of the approximation:

.. math::

   sin\ x = x

(if :math:`x` is "sufficiently small"),
and the trigonometric identity:

.. math::

   sin\ x = 3 \ sin(x / 3) - 4 \ sin^3(x/3)

to reduce the size of the argument of :math:`sin`
if :math:`x` is *not* sufficiently small.
For purposes of this exercise an angle is considered "sufficiently small" if
its magnitude is less than 0.1 radians.

These ideas are incorporated in the following functions (using
floating-point arithmetic throughout):

.. code-block:: ocaml

   let cube x = x *. x *. x
   let p x = 3.0 *. x -. 4.0 *. cube x
   let rec sine angle =
     if abs_float angle < 0.1
        then angle
        else p (sine (angle /. 3.0))

#. How many times is the function ``p`` applied when ``sine 12.15`` is
   evaluated?

#. What is the order of growth in space and number of steps
   used by the process generated by the ``sine`` function
   when ``sine a`` is evaluated (as a function of ``a``)?

By "growth in number of steps",
we mean the asymptotic time complexity of the ``sine`` function
as a function of the size of the input.
Explain the reason for the space/time complexities;
don’t just state an answer.


3. :sicp_11:`1.16`
------------------

[**1.5**] (30 minutes)

SICP describes a non-iterative function called ``fast_expt`` that does
exponentiation using successive squaring (when possible). Translated
into OCaml, that function looks like this:

.. code-block:: ocaml

   let rec fast_expt b n =
     let is_even m = m mod 2 = 0 in
     let square m = m * m in
       if n = 0 then 1
       else if is_even n then square (fast_expt b (n / 2))
       else b * fast_expt b (n - 1)

Note that ``mod`` is a predefined infix operator in OCaml (not a
function!) which computes remainders; you use it like this: ``5 mod 2``
(which will return ``1``).

a.
^^

This function uses nested ``if``/``then``/``else`` forms, which are a
bit ugly and error-prone (since OCaml doesn’t actually have an
``else if`` syntax). Rewrite the function using pattern matching on the
``n`` argument (a ``match`` expression); use ``when`` clauses in pattern
matches when you need to test for non-structural conditions (and *only*
then). Your function should not have any ``if`` expressions.

Here is a skeleton version of the function you should write:

.. code-block:: ocaml

   let rec fast_expt b n =
     let is_even m = m mod 2 = 0 in
     let square m = m * m in
       match n with
         (* fill in the rest here *)

|NB| the "wildcard" pattern ``_`` may be useful to you.
Any compiler warnings will be considered to be errors.


b.
^^

Write a function called ``ifast_expt`` that evolves an *iterative*
exponentiation process that uses successive squaring and uses a
logarithmic number of steps.

*Hint*: Using the observation that :math:`b^n = (b^{n/2})^2 = (b^2)^{n/2}`,
keep, along with the exponent :math:`n` and the base :math:`b`,
an additional state variable :math:`a`,
and define the state transformation in such a way
that the product :math:`a b^n` is unchanged from state to state.
At the beginning of the process :math:`a` is taken to be 1,
and the answer is given by the value of :math:`a` at the end of the process.
In general, the technique of defining an *invariant quantity*
that remains unchanged from state to state
is a powerful way to think about the design of iterative algorithms.

Use integer arithmetic for this problem. You may assume that all the
(integer) arguments to your function are non-negative.

You will need some helper functions in the implementation of your
``ifast_expt`` function. You should make these internal to your
``ifast_expt`` function, as was done with the ``fast_expt`` function
above. One of these will need to be recursive; call it ``iter``. Only
use ``let rec`` with that function; use ``let`` for all other internal
definitions and for the ``ifast_expr`` function as a whole.

Use pattern matching instead of nested ``if``/``then``/``else`` forms as
you did for the ``fast_expt`` function.


4. :sicp_11:`1.17`
------------------

[**1.5**] (15 minutes)

The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. The simplest such
function is this:

.. code-block:: ocaml

   let rec expt a b =
     if b = 0
        then 1
        else a * expt a (b - 1)

In a similar way, one can perform integer multiplication by means of
repeated addition. The following multiplication function (in which it is
assumed that our language can only add, not multiply), is analogous to
the ``expt`` function:

.. code-block:: ocaml

   let rec mult a b =
     if b = 0
        then 0
        else a + mult a (b - 1)

This algorithm takes a number of steps that is linear in ``b``. Now
suppose we include, together with addition, the operations ``double``,
which doubles an integer, and ``halve``, which divides an (even) integer
by 2. Using these, design a multiplication function analogous to
``fast_expt`` that uses a logarithmic number of steps.

.. note::

   Don't do any multiplications or divisions except by using
   ``double`` or ``halve``.  You can also use addition,
   subtraction, and the ``mod`` operator to test for evenness.

Use integer arithmetic for this problem. The multiplication function you
write should generate a recursive process.

For this problem, write all helper functions (including ``double`` and
``halve``) inside the ``fast_mult`` function, and again use pattern
matching on the ``n`` argument instead of nested
``if``/``then``/``else`` expressions.


5. :sicp_11:`1.18`
------------------

[**1.5**] (15 minutes)

Using the results of the previous exercises, devise a function called
``ifast_mult`` that generates an iterative process for multiplying two
integers in terms of adding, doubling, and halving and uses a
logarithmic number of steps.

This multiplication function should generate an iterative process.
If you are multiplying integer :math:`b` by integer :math:`n`,
you will need another state variable :math:`a`
such that the invariant is :math:`a + bn`,
and :math:`n` will decrease to zero,
at which point :math:`a` will be the answer.

Again, use pattern matching instead of nested ``if``/``then``/``else``
expressions. And again, only use ``let rec`` where it’s absolutely
necessary.


6. A mysterious function
------------------------

[**1.5**] (30 minutes)

Consider the following (higher-order) function:

.. code-block:: ocaml

   let rec foo f n =
     if n <= 1
        then f 0
        else foo f (n / 2) + foo f (n / 2)

Note that function calls have the highest precedence in OCaml, so the
last expression is the same as ``(foo f (n / 2)) + (foo f (n / 2))``.

If we assume that the function ``f`` can compute its result in constant
time and constant space, what are the (worst-case) time and space
complexities of the function ``foo``? Justify your answer. (It doesn’t
have to be a full mathematical proof, but it should be a convincing
argument.) Assume that the integer input ``n`` is always non-negative,
and assume the usual applicative-order evaluation rule.


7. Fibonacci yet again
----------------------

[**1.5**] (15 minutes)

Consider this function to compute fibonacci numbers:

.. code-block:: ocaml

   let fib n =
     let rec last_two n =
       if n < 1
         then (0, 1)
         else
           let (p0, p1) = last_two (n - 1) in
             (p1, p0 + p1)
     in
       fst (last_two n)

A couple of OCaml notes:

* It’s legal to assign more than one value at a time in a ``let``
  expression as shown above. Effectively you are doing a pattern match
  that cannot fail.

* ``fst`` is a function which extracts the first value of a two-tuple.

Please answer the following two questions in OCaml comments:

#. What kind of process does this function represent (linear recursive,
   linear iterative, tree recursive |etc|) and why?

#. What is the space and time complexity of this function with respect
   to its argument ``n``?

