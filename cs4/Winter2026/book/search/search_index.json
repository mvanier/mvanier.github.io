{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The CS 4 book: Winter 2026","text":"<p>This book is the official document repository for the Caltech CS 4 course  (Fundamentals of Computer Programming) for the Winter 2026 term.</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p> <p>Please read this page for an overview of the course.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 4 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>You are welcome to collaborate informally on your assignments (but not on exams!) with other individuals who are taking the course, but you must write all of your own code and you must not look at other students' code, except to help them as described below. Copying another student's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another student's file and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another student's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone dictate code while you type isn't acceptable either. Basically, you have to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine.</p> <p>All of the above also applies if you are getting tutored for the course, officially or unofficially.</p> <p>All of the above also applies to student work from previous years. We re-use some problems in assignments, and copying answers from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a student who is currently taking the course.</p>"},{"location":"admin/collab/#in-class-exercises","title":"In-class exercises","text":"<p>Some lectures will feature in-class exercises (programming problems that will be solved during the lecture by students). These exercises will also be on the assignments. While in the lecture where the exercise is presented, students may collaborate with other students as well as take notes on the solution given by the instructor (if there is one). However, on the assignment, these in-class exercise problems are no collaboration; you are only allowed to consult notes that you personally took during the lecture where the exercise was done.</p> <p>Note</p> <p>If you did not attend the lecture where a particular in-class exercise was presented, you must do the problem without any additional help (no collaboration). (Among other objectives, in-class exercises are an incentive for you to come to lectures.)</p> <p>Note that if you missed a lecture, you may not get notes on an in-class exercise from other students at any time, including in a subsequent lecture.</p> <p>If you attended a lecture where an in-class exercise was presented, but didn't take notes, you may not borrow the notes from another student, whether you collaborated with them in class or not.</p> <p>You are also not allowed to ask for help from the TAs or instructor on in-class exercises after the class in which they were presented (for instance, during office hours), unless you are working on a rework of an assignment containing in-class exercises, in which case you can ask for help from TAs or the instructor only. (You can't ask for help from other students.)</p>"},{"location":"admin/collab/#exams-midterm-final","title":"Exams (midterm, final)","text":"<p>Exams are strictly no-collaboration under all circumstances. The only exception is that you can ask the instructor (Mike) for clarification on anything in the exam that is confusing (for example, when you don't know exactly what a problem is asking you to do). Don't ask a teaching assistant; clarifying exam questions is not their responsibility.</p>"},{"location":"admin/collab/#helping-others-and-the-50-foot-rule","title":"Helping others and the \"50-foot rule\"","text":"<p>It is common for students to want to help other students to write and debug their assignments. While we prefer that you go to one of the course teaching assistants when you need help on the assignments (it doesn't matter which one), we don't forbid you from seeking help from other students or offering your help to other students. However, we do insist on some guidelines to make the process fair for everyone.</p> <p>When you are helping another student with their homework, you are acting as an unofficial teaching assistant, and thus you must behave like one. A teaching assistant will not just tell you the answer or dictate code to you; they will help you work through the problem so that you understand what you are doing wrong. If you don't have the time or the inclination to do this, do not assist other students. If you just give them your code, you are violating the Honor Code and both you and the people you are giving the code to may be in for some serious consequences.</p> <p>As a way of clarifying the way in which you can help other students (especially when it comes to debugging their code), we want you to obey the \"50 foot rule\". This rule states that if you help another student with their programming problems (including debugging), you must not consult your own code while doing so. Specifically, we ask that your own code be at least 50 feet away i.e. not visible to you or the person you are helping while you are helping them. (It doesn't have to be exactly 50 feet; the point is that you can't see your code while helping the other person and you shouldn't run back and forth between your computer with your code and the computer of the person you're helping.) The slogan of the 50-foot rule is: \"Help them with your brain, not with your code.\" Please do not try to find a loophole kind of way around this e.g. projecting your code on a building 50 feet away; that is clearly not what we mean. Posting your code on a pastebin-like internet site, emailing your code to other people, sharing your screen with your code on it, printing it out, or even referring to it on your laptop while helping someone else, are all clear violations of the collaboration policy for this course. Also, we don't want you to put your code up on a computer in a room 50 feet away from where you're helping someone and run back and forth, dictating a line at a time. If you can't help them without consulting your code, don't help them. Refer them to a teaching assistant.</p> <p>Note</p> <p>The 50-foot rule only applies when helping another student in person.</p> <p>Helping another student using teleconferencing software like Zoom, Skype, Discord etc. is covered below, but one aspect of it is that screen sharing is not permitted.</p> <p>We realize that it's more convenient to ask someone in your house for help than to walk all the way to the Annenberg building. A possible solution is to get to know a TA and meet with them in their dorm room (if they are willing). Another possibility is to meet with a TA on Zoom (if they are OK with this).</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord with VOIP), you may not share your screen with other students, whether to help them or to get help from them. This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software. This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs. If this happens you may lose the ability to use the discussion board for any purpose.</p> <p>This also applies to programs with chat features that are not used in the course (like Slack or Discord), or email for that matter.</p>"},{"location":"admin/collab/#use-of-websites","title":"Use of websites","text":"<p>It is strictly forbidden to post any of the problems from the assignments onto websites (for instance, Stack Overflow), and anyone caught doing this will be charged with an Honor Code violation. This includes problems that are similar to assignment problems even if not identical. If you find a discussion of course-related material on internet websites, you may read it as long as the discussion is not about a problem that is identical to or very similar to a problem on one of the course assignments. However, do not transcribe code from the internet into your homework submissions.</p> <p>It is strictly forbidden to look at any solutions to any previous years' CS4 work posted on internet code repository sites (including but not limited to GitHub, GitLab, BitBucket, etc.). It is also strictly forbidden to put your own code on such a repository unless (a) it is a private repository, and (b) you do not allow anyone else access to this private repository. You may also not fork any such repositories that you might happen to find; we will consider this prima facie evidence of intent to plagiarize.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-eg-github-copilot-chatgpt","title":"Use of code hinting software (e.g. Github Copilot, ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. (This should be obvious.)</p> <p>AI tools are enabled by default in the Visual Studio Code text editor, which is a very popular editor. You can use this editor in this course only if you disable all the AI features. Instructions on how to do this are included in the instructions for setting up the course software (assignment 0).</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments and exams.</p> Item Status Course book OK Course textbook OK Official OCaml documentation OK Other OCaml documentation OK Other OCaml books OK Your notes OK Notes of other students Not allowed Your graded assignments OK Other students' graded assignments Not allowed Other students' ungraded assignments Not allowed Other code written by anyone else that answers an assigned problem Not allowed Solutions to assignment/exam problems from a previous year Not allowed Material posted on internet forums that answers specific problems Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor (Mike). Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the course syllabus for CS 4 (Fundamentals of Computer Programming) for the Winter 2026 term.</p>"},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor/lecturer for the course is Mike Vanier (mvanier@cms.caltech.edu). Mike's pronouns are he/him. Mike's office is in Annenberg 110.</p> <p> </p> Mike"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held in Beckman Institute Auditorium (Beckman Institute, room 134) on Mondays, Wednesdays, and Fridays from 3 PM to 4 PM.</p>"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for the course. Contact information for teaching assistants will be posted on the course Canvas page. Office hours for teaching assistants will be posted on the course Piazza page.</p> <ul> <li> <p>Eric Lee (he/him) (head TA) Eric </p> </li> <li> <p>Li Yu Chu (he/him)      Li Yu </p> </li> <li> <p>Mia Mutadich (she/her)      Mia </p> </li> <li> <p>Thanhthanh Nguyen (she/her)      Thanhthanh </p> </li> <li> <p>Ashlyn Roice (she/her)      Ashlyn </p> </li> <li> <p>Pratyush Singh      Pratyush </p> </li> <li> <p>Tami Soyebo (she/her)      Tami </p> </li> <li> <p>Tom Zhang (he/him)      Tom </p> </li> </ul>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Times and locations of office hours for teaching assistants and the instructor will be posted on the course Piazza page (see below).</p> <p>TA office hours are normally held in-person, but may be held on Zoom in certain situations.</p> <p>The instructor (Mike) will hold office hours on Zoom.</p>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>From the Caltech catalog entry for CS 4:</p>  This course gives students the conceptual background necessary to construct and analyze programs, which includes specifying computations, understanding evaluation models, and using major programming language constructs (functions and procedures, conditionals, recursion and looping, scoping and environments, compound data, side effects, higher-order functions and functional programming, and object-oriented programming). It emphasizes key issues that arise in programming and in computation in general, including time and space complexity, choice of data representation, and abstraction management. This course is intended for students with some programming background who want a deeper understanding of the conceptual issues involved in computer programming. Prerequisites: CS 1 or instructor's permission.  <p>A longer (and arguably more accurate) description of the course is given in the Motivation page of this book.</p>"},{"location":"admin/syllabus/#recommended-textbooks","title":"Recommended textbooks","text":"<p>There are two recommended textbooks, both available online in their entirety:</p> <ul> <li> <p>Structure and Interpretation of Computer Programs,   (usually referred to as \"SICP\", and pronounced \"sick pea\"),   by Hal Abelson, Gerry Sussman, and Julie Sussman</p> </li> <li> <p>Real World OCaml, also known as \"RWO\",   by Yaron Minsky and Anil Madhavapeddy</p> </li> </ul> <p>Both books are excellent (and we thank their authors for providing them for free online!), but neither is a perfect match for CS 4. The conceptual basis of CS 4 largely derives from SICP, but SICP uses Scheme, not OCaml, as its programming language. RWO is a more recent book which has excellent coverage of OCaml, but uses the <code>Base</code> and <code>Core</code> libraries throughout, which we will not use. Nevertheless, both books are good references for the material covered in this course.</p>"},{"location":"admin/syllabus/#additional-reference-material","title":"Additional reference material","text":"<p>You should definitely bookmark the OCaml manual. Even though this is not the easiest way to learn OCaml, the manual has complete coverage of the language, including obscure topics and language extensions. More important for day-to-day programming are the chapters on the core library and (especially) the standard library, which contains links to the <code>List</code> library, the <code>Array</code> library, and so on. You should have these close by whenever writing any moderately complicated OCaml program.</p> <p>Another great resource is the online textbook for the Cornell CS 3110 course, OCaml Programming: Correct + Efficient + Beautiful, most of which was written by Michael Clarkson. This book contains a lot of excellent explanatory material on OCaml programming, and goes over the material at a slower pace than the manual. It also includes videos!</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There will be a Piazza site, which you will be enrolled in if you are registered for this course.</p> <p>For homework submission and grading, we will use GradeScope. GradeScope will be accessible from the course Canvas page.</p>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>There will be 7 assignments, one midterm exam, and one final exam. Grades will be calculated as follows:</p> Item Points Assignments (7 x 10 points each) 70 Midterm exam 20 Final exam 30 Total 120 <p>The total out of 120 will be rescaled to give an actual grade out of 100%. Letter grades will be assigned as follows:</p> Numerical grade (out of 100%) Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 65-70% C+ 62-65% C 60-62% C- 58-60% D+ 55-58% D &lt; 55% F"},{"location":"admin/syllabus/#grading-individual-assignments","title":"Grading individual assignments","text":"<p>On GradeScope, assignments will be graded out of 100. Each assignment will be divided into sections. On GradeScope, each section will get a certain number of points (not necessarily the same for each section). The actual grade of the assignment is the sum of all the section grades. The GradeScope grade will be divided by 10 to get the actual recorded grade.</p> <p>Note</p> <p>We refer to the numerical grade on GradeScope (out of 100) as the \"GradeScope grade\". We divide the GradeScope grade by 10 to get the actual grade. Similarly, marks on GradeScope are called \"GradeScope points\", in contrast to actual marks. So 10 GradeScope points is 1 actual mark.</p>"},{"location":"admin/syllabus/#redoing-assignments","title":"Redoing assignments","text":"<p>After you receive your initial grade on an assignment, you have one week to submit a redo. Redos will be submitted as a separate GradeScope assignment called <code>Assignment N (rework)</code> (for assignment <code>N</code>). Late redos (received after the 1-week redo window) will not be graded and your previous grade will stand. You may not submit more than one redo per assignment.</p>"},{"location":"admin/syllabus/#late-policy-for-assignments","title":"Late policy for assignments","text":""},{"location":"admin/syllabus/#late-days","title":"Late days","text":"<p>Each student gets 10 \"late days\" for the entire term. Each late day allows you to submit an assignment one day late. You are allowed to use more than one late day on an assignment if you need to.</p> <p>In order to use late days, you must specify on the assignment when you submit it:</p> <ul> <li>how many late days you have used for the assignment,</li> <li>how many late days you have used up for the entire term.</li> </ul> <p>Please write this in an OCaml comment in (one of) your submitted files.</p> <p>Once you have used up all of your late days, you can't use them any more.</p> <p>If you don't specify any late days in your assignment submission, we will assume that you are not using any for the assignment.</p> <p>You are never required to use late days, even if you submit an assignment late, but if you do submit an assignment late and don't use late days, you will receive late penalties.</p> <p>Restrictions on late days</p> <p>There are three restrictions on the use of late days:</p> <ol> <li> <p>To keep you from using up all of your late days on a single assignment,     you cannot use more than 3 late days on any single assignment.</p> </li> <li> <p>You cannot use late days on redos.     As specified above, a redo which is late is not graded.</p> </li> <li> <p>You cannot use late days on exams (midterm or final).</p> </li> </ol>"},{"location":"admin/syllabus/#late-penalties","title":"Late penalties","text":"<p>For each day an assignment is submitted late and which isn't covered by a late day, you will receive a penalty of 25% per day late (25 GradeScope points or 2.5 marks). These marks can't be regained through rework.</p> <p>If a rework is late (i.e. is submitted more than one week after the original grade was submitted), it doesn't count, and the previous grade stands.</p> <p>Note</p> <p>If an assignment is submitted on time, but is missing one or more sections, you will not receive late penalties, but missing sections will be graded as a 0. The assignment can be reworked, of course, but assuming the sections that were missing on the initial submission are submitted with the rework, there is no additional rework for these sections. This means (for instance) if you don't submit a section on the initial submission, but do submit it in the rework, the grade of that section in the rework is final \u2013 you don't get to rework it just because you hadn't submitted it before. So please don't leave out sections!</p> <p>Students may request extensions for assignments due to unusual circumstances. These extensions have to be approved by the course instructor (Mike). However, we expect that most routine extensions can be handled by late days, so please reserve the \"unusual circumstances\" request for more serious issues e.g. health issues or personal crises (which we sincerely hope you don't have!).</p>"},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Friday at 2 AM unless otherwise indicated. Note that a due time of 2 AM means early that morning, so effectively it means very late the previous evening.</p>"},{"location":"admin/syllabus/#attendance-and-participation","title":"Attendance and participation","text":"<p>Attendance and participation currently do not count towards the final grade. However, we strive to make lectures interactive and do a lot of live coding during lectures. Missing out on this will deprive you of many of the benefits of the course (as well as a lot of the fun!). Lectures will not be recorded, but all slides will be posted.</p>"},{"location":"admin/syllabus/#in-class-exercises","title":"In-class exercises","text":"<p>Some lectures will feature in-class exercises which will also appear on the assignments. These exercises can be (and are expected to be) solved collaboratively in class, but must be solved without collaboration on the assignments. (You may of course take notes on the solution during lectures, but you may not share these notes with other students. Consult the collaboration policies for more details.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech\u2019s Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this page.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>The course collaboration policies are listed in the collaboration policies page in this book.</p> <p>Note</p> <p>Please read the collaboration policies! You are responsible for knowing what is and isn't acceptable collaboration, and if you over-collaborate you may be sent to the Board of Control, which is never pleasant.</p>"},{"location":"admin/syllabus/#software","title":"Software","text":"<p>In this course, we will be using the OCaml programming language. Assignment 0 (which is not graded) will instruct you on how to set up the OCaml environment on your computer.</p> <p>Other than that, you will only need a terminal program and a plain text editor. There are a variety of choices for these; assignment 0 discusses this further. For in-class live coding demos, we will use either the Neovim text editor or the Visual Studio Code editor.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated by your classmates and the course staff with respect. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to your learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructors know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student Wellness","text":"<p>It is very important to us that you take care of your mental wellness throughout the course! Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary. If personal issues are impeding your performance in the course (or even just your enjoyment of the material) the course instructor (Mike) is always ready and willing to help you work out a solution to these issues, or to refer you to someone who can.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation,  recommend reasonable accommodations,  and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made.  Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See the CASS website for more information.</p> <p>Undergraduate students should contact Dr. Lesley Nye, interim Dean of Undergraduate Students (administrative contact: Beth Larranaga) and graduate students should contact Darrell Peterson, Associate Dean of Graduate Studies (administrative contact: Georgine Okura).</p>"},{"location":"assignments/0/assignment0/","title":"Assignment 0: Getting set up","text":""},{"location":"assignments/0/assignment0/#due-date","title":"Due date","text":"<p>This assignment has no due date, and isn't graded.</p>"},{"location":"assignments/0/assignment0/#overview","title":"Overview","text":"<p>The purpose of this pseudo-assignment is to make sure that all the software you need in order to do the assignments for this class is set up correctly. This is not a real assignment and it's not worth any marks, but if you want to complete the actual assignments you'll need to do it.</p> <p>Warning</p> <p>You are responsible for getting the course software installed. If you are having problems with this, the course staff is here to assist you. DO NOT write your assignments in an online OCaml environment, even though this will work for some of the early assignments. It will not work for later assignments or the exams, so if you try to do this, you are likely to get heavily penalized.</p> <p>If it proves to be impossible to install OCaml on your computer (yes, this has happened!) contact the instructor so we can arrange to have you get a loaner laptop for the duration of the course. However, this is an extremely rare situation; if you have any modern (non-Chromebook) laptop with a reasonable amount of available disk space, you should have no problem installing OCaml.</p>"},{"location":"assignments/0/assignment0/#getting-ocaml-installed","title":"Getting OCaml installed","text":"<p>Here are the steps you should go through to install OCaml on your computer.</p>"},{"location":"assignments/0/assignment0/#install-ocaml-and-opam","title":"Install OCaml and <code>opam</code>","text":"<p>See the instructions on the OCaml website.</p> <p>Note</p> <p>Be aware that the version numbers may have changed since that document was written. Be sure to install the correct version! This term, we are using OCaml version 5.4.0.</p>"},{"location":"assignments/0/assignment0/#macos","title":"MacOS","text":"<p>Note</p> <p>If you have never installed the MacOS command-line tools, you need to do that first.  In a terminal, type:</p> <pre><code>$ xcode-select \u2013-install\n</code></pre> <p>See this page for more information on this.</p> <p>The OCaml installation instructions for MacOS refer to the Homebrew package manager, which needs to be installed first.</p> <p>Note</p> <p>Homebrew does not come pre-installed on Macs, but it is easy to install and is incredibly useful. Almost any open-source command-line program you can imagine can be installed using Homebrew with a single command. (This includes most programming languages, including OCaml).</p> <p>We strongly recommend that you use Homebrew, and not the MacPorts package manager (an alternative package manager for Macs), unless you happen to be an expert MacPorts user.</p>"},{"location":"assignments/0/assignment0/#linux","title":"Linux","text":"<p>If you are using Linux, you can install OCaml using your system's package manager. If your Linux is an Ubuntu variant (the most common kind), you should install OCaml using the Ubuntu package manager <code>apt</code>. The commands are:</p> <pre><code>$ sudo apt update\n$ sudo apt install opam\n</code></pre> <p>The <code>sudo</code> is so you don't have to install the software as the root user. You may be asked to enter your password, which you should do.</p>"},{"location":"assignments/0/assignment0/#windows","title":"Windows","text":"<p>If you are using Windows, you should install a Linux system inside of Windows using the Windows Subsystem for Linux, also known as \"WSL\". Then you can use <code>apt</code> like on any Ubuntu Linux system. Don't try to install OCaml natively on Windows; although this may be possible, you are very likely to run into problems beyond the capability of the instructors to solve. Use WSL.</p>"},{"location":"assignments/0/assignment0/#initialization","title":"Initialization","text":"<p>Once you have a version of OCaml and <code>opam</code> installed, you need to set it up, and, if necessary, upgrade the versions. Go through the following steps.</p> <ul> <li>Start a terminal.   If you are running MacOS, you can use the <code>Terminal</code> program.   If you're using Windows/WSL, you can either use   Windows Terminal   or use Visual Studio Code   and start a terminal inside the editor.   If you're using Windows, make sure you are   running WSL inside the terminal and not Powershell   (a terminal shell that is native to Windows).   Both Windows Terminal and VS Code   allow you to select either Powershell or WSL,   assuming WSL has been installed.   The Ubuntu shell will usually be called <code>bash</code> but may be called <code>zsh</code>.</li> </ul> <p>You will be using the terminal a lot in this course, so you should   definitely get used to working inside it.</p> <ul> <li> <p>Initialize <code>opam</code> by typing <code>opam init</code> in a terminal   and following the instructions.</p> <p>Note</p> <p>There is an issue with initializing <code>opam</code> inside of WSL. Basically, due to the way WSL works, you have to initialize <code>opam</code> differently by disabling sandboxing. This theoretically can cause some problems if a package does something really stupid, but it probably won't. The fix is to use this command instead of just <code>opam init</code>:</p> <pre><code>$ opam init --disable-sandboxing\n</code></pre> </li> <li> <p>At the end of the <code>opam init</code> command,   it will ask you to run <code>eval ${opam env}</code><sup>1</sup>   to set up the <code>PATH</code> variable of your shell   to point to the <code>opam</code> directories.   This is important, because if you don't do this,   adding new packages (and new OCaml versions) will not work.   Opam will also ask you if it can change your shell initialization file   (e.g. <code>~/.bashrc</code> for <code>bash</code> or <code>~/.zshrc</code> for <code>zsh</code>)   by adding some commands.   You should say yes, because if you don't,   every time you start up a new terminal   you will have to type <code>eval ${opam env}</code>   to get <code>opam</code> to work correctly.</p> </li> <li> <p>In your terminal, type:</p> <pre><code>$ opam update\n$ opam upgrade\n</code></pre> <p>to make sure the package repository is up to date and all OCaml packages have been upgraded to the most recent versions.</p> </li> <li> <p>Check the OCaml version by typing <code>ocaml --version</code>.   If it's the desired version (which is 5.4.0 this term),   you are done with this part.   Otherwise do</p> <pre><code>$ opam switch create 5.4.0\n</code></pre> <p>and wait for the new version to be installed. (This will take a while.)</p> </li> <li> <p>Install some libraries and programs:</p> <pre><code>$ opam install utop dune ocamlformat\n</code></pre> <p>This will install the <code>utop</code>, <code>dune</code>, and <code>ocamlformat</code> programs, as well as a number of other OCaml libraries you don't have to worry about.</p> <p><code>utop</code> is the OCaml interactive interpreter. (The name <code>utop</code> is short for \"Universal Toplevel for OCaml\") We will be working with it a lot!</p> <p>Note</p> <p>There is a more primitive interactive OCaml interpreter just called <code>ocaml</code> that comes with the OCaml distribution. We won't use this, because <code>utop</code> is vastly more featureful and nicer to use.</p> <p><code>dune</code> is the OCaml compilation manager. We will introduce this when we need it (which won't be for a few weeks).</p> <p><code>ocamlformat</code> is an auto-formatter for OCaml code. You don't absolutely need this, but it's useful when you are working with longer files of code and you want to make sure everything is formatted neatly.<sup>2</sup></p> </li> </ul> <p>We will also be installing other libraries as needed for the assignments.</p>"},{"location":"assignments/0/assignment0/#using-ocaml","title":"Using OCaml","text":"<p>There are only a few things you need to know in order to use OCaml effectively.</p>"},{"location":"assignments/0/assignment0/#starting-ocaml","title":"Starting OCaml","text":"<p>Open a terminal and type:</p> <pre><code>$ utop\n</code></pre> <p>at the terminal prompt. (The <code>$</code> is the terminal prompt; don't type that.) This will bring up the OCaml interactive interpreter, which is a good environment for experimenting with the language and for testing code you've written. (This is similar to the Python interactive interpreter.)</p> <p>Note</p> <p>You can also type <code>ocaml</code> instead of <code>utop</code>, which will bring up the simpler interactive interpreter that ships with the OCaml distribution. However, <code>utop</code> is so much better than <code>ocaml</code> that there is no need to do this unless <code>utop</code> isn't working for some reason.</p> <p><code>utop</code> makes it possible to easily recall and edit previously-input lines of text by using the up and down arrow keys. To see what it can do, start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>and type the following commands (one per line, hitting the return key at the end of each line):</p> <pre><code># Printf.printf \"hello\\n\" ;;\n# Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>Note</p> <p>The <code>utop</code> prompt is the hash sign (<code>#</code>); don't type that!</p> <p>These lines should, when evaluated, print the words <code>\"hello\"</code> and <code>\"goodbye\"</code> respectively. Once you've done this, you should be able to recall either line by using the up arrow key. For instance, you can hit the up arrow key once to get the line:</p> <pre><code>Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>and edit it so that it says:</p> <pre><code>Printf.printf \"hasta la vista\\n\" ;;\n</code></pre> <p>When you hit return, it should print out <code>\"hasta la vista\"</code> on a separate line. This feature makes line editing much easier. You can also use control-a (hold the control key down and type <code>a</code>) to get to the beginning of a line you are editing and control-e to get to the end. control-l (lower-case L) clears the terminal and puts the cursor at the top of the terminal window.</p> <p>By the way, in addition to printing out the messages you wanted, you'll also see the line:</p> <pre><code>- : unit = ()\n</code></pre> <p>printed out after hitting return. This is OCaml telling you the type of the result. In this case it's the <code>unit</code> type, which is what <code>printf</code> returns. We will talk about this in class.</p> <p>Exit the interpreter by typing control-d (this is just like Python). You can also type <code>#quit;;</code> at the prompt:</p> <pre><code># #quit;;\n</code></pre> <p>and that will also work.</p>"},{"location":"assignments/0/assignment0/#configuring-utop","title":"Configuring <code>utop</code>","text":"<p>One annoying thing about <code>utop</code> is that it tends to go overboard on command completion. You can disable this by typing this inside <code>utop</code>:</p> <pre><code># #utop_prompt_dummy;;\n# UTop.set_show_box false;;\n</code></pre> <p>It's annoying to type this every time you start <code>utop</code>, so what I do is make a <code>utop</code> initialization file called <code>init.ml</code> and put it in the directory <code>~/.config/utop</code> (creating that directory if necessary). Then these commands will be run every time <code>utop</code> starts.</p> <p>Note</p> <p>Unfortunately, this will not work properly if used in a directory that has a <code>.ocamlinit</code> file in it (usually your home directory). There are workarounds, but most of the time it will work properly. Other than that, <code>utop</code> is far superior to the basic <code>ocaml</code> interpreter.</p>"},{"location":"assignments/0/assignment0/#notes-on-the-interactive-interpreter","title":"Notes on the interactive interpreter","text":"<p>One confusing aspect of OCaml is that when entering code in the interactive interpreter, nothing gets evaluated until you enter a double semicolon (<code>;;</code>) followed by a carriage return. What this does is tell the OCaml interpreter \"Hey, I'm done entering code, so take the code I've entered and evaluate it.\" The advantage of this is that you can enter code that spans more than one line without having to enter line continuation characters at the end of lines (like you have to do in e.g. Python). The confusing part is that it's almost never necessary to enter the double semicolons when writing OCaml code in a file (though it is legal). This is a very common style mistake beginning OCaml programmers make. It usually doesn't cause any harm, but it looks bad, so don't use the double semicolons when writing OCaml code in files. (We will take style marks off if you violate this guideline, so don't do it.)</p> <p>Tip</p> <p>Don't write <code>;;</code> to end chunks of code in a file of OCaml code!</p> <p>The usual way of writing code using OCaml is to write it in a file and then load the code into the interactive interpreter to test it. The interactive interpreter has several commands that are used for this, all of which begin with the hash sign (<code>#</code>). The simplest one is the <code>#use</code> command, which loads up some OCaml source code from a file, compiles it, and runs it. For instance, open up your text editor and type the following into a file called <code>test.ml</code>:</p> <pre><code>let f x = 3 * x * x + 4 * x + 5\n</code></pre> <p>(Note, by the way, that we didn't use the double semicolons, since this is OCaml code in a file!) Save the file, then start a terminal and navigate to the directory containing that file. Then start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>Inside the interpreter, type the following command:</p> <pre><code># #use \"test.ml\";;\n</code></pre> <p>The first <code>#</code> is just the OCaml prompt and shouldn't be typed. If you've done this right, OCaml should respond with:</p> <pre><code>val f : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>What this means is that OCaml has compiled the code in the file <code>test.ml</code> and is printing out the type signature of all functions it has found there (in this case, there is only one, <code>f</code>). Test that it works by typing the following:</p> <pre><code># f 10 ;;\n</code></pre> <p>OCaml should reply with:</p> <pre><code>- : int = 345\n</code></pre> <p>By the way, the <code>-</code> to the left of the colon just indicates that the value that is printed is not a named value (unlike <code>f</code>, which we saw above).</p> <p>Interpreter commands like <code>#use</code> are not part of the OCaml language; they are only used in the interactive interpreter.</p> <p>Most of the time, we will compile OCaml code outside of the interactive interpreter by using the OCaml compilers <code>ocamlc</code> and <code>ocamlopt</code>; we will discuss how to do this in later assignments. Even later, we'll learn how to automate this process using the <code>dune</code> compilation manager.</p>"},{"location":"assignments/0/assignment0/#using-visual-studio-code","title":"Using Visual Studio Code","text":"<p>You can use any text editor you like to write OCaml code, but we recommend you try Visual Studio Code (also known as VS Code), which has excellent OCaml support, and isn't difficult to set up.<sup>3</sup> In order to use it, you need to do the following steps:</p> <ul> <li> <p>Install the OCaml Language Server Protocol by typing this into a terminal:</p> <pre><code>$ opam install ocaml-lsp-server\n</code></pre> <p>A \"language server protocol\" provides a way for editors to query languages so that things like command completion and type information can be displayed in the editor while you're editing code.</p> </li> <li> <p>Install Visual Studio Code from the   VS Code website.</p> </li> <li> <p>When inside VS Code, look at the Extensions pane   (select View/Extensions from the menu).   Type \"OCaml\" into the search bar at the top,   and select and install \"OCaml Platform\".</p> </li> </ul> <p>Now you will get nice syntax highlighting and code completion when you edit OCaml source code. You can also start a terminal while inside VS Code to test your code by running the OCaml interpreter.</p>"},{"location":"assignments/0/assignment0/#disabling-ai-tools-in-visual-studio-code","title":"Disabling AI tools in Visual Studio Code","text":"<p>Please disable all AI tools in VS Code before using them in this course!</p> <p>See this link. The setting you want to change is <code>chat.disableAIFeatures</code>. Go into the \"View\" menu, select Command Palette\", and in the dialog box, type \"Chat\". It should bring up a menu containing the option \"Chat Settings\". Select that, and scroll down until you see the box marked \"Disable AI features\". Check that box, and you are done!</p> <p>Failure to do this is an Honor Code violation! Also, relying on AI tools will destroy your learning experience.</p> <p>Other AI tools</p> <p>As is described in the collaboration policies, use of other AI tools (e.g. ChatGPT) is also strictly forbidden in this course.</p> <p>OK, now you are ready to write OCaml code!</p>"},{"location":"assignments/0/assignment0/#using-dune-with-visual-studio-code","title":"Using <code>dune</code> with Visual Studio Code","text":"<p>Some aspects of the OCaml LSP server require the <code>dune</code> compilation manager in order to work. In particular, if you want to have code completion on libraries (like the <code>num</code> library used in assignment 2), you will need to use <code>dune</code>.</p> <p>Note</p> <p>You should have installed <code>dune</code> using <code>opam</code> if you followed the instructions above. If not, install it like this:</p> <pre><code>$ opam install dune\n</code></pre> <p>Fortunately, using <code>dune</code> isn't hard. In the directory in which your OCaml code is being developed, create a file called <code>dune-project</code> with these contents:</p> <pre><code>(lang dune 3.20.2)\n</code></pre> <p>The number <code>3.20.2</code> is the version number of <code>dune</code>; you can check this by typing</p> <pre><code>$ dune --version\n</code></pre> <p>and change it if necessary.</p> <p>Also create a file called <code>dune</code> with these contents:</p> <pre><code>(library  \n  (name cs4)  \n  (modules lab2)  \n  (libraries num)  \n  (modes byte))\n\n(env  \n  (dev  \n    (flags (:standard -warn-error -A))))\n</code></pre> <p>Once this is done, exit restart VS Code and type this in your terminal:</p> <pre><code>$ dune build\n</code></pre> <p>Then restart VS Code, and you should get completion even on functions from the included libraries.</p> <p>For later assignments, you will be able to re-use the <code>dune-project</code> file unchanged. However, the <code>dune</code> file will need to be modified depending on the name of your code file(s) and the library/libraries you are using. Here, we are assuming that the code is <code>lab2.ml</code>, which becomes one of the \"modules\" listed (without the <code>.ml</code> suffix), and we are using the <code>num</code> library, which becomes one of the \"libraries\" listed. You can specify multiple modules and multiple libraries. If you aren't using any libraries, you can leave out the <code>(libraries ...)</code> line.</p> <p>Also, if you are developing each assignment in a separate directory (which you should be), then you can just put the <code>dune-project</code> in the parent directory of all the assignment directories and it will work (you won't need to copy that file). On the other hand, each assignment directory will need its own <code>dune</code> file.</p> <ol> <li> <p>Or possibly <code>eval ${opam config env}</code> or something similar. It all does the same thing.\u00a0\u21a9</p> </li> <li> <p>It's also a great way to avoid losing marks for poor coding style!\u00a0\u21a9</p> </li> <li> <p>I (Mike) actually use Neovim as my code editor most of the time. Neovim is incredibly powerful, but it takes a lot longer to learn and to configure. I don't recommend it to students unless they are willing to spend a lot of time learning it.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/assignment1/","title":"Assignment 1: Evaluation and recursion","text":""},{"location":"assignments/1/assignment1/#things-you-should-read","title":"Things you should read","text":"<p>As this is the first real assignment, we would like to remind you of some documents that you should read (or at least skim) before starting your assignment:</p> <ul> <li> <p>The course syllabus.</p> <p>This contains all the administrative information of the course. In particular, it describes the grading scheme for the course as a whole and also for individual assignments. It also describes the rework and late policies for assignments.</p> </li> <li> <p>The course collaboration policies.</p> <p>This document describes what kind of collaboration are allowed on assignments, and what isn\u2019t allowed.</p> <p>Note</p> <p>It\u2019s easy to just assume you won\u2019t do anything wrong, but please read this page, because if you don\u2019t, and you\u2019re involved in some kind of collaboration that isn\u2019t allowed, you could end up getting called before the Caltech Board of Control (BoC), which is not a pleasant experience.</p> <p>Warning</p> <p>This is in the course collaboration policies, but our experience is that many students won't read it, so we repeat it here for clarity:</p> <p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. Any use of such software is an Honor Code violation, and will be taken up with the Caltech Board of Control.</p> <p>In addition, if you use Visual Studio Code as your code editor, you must disable the AI features, as described in Assignment 0.</p> </li> <li> <p>The OCaml cheat sheet.</p> <p>The cheat sheet describes a number of potentially confusing aspects of OCaml syntax. If you discover some weird behavior of OCaml you don\u2019t understand, the cheat sheet is the first place you should look. You don\u2019t need to read all of it now, but take a look and come back to it as needed.</p> </li> </ul>"},{"location":"assignments/1/assignment1/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, January 23, at 2 AM.</p>"},{"location":"assignments/1/assignment1/#grading-scheme","title":"Grading scheme","text":"<p>See the syllabus for the assignment grading scheme.</p>"},{"location":"assignments/1/assignment1/#assignment-redos","title":"Assignment redos","text":"<p>Assignments can be redone after they have been graded. See the syllabus for the assignment redo policy.</p>"},{"location":"assignments/1/assignment1/#late-days","title":"Late days","text":"<p>You are allowed to use up to 10 \"late days\" in the term if you need extensions on an assignment (but no more than 3 late days per assignment). The details are covered in the syllabus, as usual.</p>"},{"location":"assignments/1/assignment1/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 4, corresponding to section 1.2.3 of SICP. Some material from recitation 1 is also covered.</p>"},{"location":"assignments/1/assignment1/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab1.ml</code>.  This file should be submitted to GradeScope as <code>Assignment 1</code>.  Please indicate in a comment what problem any piece of code in your submission refers to. For instance:</p> <pre><code>(* A.2 *)\n</code></pre> <p>refers to problem 2 of section A.</p>"},{"location":"assignments/1/assignment1/#supplied-files","title":"Supplied files","text":"<p>We are supplying you with this file:</p> <ul> <li><code>lab1.mli</code></li> </ul> <p>You should download it from the course Canvas site. Its use will be described below.</p>"},{"location":"assignments/1/ocaml_notes/","title":"Assignment 1: OCaml notes","text":""},{"location":"assignments/1/ocaml_notes/#mli-files","title":"<code>.mli</code> files","text":"<p>For this and all subsequent assignments, we will be supplying you with one or more OCaml interface files to be used with your code. For this assignment, the file is called <code>lab1.mli</code> (note the <code>.mli</code> extension; all OCaml interface files have this filename extension), and you should download it into the same directory that you are using to write and test your <code>lab1.ml</code> code.</p> <p>The interface file consists mostly of type signatures of functions, though occasionally it will have other things as well. The <code>lab1.mli</code> interface file looks like this:</p> <pre><code>(* Interface file for lab1.ml *)\n\nval sum_squares_to : int -&gt; int\nval sum_of_squares_of_two_largest : int -&gt; int -&gt; int -&gt; int\nval factorial : int -&gt; int\nval e_term : int -&gt; float\nval e_approximation : int -&gt; float\nval is_even : int -&gt; bool\nval is_odd : int -&gt; bool\nval f_rec : int -&gt; int\nval f_iter : int -&gt; int\nval pascal_coefficient : int -&gt; int -&gt; int\n</code></pre> <p>The <code>val</code> declarations indicate that the type signature of a particular value is being described. Here, all such values are functions (functions are values in OCaml). For instance, the <code>factorial</code> function has the type signature:</p> <pre><code>val factorial : int -&gt; int\n</code></pre> <p>which indicates that it takes one argument (an <code>int</code>) and returns an <code>int</code>, as you would expect. Functions which take more arguments (like <code>pascal_coefficient</code>, which takes two integer arguments) have somewhat less intuitive type signatures:</p> <pre><code>val pascal_coefficient : int -&gt; int -&gt; int\n</code></pre> <p>You might have expected something like this instead:</p> <pre><code>val pascal_coefficient : int int -&gt; int  (* WRONG *)\n</code></pre> <p>The reason why this is wrong is that arguments to OCaml functions are automatically curried, which means that they can be partially applied. (The name \"curried\" is a tribute to Haskell Curry, a logician whose work influenced modern functional programming languages in many ways.) In this case, it means that if we call <code>pascal_coefficient</code> with only one argument (an integer), it will return a function that takes the other integer argument and returns the integer result. Currying can occasionally give rise to confusing error messages, but it\u2019s also extremely handy in practice, as we will see.</p> <p>OK, let\u2019s assume you\u2019ve written all of your code, and you want to check that it conforms to the type declarations in the <code>.mli</code> file. How do you do that? The simplest way is to compile your code along with the interface file from the command line:</p> <pre><code>$ ocamlc -c lab1.mli lab1.ml\n</code></pre> <p>If no error messages are printed, your code is at least type-correct! Also, if you list the files in your directory, you will see two new ones: <code>lab1.cmi</code> and <code>lab1.cmo</code>. These are the (byte-code) compiled versions of the <code>lab1.mli</code> and <code>lab1.ml</code> files, respectively. Note that you have to put the <code>.mli</code> file before the <code>.ml</code> file on the command line; this won\u2019t work:</p> <pre><code>$ ocamlc -c lab1.ml lab1.mli\n</code></pre> <p>unless the <code>.cmi</code> file has already been compiled, in which case you don\u2019t have to have <code>lab1.mli</code> on the command line anyway. This is a bit annoying, but we live with it.</p> <p>You can now load the <code>.cmo</code> file into an interactive OCaml session as follows:</p> <pre><code># #load \"lab1.cmo\";;\n</code></pre> <p>In this case, nothing will be printed if there are no errors. A different way to load your code is to use the <code>#use</code> command:</p> <pre><code># #use \"lab1.ml\";;\n</code></pre> <p>If you do this, then OCaml will compile your code and print out the signature of every value in <code>lab1.ml</code>. When using <code>#use</code>, you don\u2019t need to compile your code beforehand. When using <code>#load</code>, you do. As a result, we tend to use <code>#use</code> more than <code>#load</code> when interactively developing code. You should know both forms.</p> <p>Let's go back to what would happen if you typed:</p> <pre><code># #load \"lab1.cmo\";;\n</code></pre> <p>You might expect that you could then use all the functions in <code>lab1.ml</code> (as you could if you\u2019d used <code>#use</code>). Actually, that isn\u2019t the case (yet). If you try, this will happen:</p> <pre><code># pascal_coefficient;;\nError: Unbound value pascal_coefficient\n</code></pre> <p>Huh? We just loaded <code>lab1.ml</code>, and <code>lab1.ml</code> defines <code>pascal_coefficient</code>, so why do we get an error message? It turns out that <code>#load</code> loads the code as a separate module called <code>Lab1</code> (the name of the file, without the extension, and with the first letter capitalized). This is like saying <code>import lab1</code> in Python. We can get the function by using the module name as a prefix:</p> <pre><code># Lab1.pascal_coefficient;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>Notice that we have to capitalize the first letter of <code>Lab1</code>. Module names are always capitalized in OCaml.</p> <p>If this is too tedious, you can dump all the names in the module into the local namespace by using an <code>open</code> declaration:</p> <pre><code># open Lab1;;\n# pascal_coefficient;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>This is like saying <code>from lab1 import *</code> in Python. Alternatively, if you used <code>#use</code> to load and compile the code, all the functions in the file are available immediately. This is another reason why <code>#use</code> is used more often for interactive development.</p> <p>It\u2019s important to realize that <code>#use</code> and <code>#load</code> are special commands of the OCaml interactive interpreter (also called the \"toplevel\"); they are not part of the OCaml language itself. (There are other special interpreter commands as well, which we will get to when we need them.)</p> <p>We will have much, much more to say about the OCaml module system in future assignments. OCaml actually has the most powerful module system of any computer language in wide use.</p> <p>Once you have finished writing your code, you should always compile it against the <code>.mli</code> file we provide to check that your code not only compiles, but also has the type signature we want. (Using <code>#use</code> will check that your code compiles, but it may not have the type signature we want.)</p> <p>In later assignments, we will introduce the <code>dune</code> compilation manager, which will automate all the tedious parts of compilation.</p>"},{"location":"assignments/1/partA_exercises/","title":"Part A: Exercises (35 points)","text":"<p>Some of the following problems are taken from the textbook (Structure and Interpretation of Computer Programs, or SICP for short). If so, the SICP exercise numbers are included, though you shouldn't need to consult the book.</p> <p>The online version of SICP is here.</p>"},{"location":"assignments/1/partA_exercises/#0-in-class-exercise-no-collaboration","title":"0. In-class exercise [No collaboration]","text":"<p>Note</p> <p>Problems in the in-class exercises section (there's only one in this assignment) were done in class collaboratively. However, you must reproduce them here (or write them from scratch, if you didn't attend class) without any collaboration. You are allowed to use notes/code that you yourself wrote down during the lecture, but that is all.</p> <p>You also cannot ask the TAs or the instructor for help solving in-class exercises, unless you are working on a rework of the (graded) assignment which included the exercise(s).</p> <p>See the collaboration policies for more information on in-class exercises.</p> <p>[5 points]</p> <p>Write a recursive function called <code>sum_squares_to</code> that takes a non-negative integer <code>n</code> as its only argument. It returns the sum of the squares of all integers from 0 to <code>n</code>.</p> <p>You can use either an <code>if</code> expression or pattern matching.</p> <p>Examples</p> <pre><code>sum_squares_to 0    --&gt; 0\nsum_squares_to 1    --&gt; 1\nsum_squares_to 2    --&gt; 5\nsum_squares_to 3    --&gt; 14\nsum_squares_to 5    --&gt; 55\nsum_squares_to 10   --&gt; 385\nsum_squares_to 20   --&gt; 2870\nsum_squares_to 50   --&gt; 42925\nsum_squares_to 100  --&gt; 338350\nsum_squares_to 1000 --&gt; 333833500\n</code></pre>"},{"location":"assignments/1/partA_exercises/#1-expressions","title":"1. Expressions","text":"<p>[10 points]</p> <p>Below is a sequence of expressions. What is the result (the type and value or the error message) printed by the OCaml interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented. If the interpreter indicates an error, explain briefly (one sentence) why the error occurred. There are also some other questions below which you should answer to the best of your ability. Note that entering each code fragment interactively requires that you add the <code>;;</code> terminator to terminate input. Write your answers as OCaml comments <code>(* like this *)</code>.</p> <ol> <li><code>10</code></li> <li><code>10.</code></li> <li><code>5 + 3 + 4</code></li> <li><code>3.2 + 4.2</code></li> <li><code>3 +. 4</code></li> <li><code>3 + 4.2</code></li> <li><code>3 +. 4.2</code></li> <li><code>3.0 +. 4.2</code></li> <li><code>9 - 3 - 1</code></li> <li><code>9 - (3 - 1)</code></li> <li><code>let a = 3</code></li> <li><code>let b = a + 1</code></li> <li><code>a = b</code></li> <li><code>[1; 2; 3] = [1; 2; 3]</code></li> <li><code>[1; 2; 3] == [1; 2; 3]</code> Is this the same as or different from the previous expression? Why or why not?</li> <li><code>[(1, 2, 3)]</code></li> <li><code>[1, 2, 3]</code> Explain why this gives the result it does. This is a nasty pitfall which highlights one of the less desirable features of OCaml\u2019s syntax. (See the OCaml cheat sheet for more on this.)</li> <li><code>if b &gt; a &amp;&amp; b &lt; a * b then b else a</code></li> <li><code>if b &gt; a and b &lt; a * b then b else a</code></li> <li><code>2 + if b &gt; a then b else a</code></li> <li><code>if b &gt; a then b else a + 2</code> Why is this different from the previous case?</li> <li><code>(if b &gt; a then b else a) + 2</code></li> <li><code>if b &gt; a then b</code> This is not a syntax error. Why does this give a type error? Hint: What does OCaml assume if the <code>else</code> in an <code>if</code>/<code>then</code>/<code>else</code> form is left off?</li> </ol>"},{"location":"assignments/1/partA_exercises/#2-sicp-exercise-13","title":"2. (SICP exercise 1.3)","text":"<p>[10 points]</p> <p>Define a function that takes three integer numbers as arguments and returns the sum of the squares of the two larger numbers. Call the function you define <code>sum_of_squares_of_two_largest</code>. You will probably find the <code>&amp;&amp;</code> special operator to be handy.</p>"},{"location":"assignments/1/partA_exercises/#3-sicp-exercise-14","title":"3. (SICP exercise 1.4)","text":"<p>[10 points]</p> <p>Our evaluation model allows you to use a function which is a compound expression (something that evaluates to a function). Use this observation to describe the behavior of the following function:</p> <pre><code>let a_plus_abs_b a b =\n  (if b &gt; 0 then (+) else (-)) a b\n</code></pre> <p>Write your answer in a comment. Note that surrounding an operator with parentheses makes it into a two-argument function, so</p> <pre><code>(+) 2 3\n</code></pre> <p>is the same as:</p> <pre><code>2 + 3\n</code></pre>"},{"location":"assignments/1/partB_evaluation/","title":"Part B: Evaluation (35 points)","text":"<p>In this section, write all essay-question-type answers inside OCaml comments.</p>"},{"location":"assignments/1/partB_evaluation/#1-sicp-exercise-15","title":"1. (SICP exercise 1.5)","text":"<p>[10 points]</p> <p>Note</p> <p>Before tackling this problem, read the subsection in SICP, section 1.1.5 (scroll down a little to get to the subsection) called Applicative order versus normal order (not covered in class!). Applicative order evaluation is just the evaluation rule we described in class; it\u2019s usually just called \"strict evaluation\". Normal order evaluation is an alternative to the evaluation rule we learned in class. In normal order evaluation, nothing is evaluated unless it needs to be to get the final result (it\u2019s sometimes called \"call-by-need\" where applicative order evaluation is called \"call-by-value\"). Normal order evaluation is used in some functional languages like Haskell (more accurately, Haskell uses lazy evaluation, which is a more efficient version of normal order evaluation).</p> <p>Ben Bitfiddle has invented a test to determine whether the interpreter he is faced with is using applicative order evaluation or normal order evaluation. He defines the following two functions:</p> <pre><code>let rec p () = p ()\nlet test x y = if x = 0 then 0 else y\n</code></pre> <p>He then evaluates the expression:</p> <pre><code>test 0 (p ())\n</code></pre> <p>What behavior will Ben observe with an interpreter that uses applicative order evaluation? What behavior will he observe with an interpreter that uses normal order evaluation? Explain your answer. (Assume that the evaluation rule for the special form <code>if</code> is the same whether the interpreter is using normal or applicative order: the predicate (test) expression is evaluated first, and the result determines whether to evaluate the consequent (<code>then</code>) or the alternative (<code>else</code>) expression.)</p> <p>NOTE: This problem doesn\u2019t require a lengthy explanation; two or three sentences should be enough.</p>"},{"location":"assignments/1/partB_evaluation/#2-sicp-exercise-16","title":"2. (SICP exercise 1.6)","text":"<p>[5 points]</p> <p>This problem is one of my (Mike\u2019s) favorites.</p> <p>Alyssa P. Hacker doesn\u2019t see why <code>if</code> needs to be provided as a special syntactic form. \"Why can\u2019t I just define <code>if</code> as an ordinary function?\" she asks. Alyssa\u2019s friend Eva Lu Ator claims this can indeed be done, and she defines a new version of <code>if</code> using pattern matching<sup>1</sup>:</p> <pre><code>let new_if predicate then_clause else_clause =\n  match predicate with\n    | true  -&gt; then_clause\n    | false -&gt; else_clause\n</code></pre> <p>Note</p> <p>Of course, since this is a function it will have to be called using function syntax (the <code>if</code> syntax is built-in to OCaml).</p> <p>Eva demonstrates its use to Alyssa:</p> <pre><code># new_if (2 = 3) 0 5;;\n- : int = 5\n# new_if (1 = 1) 0 5;;\n- : int = 0\n</code></pre> <p>Delighted, Alyssa uses <code>new_if</code> to write the following program to compute square roots:</p> <pre><code>let square x = x *. x\nlet average x y = (x +. y) /. 2.0\n\nlet improve guess x = average guess (x /. guess)\nlet is_good_enough guess x =\n  abs_float (square guess -. x) &lt; 0.00001\n\nlet rec sqrt_iter guess x =\n  new_if (is_good_enough guess x)\n         guess\n         (sqrt_iter (improve guess x) x)\n</code></pre> <p>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>"},{"location":"assignments/1/partB_evaluation/#3-sicp-exercise-19","title":"3. (SICP exercise 1.9)","text":"<p>[20 points]</p> <p>Each of the following two functions defines a method for adding two positive integers in terms of the functions <code>inc</code>, which increments its argument by 1, and <code>dec</code>, which decrements its argument by 1.</p> <pre><code>let rec add_a a b =\n  if a = 0\n    then b\n    else inc (add_a (dec a) b)\n\nlet rec add_b a b =\n  if a = 0\n    then b\n    else add_b (dec a) (inc b)\n</code></pre> <p>Note that <code>inc</code> or <code>dec</code> could trivially be defined as:</p> <pre><code>let inc a = a + 1\nlet dec a = a - 1\n</code></pre> <p>but for this problem, assume that they are primitive functions.</p> <p>We will use the substitution model to understand the process generated by each function when evaluating <code>add_a 2 5</code> and <code>add_b 2 5</code>.</p> <ol> <li> <p>Both <code>add_a</code> and <code>add_b</code> are recursive functions. State whether they generate recursive or iterative processes in the sense described in the lectures and in the book.</p> </li> <li> <p>For the <code>add_a</code> function only, we want you to write out the substitution model evaluation in great detail. That means you have to actually write out the fact that numbers evaluate to themselves, built-in functions evaluate to their internal representations, functions with arguments desugar to their corresponding <code>fun</code> forms, etc. Don\u2019t skip steps or you\u2019ll lose marks on this problem. Also note when names are bound to their values.</p> <p>One shortcut that you can take is to replace the body of a function with ellipses (<code>...</code>), or to replace parts of it that aren\u2019t relevant with ellipses. Please indent your work to make it obvious when you are evaluating a subexpression, a sub-sub-expression, etc. Be explicit about writing out evaluate, apply, and substitution steps, and when you are desugaring a function definition into the equivalent <code>fun</code> form. Also note where you are invoking a special form rule distinct from the usual evaluation rule (e.g. with an <code>if</code> expression).</p> <p>Assume that function arguments evaluate from left to right. This isn\u2019t necessary to get the right result, but it will make it easier for your graders to grade if everyone does this the same way.</p> <p>Write the substitution model evaluation in an OCaml comment. Our solution for this part is around 60-70 lines long. If your solution is much shorter than that, then you are skipping too many steps.</p> <p>You may find the reading on the substitution model to be useful.</p> <p>Note</p> <p>We realize that some of you (OK, all of you) may dislike this problem. Think of it the same way you might think of taking cod liver oil or eating broccoli; unpleasant but ultimately good for you. Understanding how a computer evaluates expressions is fundamental knowledge, and we will revisit this idea several times in this course (but it will never again be as tedious as in this problem!).</p> </li> <li> <p>For the <code>add_b</code> function, we want you to correct the following substitution model evaluation that Ben Bitfiddle dashed off in a hurry. Copy his evaluation into a comment and add the lines that Ben forgot to include. Each such line should start with the characters:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> <p>so your grader can easily identify them.</p> <p>Note</p> <p>Don't write out your own substitution model evaluation from scratch! Just modify the evaluation below by adding the missing lines.</p> <pre><code>(*\nlet rec add_b a b =\n  if a = 0\n     then b\n     else add_b (dec a) (inc b)\n\nDesugar this to:\n\nlet rec add_b =\n  fun a b -&gt;\n    if a = 0\n       then b\n       else add_b (dec a) (inc b)\n\nBind the name \"add_b\" to the value:\n\n  fun a b -&gt;\n    if a = 0\n       then b\n       else add_b (dec a) (inc b)\n\nEvaluate (add_b 2 5)\n  apply (fun a b -&gt; if ...) to 2, 5\n  substitute 2 for a, 5 for b in (if ...)\n    -&gt; if 2 = 0 then 5 else add_b (dec 2) (inc 5)\n  evaluate (if 2 = 0 then 5 else add_b (dec 2) (inc 5))\n    if is a special form, so evaluate the first operand:\n      evaluate (2 = 0)\n        apply = to 2, 0 -&gt; false\n    first argument of if is false, so evaluate the third operand:\n      evaluate (add_b (dec 2) (inc 5))\n        evaluate (dec 2)\n          apply dec to 2 -&gt; 1\n        evaluate (inc 5)\n          apply inc to 5 -&gt; 6\n        apply (fun a b -&gt; if ...) to 1, 6\n        substitute 1 for a, 6 for b in (if ...)\n          -&gt; if 1 = 0 then 6 else add_b (dec 1) (inc 6)\n        evaluate (if 1 = 0 then 6 else add_b (dec 1) (inc 6))\n          if is a special form, so evaluate the first operand:\n            evaluate (1 = 0)\n              apply = to 1, 0 -&gt; false\n          first argument of if is false, so evaluate the third operand:\n            evaluate (add_b (dec 1) (inc 6))\n              evaluate (dec 1)\n                apply dec to 1 -&gt; 0\n              evaluate (inc 6)\n                apply inc to 6 -&gt; 7\n              apply (fun a b -&gt; if ...) to 0, 7\n              substitute 0 for a, 7 for b in (if ...)\n                -&gt; if 0 = 0 then 7 else add_b (dec 0) (inc 7)\n              evaluate (if 0 = 0 then 7 else add_b (dec 0) (inc 7))\n                if is a special form, so evaluate the first operand:\n                  evaluate (0 = 0)\n                    apply = to 0, 0 -&gt; true\n                first argument of if is true, so evaluate the second operand:\n                  result: 7\n*)\n</code></pre> </li> </ol> <ol> <li> <p>OCaml's pattern matching syntax was covered in recitation lecture 1.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/partC_recursion/","title":"Part C: Recursion (30 points)","text":""},{"location":"assignments/1/partC_recursion/#1-computing-e","title":"1. Computing e","text":"<p>[10 points]</p> <p>In this problem we're going to write a function that enables us to compute the number e, the base of natural logarithms, which is equal to 2.7182818... We will do this by summing a part of an infinite series expansion which computes e:</p> <pre><code>e = 1/0! + 1/1! + 1/2! + ...\n</code></pre> <p>where <code>n!</code> is the factorial of <code>n</code>, which in defined as</p> <pre><code>n! = n * (n-1) * (n-2) * ... * 1\n</code></pre> <p>We'll start out with the factorial function itself:</p> <pre><code>(* This function computes the factorial of the input number,\n   which for a number n is equal to n * (n-1) * ... * 1. *)\nlet rec factorial n =\n  if n = 0 then 1 else n * factorial (n - 1)\n</code></pre> <p>Note</p> <p>The definition of <code>factorial</code> has to be included in your assignment submission or the rest of the code won't work.</p> <p>Also, if you're unhappy because this is a space-inefficient way to compute factorials, you're right! But it won't matter for this problem.</p>"},{"location":"assignments/1/partC_recursion/#a-e_term","title":"a. <code>e_term</code>","text":"<p>Write a simple function called <code>e_term</code> which takes a (non-negative) integer argument and computes that term of the infinite series expansion of <code>e</code>. This function is not recursive. Note that the result must be a floating-point number; use the <code>float_of_int</code> function to convert from an OCaml <code>int</code> to a <code>float</code>.</p> <p>Note</p> <p>OCaml never implicitly promotes one numeric type to another, so you must do it explicitly if that's what you want.</p> <p>Examples</p> <pre><code># e_term 0;;\n- : float = 1.\n# e_term 1;;\n- : float = 1.\n# e_term 2;;\n- : float = 0.5\n# e_term 5;;\n- : float = 0.00833333333333333322\n</code></pre>"},{"location":"assignments/1/partC_recursion/#b-e_approximation","title":"b. <code>e_approximation</code>","text":"<p>Write a recursive function called <code>e_approximation</code> that takes one positive integer argument and computes an approximation to e (an \"e-proximation\", as it were) by summing up that many terms of the infinite series expansion of e (actually, it'll sum up the first n+1 terms, since it starts at term 0 and ends at term n). Write the function as a linear recursive process. Use your <code>e_term</code> function to help you write this one.</p> <p>Examples</p> <pre><code># e_approximation 0;;\n- : float = 1.\n# e_approximation 1;;\n- : float = 2.\n# e_approximation 2;;\n- : float = 2.5\n# e_approximation 5;;\n- : float = 2.71666666666666634\n# e_approximation 10;;\n- : float = 2.71828180114638451\n</code></pre>"},{"location":"assignments/1/partC_recursion/#c-computing-the-approximation","title":"c. Computing the approximation","text":"<p>Compute an approximation to e by summing up to the 20th term of the infinite series expansion. Write down the answer that OCaml gives you in a comment in your lab submission. Then write down the value of <code>exp 1.0</code> which is <code>e</code> to the power of <code>1</code>, and compare with the result given by <code>e_approximation 20</code> (they should be nearly identical).</p>"},{"location":"assignments/1/partC_recursion/#d-too-many-terms","title":"d. Too many terms?","text":"<p>What happens if you try to compute a better approximation to <code>e</code> by summing up to the 100th term of the infinite series expansion? Why does this happen? Write your answer in a comment.</p>"},{"location":"assignments/1/partC_recursion/#2-mutual-recursion","title":"2. Mutual recursion","text":"<p>[5 points]</p> <p>It's possible to have a kind of recursion which involves more than one function; this is called mutual recursion. A simple example is a pair of functions <code>is_even</code> and <code>is_odd</code>. <code>is_even</code> is a predicate which returns <code>true</code> if its argument is an even (non-negative) integer and <code>false</code> if its argument is an odd (non-negative) integer (zero is considered even). <code>is_odd</code> returns <code>true</code> if its numeric argument is odd and <code>false</code> otherwise. Write these functions, using only recursion, testing for equality with zero, and subtracting 1. (The solution is very short.) Since the solution uses mutual recursion, the <code>is_even</code> function will need to call the <code>is_odd</code> function and the <code>is_odd</code> function will need to call the <code>is_even</code> function.</p> <p>Note</p> <p>Of course, this is an extremely inefficient way of computing evenness and oddness! It's just for illustration purposes.</p> <p>When defining mutually recursive functions in OCaml, you need to use the <code>let rec ... and ...</code> syntax:</p> <pre><code>let rec f1 a b c = ...  (* ... may include f2 *)\nand f2 x y z = ...      (* ... may include f1 *)\n</code></pre> <p>This works for any number of mutually-recursive functions. The whole form starts with a <code>let rec</code> and then each function after the first in the group starts with <code>and</code>.</p> <p>Note</p> <p>Mutual recursion might seem like something extremely esoteric with few real uses, but it isn't. If you are writing a programming language interpreter or compiler (as you will if you take CS 131 or CS 164), you will find that your code is full of large swaths of mutually-recursive functions.</p>"},{"location":"assignments/1/partC_recursion/#3-sicp-exercise-111","title":"3. (SICP exercise 1.11)","text":"<p>[5 points]</p> <p>A function <code>f</code> is defined by the rules:</p> <ul> <li><code>f(n) = n</code> if <code>n &lt; 3</code></li> <li><code>f(n) = f(n - 1) + 2 * f(n - 2) + 3 * f(n - 3)</code> if <code>n &gt;= 3</code>.</li> </ul> <p>Write a function called <code>f_rec</code> that computes <code>f</code> by means of a recursive process. Write another function called <code>f_iter</code> that computes <code>f</code> by means of an iterative process.</p> <p>Hint</p> <p>The recursive definition is straightforward. Use it to check the correctness of the iterative definition. The iterative definition will need a helper function that keeps track of the last three numbers in the series, among other things.</p> <p>Examples</p> <pre><code># f_rec 0;;\n- : int = 0\n# f_rec 1;;\n- : int = 1\n# f_rec 3;;\n- : int = 4\n# f_rec 10;;\n- : int = 1892\n# f_rec 20;;\n- : int = 10771211\n(* f_iter gives the same results *)\n</code></pre>"},{"location":"assignments/1/partC_recursion/#4-sicp-exercise-112","title":"4. (SICP exercise 1.12)","text":"<p>[10 points]</p> <p>The following pattern of numbers is called \"Pascal's triangle\":</p> <pre><code>    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n</code></pre> <p>The numbers at the edges of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it to the left and right. Write a function called <code>pascal_coefficient</code> which takes two <code>int</code> arguments (corresponding to the row number (starting from 1) and the index inside the row (also starting from 1)) and computes elements of Pascal's triangle by means of a recursive process.</p> <p>Use pattern matching to make the code cleaner. This is not optional! Use of <code>if</code>/<code>then</code>/<code>else</code> in your solution will result in lost marks.</p> <p>Note</p> <p>If you have a <code>match</code>, but use a <code>when</code> clause with each match case, this is equivalent to having nested <code>if</code>/<code>then</code>/<code>else</code> expressions, and you will still lose marks.  See the hint below.</p> <p>For arguments that don't correspond to locations in Pascal's triangle (like numbers &lt; 1 or index numbers that are greater than the row number) you should signal an error using the code: <code>failwith \"invalid arguments\"</code>. This raises a <code>Failure</code> exception. We'll talk more about exceptions later in the course.</p> <p>Examples</p> <pre><code># pascal_coefficient 1 1 ;; (* row 1, index 1 in row *)\n- : int = 1\n# pascal_coefficient 2 1 ;;\n- : int = 1\n# pascal_coefficient 2 2 ;;\n- : int = 1\n# pascal_coefficient 3 1 ;;\n- : int = 1\n# pascal_coefficient 3 2 ;;\n- : int = 2\n# pascal_coefficient 3 3 ;;\n- : int = 1\n# pascal_coefficient 10 5 ;;\n- : int = 126\n# pascal_coefficient 1 0 ;;\nException: Failure \"invalid arguments\".\n</code></pre> <p>Hints</p> <ul> <li> <p>It's much easier to write this as a recursive process   (i.e. with pending operations) than as an iterative process,   though both approaches will involve recursive functions.   Since you don't have to do it both ways,   we recommend you write it as a recursive process.</p> </li> <li> <p>Pattern match on a tuple of both input arguments.   Use the <code>when</code> form in a pattern   when you need to specify non-structural conditions for a match   (like two things being equal).   Only use <code>when</code> when you can't use structural pattern matching.   For instance, don't do this kind of thing:</p> <pre><code>match x with\n  | x' when x' = 1 -&gt; ...\n  ...\n</code></pre> <p>when you can do this instead:</p> <pre><code>match x with\n  | 1 -&gt; ...\n  ...\n</code></pre> <p>Also don't forget about the <code>_</code> (wildcard) syntax for don't-care patterns. Remember that a number in a pattern matches that literal number only.</p> </li> <li> <p>It's convenient (though not required)   to use the first pattern match for error checking only.</p> </li> </ul> <p>Despite all this explanation, this function only needs to be a few lines long.</p>"},{"location":"assignments/2/assignment2/","title":"Assignment 2: Asymptotic complexity and higher-order functions","text":""},{"location":"assignments/2/assignment2/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, January 30, at 2 AM.</p>"},{"location":"assignments/2/assignment2/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 6, corresponding to section 1.3.4 of SICP.</p>"},{"location":"assignments/2/assignment2/#what-to-hand-in","title":"What to hand in","text":"<p>All of your code should be saved to a file named <code>lab2.ml</code>. This file should be submitted to GradeScope as <code>Assignment 2</code>. Do not submit the interface file (<code>lab2.mli</code>), or the test script (<code>tests_lab2.ml</code>), or the <code>Makefile</code> we supply for you.</p>"},{"location":"assignments/2/ocaml_notes/","title":"OCaml notes","text":""},{"location":"assignments/2/ocaml_notes/#packages-needed","title":"Packages needed","text":"<p>For this assignment, you'll need to have the following <code>opam</code> packages installed:</p> <ul> <li><code>ocamlfind</code> (various compilation utilities)</li> <li><code>num</code> (arbitrary-precision integer/rational number arithmetic)</li> </ul> <p><code>ocamlfind</code> should already be installed if you followed the instructions in assignment 0. Install the other packages using <code>opam</code> as follows:</p> <pre><code>$ opam update\n$ opam install num\n</code></pre> <p>As you can see, you can install multiple packages using one <code>opam</code> command. Type this:</p> <pre><code>$ opam list\n</code></pre> <p>after installation to verify that the <code>ocamlfind</code> and <code>num</code> packages are installed. If not, consult with a TA or the instructor.</p>"},{"location":"assignments/2/ocaml_notes/#testing","title":"Testing","text":"<p>Note</p> <p>In what follows, we're assuming that you are editing and running your code in a Unix-like environment (MacOS X, Linux, or Windows with WSL). If you aren't (e.g. if you are running Windows and are using Powershell instead of the WSL <code>bash</code> shell), things will not work correctly. In that case, you should install WSL from this site.</p> <p>Note that you can easily run WSL shells from inside Visual Studio Code, and this is recommended if you're using Windows.</p> <p>See a TA if you are having problems getting set up. (Also review assignment 0, which contains detailed instructions on how to get set up.)</p>"},{"location":"assignments/2/ocaml_notes/#supplied-files","title":"Supplied files","text":"<p>For this assignment, we are supplying you with these support files:</p> <ol> <li>An OCaml interface file: <code>lab2.mli</code></li> <li>a test script: <code>tests_lab2.ml</code></li> <li>a <code>Makefile</code> to automate compilation.</li> </ol> <p>These files are all available on the course Canvas site in a single zip file called <code>lab2.zip</code>. Download this file and unzip it:</p> <pre><code>$ unzip lab2.zip\n</code></pre> <p>This will create a <code>lab2</code> directory with the files inside it. You should not change these files, and you should not submit them as part of your assignment submission. You should create and edit the file <code>lab2.ml</code> (which you will be handing in) in the same directory.</p>"},{"location":"assignments/2/ocaml_notes/#running-the-tests-once-all-the-code-is-written","title":"Running the tests once all the code is written","text":"<p>Once your assignment is done, you should compile it and check that it conforms to the interface file by entering this command:</p> <pre><code>$ make compile\n</code></pre> <p>Of course, you can also compile your code from inside the <code>utop</code> OCaml interpreter using the <code>#use</code> directive. Using <code>#use</code> is recommended while developing code to check that the code has no type errors. Using the <code>make</code> command is useful when the code is finished to make sure that all your functions, types etc. have the correct type signatures (which they should, if you have been following the directions). Note that it's possible to write a function that type checks but doesn't have the type we want it to have; that's why using <code>make</code> is important. The type signatures we expect are in the <code>lab2.mli</code> interface file, and these are used by the <code>Makefile</code> when compiling the code.</p> <p>Finally, to run the test script, type this after compiling the code with <code>make compile</code>:</p> <pre><code>$ make test\n</code></pre> <p>This will compile the <code>tests_lab2.ml</code> file (which contains the unit tests) and output an executable program called <code>tests_lab2</code>. Then it will run that program and report all test failures.</p> <p>If you want to compile the code and immediately run the test script (useful during development/debugging), type:</p> <pre><code>$ make all\n</code></pre> <p>or just type:</p> <pre><code>$ make\n</code></pre> <p>which does the same thing. This is equivalent to typing <code>make compile</code> followed by <code>make test</code>.</p> <p>Type</p> <pre><code>$ make clean\n</code></pre> <p>to get rid of the <code>tests_lab2</code> executable and all files ending in <code>.cmo</code> and <code>.cmi</code> (compilation artifacts).</p>"},{"location":"assignments/2/ocaml_notes/#running-the-tests-before-all-the-code-is-written","title":"Running the tests before all the code is written","text":"<p>While writing your assignment code, you probably will want to edit the <code>tests_lab2.ml</code> file and comment out the lines at the bottom of the file corresponding to tests of functions you haven't yet written. (See the note in the file at the end.) This will allow you to test your code as you are writing it, which we recommend. Don't forget to uncomment all the test lines once all the functions are written! (There are 88 tests in all.)</p> <p>You can also write stubs for functions you haven't yet written i.e. something like this:</p> <pre><code>let function_not_yet_written = failwith \"TODO\"\n</code></pre> <p>This will at least allow the test script to compile.</p> <p>Be aware that the test scripts are in no way exhaustive! Some functions are just inherently hard to test, or else hard to test in a way that wouldn't give away the answer to a student who looked at the test script code.  We recommend that you experiment with the code on your own (using the <code>utop</code> interactive interpreter) in addition to running the test script.</p> <p>Warning</p> <p>Don't assume that just because your code passes all the tests that everything is perfect! It's necessary but not sufficient, as the math folks like to say.</p>"},{"location":"assignments/2/ocaml_notes/#compiler-warnings","title":"Compiler warnings","text":"<p>The <code>Makefile</code> commands to compile OCaml code turn on most of the OCaml compiler warning options, even ones that are normally turned off. Therefore, you might see some warnings when compiling your code that you don't see when loading it into the interpreter. Compiling your code shouldn't give rise to any warnings, so if there are any, fix them. If you don't understand what a compiler warning means, ask us!</p> <p>A list of compiler warnings is on this page; scroll down to find it (under the <code>-w</code> command-line option). Don't expect to understand all of them, but the ones you are likely to encounter should be comprehensible.</p>"},{"location":"assignments/2/ocaml_notes/#using-libraries-in-ocaml","title":"Using libraries in OCaml","text":"<p>Some of the problems below require the use of arbitrary-precision integers and rational numbers. The easiest way to get this in OCaml is by using the <code>Num</code> library.<sup>1</sup> Here we will show you how to use OCaml libraries in two different ways: in the <code>utop</code> interactive interpreter (useful for debugging and testing code) and while compiling code. We'll use the <code>Num</code> library as an example, but the information will apply to any OCaml library.</p>"},{"location":"assignments/2/ocaml_notes/#in-the-utop-interactive-interpreter","title":"In the <code>utop</code> interactive interpreter","text":"<p>The most basic way to use an OCaml library inside <code>utop</code> (which we don't recommend) is to use the <code>#load</code> command. This requires that you know the full name of the compiled library file. This means that you have to enter the following commands before using the <code>Num</code> library interactively:</p> <pre><code># #load \"nums.cma\";;\n# open Num;;\n</code></pre> <p>(In all the interactive OCaml examples, the first <code>#</code> is the interactive prompt that you shouldn't type.)</p> <p>Here, we have to know that the library file is called <code>\"nums.cma\"</code>, which is a bit annoying. The line <code># open Num;;</code> brings all the contents of the <code>Num</code> library into the top-level namespace, so you don't have to use the <code>Num</code> prefix when using any of the functions in the <code>Num</code> library. (This is like entering <code>from Num import *</code> in Python.)</p> <p>If the library file is in a non-standard location, it's even worse; you have to add this line before the <code>#load</code> line:</p> <pre><code>#directory /path/to/the/library/directory\n</code></pre> <p>(where you should substitute the real path for <code>/path/to/the/library/directory</code>) or else start <code>utop</code> with the <code>-I</code> argument:</p> <pre><code>$ utop -I /path/to/the/library/directory\n</code></pre> <p>Either way, it's a nuisance.</p> <p>Fortunately, the <code>utop</code> interactive interpreter supports a much simpler way of loading libraries. (Internally, it uses the <code>ocamlfind</code> library to do this, but you don't need to know exactly how this works.) All you need to do is type the following commands inside <code>utop</code>:</p> <pre><code># #require \"num\";;\n# open Num;;\n</code></pre> <p>Now you can use anything in the <code>Num</code> module without having to qualify it with the <code>Num.</code> prefix.</p> <p>We'd like to reiterate here that all the <code>#</code>-commands like <code>#use</code>, <code>#require</code> etc. are not part of the OCaml language but are specific to the interactive interpreter. Please do not use these commands in compiled OCaml code (i.e. <code>.ml</code> and <code>.mli</code> files)!</p>"},{"location":"assignments/2/ocaml_notes/#in-compiled-code","title":"In compiled code","text":"<p>If you want to compile an executable program that uses the <code>Num</code> library, there are three ways to do it: the hard way, the easy way, and the automatic way.</p> <p>The hard way is to specify the library information explicitly when you compile your code. For instance, if you have a file <code>\"myprog.ml\"</code> that uses the <code>Num</code> library, you can compile it like this:</p> <pre><code>$ ocamlc nums.cma myprog.mli myprog.ml -o myprog\n</code></pre> <p>Here, <code>ocamlc</code> is the name of the OCaml compiler program.<sup>2</sup></p> <p>Note again that you have to specify the library name in full. If the directory where <code>nums.cma</code> is located is not a standard location (which it probably isn't), you would additionally have to specify the directory with the <code>-I</code> option, e.g.:</p> <pre><code>$ ocamlc -I /path/to/the/library/directory nums.cma myprog.mli myprog.ml -o myprog\n</code></pre> <p>Clearly, this is a nuisance, and the easy way to do this involves using the <code>ocamlfind</code> package. In this case we will use the <code>ocamlfind</code> program (which is part of the <code>ocamlfind</code> package; don't confuse the two distinct uses of <code>ocamlfind</code>):</p> <pre><code>$ ocamlfind ocamlc -package num myprog.mli myprog.ml -o myprog -linkpkg\n</code></pre> <p>You can also use <code>ocamlfind</code> for compiling non-executables (e.g. object code files or libraries); in that case you leave off the <code>-linkpkg</code> argument and adjust the <code>ocamlc</code> arguments as necessary. For instance, if we were compiling a library <code>mylib.ml</code> that used the <code>Num</code> library we would compile it like this:</p> <pre><code>$ ocamlfind ocamlc -c  -package num mylib.mli mylib.ml\n</code></pre> <p>Since this is still kind of annoying, we automate this by putting these kinds of commands in a <code>Makefile</code> that we will supply to you. Then, in order to compile your program, you will just have to type:</p> <pre><code>$ make\n</code></pre> <p>as previously discussed.</p> <p>The \"automatic\" way, which is used for more complicated programs containing multiple files of OCaml code, requires the Dune compilation manager. We'll learn more about Dune in later assignments.</p>"},{"location":"assignments/2/ocaml_notes/#using-the-num-library","title":"Using the <code>Num</code> library","text":"<p>The <code>Num</code> library defines a data type called <code>num</code> which can represent arbitrarily-large integers and rational numbers composed of arbitrarily-large integers. The library documentation is here. (It's pretty sparse!)</p> <p>The <code>num</code> type is abstract, which means that its internal structure is not exposed to users. Therefore, you have to convert e.g. integers to and from <code>num</code>s in order to use them. To convert an integer to a <code>num</code>, use the <code>num_of_int</code> function, and to convert back, use the <code>int_of_num</code> function. The <code>string_of_num</code> function converts a <code>num</code> to a string, while <code>float_of_num</code> converts a <code>num</code> to a floating-point number. The numeric operators in the <code>Num</code> library all have a <code>/</code> suffix, so instead of <code>+ - * /</code> etc. we have <code>+/ -/ */ //</code> etc. This is analogous to floating-point numbers which use <code>+. -. *. /.</code> etc. It's not terribly pleasant to use, but it works.</p> <p>There are also <code>num</code>-specific relational operators (<code>&lt;/</code>, <code>&lt;=/</code>, <code>&gt;/</code>, etc.). You should use these on <code>num</code>s instead of the (overloaded) built-in ones (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, etc.) because the overloaded ones won't always work properly on <code>num</code>s.  This includes the equality operators, which for <code>num</code>s are <code>=/</code> and <code>&lt;&gt;/</code>.</p> <p>Here are some examples of the <code>Num</code> library in use in the interactive interpreter:</p> <pre><code>$ utop\n# #require \"num\";;\n# open Num;;\n# let n1 = num_of_int 42;;\nval n1 : Num.num = &lt;num 42&gt;\n# let n2 = num_of_int 57;;\nval n2 : Num.num = &lt;num 57&gt;\n# n1 +/ n2;;\n- : Num.num = &lt;num 99&gt;\n# n1 */ n2;;\n- : Num.num = &lt;num 2394&gt;\n# n1 // n2;;\n- : Num.num = &lt;num 14/19&gt;\n# float_of_num (n1 // n2);;\n- : float = 0.736842105263\n# string_of_num (n1 // n2);;\n- : string = \"14/19\"\n# int_of_num (n1 // n2);;\nException: Failure \"integer argument required\".\n# int_of_num ((num_of_int 42) // (num_of_int 21));;\n- : int = 2\n</code></pre> <p>This should be enough to get you through this assignment.</p> <ol> <li> <p>The <code>Num</code> package is pretty much deprecated in favor of the <code>Zarith</code> package, but we still use <code>Num</code> because it's simpler.\u00a0\u21a9</p> </li> <li> <p>More specifically, this is the OCaml bytecode compiler, which is optimized for very fast compilation. There is also a native-code OCaml compiler called <code>ocamlopt</code>, which is slower but produces much faster code. We will usually just use <code>ocamlc</code>, because it will be fast enough for our purposes.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partA_orders_of_growth/","title":"Part A: Orders of growth (40 points)","text":"<p>This section will feature problems relating to estimating time and space complexity in OCaml functions. As usual, write essay-type answers as OCaml comments.</p>"},{"location":"assignments/2/partA_orders_of_growth/#1-in-class-exercise-is_power_of_two","title":"1. In-class exercise: <code>is_power_of_two</code>","text":"<p>[5 points] (no collaboration)</p> <p>What are the time and space complexities of the following function?</p> <pre><code>let rec is_power_of_two n =\n  if n = 1 then\n    true\n  else if n mod 2 &lt;&gt; 0 then\n    false\n  else\n    is_power_of_two (n / 2)\n</code></pre> <p>Explain your reasoning. (A sentence or two should be enough.)</p>"},{"location":"assignments/2/partA_orders_of_growth/#2-fibonacci-again","title":"2. Fibonacci again","text":"<p>[5 points]</p> <p>Consider the tree-recursive fibonacci function discussed in class:</p> <pre><code>let rec fib n =\n  if n &lt; 2\n     then n\n     else fib (n - 1) + fib (n - 2)\n</code></pre> <p>You know that the time complexity for this function is \\(O(2^n)\\).</p> <p>Note</p> <p>More specifically, it is \\(\\Theta(g^n)\\), where \\(g\\) is the golden ratio (\\(1.618...\\)). See SICP section 1.2.2 and exercise 1.13 for more on this.</p> <p>If we assume that OCaml is using applicative-order evaluation (the normal OCaml evaluation rule), then what is its space complexity? Explain why this is different from the time complexity.</p> <p>Hint: consider what the largest number of pending operations would have to be when evaluating <code>fib 7</code>. You may assume that once an expression is fully evaluated, all the memory used in evaluating that expression is returned to the system.</p> <p>Note</p> <p>You are not required to state what the effect of normal-order evaluation is on the space requirements of the <code>fib</code> function, though it is interesting! </p>"},{"location":"assignments/2/partA_orders_of_growth/#3-sine-sicp-exercise-115","title":"3. <code>sine</code> (SICP exercise 1.15)","text":"<p>[5 points]</p> <p>The sine of an angle (specified in radians) can be computed by making use of the approximation:</p> \\[ sin\\ x = x \\] <p>(if \\(x\\) is \"sufficiently small\"), and the trigonometric identity:</p> \\[ sin\\ x = 3 \\ sin(x / 3) - 4 \\ sin^3(x/3) \\] <p>to reduce the size of the argument of \\(sin\\) if \\(x\\) is not sufficiently small. For purposes of this exercise an angle is considered \"sufficiently small\" if its magnitude is less than 0.1 radians.</p> <p>These ideas are incorporated in the following functions (using floating-point arithmetic throughout):</p> <pre><code>let cube x = x *. x *. x\nlet p x = 3.0 *. x -. 4.0 *. cube x\nlet rec sine angle =\n  if abs_float angle &lt; 0.1\n     then angle\n     else p (sine (angle /. 3.0))\n</code></pre> <ol> <li> <p>How many times is the function <code>p</code> applied when <code>sine 12.15</code> is    evaluated?</p> </li> <li> <p>What is the order of growth in space and number of steps    used by the process generated by the <code>sine</code> function    when <code>sine a</code> is evaluated (as a function of <code>a</code>)?</p> </li> </ol> <p>By \"growth in number of steps\", we mean the asymptotic time complexity of the <code>sine</code> function as a function of the size of the input. Explain the reason for the space/time complexities; don\u2019t just state an answer.</p>"},{"location":"assignments/2/partA_orders_of_growth/#4-fast_expt-and-ifast_expt-sicp-exercise-116","title":"4. <code>fast_expt</code> and <code>ifast_expt</code> (SICP exercise 1.16)","text":"<p>[5 points]</p> <p>SICP describes a non-iterative function called <code>fast_expt</code> that does exponentiation using successive squaring (when possible). Translated into OCaml, that function looks like this:</p> <pre><code>let rec fast_expt b n =\n  let is_even m = m mod 2 = 0 in\n  let square m = m * m in\n    if n = 0 then 1\n    else if is_even n then square (fast_expt b (n / 2))\n    else b * fast_expt b (n - 1)\n</code></pre> <p>Note that <code>mod</code> is a predefined infix operator in OCaml (not a function!) which computes remainders; you use it like this: <code>5 mod 2</code> (which will return <code>1</code>).</p>"},{"location":"assignments/2/partA_orders_of_growth/#a-fast_expt","title":"a. <code>fast_expt</code>","text":"<p>The <code>fast_expt</code> function uses nested <code>if</code>/<code>then</code>/<code>else</code> forms, which are a bit ugly and error-prone (since OCaml doesn\u2019t actually have an <code>else if</code> syntax). Rewrite the function using pattern matching on the <code>n</code> argument (a <code>match</code> expression); use <code>when</code> clauses in pattern matches when you need to test for non-structural conditions (and only then). Your function should not have any <code>if</code> expressions.</p> <p>Here is a skeleton version of the function you should write:</p> <pre><code>let rec fast_expt b n =\n  let is_even m = m mod 2 = 0 in\n  let square m = m * m in\n    match n with\n      (* fill in the rest here *)\n</code></pre> <p>Hint: the \"wildcard\" pattern <code>_</code> may be useful to you. Any compiler warnings will be considered to be errors.</p>"},{"location":"assignments/2/partA_orders_of_growth/#b-ifast_expt","title":"b. <code>ifast_expt</code>","text":"<p>Write a function called <code>ifast_expt</code> that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps.</p> <p>Hint</p> <p>Using the observation that \\(b^n = (b^{n/2})^2 = (b^2)^{n/2}\\), keep, along with the exponent \\(n\\) and the base \\(b\\), an additional state variable \\(a\\), and define the state transformation in such a way that the product \\(a b^n\\) is unchanged from state to state. At the beginning of the process \\(a\\) is taken to be 1, and the answer is given by the value of \\(a\\) at the end of the process. In general, the technique of defining an invariant quantity that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.</p> <p>Use integer arithmetic for this problem. You may assume that all the (integer) arguments to your function are non-negative.</p> <p>You will need some helper functions in the implementation of your <code>ifast_expt</code> function. You should make these internal to your <code>ifast_expt</code> function, as was done with the <code>fast_expt</code> function above. One of these will need to be recursive; call it <code>iter</code>. Only use <code>let rec</code> with that function; use <code>let</code> for all other internal definitions and for the <code>ifast_expr</code> function as a whole.</p> <p>Use pattern matching instead of nested <code>if</code>/<code>then</code>/<code>else</code> forms as you did for the <code>fast_expt</code> function.</p>"},{"location":"assignments/2/partA_orders_of_growth/#5-fast_mult-sicp-exercise-117","title":"5. <code>fast_mult</code> (SICP exercise 1.17)","text":"<p>[5 points]</p> <p>The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. The simplest such function is this:</p> <pre><code>let rec expt a b =\n  if b = 0\n     then 1\n     else a * expt a (b - 1)\n</code></pre> <p>In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication function (in which it is assumed that our language can only add, not multiply), is analogous to the <code>expt</code> function:</p> <pre><code>let rec mult a b =\n  if b = 0\n     then 0\n     else a + mult a (b - 1)\n</code></pre> <p>This algorithm takes a number of steps that is linear in <code>b</code>. Now suppose we include, together with addition, the operations <code>double</code>, which doubles an integer, and <code>halve</code>, which divides an (even) integer by 2. Using these, design a multiplication function analogous to <code>fast_expt</code> that uses a logarithmic number of steps. Call this function <code>fast_mult</code>.</p> <p>Note</p> <p>Don't do any multiplications or divisions in <code>fast_mult</code> except indirectly by using <code>double</code> or <code>halve</code>. (<code>double</code> and <code>halve</code> themselves can do multiplication or division, of course.) You can also use addition, subtraction, and the <code>mod</code> operator to test for evenness.</p> <p>Use integer arithmetic for this problem. The multiplication function you write should generate a recursive process.</p> <p>Use the following definitions for <code>double</code> and <code>halve</code>:</p> <pre><code>let double n = n + n\nlet halve n = n / 2\n</code></pre> <p>For this problem, write all helper functions (including <code>double</code> and <code>halve</code>) inside the <code>fast_mult</code> function<sup>1</sup>, and again use pattern matching on the <code>n</code> argument instead of nested <code>if</code>/<code>then</code>/<code>else</code> expressions.</p>"},{"location":"assignments/2/partA_orders_of_growth/#6-ifast_mult-sicp-exercise-118","title":"6. <code>ifast_mult</code> (SICP exercise 1.18)","text":"<p>[5 points]</p> <p>Using the results of the previous exercises, devise a function called <code>ifast_mult</code> that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.</p> <p>This multiplication function should generate an iterative process. If you are multiplying integer \\(b\\) by integer \\(n\\), you will need another state variable \\(a\\) such that the invariant is \\(a + bn\\), and \\(n\\) will decrease to zero, at which point \\(a\\) will be the answer.</p> <p>Again, use pattern matching instead of nested <code>if</code>/<code>then</code>/<code>else</code> expressions. And again, only use <code>let rec</code> where it\u2019s absolutely necessary.</p>"},{"location":"assignments/2/partA_orders_of_growth/#7-a-mysterious-function","title":"7. A mysterious function","text":"<p>[5 points]</p> <p>Consider the following (higher-order) function:</p> <pre><code>let rec foo f n =\n  if n &lt;= 1\n     then f 0\n     else foo f (n / 2) + foo f (n / 2)\n</code></pre> <p>Note that function calls have the highest precedence in OCaml, so the last expression is the same as <code>(foo f (n / 2)) + (foo f (n / 2))</code>.</p> <p>If we assume that the function <code>f</code> can compute its result in constant time and constant space, what are the (worst-case) time and space complexities of the function <code>foo</code>? Justify your answer. (It doesn\u2019t have to be a full mathematical proof, but it should be a convincing argument.) Assume that the integer input <code>n</code> is always non-negative, and assume the usual applicative-order evaluation rule.</p> <p>Note</p> <p>This problem shows that tree recursion doesn't necessarily give rise to an inefficient function.</p>"},{"location":"assignments/2/partA_orders_of_growth/#8-fibonacci-yet-again","title":"8. Fibonacci yet again","text":"<p>[5 points]</p> <p>Consider this function to compute fibonacci numbers:</p> <pre><code>let fib n =\n  let rec last_two n =\n    if n &lt; 1\n      then (0, 1)\n      else\n        let (p0, p1) = last_two (n - 1) in\n          (p1, p0 + p1)\n  in\n    fst (last_two n)\n</code></pre> <p>A couple of OCaml notes:</p> <ul> <li> <p>It\u2019s legal to assign more than one value at a time   in a <code>let</code> expression as shown above.   (Effectively, you are doing a pattern match that cannot fail.)</p> </li> <li> <p><code>fst</code> is a built-in function which extracts the first value of a two-tuple.</p> </li> </ul> <p>Please answer the following two questions in OCaml comments:</p> <ol> <li> <p>What kind of process does this function represent    (linear recursive, linear iterative, tree recursive etc.)    and why?</p> </li> <li> <p>What is the space and time complexity of this function    with respect to its argument <code>n</code>?</p> </li> </ol> <ol> <li> <p>You will have to add the <code>in</code> keyword at the end of each definition when you embed them inside another function.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partB_evaluation/","title":"Part B: Evaluation (20 points)","text":"<p>In this section, write all answers inside OCaml comments. (If you don\u2019t, your <code>lab2.ml</code> file probably won\u2019t compile.)</p>"},{"location":"assignments/2/partB_evaluation/#1-desugaring-let","title":"1. Desugaring <code>let</code>","text":"<p>[10 points]</p> <p>Desugar the following (nonrecursive) <code>let</code> expressions to the equivalent <code>fun</code> expressions applied to arguments. You do not need to evaluate the resulting <code>fun</code> expressions. Use the OCaml interpreter to test that your desugared versions are equivalent to the original versions. (You don\u2019t have to prove this to anyone but yourself.)</p> <p>Note</p> <p>A non-recursive <code>let</code> / <code>and</code> form binds multiple values to the result of evaluating the corresponding expressions, but none of the binding expressions can depend on the other bindings. (In a recursive <code>let rec</code> / <code>and</code> form, any or all of the binding expressions can depend on any or all of the bindings.) A non-recursive <code>let</code> / <code>and</code> form is therefore equivalent to a function of more than one argument applied to its arguments, as discussed in the lectures.</p>"},{"location":"assignments/2/partB_evaluation/#a","title":"a.","text":"<pre><code>let x = 20\nand y = 2 * 4\nin x * (2 + y)\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#b","title":"b.","text":"<pre><code>let a = 1.0\nand b = 20.0\nand c = 3.0\nin sqrt (b *. b -. 4.0 *. a *. c)\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#c","title":"c.","text":"<p>For this problem, desugar all of the <code>let</code> expressions. Note that successive <code>let</code>/<code>in</code> forms are not the same as a <code>let</code>/<code>and</code> form with multiple <code>and</code>s, because expressions can depend on earlier bindings.</p> <pre><code>let x = 1 in\nlet y = 2 in\nlet z = 3 in\n  x * y * z\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#d","title":"d.","text":"<p>For this problem, desugar all of the <code>let</code> expressions.</p> <pre><code>let x = 1 in\nlet x = 2 in\nlet x = 3 in\n  x * x * x\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#2-desugaring-let-and-the-substitution-model","title":"2. Desugaring <code>let</code> and the substitution model","text":"<p>[5 points]</p> <p>Using the substitution model (including desugaring <code>let</code> to <code>fun</code>), evaluate the following expression. You may skip obvious steps (for instance, you can reduce <code>2 + 2</code> to <code>4</code> in a single step).</p> <p>Hint</p> <p>Desugar all the <code>let</code>s to <code>fun</code>s before doing anything else.</p> <p>Our evaluation took about 35 lines. Watch out for lambda shielding!</p> <pre><code>let x = 2 * 10\nand y = 3 + 4\nin\n  let y = 14 in\n  let z = 22 in\n    x * y * z\n</code></pre>"},{"location":"assignments/2/partB_evaluation/#3-why-doesnt-this-work","title":"3. Why doesn\u2019t this work?","text":"<p>[5 points]</p> <p>Ben Bitfiddle can\u2019t understand why the following code gives an error:</p> <pre><code>let x = 10\nand y = x * 2\nand z = y + 3\nin x + y + z\n</code></pre> <p>When Ben runs this (expecting the result to be 53), OCaml complains about <code>x</code> being an unbound value. \"That\u2019s not true!\" cries Ben angrily, \"<code>x</code> was bound on the first line!\". Explain why this doesn\u2019t work by first desugaring the <code>let</code> to a <code>fun</code>, and then explain in words why it can\u2019t work, by referring to the way expressions get evaluated (you don\u2019t need to evaluate the expression explicitly). Then show Ben a simple way to fix this code to make it do what he wants.</p>"},{"location":"assignments/2/partC_higher_order_functions/","title":"Part C. Higher-order functions (30 points)","text":"<p>In this section, use <code>num</code> as the numeric type for all operations unless otherwise indicated. For convenience, put this at the top of the file:</p> <pre><code>open Num\n</code></pre> <p>and define this helper function (really just an alias):</p> <pre><code>let ni = num_of_int     (* convert int -&gt; num *)\n</code></pre> <p>We will use <code>num</code> as the numeric type when we want either or both of arbitrarily large integers and rational numbers. Note that doing arithmetic on <code>num</code>s requires the use of the special <code>num</code> operators <code>+/</code>, <code>-/</code>, <code>*/</code>, <code>//</code> etc. The usual relational operators (<code>&lt;</code>, <code>&lt;=</code>, <code>=</code> etc.) will work if used on integers, but don't work with rational numbers, so use the <code>num</code> equivalents <code>&lt;/</code>, <code>&lt;=/</code>, <code>=/</code> in these cases.</p>"},{"location":"assignments/2/partC_higher_order_functions/#1-in-class-exercise-foldn","title":"1. In-class exercise: <code>foldn</code>","text":"<p>[3 points] (No collaboration)</p> <p>Here are two simple recursive functions:</p> <pre><code>let rec sum_to n =\n  if n = 0 then\n    0\n  else\n    n + sum_to (n - 1)\n\nlet rec fact n =\n  if n = 0 then\n    1\n  else\n    n * fact (n - 1)\n</code></pre> <p><code>sum_to</code> computes the sum of all numbers from <code>0</code> up to and including <code>n</code>. <code>fact</code> computes the factorial of <code>n</code> i.e. the product of all numbers from <code>1</code> up to and including <code>n</code>.</p> <p>It's pretty clear that the recursion pattern is very similar in both functions. In functional programming languages like OCaml, we like to capture recursion patterns in higher-order functions so we can re-use them again and again.</p> <p>Define a function called <code>foldn</code> (\"fold over integers up to n\") that encapsulates the recursion pattern of both <code>sum_to</code> and <code>fact</code>. Notice that the only things that change between these two functions are:</p> <ul> <li>the base case return value (<code>0</code> or <code>1</code>)</li> <li>the operator used in the recursive step (<code>+</code> or <code>*</code>)</li> </ul> <p>These will be arguments to <code>foldn</code>. Here is the skeleton of <code>foldn</code>:</p> <pre><code>let rec foldn op init =\n  fun n -&gt;\n    failwith \"TODO\"  (* replace this with your code *)\n</code></pre> <p>Write <code>foldn</code>. Once you've done this, the following definitions should give the same results as <code>sum_to</code> and <code>fact</code>:</p> <pre><code>let fact' = foldn ( * ) 1\nlet sum_to' = foldn ( + ) 0\n</code></pre> <p>We will see a more sophisticated version of <code>foldn</code> (called <code>accumulate</code>) below.</p>"},{"location":"assignments/2/partC_higher_order_functions/#2-isum-sicp-exercise-130","title":"2. <code>isum</code> (SICP exercise 1.30)","text":"<p>[5 points]</p> <p>The following <code>sum</code> function generates a linear recursion:</p> <pre><code>let rec sum term a next b =\n  if a &gt;/ b\n     then (ni 0)\n     else term a +/ (sum term (next a) next b)\n</code></pre> <p>(Recall that the <code>&gt;/</code> operator is comparison of <code>num</code>s and the <code>+/</code> operator is addition of <code>num</code>s.) <code>term</code> is a function of one argument which generates the current term in a sequence given a sequence value, while <code>next</code> is a function of one argument which generates the next value in the sequence. For instance:</p> <pre><code>sum (fun x -&gt; x */ x) (ni 1) (fun n -&gt; n +/ (ni 1)) (ni 10)\n</code></pre> <p>will compute the sum of all squares of the numbers 1 through 10 (expressed as <code>num</code>s).</p> <p>The function can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:</p> <pre><code>let isum term a next b =\n  let rec iter a result =\n    if &lt;??&gt;\n       then &lt;??&gt;\n       else iter &lt;??&gt; &lt;??&gt;\n  in\n    iter &lt;??&gt; &lt;??&gt;\n</code></pre> <p>Assume that <code>term</code> is a function of type <code>num -&gt; num</code>.</p> <p>Examples</p> <pre><code># let square n = n */ n ;;\nval square : Num.num -&gt; Num.num = &lt;fun&gt;\n# let step1 n = n +/ (ni 1) ;;\nval step1 : Num.num -&gt; Num.num = &lt;fun&gt;\n# isum square (ni 10) step1 (ni 0);;\n- : Num.num = &lt;num 0&gt;\n# isum square (ni 4) step1 (ni 4);;\n- : Num.num = &lt;num 16&gt;\n# isum square (ni 0) step1 (ni 10);;\n- : Num.num = &lt;num 385&gt;\n</code></pre>"},{"location":"assignments/2/partC_higher_order_functions/#3-product-sicp-exercise-131","title":"3. <code>product</code> (SICP exercise 1.31)","text":"<p>[5 points]</p> <ol> <li> <p>The <code>sum</code> function is only the simplest of a vast number of similar abstractions that can be captured as higher-order functions. Write an analogous function called <code>product</code> that returns the product of the values of a function at points over a given range. Show how to define <code>factorial</code> in terms of product. Also use <code>product</code> to compute approximations to \\(\\pi\\) (3.1415926...) using the formula:</p> \\[ \\frac{\\pi}{4} = \\frac{2 \\cdot 4 \\cdot 4 \\cdot 6 \\cdot 6 \\cdot 8}        {3 \\cdot 3 \\cdot 5 \\cdot 5 \\cdot 7 \\cdot 7} \\] </li> <li> <p>If your product function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p> </li> </ol> <p>Call your recursive <code>product</code> function <code>product_rec</code> and your iterative one <code>product_iter</code>. Define a version of <code>factorial</code> using both forms of <code>product</code>, calling one <code>factorial_rec</code> and the other <code>factorial_iter</code>.</p> <p>Warning</p> <p>Do not use recursion in your definitions of <code>factorial</code>. Using the higher-order function <code>product_rec</code> makes recursion unnecessary.</p> <p>Examples</p> <pre><code># factorial_rec (ni 0)\n- : Num.num = &lt;num 1&gt;\n# factorial_iter (ni 0)\n- : Num.num = &lt;num 1&gt;\n# factorial_rec (ni 10)\n- : Num.num = &lt;num 3628800&gt;\n# factorial_iter (ni 10)\n- : Num.num = &lt;num 3628800&gt;\n</code></pre> <p>Also write the code to generate an approximation to \\(\\pi\\) (using either the recursive or iterative version of <code>product</code>) by filling in the following definitions using the formula described above. Use at least 1000 terms from the product.</p> <pre><code>let pi_product n = &lt;??&gt;   (* infinite product expansion up to n terms *)\nlet pi_approx = &lt;??&gt;      (* defined in terms of pi_product *)\n</code></pre> <p>Tip</p> <p>For the purposes of this problem, consider a \"single term\" of the \\(\\pi\\) approximation to be two consecutive numerator numbers and two consecutive denominator numbers. So the first \"term\" would be </p> \\[ \\frac{2 \\cdot 4}{3 \\cdot 3} \\] <p>the second \"term\" would be</p> \\[ \\frac{4 \\cdot 6}{5 \\cdot 5} \\] <p>etc. Multiplying all the terms together gives the desired approximation to \\(\\pi\\).</p> <p>Note: This is a requirement of this problem. Even if you can define terms in a different way, don't.</p> <p>Question</p> <p>How large does <code>n</code> (the argument of <code>pi_approx</code>) have to be to give you at least 1000 terms?</p> <p>Use <code>num</code> as the numeric type for all operations except for the <code>pi_approx</code> value, which should be a <code>float</code>. Use the <code>float_of_num</code> function to convert from a rational approximation to pi (obtained by the formula given above) to a <code>float</code>. Note that we're using <code>num</code>s in this case because we want arbitrarily-precise rational numbers. Be careful to use <code>num</code> operators throughout!</p> <p>Warning</p> <p>Do not use recursion in your definition of <code>pi_product</code>.</p> <p>Note that none of these functions need to be more than a few lines long. (Our longest function for this problem is 7 lines long.)</p>"},{"location":"assignments/2/partC_higher_order_functions/#4-accumulate-sicp-exercise-132","title":"4. <code>accumulate</code> (SICP exercise 1.32)","text":"<p>[5 points]</p> <ol> <li> <p>Show that <code>sum</code> and <code>product</code> from the previous problems are both special cases of a still more general notion called <code>accumulate</code> that combines a collection of terms, using some general accumulation function:</p> <pre><code>accumulate combiner null_value term a next b\n</code></pre> <p><code>accumulate</code> takes as arguments the same term and range specifications as <code>sum</code> and <code>product</code>, together with a <code>combiner</code> function (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms, and a <code>null_value</code> that specifies what base value to use when the terms run out. Write <code>accumulate</code> and show how <code>sum</code> and <code>product</code> can both be defined as simple calls to <code>accumulate</code>. Assume that all numeric types are <code>num</code>.</p> </li> <li> <p>If your <code>accumulate</code> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p> </li> </ol> <p>Call the recursive <code>accumulate</code> function <code>accumulate_rec</code> and the iterative version <code>accumulate_iter</code>. You can use either form to define <code>sum</code> and <code>product</code>. Note that in order to use an operator as a function, you must wrap it in parentheses (this is useful when passing an operator as an argument to a function). If the operator name starts with an asterisk, you have to put a space between it and the open parenthesis so OCaml doesn't mistake it for a comment! In other words, write <code>( */ )</code> instead of <code>(*/)</code>.</p>"},{"location":"assignments/2/partC_higher_order_functions/#5-compose-sicp-exercise-142","title":"5. <code>compose</code> (SICP exercise 1.42)","text":"<p>[2 points]</p> <p>Let <code>f</code> and <code>g</code> be two one-argument functions. The composition of function \\(f\\) after \\(g\\) (often written \\(f \\circ g\\)) is defined to be the function \\(x \\mapsto f(g(x))\\). Define a function <code>compose</code> that implements composition.</p> <p>In the examples below, we use <code>int</code> instead of <code>num</code> as the numeric type. The type of <code>compose</code> doesn't depend on what numeric type we use.</p> <p>Examples</p> <pre><code># let square n = n * n;;\n# let inc n = n + 1;;\n# (compose square inc) 6\n- : int = 49\n# (compose inc square) 6\n- : int = 37\n</code></pre>"},{"location":"assignments/2/partC_higher_order_functions/#6-repeated-sicp-exercise-143","title":"6. <code>repeated</code> (SICP exercise 1.43)","text":"<p>[5 points]</p> <p>If \\(f\\) is a numerical function and \\(n\\) is a positive integer, then we can form the \\(n\\)th repeated application of \\(f\\), which is defined to be the function whose value at \\(x\\) is \\(f(f(\\ldots(f(x))\\ldots))\\) (with \\(n\\) \\(f\\)s).</p> <p>For example, if \\(f\\) is the function \\(x \\mapsto x + 1\\), then the \\(n\\)th repeated application of \\(f\\) is the function \\(x \\mapsto x + n\\). If \\(f\\) is the operation of squaring a number, then the \\(n\\)th repeated application of \\(f\\) is the function that raises its argument to the (\\(2n\\))th power.</p> <p>Write a function that takes as inputs a function that computes \\(f\\) and a positive integer \\(n\\) and returns the function that computes the \\(n\\)th repeated application of \\(f\\). Your function should be able to be used as follows:</p> <pre><code># (repeated square 2) 5\n- : int = 625\n</code></pre> <p>Tip</p> <p>You will find it convenient to use <code>compose</code> from the previous exercise in your definition of <code>repeated</code>.</p> <p>In the examples below, we use <code>int</code> instead of <code>num</code> as the numeric type. The type of <code>repeated</code> doesn't depend on what numeric type we use.</p> <p>Examples</p> <pre><code># let square n = n * n;;\n# (repeated square 0) 6\n- : int = 6\n# (repeated square 1) 6\n- : int = 36\n# (repeated square 2) 6\n- : int = 1296\n</code></pre> <p>Note that a function repeated 0 times is the identity function. If you do this right, the solution will be very short.</p>"},{"location":"assignments/2/partC_higher_order_functions/#7-smooth-and-nsmoothed-sicp-exercise-144","title":"7. <code>smooth</code> and <code>nsmoothed</code> (SICP exercise 1.44)","text":"<p>[5 points]</p> <p>The idea of smoothing a function is an important concept in signal processing. If \\(f\\) is a function of one (numerical) argument and \\(dx\\) is some small number, then the smoothed version of \\(f\\) is the function whose value at a point \\(x\\) is the average of \\(f(x - dx)\\), \\(f(x)\\), and \\(f(x + dx)\\).</p> <p>Write a function <code>smooth</code> that takes as input a function <code>f</code> and a <code>dx</code> value and returns a function (of one numerical argument) that computes the smoothed <code>f</code>.</p> <p>It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the \\(n\\)-fold smoothed function. Show how to generate the \\(n\\)-fold smoothed function of any given function using <code>smooth</code> and the <code>repeated</code> function you defined in the previous problem. Call this second function <code>nsmoothed</code>.</p> <p>For this problem, we use <code>float</code> instead of <code>num</code> as the numeric type.</p> <p>Hint</p> <p>Be careful with the <code>dx</code> argument to <code>nsmoothed</code>! It's actually more convenient to have <code>smooth</code> take the <code>dx</code> argument as its first argument, because you may need to partially apply <code>smooth</code> to <code>dx</code> in the definition of <code>nsmoothed</code> (at least, that's one way to do it).</p> <p>Note that both <code>smooth</code> and <code>nsmoothed</code> are very short if you write them the right way.</p> <p>Tip</p> <p><code>nsmoothed</code> can be tricky to write. If you get stuck, try writing two other functions: <code>smoothed2</code> (which smooths a function twice), and <code>smoothed3</code> (which smooths a function three times). Writing these functions will help you understand how you need to write <code>nsmoothed</code>. (You don't need to include the <code>smoothed2</code> or <code>smoothed3</code> functions as part of your assignment.)</p> <p>Here are some examples. Note that your results may not be identical; floating-point math is notoriously hard to reproduce between computers. However, your results should be pretty close to these.</p> <p>Examples</p> <pre><code>(* smooth examples *)\n\n(* smoothed sin function *)\n# let ssin = smooth 0.1 sin;;\nval ssin : float -&gt; float = &lt;fun&gt;\n# sin 0.0;;\n- : float = 0.\n# ssin 0.0;;\n- : float = 0.\n# sin 0.1;;\n- : float = 0.0998334166468281548\n# ssin 0.1;;\n- : float = 0.0995009158139631283\n# sin 1.0;;\n- : float = 0.841470984807896505\n# ssin 1.0;;\n- : float = 0.838668418165605112\n# sin 3.0;;\n- : float = 0.141120008059867214\n# ssin 3.0;;\n- : float = 0.14064999990238003\n# let pi = 4.0 *. atan 1.0;;\n# sin (pi /. 2.0);;\n- : float = 1.\n# ssin (pi /. 2.0);;\n- : float = 0.996669443518683806\n\n(* nsmoothed examples *)\n\n# let nssin n = nsmoothed 0.1 sin n\nval nssin : int -&gt; float -&gt; float = &lt;fun&gt;\n\n(* ssin0 is the same as sin *)\n# let ssin0 = nssin 0;;\nval ssin0 : float -&gt; float = &lt;fun&gt;\n# ssin0 (pi /. 2.0);;\n- : float = 1.\n# sin (pi /. 2.0);;\n- : float = 1.\n# ssin0 1.0;;\n- : float = 0.841470984807896505\n# sin 1.0;;\n- : float = 0.841470984807896505\n\n(* ssin1 is the same as ssin *)\n# let ssin1 = nssin 1;;\nval ssin1 : float -&gt; float = &lt;fun&gt;\n# ssin 1.0;;\n- : float = 0.838668418165605112\n# ssin1 1.0;;\n- : float = 0.838668418165605112\n# ssin 2.0;;\n- : float = 0.906268960387323297\n# ssin1 2.0;;\n- : float = 0.906268960387323297\n\n(* ssin10 is flatter than ssin1 *)\n# let ssin10 = nssin 10;;\nval ssin10 : float -&gt; float = &lt;fun&gt;\n# ssin10 1.0;;\n- : float = 0.813861644301632103\n# ssin1 1.0;;\n- : float = 0.838668418165605112\n# ssin1 (pi /. 2.0);;\n- : float = 0.996669443518683806\n# ssin10 (pi /. 2.0);;\n- : float = 0.96718919486859356\n</code></pre>"},{"location":"assignments/2/partD_additional_problems/","title":"Part D: Additional problems (10 points)","text":"<p>In this section, we\u2019ll write some functions that were referred to in the lectures but not defined.</p>"},{"location":"assignments/2/partD_additional_problems/#1-is_prime","title":"1. <code>is_prime</code>","text":"<p>[5 points]</p> <p>In lecture 5, we referred to a function called <code>is_prime</code> which returns <code>true</code> if an integer is a prime number and <code>false</code> otherwise. Write this function. For the purposes of the function, consider all negative numbers, zero, and 1 to be non-prime (and thus return <code>false</code> instead of e.g. raising an exception). Your function doesn\u2019t have to be maximally efficient, but it should have a time complexity of at most \\(\\Theta(\\sqrt{n})\\) for input \\(n\\).</p> <p>Hints</p> <p>For any input \\(n\\) you only have to check if numbers up to \\(\\sqrt{n}\\) can divide \\(n\\), since if they can't, no larger number can either, and so \\(n\\) must be prime.</p> <p>The OCaml builtin function <code>sqrt</code> works on <code>float</code>s only; you may find the functions <code>float_of_int</code> and <code>int_of_float</code> to be useful.</p>"},{"location":"assignments/2/partD_additional_problems/#2-smallest_prime_factor","title":"2. <code>smallest_prime_factor</code>","text":"<p>[5 points]</p> <p>In lecture 5, we also referred to a function called <code>smallest_prime_factor</code> which returns the smallest prime factor of a composite (non-prime) positive integer. Write this function. (You can use the <code>is_prime</code> function you defined above in the definition.) If the input number is prime or less than 2, raise an exception using the <code>invalid_arg</code> function. Again, we\u2019re not worried about maximal efficiency here, but your function must work properly.</p>"},{"location":"intro/motivation/","title":"Motivation","text":"<p>Here we'll talk about why we think you should learn the material in this course, and what you can hope to gain from taking it.</p>"},{"location":"intro/motivation/#what-are-the-goals-of-this-course","title":"What are the goals of this course?","text":"<p>Very broadly speaking, I would say that the goals of this course are:</p> <ol> <li>to make you a better programmer,</li> <li>to deepen your understanding of programming,</li> <li>to teach you to think about programming at a higher level,</li> <li>and to learn some beautiful ideas.</li> </ol> <p>We also hope that you have fun doing it, because programming should be fun! If it isn't fun, we're doing something wrong, and you should complain.<sup>1</sup></p> <p>The goals just given can be approached in many different ways. Programming is a big field, and there is no shortage of useful information on how to improve yourself as a programmer. Similarly, there are lots of beautiful ideas in programming, and we can't cover all of them in this course! What we can do is cover interesting and useful programming methods and ideas that most of you haven't encountered before. Some of these ideas are unfamiliar even to professional programmers who have been programming for a living for decades.</p> <p>If we can open your eyes to some of these ideas, if we help you see that there is more to programming than just grinding out solutions to problems, that programs can be beautiful as well as (ahem) functional, then we've done our job.</p> <p>Our way of approaching these goals will be to teach you a new way of writing programs, a way that is usually referred to as \"functional programming\".</p>"},{"location":"intro/motivation/#what-is-functional-programming","title":"What is functional programming?","text":"<p>What functional programming is will take many lectures to describe fully, but we can say a few things about it here.</p> <p>It's important to realize that functional programming isn't a yes/no proposition. There are many aspects of functional programming, and some languages support some of them but not others. Even languages that call themselves functional programming languages can have significant differences in how they implement these ideas. Conversely, languages that do not call themselves functional programming languages can still support many features of functional languages. Python is one such language; if you want to, you can program in a functional style in Python, for the most part. However, real \"functional languages\" make this style of programming more convenient and more efficient than languages that aren't specifically functional.</p> <p>The overall goal of functional programming is to make programming easier. This has two interrelated aspects. Compared to programs written in non-functional languages:</p> <ul> <li>programs are shorter</li> <li>programs have fewer bugs</li> </ul> <p>Some important aspects of functional languages that contribute to these goals include the following.</p> <ul> <li> <p>Functions are data,   and functions can be passed as arguments to other functions,   returned from functions,   created on-the-fly,   and stored into and retrieved from data structures.   Functions that take or return functions   are referred to as higher-order functions,   and they are massively useful!   They can drastically cut down on the amount of repeated code in programs,   which lets programs be shorter.   Also, since programming patterns can be captured in higher-order functions   and re-used in many different contexts,   once you've debugged a higher-order function   it will work correctly in many different contexts,   which means your programs will have fewer bugs.</p> </li> <li> <p>Functional programming emphasizes immutable data,   which means data that doesn't change.   Functional programmers prefer to compute new data than change old data.   So even things as basic as variables   (names whose values change as the program evolves) are discouraged,   which means that we need to find new ways to do   what we previously did with variables.   Functional languages also discourage mutable data structures like arrays   (where you can change the contents of a part of the data structure),   preferring immutable data structures   like singly-linked lists and immutable maps and sets   (where you can't change the contents of the data structure,   but you can create new ones that extend the old ones).   It turns out that avoiding variables and using immutable data structures   gets rid of large classes of potential bugs.</p> <p>Note</p> <p>Don't panic! Just because functional programming languages discourage the use of mutable variables and mutable data structures doesn't mean the languages don't have them.<sup>2</sup> It's just that you usually reserve them for situations where they really are the best choice, instead of just using them everywhere.</p> </li> <li> <p>Functional languages discourage the use of looping constructs,   preferring to use recursion or higher-order functions   to achieve the same effect.   This heavy use of recursion is quite startling   to new functional programmers,   but after a while it becomes as natural as using loops.   Also, unlike loops, recursive functions   are much less likely to have subtle off-by-one errors,   which means fewer bugs.</p> <p>Note</p> <p>Once again, \"discourage\" doesn't mean that looping constructs don't exist (at least, they exist in OCaml). But you never need them, so you almost never use them.</p> <p>Also, one hidden benefit of this course is that by the end of it, you will understand recursion completely, even if you're a bit fuzzy on it at the beginning.</p> </li> <li> <p>Most, but not all, functional languages are statically typed,   which means that they make sure that code has no type errors   before it executes.   Many non-functional languages are also statically typed   (for instance, C, C++, and Java),   but the type system of functional languages is much more powerful   (able to express more features of data in the type system),   and also easier to use   (because of type inference,   which means you rarely have to declare types in your code).   Most functional languages   also provide a very powerful pattern matching feature   that works with the type system;   this can lead to very concise code   which expresses the intent of the programmer in a clean and natural style.</p> <p>A powerful static type system, coupled with pattern matching, allows code to be shorter and have fewer bugs.</p> <p>Note</p> <p>In fact, some people will tell you that in functional languages, \"if it compiles, it works!\". Sadly, this isn't always true, but it's surprising how often this is the case.</p> </li> </ul>"},{"location":"intro/motivation/#why-learn-functional-programming","title":"Why learn functional programming?","text":"<p>We learn functional programming because:</p> <ul> <li>we want to write less code,</li> <li>we want our code to be correct,</li> <li>we want to think at a higher level,</li> <li>and we want our code to be beautiful!</li> </ul> <p>We've talked above about how functional programming contributes to the first two goals. Why should functional programs be more \"beautiful\" than code written in non-functional languages? How can functional languages allow us to think at a higher level? What does \"higher level\" even mean?</p> <p>These are aesthetic judgments, and reasonable people can disagree on this. In fact, you might be wondering why we should even care about how \"beautiful\" code is. I think a good point of comparison is with mathematical proofs. Most true statements in mathematics can be proved in more than one way. However, good mathematicians definitely favor certain kinds of proofs, which they call more \"beautiful\" or \"elegant\" than others. The mathematician Paul Erd\u00f6s used to talk about \"the Book\", which was where God kept the most perfect proofs of each theorem. There is even a whole book of such proofs, called, not surprisingly, Proofs from the Book.<sup>3</sup> And since computer programs are in some sense concrete crystallizations of mathematical ideas, if you can accept that some proofs are more \"beautiful\" than others, then it's also likely that some ways of writing code are more \"beautiful\" than others. But what would this elusive concept of \"code beauty\" entail?</p> <p>I think one important aspect of beautiful code is that it's lean \u2014 it has nothing superfluous in it. It's concise without being cryptic. It expresses the essence of a computation in as straightforward and clear a way as it can be expressed.</p> <p>The problem with this criterion is that what is \"straightforward\" and \"clear\" depends greatly on the way you've been taught to think about programming. And this is where the \"higher level thinking\" comes in. For example, Python is often praised as a language in which code is extremely clear and readable, and that's true, if you restrict yourself only to the kind of programming idioms that are found in Python (and in most other languages). But functional languages introduce a whole new set of idioms, and once you understand them, you can think at a higher level. And because of this, you can write better code.</p> <p>Here's a simple example. Let's write a function that takes a list of integers and returns a new list, where the new list has all the same numbers as the original list, but multiplied by 2. Also, the original list shouldn't be altered.</p> <p>In Python, you might write this function as follows:</p> <pre><code>def double_list(lst):\n    new_lst = lst[:]\n    for i in range(len(new_lst)):\n        new_lst[i] *= 2\n    return new_lst\n</code></pre> <p>This is pretty straightforward. You copy the list, and then go through each element of the new list, multiplying the element by 2 and storing the new value in place of the old value. Then you return the new list.</p> <p>In OCaml, you could write this function like this:</p> <pre><code>let double_list lst = List.map (fun x -&gt; x * 2) lst\n</code></pre> <p>In fact, you can write it even more concisely:</p> <pre><code>let double_list = List.map (fun x -&gt; x * 2)\n</code></pre> <p>What this is saying is \"take a function which doubles its argument (<code>fun x -&gt; x * 2</code>) and apply (map) it to each element of a list, collecting all the values in a new list\". This includes two ideas which are fundamental to functional languages: anonymous functions (the doubling function doesn't have a name), and mapping a function over a list (although other data structures can also be mapped over). The <code>map</code> function is also a \"higher-order\" function, since its first argument is itself a function. And once you understand these ideas, you can write more elegant code. In this case, we took five lines of Python and reduced them to one line of OCaml.</p> <p>I can't leave this without also mentioning that you can write this code in a functional style in Python as well:</p> <pre><code>def double_list(lst): return list(map(lambda x: x * 2, lst))\n</code></pre> <p>It's not quite as simple as the OCaml code, but it's pretty close.<sup>4</sup> (On the other hand, the OCaml code is type checked, but the Python code isn't.)</p> <p>So Python supports some (but not all) ideas from functional programming.<sup>5</sup> But a lot of Python programmers are unaware of this. So one benefit of learning functional programming is that you'll be able to use some of the functional programming ideas you learn in the languages you already know! In fact, it may totally change the way you write code even in non-functional languages. And the new code you write will be shorter and more elegant than the code you used to write.</p> <p>This is just a very simple example. CS 4 will show you many more kinds of beautiful code, and (more importantly) will teach you how to think about computational processes at a higher level, which will make the code you write better no matter what language you use.</p>"},{"location":"intro/motivation/#is-functional-programming-better-than-other-kinds-of-programming","title":"Is functional programming better than other kinds of programming?","text":"<p>It depends on the application.</p> <p>We love functional programming, but we are not zealots. Functional programming is a great fit for a lot of different programming tasks, but it isn't right for everything. Furthermore, in practice, language choice is usually much more likely to be made because of the availability of libraries than because of any intrinsic quality of the language.</p> <p>For instance, if you are programming graphical user interfaces (GUIs), you would probably be better off using Java than OCaml, because Java has more and better GUI libraries than OCaml does, and object-oriented programming has proven to be a good fit for this task. Or if you are doing numerical computations for machine learning or data science, you might be better off using Python with NumPy and Pandas, because those libraries are better suited for those tasks than anything in OCaml (at least currently).</p> <p>On the other hand, if you're doing anything that involves very complex algorithms, symbolic manipulations, or are writing an interpreter (e.g. if you take CS 131) or a compiler (e.g. if you take CS 164), functional programming and OCaml are a great fit. It takes time to learn which kinds of problems are best suited to which languages, but having a functional language in your toolkit is a good idea, not least because other languages (even Java!) keep borrowing ideas from functional languages.</p>"},{"location":"intro/motivation/#why-are-we-using-ocaml","title":"Why are we using OCaml?","text":"<p>There are a number of programming languages that are usually considered to be \"functional programming languages\". Why are we choosing to use OCaml instead of another one (say, Haskell)?</p> <p>There are three reasons for this:</p> <ol> <li> <p>OCaml contains all the features one would expect to have in a full-fledged functional programming language.</p> </li> <li> <p>OCaml is easier to learn than many other functional languages. In particular, it's easier to learn than Haskell. (But after learning OCaml, Haskell is a lot easier to learn; take CS 115 if you're interested in Haskell.)</p> </li> <li> <p>OCaml is not dogmatic. In addition to its functional features, OCaml also fully supports imperative and object-oriented programming, and sometimes, those features are exactly what you need in order to write the best code.</p> </li> </ol> <p>In addition to being a great on-ramp to the world of functional programming, OCaml is a useful language in its own right, and is used as a production language in a number of companies, including Jane Street Capital, Bloomberg, and Facebook.</p>"},{"location":"intro/motivation/#going-further","title":"Going further","text":"<p>If you want to go deeper into the world of functional programming after taking this course, take CS 115 and you'll learn Haskell and how it differs from the ideas you'll learn in CS 4. In some ways, Haskell is a \"super-OCaml\" which pushes functional programming ideas to their limits. In other ways (notably the module system and its multi-paradigm nature) OCaml still has the edge.</p> <p>Recently, the Rust programming language has become quite popular. Rust is a systems-level language which does not use garbage collection and which is used for computationally-intensive tasks. The Rust compiler was originally written in OCaml, but more interesting to us is that the Rust language has borrowed many features from OCaml, including algebraic datatypes, pattern matching and an emphasis on immutable data. If you want to learn Rust, learning OCaml is an excellent starting point. In fact, Rust is basically as close to a functional language as you can get without having garbage collection.</p> <p>Note</p> <p>There is a CS 11 Rust track which is taught in the Spring term, so take that if you are interested in Rust.</p> <p>In addition to Rust, there are other languages that are even closer to OCaml, including F#, which is a language very similar to OCaml for the .NET platform, and ReScript and ReasonML, which are OCaml dialects which compile to Javascript. All of these languages are used for very practical purposes (including web development), so they aren't just academic languages. And there are many other functional languages that share many features with OCaml, including Lisp dialects (Common Lisp, Scheme, Racket, and Clojure), Erlang dialects (Erlang itself and Elixir), and many others.</p> <p>Learning OCaml will make it much easier to learn any of these languages.</p> <ol> <li> <p>That is, except for the substitution model evaluations. Those aren't much fun, but we think that they're worth doing \u2014 once.\u00a0\u21a9</p> </li> <li> <p>At least, OCaml has them. Haskell, another well-known functional language, kind-of has them, but the story is more complicated. Take CS 115 to learn all about Haskell.\u00a0\u21a9</p> </li> <li> <p>However, to the best of our knowledge, God was not directly involved in the preparation of this book.\u00a0\u21a9</p> </li> <li> <p>You can make the Python code even shorter using list comprehensions:</p> <pre><code>def double_list(lst): return [x * 2 for x in lst]\n</code></pre> <p>OCaml doesn't have list comprehensions, though other functional languages (like Haskell) do. In fact, Python borrowed the idea of list comprehensions from Haskell.\u00a0\u21a9</p> </li> <li> <p>One very important idea from functional programming is called tail call optimization, which we'll be learning about. People have been begging Guido van Rossum (the author of Python) to add tail call optimization to Python for a long time, but so far he has vetoed it.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/welcome/","title":"Welcome to CS 4!","text":"<p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about the material. In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>coding notes and tips</li> <li>readings on particular topics</li> </ul> <p>and anything else we consider useful.</p> <p>Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>lecture slides</li> <li>code supplied to students for assignments</li> <li>exams (midterm and final)</li> </ul> <p>These will be posted on the course Canvas page, in the Modules section.</p>"},{"location":"intro/welcome/#instructor-and-course-staff","title":"Instructor and course staff","text":"<p>The course instructor is Mike Vanier (mvanier@cms.caltech.edu).</p> <p>The teaching assistants are listed in the syllabus. Their contact information will be posted on the course Canvas page.</p>"},{"location":"intro/welcome/#what-this-course-is-about","title":"What this course is about","text":"<p>This course is officially titled \"Fundamentals of Computer Programming\", but that's a vague name that says basically nothing about what the course is about. What this course actually is is an introduction to functional programming using the OCaml programming language.</p> <p>More importantly, this is a course on teaching you a new, better, and more enjoyable way of programming.<sup>1</sup> What this means will be fleshed out in the lectures and in the assignments.</p> <p>This course will be a bit disorienting and even mind-bending at times, but our primary goal is to expose you to new ideas, new ways of programming, and for you to have an enjoyable time learning. If you aren't having fun, we aren't doing our job right, so let us know what you don't like so we can improve it!</p> <p>For more general information about the course, please read the motivation page.</p> <ol> <li> <p>All opinions expressed are the views of the instructor and do not necessarily reflect the views of other instructors, other professors in the Caltech CMS department, or the majority of programmers and employers of programmers in the world.\u00a0\u21a9</p> </li> </ol>"},{"location":"readings/ocaml_cheat_sheet/","title":"OCaml syntax cheat sheet","text":"<p>OCaml is a great language, but its syntax is not its best feature. More importantly, the syntax is probably quite different from any other language you know, so getting comfortable with it will take some time.</p> <p>In this document we describe aspects of OCaml syntax that are most likely to be confusing and/or counterintuitive, as well as some other features which may trip you up. This document is not a complete description of OCaml syntax. For that, consult the lectures and the online OCaml documentation. We also refer you to the official OCaml cheat sheet which is here.</p> <p>Along the way, we will also sometimes mention non-syntactic aspects of OCaml that are confusing to new OCaml programmers.</p>"},{"location":"readings/ocaml_cheat_sheet/#operators","title":"Operators","text":""},{"location":"readings/ocaml_cheat_sheet/#operator-underloading","title":"Operator underloading","text":"<p>OCaml doesn't overload most of its operators. Notably, arithmetic operators like <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> are not overloaded. Instead, they are considered to be exclusively integer operators. The corresponding operators on floating-point numbers have an extra dot (<code>.</code>) at the end e.g. <code>+.</code>, <code>-.</code>, <code>*.</code> and <code>/.</code>. Confusingly, the floating-point power operator (<code>**</code>) doesn't have a dot at the end.</p> <pre><code># let sumsq x y = x *. x +. y *. y;;\nval sumsq : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre> <p>This is by far the most annoying aspect of OCaml's syntax. The reason for it is so that every operator has a very specific type, which makes type inference much simpler.</p>"},{"location":"readings/ocaml_cheat_sheet/#operator-overloading","title":"Operator overloading","text":"<p>On the other hand, OCaml does overload some operators. The comparison/equality operators (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) are all polymorphic, which means they work on arbitrary OCaml datatypes. (This is also true of the <code>max</code> and <code>min</code> functions.) One exception: you are not allowed to compare functional values, though you can check identity:</p> <pre><code># abs;;\n- : int -&gt; int = &lt;fun&gt;\n# abs == abs;;\n- : bool = true\n# abs = abs;;\nException: Invalid_argument \"compare: functional value\".\n# max abs abs;;\nException: Invalid_argument \"compare: functional value\".\n</code></pre> <p>We'll discuss equality comparisons and identity comparisons below.</p>"},{"location":"readings/ocaml_cheat_sheet/#operators-as-functions","title":"Operators as functions","text":"<p>This is a good feature, but it can be confusing as well. Operators can be converted into two-argument functions by wrapping parentheses around them. For instance, the operator <code>+</code> can be made into the two-argument function <code>(+)</code>.</p> <pre><code># (+);;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 + 3;;\n- : int = 5\n# (+) 2 3;;\n- : int = 5\n</code></pre> <p>The only time this causes problems is with the multiplication operators (<code>*</code>) and (<code>*.</code>), because if the left parenthesis is next to the asterisk OCaml thinks it's the start of a comment:</p> <pre><code># (*);;\nLine 1, characters 0-3:\n1 | (*);;\n    ^^^\nWarning 1: this `(*' is the start of a comment.\nHint: Did you forget spaces when writing the infix operator `( * )'?\n* *);;\n# ( * ) ;;\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# ( *);;\nLine 1, characters 2-4:\n1 | ( *);;\n      ^^\nWarning 2: this is not the end of a comment.\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>(Notice that after the first error the prompt changed to <code>*</code> (which means that OCaml thinks we're still inside a comment) and we had to manually insert a <code>*)</code> to close the comment.)</p> <p>Fortunately, here OCaml is smart enough to catch this problem and issue a warning. However, this doesn't always happen (see below).</p>"},{"location":"readings/ocaml_cheat_sheet/#equalityinequality-operators","title":"Equality/inequality operators","text":"<p>OCaml has two different equality operators and two different inequality operators:</p> <ul> <li>equality: <code>=</code> and <code>==</code></li> <li>inequality: <code>&lt;&gt;</code> and <code>!=</code></li> </ul> <p>Almost always, you want to use the <code>=</code> operator for equality testing and the <code>&lt;&gt;</code> operator for inequality testing. They test for structural equality i.e. whether one operand is equivalent to the other (or \"has the same contents\"). The <code>==</code> and <code>!=</code> operators check for identity i.e. whether two things are the exact same thing in memory. Even though this may sometimes work, it can lead to very difficult-to-find bugs. (It's unfortunate that the operators you shouldn't use in OCaml are the ones you should use in most other languages.)</p> <pre><code># \"foo\" = \"bar\";;\n- : bool = false\n# \"foo\" = \"foo\";;\n- : bool = true\n# \"foo\" == \"foo\";;\n- : bool = false   (* not the same object in memory! *)\n# \"foo\" &lt;&gt; \"bar\";;\n- : bool = true\n# \"foo\" != \"bar\";;\n- : bool = true\n# \"foo\" &lt;&gt; \"foo\";;\n- : bool = false\n# \"foo\" != \"foo\";;\n- : bool = true\n</code></pre> <p>Here, the two <code>\"foo\"</code>s are different objects in memory.</p> <pre><code># let x = \"foo\";;\nval x : string = \"foo\"\n# x = x;;\n- : bool = true\n# x == x;;\n- : bool = true\n</code></pre> <p>Here, <code>x</code> is equal to itself and is also the same object in memory as itself.</p>"},{"location":"readings/ocaml_cheat_sheet/#word-operators","title":"Word operators","text":"<p>OCaml has a number of infix operators which are words. Here they are:</p> Operator Description <code>mod</code> integer remainder (modulus) <code>asr</code> arithmetic shift right <code>lsr</code> logical shift right <code>lsl</code> logical shift left <code>land</code> logical (bitwise) AND <code>lor</code> logical (bitwise) OR <code>lxor</code> logical (bitwise) XOR <code>lnot</code> logical (bitwise) NOT <p>You probably won't need any of these except the <code>mod</code> operator, which is handy:</p> <pre><code># 5 mod 2;;\n- : int = 1\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#unusual-operators","title":"Unusual operators","text":"<p>The built-in OCaml operators are described in the documentation for the <code>Stdlib</code> library, which is here.</p> <p>Note especially the following operators:</p> Operator Description <code>^</code> string concatenation <code>^^</code> format string concatenation <code>@</code> list concatenation <code>~-</code> unary negation <code>~-.</code> unary float negation <code>@@</code> function application (<code>f @@ x</code> is the same as <code>f x</code>) <code>|&gt;</code> reverse function application (<code>x |&gt; f</code> is the same as <code>f x</code>) <code>!</code> dereference a <code>ref</code> cell <code>:=</code> assignment into a <code>ref</code> cell <p>Note that unary negation can also be indicated by a <code>-</code> or <code>-.</code> operator without a left-hand operand, if there is no ambiguity. The <code>~-</code> and <code>~-.</code> operators are strictly unary operators and can work in contexts where conventional unary negation doesn't:</p> <pre><code># -1;;\n- : int = -1\n# abs (-1);;\n- : int = 1\n# abs -1;;\nLine 1, characters 0-3:\n1 | abs -1;;\n    ^^^\nError: This expression has type int -&gt; int\n       but an expression was expected of type int\n</code></pre> <p>OCaml is telling you you can't subtract 1 from the <code>abs</code> function.</p> <pre><code># ~-1;;\n- : int = -1\n# abs ~-1;;\n- : int = 1\n</code></pre> <p>This works. Here's another example where these operators are handy:</p> <pre><code># List.map (~-) [1;2;3;4;5];;\n- : int list = [-1; -2; -3; -4; -5]\n</code></pre> <p>Nevertheless, most people don't bother with the unary negation operators and just add extra parentheses if needed.</p> <p>The function application operators are interesting. The reverse function application operator <code>|&gt;</code> is nearly always used to chain together a series of computations, each taking the result of the previous one:</p> <pre><code># open List;;\n# map (fun x -&gt; x * 2) [1; 2; 3; 4; 5];;\n- : int list = [2; 4; 6; 8; 10]\n# filter (fun x -&gt; x &gt; 5) (map (fun x -&gt; x * 2) [1; 2; 3; 4; 5]);;\n- : int list = [6; 8; 10]\n# List.fold_left max 0\n    (filter (fun x -&gt; x &gt; 5) (map (fun x -&gt; x * 2) [1; 2; 3; 4; 5]));;\n- : int = 10\n# [1; 2; 3; 4; 5]\n    |&gt; map (fun x -&gt; x * 2)\n    |&gt; filter (fun x -&gt; x &gt; 5)\n    |&gt; List.fold_left max 0;;\n- : int = 10\n</code></pre> <p>I'd argue that the last expression is much more readable than the second-last one. You read it as \"take the list from 1 to 5, double all the numbers, keep only the numbers that are greater than 5, and find the maximum\". (You don't have to line up the <code>|&gt;</code> operators, but it looks good that way.)</p> <p>The function call after a <code>|&gt;</code> gets one less argument than usual, which is supplied by the result of evaluating the expression before the <code>|&gt;</code>.</p> <p>The <code>@@</code> operator might seem useless since <code>f @@ x</code> is the same as <code>f x</code>. However, its precedence is extremely low, so the expression to the right of the <code>@@</code> will be evaluated before calling the function. This can allow us to drop some parentheses:</p> <pre><code># abs (-2 + 1);;\n- : int = 1\n# abs @@ (-2 + 1);;\n- : int = 1\n# abs @@ -2 + 1;;\n- : int = 1\n</code></pre> <p>Note that the expression <code>-2 + 1</code> is evaluated in the last case before calling the <code>abs</code> function. This can be useful if you have a lot of functions acting on the result of other functions. (Note that this is just like the <code>|&gt;</code> operator except that the function calls are arranged right-to-left instead of left-to-right.) Another example:</p> <pre><code># List.rev (List.sort compare [4;2;5;2;7;5;4;1;3;9;0]);;\n- : int list = [9; 7; 5; 5; 4; 4; 3; 2; 2; 1; 0]\n# List.rev @@ List.sort compare [4;2;5;2;7;5;4;1;3;9;0];;\n- : int list = [9; 7; 5; 5; 4; 4; 3; 2; 2; 1; 0]\n</code></pre> <p>One of the least-used operators is the <code>^^</code> operator, which concatenates strings used as format strings. We will talk about this below.</p> <p>Note that some libraries define their own operators (see below). For instance, the <code>Num</code> library defines operators on rational numbers: <code>+/</code>, <code>-/</code>, <code>*/</code>, and <code>//</code>. (These also work with arbitrary-precision integers, since the <code>Num</code> data type contains both these and arbitrary-precision rationals.)</p>"},{"location":"readings/ocaml_cheat_sheet/#defining-new-operators","title":"Defining new operators","text":"<p>Unusually for programming languages, OCaml allows you to define your own operators. All user-defined operators must be made from \"operator characters\" and get their operator precedence and associativity from the first character of the operator (if it is itself an operator).</p> <pre><code># let (++) x y = x * y;;\nval ( ++ ) : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 ++ 3;;\n- : int = 6\n# 1 + 2 ++ 3;;\n- : int = 9\n</code></pre> <p>Note that the <code>++</code> operator has the same precedence as the <code>+</code> operator, so the expression <code>1 + 2 ++ 3</code> is evaluated from left to right. Let's try this with a new operator that starts with the <code>*</code> character instead:</p> <pre><code># let (*+) x y = x * y;;\n* *);;\nLine 2, characters 2-4:\n2 | *);;\n      ^^\nError: Syntax error\n</code></pre> <p>Oops! We forgot that the <code>(*</code> characters will be interpreted as the start of a comment. Notice that we didn't even get an error message; the prompt just turned to a <code>*</code> (indicating that OCaml thought we were still in a comment). When we added the <code>*)</code> to terminate the comment, we got an unhelpful error message.</p> <pre><code># let ( *+ ) x y = x * y;;\nval ( *+ ) : int -&gt; int -&gt; int = &lt;fun&gt;\n# 2 *+ 3;;\n- : int = 6\n# 1 + 2 *+ 3;;\n- : int = 7\n</code></pre> <p>Now we see that the <code>*+</code> operator has the same precedence as the <code>*</code> operator.</p> <p>Tip</p> <p>When defining new operators, it's always a good idea to put a blank space after the <code>(</code> and before the <code>)</code> characters that surround the operator.</p> <p>You can even define unary prefix operators, as long as they start with the <code>!</code> character:</p> <pre><code># let ( !++ ) x = x := !x + 1;;\nval ( !++ ) : int ref -&gt; unit = &lt;fun&gt;\n# let r = ref 0;;\nval r : int ref = {contents = 0}\n# !++ r;;\n- : unit = ()\n# !r;;\n- : int = 1\n</code></pre> <p>We will have more to say about <code>ref</code> types below.</p>"},{"location":"readings/ocaml_cheat_sheet/#printf-and-format-strings","title":"<code>printf</code> and format strings","text":"<p>OCaml has a <code>printf</code> function (technically, <code>Printf.printf</code>) which has a number of pecularities. Check this out:</p> <pre><code># Printf.printf;;\n- : ('a, out_channel, unit) format -&gt; 'a = &lt;fun&gt;\n# Printf.printf \"%d\\n\";;\n- : int -&gt; unit = &lt;fun&gt;\n# \"%d\\n\";;\n- : string = \"%d\\n\"\n</code></pre> <p>So even though <code>\"%d\\n\"</code> appears to be just a string, somehow it can also be the first argument of <code>Printf.printf</code>, where it is somehow compatible with the type <code>('a, out_channel, unit) format</code>. What is actually happening is that OCaml is turning a literal string into a something that does not have the <code>string</code> type, but is instead something called a format string. You can actually convert strings to format strings manually, but do not expect to understand the process:</p> <pre><code># format_of_string;;\n- : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n&lt;fun&gt;\n# let fs = format_of_string \"%d\\n\";;\nval fs : (int -&gt; '_weak1, '_weak2, '_weak3, '_weak4, '_weak4, '_weak1) format6 =\n  CamlinternalFormatBasics.Format\n   (CamlinternalFormatBasics.Int (CamlinternalFormatBasics.Int_d,\n     CamlinternalFormatBasics.No_padding,\n     CamlinternalFormatBasics.No_precision,\n     CamlinternalFormatBasics.Char_literal ('\\n',\n      CamlinternalFormatBasics.End_of_format)),\n   \"%d\\n\")\n# Printf.printf fs;;\n- : int -&gt; unit = &lt;fun&gt;\n# Printf.printf fs 10;;\n10\n- : unit = ()\n</code></pre> <p>Note</p> <p>Another peculiarity is that <code>format_of_string</code> only works when the string argument is a literal string; its first argument is not actually a string. Don't worry about any of this!</p> <p>Regardless of the weird types that format strings have, when you give a (literal) format string as the first argument of <code>Printf.printf</code>, the result will have the correct type (here, <code>int -&gt; unit</code> because it takes an <code>int</code> and returns a value of type <code>unit</code>).</p> <p>Since format strings aren't strings, this doesn't work:</p> <pre><code># let fs = \"%d\\n\";;\nval fs : string = \"%d\\n\"\n# Printf.printf fs 10;;\nLine 1, characters 14-16:\n1 | Printf.printf fs 10;;\n                  ^^\nError: The value fs has type string but an expression was expected of type\n         ('a -&gt; 'b, out_channel, unit) format =\n           ('a -&gt; 'b, out_channel, unit, unit, unit, unit) format6\n</code></pre> <p>One issue with format strings is that sometimes you would like to be able to divide them over multiple lines. However, you can't just concatenate them as if they were strings:</p> <pre><code># Printf.printf (\"int: %d\\t\" ^ \"string: %s\\n\") 10 \"foo\";;\nLine 1, characters 14-44:\n1 | Printf.printf (\"int: %d\\t\" ^ \"string: %s\\n\") 10 \"foo\";;\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a -&gt; 'b -&gt; 'c, out_channel, unit) format =\n           ('a -&gt; 'b -&gt; 'c, out_channel, unit, unit, unit, unit) format6\n</code></pre> <p>Instead, you have to use the special format string concatenation operator <code>(^^)</code> to do the job:</p> <pre><code># Printf.printf (\"int: %d\\t\" ^^ \"string: %s\\n\") 10 \"foo\";;\nint: 10 string: foo\n- : unit = ()\n# (^^) ;;\n- : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt;\n    ('f, 'b, 'c, 'e, 'g, 'h) format6 -&gt; ('a, 'b, 'c, 'd, 'g, 'h) format6\n= &lt;fun&gt;\n# \"int: %d\\t\" ^^ \"string: %s\\n\";;\n- : (int -&gt; string -&gt; '_weak9, '_weak10, '_weak11, '_weak12, '_weak12,\n     '_weak9)\n    format6\n=\nCamlinternalFormatBasics.Format\n (CamlinternalFormatBasics.String_literal (\"int: \",\n   CamlinternalFormatBasics.Int (CamlinternalFormatBasics.Int_d,\n    CamlinternalFormatBasics.No_padding,\n    CamlinternalFormatBasics.No_precision,\n    CamlinternalFormatBasics.Char_literal ('\\t',\n     CamlinternalFormatBasics.String_literal (\"string: \",\n      CamlinternalFormatBasics.String (CamlinternalFormatBasics.No_padding,\n       CamlinternalFormatBasics.Char_literal ('\\n',\n        CamlinternalFormatBasics.End_of_format)))))),\n \"int: %d\\t%,string: %s\\n\")\n</code></pre> <p>Fortunately, you probably won't need this operator.</p>"},{"location":"readings/ocaml_cheat_sheet/#lists","title":"Lists","text":"<p>There are three important things you need to remember about lists in OCaml:</p> <ol> <li>All the elements of a list must be of the same type.</li> <li>You can't change the elements of a list.</li> <li>Elements are separated with semicolons (<code>;</code>), not commas.</li> </ol> <p>A very common pitfall is to use commas instead of semicolons, which not only doesn't do what you expect, but sometimes seems to work only to fail later while giving hilariously obscure type errors. We will see why in the section on tuples below. Remember: OCaml's syntax is different from Python's!</p> <p>There is a List module with many useful functions on lists.</p>"},{"location":"readings/ocaml_cheat_sheet/#arrays","title":"Arrays","text":"<p>Syntactically, arrays are exactly like lists except that they use different delimiters. Instead of <code>[</code> and <code>]</code> arrays use <code>[|</code> and <code>|]</code>. Here is a literal array:</p> <pre><code># let my_array = [| 1; 2; 3; 4; 5 |];;\nval my_array : int array = [|1; 2; 3; 4; 5|]\n</code></pre> <p>Notice that the array has type <code>int array</code>; the type of the elements is part of the type of the array.</p> <p>Accessing elements from arrays uses the unusual <code>&lt;array&gt;.(&lt;index&gt;)</code> syntax:</p> <pre><code># my_array.(0);;\n- : int = 1\n# my_array.(4);;\n- : int = 5\n# my_array.(5);;\nException: Invalid_argument \"index out of bounds\".\n</code></pre> <p>Mutating (changing) elements in an array also uses an unusual syntax:</p> <pre><code># my_array;;\n- : int array = [|1; 2; 3; 4; 5|]\n# my_array.(0) &lt;- 42;;\n- : unit = ()\n# my_array;;\n- : int array = [|42; 2; 3; 4; 5|]\n</code></pre> <p>There is an Array module with many useful functions on arrays.</p>"},{"location":"readings/ocaml_cheat_sheet/#tuples","title":"Tuples","text":"<p>A fundamental data type in OCaml is the tuple (pronounced \"too-ple\" or \"tup-ple\" depending on your preference; I prefer \"too-ple\"). It is nothing more than a sequence of arbitrary OCaml values wrapped in parentheses, separated by commas. Tuples can (and usually do) contain data of different types.</p> <p>Note</p> <p>Tuples exist in Python too, but in that language they are almost superfluous, being basically a restricted form of lists. In OCaml, tuples are necessary because lists can only contain one type of data, whereas tuples can contain arbitrarily-typed data.</p>"},{"location":"readings/ocaml_cheat_sheet/#type-notation","title":"Type notation","text":"<p>The notation for tuple types is a bit weird; they are written as the product of the individual types:</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n</code></pre> <p>This tuple has the type <code>int * string * float</code>, which is a type-theoretic \"product\" of the individual types. This notion of \"product\" is basically the same as the set-theoretic notion, but don't worry about that. Just make sure you realize that this use of the <code>*</code> operator doesn't represent multiplication.</p>"},{"location":"readings/ocaml_cheat_sheet/#implicit-parentheses","title":"Implicit parentheses","text":"<p>Unfortunately, OCaml (like Python) allows you to omit the parentheses in many situations:</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n# 1, \"foo\", 3.14;;\n- : int * string * float = (1, \"foo\", 3.14)\n# let tup = (1, \"foo\", 3.14);;\nval tup : int * string * float = (1, \"foo\", 3.14)\n# let tup = 1, \"foo\", 3.14;;\nval tup : int * string * float = (1, \"foo\", 3.14)\n</code></pre> <p>\"So what?\", you say. \"What's the big deal?\" Well, look at this code:</p> <pre><code># [1; 2; 3];;\n- : int list = [1; 2; 3]\n</code></pre> <p>This is the correct way to write a list, using semicolons as separators. A common error is to write lists with commas, which gives this:</p> <pre><code># [1, 2, 3];;\n- : (int * int * int) list = [(1, 2, 3)]\n</code></pre> <p>Note that this is not a syntax error! Instead, OCaml has interepreted the commas as meaning a tuple, so it thinks you want a list with a single element which is a 3-tuple. Then, when you try to use this list, it will not do what you expect, and the error messages will probably not be very helpful.</p> <p>We recommend that you never write a tuple without explicit parentheses. However, this will not fix the problem above, because OCaml will still interpret the wrongly-written \"list\" as a list of N-tuples. Ultimately, you just have to be able to recognize this problem for what it is, and learn to write lists the right way.</p>"},{"location":"readings/ocaml_cheat_sheet/#commas-vs-semicolons","title":"Commas vs. semicolons","text":"<p>What about the opposite problem: writing a tuple with semicolons as separators instead of using commas?</p> <pre><code># (1, \"foo\", 3.14);;\n- : int * string * float = (1, \"foo\", 3.14)\n# (1; \"foo\"; 3.14);;\nLine 1, characters 1-2:\n1 | (1; \"foo\"; 3.14);;\n     ^\nWarning 10: this expression should have type unit.\nLine 1, characters 4-9:\n1 | (1; \"foo\"; 3.14);;\n        ^^^^^\nWarning 10: this expression should have type unit.\n- : float = 3.14\n</code></pre> <p>A parenthesized expression with semicolon separators is a sequence expression, which is mainly used in imperative code. (You can also write them with <code>begin</code>/<code>end</code> delimiters instead of parentheses, which we prefer.) In a sequence expression, all but the last subexpression should have type <code>unit</code>, or you get warnings (as you see above). You probably won't run into this pitfall, but you should be aware of it. We will talk about sequence expressions more below when we discuss imperative programming.</p>"},{"location":"readings/ocaml_cheat_sheet/#records","title":"Records","text":"<p>Records are basically a generalization of tuples where each component of the record has a name (called a \"field name\", so each component is a \"field\" of the record). You need to define a record type before using a record.</p> <pre><code>type my_record = { foo : int; bar : string }\n</code></pre> <p>Then you can create records by giving the field names and the values like this:</p> <pre><code>let a_record = { foo = 10; bar = \"ten\" }\n</code></pre> <p>You can extract the contents of a record using the \"dot notation\" as in most programming languages:</p> <pre><code>Printf.printf \"foo field: %d\\n\" a_record.foo\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#pattern-matching-and-field-punning","title":"Pattern matching and field punning","text":"<p>To pattern match on a record, you give the field names and corresponding variable names that you choose.</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x = x_coord; y = y_coord } = x_coord + y_coord\n</code></pre> <p>Note that <code>x</code> and <code>y</code> are field names here, and <code>x_coord</code> and <code>y_coord</code> are variable names you chose for this function.</p> <p>Note that the field names don't have to come in any particular order:</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { y = y_coord; x = x_coord } = x_coord + y_coord\n</code></pre> <p>A shortcut is to use the field name as a variable name. This is called field punning.</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x; y } = x + y\n(* Also OK: let sum_xy { y; x } = x + y *)\n</code></pre> <p>This is exactly equivalent to:</p> <pre><code>type point = { x : int; y : int }\nlet sum_xy { x = x; y = y } = x + y\n</code></pre> <p>but shorter.</p>"},{"location":"readings/ocaml_cheat_sheet/#matching-a-part-of-a-record","title":"Matching a part of a record","text":"<p>Often, we only need part of a record. You could write code like this:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x = x_coord; y = y_coord } = x_coord\n</code></pre> <p>but you might get a warning about unused variable names. The solution is to use the <code>_</code> syntax:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x = x_coord; _ } = x_coord\n</code></pre> <p>The <code>_</code> means \"all other fields in the record, which we don't care about\".</p> <p>With field punning, this becomes:</p> <pre><code>type point = { x : int; y : int }\nlet point_x { x; _ } = x\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#strings","title":"Strings","text":"<p>Strings are pretty standard in OCaml, except that the notation for accessing characters in a string is weird:</p> <pre><code># let s = \"this is a string\";;\nval s : string = \"this is a string\"\n# s.[0];;\n- : char = 't'\n# s.[9];;\n- : char = ' '\n</code></pre> <p>OCaml treats strings like a kind of specialized array. Strings are immutable. (There is a mutable string type called <code>bytes</code> if you really need that.)</p>"},{"location":"readings/ocaml_cheat_sheet/#conditionals","title":"Conditionals","text":""},{"location":"readings/ocaml_cheat_sheet/#if-expressions","title":"<code>if</code> expressions","text":"<p>In most programming languages, <code>if</code> is a statement, but in functional languages like OCaml, <code>if</code> is an expression. This means that an <code>if</code> expression returns a value. This is nice in that you can use <code>if</code> expressions anywhere an expression is desired. For instance, this function computes the ratio of the maximum and minimum of two floats:</p> <pre><code>let scale x y = (if x &gt; y then x else y) /. (if x &gt; y then y else x)\n</code></pre> <p>(Note the <code>/.</code> operator for float division.) This is not the most elegant way to write this function, but it illustrates that <code>if</code> expressions can be embedded in larger expressions.</p> <p>Since <code>if</code> is an expression, <code>if</code> expressions must have a specific type regardless of whether the test clause of the <code>if</code> returns <code>true</code> or <code>false</code>. Therefore, both branches of the <code>if</code> (the <code>then</code> branch and the <code>else</code> branch) must be expressions which have the exact same type. Something like this is not legal:</p> <pre><code># let a = 10;;\nval a : int = 10\n# let b = 20;;\nval b : int = 20\n# if a &gt; b then \"success\" else 0;;\nLine 1, characters 29-30:\n1 | if a &gt; b then \"success\" else 0;;\n                                 ^\nError: This expression has type int but an expression was expected of type\n         string\n</code></pre> <p>This is easy to understand, but things are not always so clear, as we will see.</p>"},{"location":"readings/ocaml_cheat_sheet/#if-without-else","title":"<code>if</code> without <code>else</code>","text":"<p>OCaml allows you to have an <code>if</code> expression without an <code>else</code> clause, but if you do that, the <code>then</code> clause must have type <code>unit</code>.</p> <pre><code># let a = 10;;\nval a : int = 10\n# if a &gt; 5 then Printf.printf \"big!\\n\";;\nbig!\n- : unit = ()\n</code></pre> <p>This works because <code>printf</code> has a return type of <code>unit</code>. But this won't work:</p> <pre><code># let b = if a &gt; 5 then 10;;\nLine 1, characters 22-24:\n1 | let b = if a &gt; 5 then 10;;\n                          ^^\nError: This expression has type int but an expression was expected of type\n         unit\n       because it is in the result of a conditional with no else branch\n</code></pre> <p>Both branches of a conditional must have the same type, and if you leave out the <code>else</code> branch, its type is assumed to be <code>unit</code>. In other words, <code>if</code> without <code>else</code> is desugared as follows. This:</p> <pre><code>if &lt;bool_expr&gt; then &lt;then_expr&gt;\n</code></pre> <p>is equivalent to this:</p> <pre><code>if &lt;bool_expr&gt; then &lt;then_expr&gt; else ()\n</code></pre> <p>When you think about it, this makes perfect sense. Normally you would only want to do an <code>if</code>-without-<code>else</code> if you are writing imperative code in the <code>then</code> clause (see below).</p>"},{"location":"readings/ocaml_cheat_sheet/#else-if","title":"<code>else if</code>","text":"<p>Technically, OCaml doesn't have an <code>else if</code> construct. However, if you're careful you can use it anyway:</p> <pre><code># let abs x =\n  if x &lt; 0 then\n    -x\n  else if x &gt; 0 then\n    x\n  else 0;;\nval abs : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>What's actually happening is that there are two nested <code>if</code> expressions:</p> <pre><code># let abs x =\n  if x &lt; 0 then\n    -x\n  else\n    (if x &gt; 0 then\n       x\n     else 0);;\n</code></pre> <p>As long as you can write your code as a sequence of nested <code>if</code> expressions like this, it will work as you expect. But if you put something more complicated in one of the <code>then</code> or <code>else</code> clauses (like another <code>if</code> expression) you may have to wrap parentheses or a <code>begin</code>/<code>end</code> pair around the inner expression:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\"\n    (* no else! *)\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\nval test : int -&gt; unit = &lt;fun&gt;\n# test 15;;\ninner if\n- : unit = ()\n# test 9;;\n- : unit = ()\n</code></pre> <p>Note that <code>test 9</code> doesn't print anything, though we might expect it to print <code>\"outer if 1\"</code>. The code above is parsed as follows:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      (if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\"\n       else if n mod 3 = 0 then\n         Printf.printf \"outer if 1\\n\"\n       else\n         Printf.printf \"outer if 2\\n\")\n  ;;\n</code></pre> <p>which is probably not what was intended. To fix it, insert either parentheses or a <code>begin</code>/<code>end</code> pair to disambiguate it:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      (if n mod 3 = 0 then\n        Printf.printf \"inner if\\n\")\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\nval test : int -&gt; unit = &lt;fun&gt;\n# test 15;;\ninner if\n- : unit = ()\n# test 9;;\nouter if 1\n- : unit = ()\n# test 8;;\nouter if 2\n- : unit = ()\n</code></pre> <p>With <code>begin</code>/<code>end</code> it looks like this:</p> <pre><code># let test n =\n    if n mod 5 = 0 then\n      begin\n        if n mod 3 = 0 then\n          Printf.printf \"inner if\\n\"\n      end\n    else if n mod 3 = 0 then\n      Printf.printf \"outer if 1\\n\"\n    else\n      Printf.printf \"outer if 2\\n\"\n  ;;\n</code></pre> <p>Either are acceptable.</p> <p>If OCaml's <code>else if</code> situation makes you uneasy, there is a perfectly reasonable alternative... that will probably also make you uneasy! It's a way of using OCaml's <code>match</code> form that is like a sequence of <code>if</code>/<code>else if</code>/<code>else</code> forms. Example:</p> <pre><code>let abs n =\n  match () with\n    | _ when n &gt; 0 -&gt; n\n    | _ when n &lt; 0 -&gt; -n\n    | _ -&gt; 0\n</code></pre> <p>We match against <code>()</code> because we don't care about the value matched; that's also why we use the <code>_</code> in each clause of the match. Instead, we're using the <code>match</code> form solely because of the ability to use <code>when</code> pattern guards; these contain the actual logic. This can often be a bit more concise and clean than an actual <code>else if</code>, but be careful: if you need to do another <code>match</code> in the expression following the right arrow (<code>-&gt;</code>) you may have to wrap it in parentheses or a <code>begin</code>/<code>end</code> form (see below for why).</p>"},{"location":"readings/ocaml_cheat_sheet/#functions","title":"Functions","text":"<p>OCaml is a functional language, so functions are fundamental. There are a number of unusual features of OCaml functions.</p>"},{"location":"readings/ocaml_cheat_sheet/#syntax-and-currying","title":"Syntax and currying","text":"<p>Unlike most conventional languages, OCaml doesn't require you to put parentheses around the arguments to a function. In fact, if you do, you change the meaning! Consider this innocent-looking function:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n# add 2 3;;\n- : int = 5\n# add (2 + 3) (3 + 4);;\n- : int = 12\n</code></pre> <p>OK, so we can get by without parentheses around the arguments. (The parentheses in the last line are to create the arguments, not to surround them for the function call.) What if we use them anyway?</p> <pre><code># add (2, 3);;\nLine 1, characters 4-10:\n1 | add (2, 3);;\n        ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n</code></pre> <p>Nope, that isn't correct. The error message may confuse you. Let's see a variation:</p> <pre><code># let add' (x, y) = x + y;;\nval add' : int * int -&gt; int = &lt;fun&gt;\n# add' (2, 3);;\n- : int = 5\n</code></pre> <p>(Note that in OCaml, you can use the <code>'</code> character (pronounced \"prime\") in identifiers.)</p> <p>If we define the function with parentheses, we have to call it with parentheses. If not:</p> <pre><code># add' 2 3;;\nLine 1, characters 0-4:\n1 | add' 2 3;;\n    ^^^^\nError: This function has type int * int -&gt; int\n       It is applied to too many arguments; maybe you forgot a `;'.\n</code></pre> <p>Huh. What is really going on here?</p> <p>Look at the second version again:</p> <pre><code># let add' (x, y) = x + y;;\nval add' : int * int -&gt; int = &lt;fun&gt;\n</code></pre> <p>Look at the type signature. The <code>int * int</code> part says that the input to the function is a single argument which must be a two-tuple (a tuple with two elements), where both elements are <code>int</code>s. If you leave the arguments \"naked\", they don't form a two-tuple, and there are two arguments, not one. This explains the error message. Now look at the first version:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>The type signature is a bit odd. Since the <code>-&gt;</code> type operator associates to the right, this is equivalent to:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; (int -&gt; int) = &lt;fun&gt;\n</code></pre> <p>This is an example of what's called currying. What the type signature means is that the <code>add</code> function actually only takes a single argument (an <code>int</code>) and returns a function of type <code>int -&gt; int</code>. If you call the function with both arguments, the function returned by applying <code>add</code> to the first argument (which has type <code>int -&gt; int</code>) is immediately applied to the second argument (of type <code>int</code>) to give the result, which is an <code>int</code>. So this function call:</p> <pre><code># add 2 3;;\n- : int = 5\n</code></pre> <p>is actually this:</p> <pre><code># (add 2) 3;;\n- : int = 5\n</code></pre> <p>And if we leave out the second argument, we get this:</p> <pre><code># add 2;;\n- : int -&gt; int = &lt;fun&gt;\n</code></pre> <p>which shows currying in action. We can use this function:</p> <pre><code># let add2 = add 2;;\nval add2 : int -&gt; int = &lt;fun&gt;\n# add2 3;;\n- : int = 5\n</code></pre> <p>Curried functions are often useful to create a partially-evaluated function whose final value will be supplied later. For instance:</p> <pre><code># List.map (add 2) [1; 2; 3; 4; 5]\n- : int list = [3; 4; 5; 6; 7]\n</code></pre>"},{"location":"readings/ocaml_cheat_sheet/#anonymous-functions","title":"Anonymous functions","text":"<p>Functions are a kind of data in functional languages like OCaml, and you can define function values directly using the <code>fun</code> expression. So instead of writing:</p> <pre><code># let add x y = x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>we could write the definition like this:</p> <pre><code># let add = fun x y -&gt; x + y;;\nval add : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre> <p>The meaning is exactly the same. We say that the first form is syntactic sugar for the latter form. We can even use a <code>fun</code> expression without giving it a name at all:</p> <pre><code># (fun x y -&gt; x + y) 2 3;;\n- : int = 5\n</code></pre> <p>Therefore, we say that the <code>fun</code> form defines an anonymous function. Anonymous functions are often used with higher-order functions (functions that take functions as input and/or return functions as output).</p> <p>Note also that because of currying, the function</p> <pre><code>fun x y -&gt; x + y\n</code></pre> <p>is the same as:</p> <pre><code>fun x -&gt; fun y -&gt; x + y\n</code></pre> <p>You should think of the first form as syntactic sugar for the second.</p>"},{"location":"readings/ocaml_cheat_sheet/#unused-arguments","title":"Unused arguments","text":"<p>If you define a function which doesn't use one (or more) of its arguments, and strict warning settings are enabled (as they are in the <code>Makefile</code>s for most assignments, but not by default in <code>utop</code>) you will get a warning. You can even see this in <code>utop</code> if you enable warnings:</p> <pre><code>$ utop -w A\n# let f s z = z;;\nWarning 27 [unused-var-strict]: unused variable s.\nval f : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n</code></pre> <p>(The <code>-w A</code> argument to <code>utop</code> turns on all compiler warnings.)</p> <p>The way to fix this is simply to replace each unused argument with <code>_</code>:</p> <pre><code>$ utop -w A\n# let f _ z = z;;\nval f : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n</code></pre> <p>Now the warning has disappeared.</p>"},{"location":"readings/ocaml_cheat_sheet/#match-expressions","title":"<code>match</code> expressions","text":"<p>OCaml <code>match</code> expressions are pretty straightforward. They have a couple of subtleties you should know about.</p>"},{"location":"readings/ocaml_cheat_sheet/#optional-before-first-match","title":"Optional <code>|</code> before first match","text":"<p>In a <code>match</code> expression, the alternatives are separated by a vertical bar character (<code>|</code>). You can also (optionally) put a vertical bar character before the first pattern to be matched. This often makes the code look cleaner. Compare:</p> <pre><code>let rec sum_list lst =\n  match lst with\n      [] -&gt; []\n    | h :: t -&gt; h + sum_list t\n</code></pre> <p>with</p> <pre><code>let rec sum_list lst =\n  match lst with\n    | [] -&gt; []\n    | h :: t -&gt; h + sum_list t\n</code></pre> <p>These two functions are identical in terms of their functionality, but the code for the second looks cleaner because of the extra <code>|</code> before the first match.</p>"},{"location":"readings/ocaml_cheat_sheet/#nested-match-expressions","title":"Nested match expressions","text":"<p>It's not uncommon to want to put a <code>match</code> expression inside another <code>match</code> expression. If you do, you have to be careful with the inner <code>match</code> expression so that its clauses aren't confused with the outer <code>match</code>'s clauses. Here's an example from the internet:</p> <pre><code>let rec filter exp =\n  match exp with\n    | Var v -&gt; Var v\n    | Sum(e1, e2) -&gt; Sum(e1, e2)\n    | Prod(e1, e2) -&gt; Prod(e1, e2)\n    | Diff(e1, e2) -&gt;\n      match e2 with  (* nested match *)\n        | Sum(e3, e4) -&gt; filter (diffRule e2)\n        | Diff(e3, e4) -&gt; filter (diffRule e2)\n        | _ -&gt; filter e2\n    (* Oops! These following clauses should belong to the outer match, but\n       they actually belong to the inner match. *)\n    | Quot(e1, e2) -&gt;\n        match e2 with\n        | Quot(e3, e4) -&gt; filter (quotRule e2)\n        | Prod(e3, e4) -&gt; filter (quotRule e2)\n        | _ -&gt; filter e2\n</code></pre> <p>The solution is to wrap the inner <code>match</code> using parentheses or <code>begin</code>/<code>end</code>. For instance:</p> <pre><code>let rec filter exp =\n  match exp with\n    | Var v -&gt; Var v\n    | Sum(e1, e2) -&gt; Sum(e1, e2)\n    | Prod(e1, e2) -&gt; Prod(e1, e2)\n    | Diff(e1, e2) -&gt;\n      begin\n        match e2 with  (* nested match *)\n          | Sum(e3, e4) -&gt; filter (diffRule e2)\n          | Diff(e3, e4) -&gt; filter (diffRule e2)\n          | _ -&gt; filter e2\n      end\n    | Quot(e1, e2) -&gt;\n        match e2 with\n        | Quot(e3, e4) -&gt; filter (quotRule e2)\n        | Prod(e3, e4) -&gt; filter (quotRule e2)\n        | _ -&gt; filter e2\n</code></pre> <p>Now it will do what it's supposed to. This is the most common mistake with pattern matching, so make sure you are aware of it.</p>"},{"location":"readings/ocaml_cheat_sheet/#function-expressions","title":"<code>function</code> expressions","text":"<p>This kind of pattern is extremely common:</p> <pre><code>let rec &lt;function name&gt; &lt;arg&gt; =\n  match &lt;arg&gt; with\n    | &lt;pattern 1&gt; -&gt; ...\n    | &lt;pattern 2&gt; -&gt; ...\n    ...\n</code></pre> <p>For instance, the <code>sum_list</code> function above is an example of this pattern. The essence of this pattern is that you pattern match on the last argument. Sometimes you have more arguments:</p> <pre><code>let rec &lt;function name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; =\n  match &lt;argN&gt; with\n    | &lt;pattern 1&gt; -&gt; ...\n    | &lt;pattern 2&gt; -&gt; ...\n    ...\n</code></pre> <p>Whenever you have a function that pattern matches on its last argument, you can rewrite it using the <code>function</code> keyword. This is like an automatic <code>match</code> on the last argument. The patterns above would be written like this using <code>function</code>:</p> <pre><code>let rec &lt;function name&gt; = function (* leave off &lt;arg&gt; *)\n  | &lt;pattern 1&gt; -&gt; ...\n  | &lt;pattern 2&gt; -&gt; ...\n  ...\n\nlet rec &lt;function name&gt; &lt;arg1&gt; &lt;arg2&gt; ... = function (* leave off &lt;argN&gt; *)\n  | &lt;pattern 1&gt; -&gt; ...\n  | &lt;pattern 2&gt; -&gt; ...\n  ...\n</code></pre> <p>Rewriting <code>sum_list</code> using <code>function</code> gives this:</p> <pre><code>let rec sum_list = function (* leave off &lt;arg1&gt; *)\n  | [] -&gt; []\n  | h :: t -&gt; h + sum_list t\n</code></pre> <p>This way of writing functions has advantages and disadvantages. The advantage is that it's more concise. The disadvantage is that you have to remember that the <code>function</code> keyword means that the function you are defining has an extra argument that doesn't have a name. Also, if you do need the name of the argument inside the body of the function, you can't use <code>function</code>. <code>function</code> is mostly used for simple functions of a simple argument where the only thing you do with the argument is pattern match on it. It's never necessary, though, so feel free to write all your code without it if you don't like it.</p>"},{"location":"readings/ocaml_cheat_sheet/#the-fragile-pattern-match-compiler-warning","title":"The \"fragile pattern match\" compiler warning","text":"<p>We like to compile OCaml code with most of the warning settings enabled. This provides a lot of suggestions for fixing problematic code which is still technically correct. You can turn on all compiler warnings by compiling with the <code>-w A</code> (<code>A</code> means \"all\") command-line option. This works both for <code>ocamlc</code> and for the interactive interpreters <code>ocaml</code> and <code>utop</code>.</p> <p>Note</p> <p>We don't necessarily recommend the <code>-w A</code> option for routine use with interactive interpreters, because some warnings would cause problems with normal use of interpreters, such as redefining datatypes.</p> <p>One particular compiler warning can be very confusing. Consider this code:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n\nlet get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | _ -&gt; 0\n</code></pre> <p>With warnings enabled, this gives this warning:</p> <pre><code>Warning 4 [fragile-match]: this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type foo.\nval get_foo_int : foo -&gt; int = &lt;fun&gt;\n</code></pre> <p>What this is complaining about is the last line in the <code>get_foo_int</code> function: <code>| _ -&gt; 0</code>. The intent of this line is to say that for all constructors except the <code>Bar</code> constructor, return the integer <code>0</code>. This is not incorrect code! On the other hand, let's say we modified the <code>foo</code> type to have another constructor that contained an <code>int</code> value:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n  | Boom of int\n</code></pre> <p>but we forgot to change the <code>get_foo_int</code> function. The function will still work, but it won't do the right thing. You would probably want to change it to this:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Boom i -&gt; i\n    | _ -&gt; 0\n</code></pre> <p>so that any constructor with an <code>int</code> value has the <code>int</code> value returned. But since the old code still compiles, you won't know that you need to make this change.</p> <p>This is what a \"fragile pattern match\" means: it's a catch-all case that matches more than one constructor, so if you happen to add more constructors to the datatype, it will match those as well.  What you would like it to do is to warn you: \"Hey!  I've never seen the <code>Boom</code> case before, and you're not handling it, so that's probably an error!\" The way to do this is to explicitly handle all constructors in the original function.</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo -&gt; 0\n    | Baz _ -&gt; 0\n</code></pre> <p>Then the warning will go away. On the other hand, it's annoying to have to write the same value (here, <code>0</code>) for two cases. In this case, we can use the \"fall through\" mechanism of pattern matching to make the code simpler:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo   (* no `-&gt;` so fall through to next case *)\n    | Baz _ -&gt; 0\n</code></pre> <p>And we can write all the catch-all cases on one line:</p> <pre><code>let get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Foo | Baz _ -&gt; 0\n</code></pre> <p>Now, if we add the <code>Boom</code> constructor, we will have to add a case for that:</p> <pre><code>type foo =\n  | Foo\n  | Bar of int\n  | Baz of string\n  | Boom of int   (* new constructor *)\n\nlet get_foo_int f =\n  match f with\n    | Bar i -&gt; i\n    | Boom i -&gt; i   (* new case *)\n    | Foo | Baz _ -&gt; 0\n</code></pre> <p>If we left out the <code>Boom</code> case, we would get a warning about a non-exhaustive pattern-match, and we would know just what to fix.</p> <p>Writing out catch-all cases like this is a bit tedious at times, but if you don't do it, you can sometimes get bugs that are extremely hard to track down.<sup>1</sup></p>"},{"location":"readings/ocaml_cheat_sheet/#let-expressions","title":"<code>let</code> expressions","text":""},{"location":"readings/ocaml_cheat_sheet/#explicit-recursion","title":"Explicit recursion","text":"<p>OCaml requires you to say <code>let rec</code> when defining a recursive function.</p> <p>You can easily define mutually recursive functions by using the</p> <pre><code>let rec f x =\n  ...  (* expression using g *)\nand g y =\n  ...  (* expression using f *)\n</code></pre> <p>syntax for top-level mutually-recursive functions, or the</p> <pre><code>let rec f x =\n  ...  (* expression using g *)\nand g y =\n  ...  (* expression using f *)\nin\n  ...\n</code></pre> <p>syntax for mutually-recursive functions inside an expression.  Leaving out the <code>rec</code> is one of the commonest mistakes beginning OCaml programmers make. Conversely, don't use the <code>rec</code> unless the function is actually recursive! (This will rarely cause problems, but it's poor style, and it may generate a warning.)</p>"},{"location":"readings/ocaml_cheat_sheet/#imperative-programming","title":"Imperative programming","text":""},{"location":"readings/ocaml_cheat_sheet/#references","title":"References","text":"<p>OCaml doesn't have \"variables\" in the sense that most programming languages do.  Instead, it has references, which are basically records with a single mutable field.  These are effectively the same as variables except that you have to explicitly dereference them to get the value they contain.  I'm not going to lie to you, this is a pain in highly imperative code! However, it is extremely explicit and it allows you to define useful functions on references.</p> <pre><code># let r = ref 0;;  (* r is a reference *)\nval r : int ref = {contents = 0}\n# r;;\n- : int ref = {contents = 0}\n# (!);;      (* ! is the dereference operator *)\n- : 'a ref -&gt; 'a = &lt;fun&gt;\n# !r;;\n- : int = 0\n# (:=);;     (* := is the assignment operator *)\n- : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;\n# r := 42;;\n- : unit = ()\n# r;;\n- : int ref = {contents = 42}\n# !r;;\n- : int = 42\n# incr;;     (* incr is a function on references *)\n- : int ref -&gt; unit = &lt;fun&gt;\n# incr r;;\n- : unit = ()\n# !r;;\n- : int = 43\n</code></pre> <p>Fun fact: we could have defined the <code>!</code> and <code>:=</code> operators ourselves, and we could have defined the <code>incr</code> function as well:</p> <pre><code># let ( ! ) r = r.contents;;\nval ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;\n# let ( := ) r v = r.contents &lt;- v;;\nval ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;\n# let incr r = r.contents &lt;- !r + 1;;\nval incr : int ref -&gt; unit = &lt;fun&gt;\n</code></pre> <p>This works because references (<code>ref</code> cells) are records with a single field called <code>contents</code>, so the record accessing and mutating syntax can be used on them.</p>"},{"location":"readings/ocaml_cheat_sheet/#sequence-expressions","title":"Sequence expressions","text":"<p>When you are doing imperative programming, it's often necessary to have a notion of sequencing, as in do-this-then-do-that etc. In OCaml, this requires a sequence expression, which has two forms:</p> <ul> <li>a series of statements separated by semicolons    and wrapped with <code>begin</code>/<code>end</code></li> <li>the same, but using parentheses instead of <code>begin</code>/<code>end</code></li> </ul> <p>The choice between using <code>begin</code>/<code>end</code> or parentheses is a style decision. I prefer parentheses for very short (one-liner) sequence expressions and <code>begin</code>/<code>end</code> for sequence expressions that span multiple lines.</p> <p>Here's an example of an (inefficient) imperative function to compute greatest common denominators (GCDs):</p> <pre><code>let gcd m n =\n  let p = ref m in\n  let q = ref n in\n    begin\n      while !p &lt;&gt; !q do\n          if !p &gt; !q then\n            p := !p - !q\n          else\n            q := !q - !p\n      done;\n      !p\n    end\n</code></pre> <p>This also shows the use of an imperative <code>while</code> loop. It also shows how annoying imperative programming is in OCaml <code>!</code> because <code>!</code> of <code>!</code> all <code>!</code> the <code>!</code> exclamation <code>!</code> points!</p>"},{"location":"readings/ocaml_cheat_sheet/#weakly-polymorphic-types","title":"Weakly polymorphic types","text":"<p>OCaml's type system has some peculiarities.  One that you are likely to run into when you do imperative programming is that there are types that are \"weakly polymorphic\".  A truly polymorphic type can be parameterized on one or more type variables, which are written with a leading quote i.e. <code>'a</code>, <code>'b</code> etc. But some types are not actually polymorphic, they are \"write-once\" types.  Look at this:</p> <pre><code># let r = ref [];;\nval r : '_weak1 list ref = {contents = []}\n# !r;;\n- : '_weak1 list = []\n# r := [1; 2; 3];;\n- : unit = ()\n# r;;\n- : int list ref = {contents = [1; 2; 3]}\n# !r;;\n- : int list = [1; 2; 3]\n</code></pre> <p>The initial type of <code>r</code> is <code>'_weak1 list ref</code>, which is pretty odd. You might expect it to be <code>'a list ref</code> i.e. that <code>r</code> is a reference which can contain any kind of list.  But this would not be type-safe; if <code>r</code> holds a list of <code>int</code>s at one time and a list of <code>bool</code>s at another, then all the types are not known at compile-time, and you might as well be writing Python code.</p> <p>Instead, what this odd type means is that <code>r</code> is a reference containing a list of currently unspecified type.  That's what the <code>'_weak1 list ref</code> means.  Since <code>r</code> was initialized with an empty list, which could have any element type, you can't say any more.  Once you reassign a list of known type to <code>r</code>, it then has a concrete type (<code>int list</code> in this case), and the type is fixed thereafter.</p> <p>OK, so what if you aren't using references or imperative features? Unfortunately, you can still get weakly polymorphic types if you partially apply a function.  Here's a trivial example:</p> <pre><code># let const x y = y ;;\nval const : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# let f = const () ;;  (* partial application of the const function *)\nval f : '_weak1 -&gt; '_weak1 = &lt;fun&gt;\n</code></pre> <p>This is purely functional code, but you still get a weak type! The reasons for this are quite involved (see the references below), but one trick that will work in most cases is to change the partial application to a full application by adding arguments:</p> <pre><code># let const x y = y ;;\nval const : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;\n# let f x = const () x ;;  (* no longer a partial application of the const function *)\nval f : 'a -&gt; 'a = &lt;fun&gt;\n</code></pre> <p>Now <code>f</code> has the expected type.  This trick (called \"eta expansion\") is definitely worth remembering.</p> <p>For more on this issue (really far more than you need to know at this point), here are some good references:</p> <ul> <li>https://ocaml.org/manual/5.4/polymorphism.html</li> <li>https://ocamlverse.github.io/content/weak_type_variables.html</li> </ul> <p>However, don't stress too much about it. This is expert-level stuff, and at this point in your OCaml learning process, the main reason we're bringing this up is in case you encounter this in practice and want to have an idea about what's going on. Sophisticated type systems like OCaml's are quite involved, and few people have completely mastered all of the details.</p> <ol> <li> <p>In the CS 164 course (Compilers), which uses OCaml, this kind of situation comes up quite frequently, because many of the compilers start with compiler passes from a simpler compiler and extend them to handle new constructors.\u00a0\u21a9</p> </li> </ol>"},{"location":"readings/subst/","title":"The substitution model","text":"<p>This reading is a summary of the rules of the substitution model, discussed starting in lecture 2.</p>"},{"location":"readings/subst/#overview","title":"Overview","text":"<p>The substitution model is a way of manually evaluating OCaml expressions. It's similar to, but not identical to, what the computer does when it evaluates OCaml code. The point of learning the model is so that you have a good mental framework for how OCaml code evaluates.</p> <p>Note</p> <p>At some point, this model will not be sufficient to explain all the features of OCaml that we will use (for instance, updating variables in imperative programming), so we will define a new model: the environment model. That model will share many features with the substitution model, but its handling of name lookup will be much more precise.</p> <p>The substitution model is adequate to understand the purely functional subset of OCaml we will use for the first half of the course.</p>"},{"location":"readings/subst/#desugaring-and-precedence","title":"Desugaring and precedence","text":"<p>Before evaluating any OCaml code using the substitution model, the code should first be desugared, and then operator precedence should be made explicit using parentheses.</p>"},{"location":"readings/subst/#desugaring","title":"Desugaring","text":"<p>The main kind of desugaring we need is to replace expressions of this form:</p> <pre><code>let f x y = ...\n</code></pre> <p>with this:</p> <pre><code>let f = fun x y -&gt; ...\n</code></pre> <p>After desugaring, all <code>let</code> expressions are \"simple\" i.e. they bind a single name (here, <code>f</code>) to a value (the result of evaluating the expression on the right-hand side of the <code>=</code>; here, <code>fun x y -&gt; ...</code>).</p> <p>Note</p> <p>If we are really being picky, we could desugar this further to:</p> <pre><code>let f = fun x -&gt; fun y -&gt; ...\n</code></pre> <p>but we don't require that.  This is because of function currying, which is the way that OCaml interprets functions with multiple arguments.</p> <p>We recommend that you don't do this in your written evaluations, unless you have to for some reason.</p>"},{"location":"readings/subst/#precedence","title":"Precedence","text":"<p>Operator precedence should be made explicit by wrapping parentheses around nested operator expressions. For instance, this code:</p> <pre><code>1 + 2 * 7\n</code></pre> <p>would become:</p> <pre><code>1 + (2 * 7)\n</code></pre> <p>The full precedence table of OCaml operators is here. In most cases, it will be what you would expect.</p> <p>This step is done so that there is never any question about what the operands of an operator are.</p>"},{"location":"readings/subst/#the-basic-rule","title":"The basic rule","text":"<p>To evaluate an OCaml expression:</p> <ol> <li>evaluate the operands of the expression</li> <li>evaluate the operator or function of the expression</li> <li>apply the operator/function to the evaluated operands</li> </ol> <p>Note</p> <p>OCaml actually evaluates operands from right-to-left, in contrast to most languages, which evaluate operands from left-to-right. Evaluation order is not part of the substitution model, and shouldn't make any difference.</p> <p>Similarly, you can evaluate the operator/function before or after evaluating the operands, and it won't make any difference in this model.</p> <p>The basic rule is used when evaluating a function call or an operator expression. Other expressions (such as <code>let</code>, <code>fun</code> and <code>if</code> expressions) do not use the basic rule; they have their own evaluation rules. Such expressions are called special forms.</p>"},{"location":"readings/subst/#specific-cases-of-the-basic-rule","title":"Specific cases of the basic rule","text":"<ul> <li> <p>Numbers evaluate to themselves: <code>10</code> \u2192 <code>10</code>   (In fact, any literal data value evaluates to itself;   that's why it's called \"literal\".   For now, we are mostly working with numbers.)</p> </li> <li> <p>Primitive (built-in) functions evaluate   to the corresponding internal procedure.   We can write this as either:   <code>+</code> \u2192 <code>[primitive function +]</code>   or just <code>+</code> \u2192 <code>+</code></p> </li> <li> <p>Variables that have been previously defined   are \"looked up\" (in some unspecified way)   and evaluate to the value that they were previously bound to.   (If they weren't bound to a value previously, it's an error.)</p> </li> </ul>"},{"location":"readings/subst/#let-bound-names","title":"<code>let</code>-bound names","text":"<p>There are two kinds of <code>let</code>-bound names: top-level and local. They evaluate differently.</p>"},{"location":"readings/subst/#top-level-let-expressions","title":"Top-level <code>let</code> expressions","text":"<p>A top-level <code>let</code> expression<sup>1</sup> looks like this:</p> <pre><code>let &lt;var&gt; = &lt;expr&gt;\n</code></pre> <p>for some variable name <code>&lt;var&gt;</code> and some expression <code>&lt;expr&gt;</code>. For instance:</p> <pre><code>let x = 2 + 3\n</code></pre> <p>To evaluate this, you</p> <ul> <li> <p>evaluate the expression to the right of the <code>=</code> sign   (here, <code>2 + 3</code>, which evaluates to <code>5</code>);</p> </li> <li> <p>\"make an association\" or \"bind\" the name (<code>x</code> here)   to the value of the evaluated expression (<code>5</code>).   The details of how to make this association aren't important for now,   though we'll revisit this later.</p> </li> </ul> <p>In this case, we make an association between the name <code>x</code> and the value <code>5</code>. We can also say that we bind <code>x</code> to <code>5</code>.</p> <p>After this expression is evaluated, the name <code>x</code> will be bound to the value <code>5</code> for the rest of the evaluated code, unless <code>x</code> is given a new binding with a new top-level <code>let</code> expression.</p> <p>Note</p> <p>A new binding for <code>x</code> would be something like:</p> <pre><code>let x = 42\n</code></pre> <p>From then on, any reference to <code>x</code> would get the new value. This is not the same as assignment in an imperative language, because it doesn't overwrite the old binding. Instead, this code creates a new binding to <code>x</code> which \"shadows\" the old binding, but the old binding still exists, and in some cases can still have effects.</p>"},{"location":"readings/subst/#local-let-expressions","title":"Local <code>let</code> expressions","text":"<p>A \"local\" <code>let</code> expression is a <code>let</code> expression where a name is bound to a value and then immediately used in another expression, such as this:</p> <pre><code>let x = 2 + 3 in x * x\n</code></pre> <p>(Note the use of the <code>in</code> keyword; that's how you know it's a local <code>let</code> expression.)</p> <p>In this case, the name <code>x</code> has a meaning inside the body of the expression (the <code>x * x</code> part) but not outside. To evaluate this, you:</p> <ul> <li> <p>evaluate the binding expression   (here, <code>2 + 3</code>, which evaluates to <code>5</code>),</p> </li> <li> <p>bind the name to the value (here, bind <code>x</code> to <code>5</code>),</p> </li> <li> <p>and evaluate the body expression (here, <code>x * x</code>).</p> </li> </ul> <p>In the body expression, of course, you can use the name <code>x</code>, which has a value (<code>5</code>). Outside of this expression, the name <code>x</code> either has no value (if it wasn't bound before) or has the value it previously had (if it was). Remember: you aren't changing a previous binding (to <code>x</code>), you're creating a new one that is used only in a single expression.</p>"},{"location":"readings/subst/#if-expressions","title":"<code>if</code> expressions","text":"<p><code>if</code> expressions consist of three subexpressions:</p> <ul> <li>the test subexpression (between the <code>if</code> and the <code>then</code> keywords)</li> <li>the <code>then</code> subexpression (between the <code>then</code> and the <code>else</code> keywords)</li> <li>the <code>else</code> subexpression (everything following the <code>else</code> keyword)</li> </ul> <p>They have the following evaluation rule.</p> <ol> <li>Evaluate the test subexpression.</li> <li>If the test subexpression evaluates to <code>true</code>,    evaluate the <code>then</code> subexpression.</li> <li>If the test subexpression evaluates to <code>false</code>,    evaluate the <code>else</code> subexpression.</li> </ol> <p>One consequence of this is that you never evaluate both the <code>then</code> and <code>else</code> subexpressions. This is why <code>if</code> can't be a function (it's not just the syntax!)<sup>2</sup></p>"},{"location":"readings/subst/#if-without-else","title":"<code>if</code> without <code>else</code>","text":"<p>When writing purely functional code in OCaml, <code>if</code> expressions always have both a <code>then</code> subexpression and an <code>else</code> subexpression. (These are sometimes called the \"then clause\" and the \"else clause\".) With respect to the substitution model, we will always have <code>else</code> subexpressions in <code>if</code> expressions.</p> <p>To learn more about how <code>if</code> expressions without <code>else</code> subexpressions work, see the OCaml cheat sheet.</p>"},{"location":"readings/subst/#fun-expressions","title":"<code>fun</code> expressions","text":"<p>A <code>fun</code> expression (like <code>fun x y -&gt; x + y</code>) represents an anonymous function. In the substitution model, a <code>fun</code> expression is usually the result of desugaring a regular function definition, like</p> <pre><code>let f x y = x + y\n</code></pre> <p>which desugars to:</p> <pre><code>let f = fun x y -&gt; x + y\n</code></pre> <p><code>fun</code> expressions consist of two parts:</p> <ul> <li>the formal parameters of the function (here, <code>x</code> and <code>y</code>),</li> <li>the body of the function (here, <code>x + y</code>).</li> </ul> <p><code>fun</code> expressions are trivial to evaluate: you basically just leave them alone. For this reason, in written evaluations you can write:</p> <pre><code>fun x y -&gt; x + y  --&gt;  fun x y -&gt; x + y\n</code></pre> <p>or just:</p> <pre><code>fun x y -&gt; x + y  --&gt;  itself\n</code></pre>"},{"location":"readings/subst/#function-application","title":"Function application","text":"<p>Function application is at the heart of the substitution model. There are two cases.</p>"},{"location":"readings/subst/#applying-built-in-functions-or-operators","title":"Applying built-in functions or operators","text":"<p>Applying a built-in function or operator is simple: you just do it. For instance:</p> <pre><code>Evaluate: 2 + 3\n  2 --&gt; 2\n  3 --&gt; 3\n  + --&gt; [primitive function +]\n  apply + to 2, 3 --&gt; 5\n\nEvaluate: abs (-10)\n  -10 --&gt; -10\n  abs --&gt; [primitive function abs]\n  apply abs to -10 --&gt; 10\n</code></pre> <p>In some cases we'll allow you to shorten lines like</p> <pre><code>abs --&gt; [primitive function abs]\n</code></pre> <p>to just:</p> <pre><code>abs --&gt; abs\n</code></pre> <p>Don't do this unless we explicitly say it's OK.</p>"},{"location":"readings/subst/#applying-user-defined-functions-substitution","title":"Applying user-defined functions: substitution","text":"<p>Now we come to the \"substitution\" part of the substitution model. It happens when you are applying a user-defined function (which means a <code>fun</code> expression, or a function which gets desugared to a <code>fun</code> expression) to its arguments (which have already been evaluated to values, so they aren't expressions anymore).</p> <p>The rules for applying user-defined functions are:</p> <ol> <li> <p>Substitute the function argument variables (formal parameters)    with the values given in the call    everywhere they occur in the function body.</p> </li> <li> <p>Evaluate the resulting expression.</p> </li> </ol> <p>For the most part, the substitution process is straightforward. For each function parameter, you substitute the argument value for the function parameter name in the function body to get the substituted expression, which you then evaluate. For instance, this expression:</p> <pre><code>(fun x y -&gt; x + y) 2 3\n</code></pre> <p>evaluates as follows:</p> <pre><code>Evaluate: (fun x y -&gt; x + y) 2 3\n  2 --&gt; 2\n  3 --&gt; 3\n  (fun x y -&gt; x + y) --&gt; itself\n  apply (fun x y -&gt; x + y) to 2, 3\n    substitute 2 for x, 3 for y in x + y --&gt; 2 + 3\n    evaluate: 2 + 3\n      2 --&gt; 2\n      3 --&gt; 3\n      + --&gt; [primitive function +]\n      apply + to 2, 3 --&gt; 5\n</code></pre> <p>You can even evaluate inside a complex expression (for instance, an <code>if</code> expression):</p> <pre><code>Evaluate (fun x y -&gt; if x &gt; y then x + y else x - y) 2 3\n  2 --&gt; 2\n  3 --&gt; 3\n  (fun x y -&gt; ...) --&gt; itself\n  apply (fun x y -&gt; ...) to 2, 3\n    substitute 2 for x, 3 for y in if x &gt; y then x + y else x - y\n    --&gt; if 2 &gt; 3 then 2 + 3 else 2 - 3\n    evaluate: if 2 &gt; 3 then 2 + 3 else 2 - 3\n      if is a special form; evaluate 2 &gt; 3\n        2 --&gt; 2\n        3 --&gt; 3\n        &gt; --&gt; [primitive function &gt;]\n        apply &gt; to 2, 3 --&gt; false\n      For false case, evaluate else clause: 2 - 3\n        2 --&gt; 2\n        3 --&gt; 3\n        - --&gt; [primitive function -]\n        apply - to 2, 3 --&gt; -1\n</code></pre> <p>Notice that the substitution goes right inside the <code>if</code> expression, regardless of which branch of the <code>if</code> will eventually end up being evaluated. (Here we also see that for long <code>fun</code> expression bodies, we can abbreviate them with <code>...</code>.)</p> <p>Note</p> <p>On the other hand, we can't substitute inside a nested <code>fun</code> expression in all cases.  See below for more details.</p>"},{"location":"readings/subst/#recursion","title":"Recursion","text":"<p>Recursion doesn't require any special treatment in the substitution model, except that you have to replace a function name with the correct definition of that function when looking up the name. This is usually obvious, and probably won't cause you any problems. It can get weird in pathological cases where you redefine a name. Here's a silly example:</p> <pre><code>let factorial n = 0   (* obviously wrong *)\n\n(* Redefine factorial. *)\nlet factorial n =     (* oops, forgot the \"rec\" *)\n  if n = 0 then\n    1\n  else\n    n * factorial (n - 1)\n</code></pre> <p>When evaluating this function, the \"recursive\" call to <code>factorial</code> will actually pick up the previous definition of <code>factorial</code>, and <code>factorial</code> will return <code>0</code> for any input but <code>0</code>. The solution is to include the <code>rec</code> in the second definition:</p> <pre><code>let factorial n = 0   (* obviously wrong *)\n\n(* Redefine factorial. *)\nlet rec factorial n =\n  if n = 0 then\n    1\n  else\n    n * factorial (n - 1)\n</code></pre> <p>Now everything will work correctly because the <code>rec</code> tells OCaml that any references to <code>factorial</code> inside the body of <code>factorial</code> represent the function being defined.<sup>3</sup></p> <p>Of course, this normally doesn't come up because you normally don't redefine functions in a file, but something like this could happen when defining functions interactively inside the OCaml interpreter. This can lead to very peculiar bugs.</p>"},{"location":"readings/subst/#nested-fun-expressions-and-shielding","title":"Nested <code>fun</code> expressions and shielding","text":"<p>The substitution model has to be adjusted to deal with nested <code>fun</code> expressions. Here's a simple example:</p> <pre><code>let f x =\n  fun x -&gt; x + x\n</code></pre> <p>How would you evaluate <code>f 3</code>? Here's a first (wrong) attempt:</p> <pre><code>Evaluate (f 3)\n  3 --&gt; 3\n  f --&gt; fun x -&gt; fun x -&gt; x + x\n  apply (fun x -&gt; fun x -&gt; x + x) to 3\n    substitute 3 for x in (fun x -&gt; x + x)\n    --&gt; fun 3 -&gt; 3 + 3  (* ??? *)\n</code></pre> <p>at which point it seems clear that something has gone wrong.</p> <p>You might think that <code>fun 3 -&gt; 3 + 3</code> is a syntax error, but that isn't actually the case in OCaml! The <code>fun</code> form uses pattern-matching to decide what to do with the arguments, so <code>fun 3 -&gt; 3 + 3</code> is a function that can only take as its input the integer <code>3</code>, and will always return 6. Clearly, this isn't going to be useful, and is not what was intended.</p> <p>Note</p> <p>If you type in <code>fun 3 -&gt; 3 + 3</code> into the OCaml interpreter, you'll get a warning about non-exhaustive pattern matches, as you'd expect.</p> <p>OK, so it seems that naively doing substitution in cases like this (where you have nested <code>fun</code> expressions that use the same argument name) doesn't work properly. So how can we fix our model so it can handle situations like this?</p> <p>The key is to realize that the problems started with this line:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n</code></pre> <p>Normally, we are substituting a value for a free variable, which is one that isn't being bound by a <code>fun</code> expression. However, in the expression <code>fun x -&gt; x + x</code>, there are two different <code>x</code>s:</p> <ul> <li> <p>the first <code>x</code>, which is in the binding position of the <code>fun</code> expression</p> </li> <li> <p>the second two <code>x</code>s, which are both bound variables, which means that their value is determined by the (eventual) value passed to the <code>fun</code> expression as its <code>x</code> argument.</p> </li> </ul> <p>Neither case corresponds to a free variable. And, as it turns out, we can't substitute into either of them.</p> <p>We've already seen that when we allow substituting into the binding position of a <code>fun</code> expression, strange things like <code>fun 3 -&gt; 3 + 3</code> result. So it's perfectly reasonable to add an extra rule to the substitution model which says \"don't allow substitutions into the binding position of <code>fun</code> expressions\".  So let's do that:</p> <p>Extra rule for the substitution model</p> <p>Don't allow substituting into the binding position of a <code>fun</code> expression.</p> <p>If we go back to the substitution that gave us grief:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n</code></pre> <p>then we could do the substitution with the extra rule to get:</p> <pre><code>substitute 3 for x in (fun x -&gt; x + x)\n--&gt; fun x -&gt; 3 + 3\n</code></pre> <p>This isn't as obviously broken as the previous attempt, but something is still funny here. It doesn't seem reasonable that we would want to generate a function that, given an arbitrary argument <code>x</code>, would always return <code>6</code>.</p> <p>In fact, the expression <code>fun x -&gt; x + x</code> is completely self-contained (other than the <code>+</code> symbol). It only has one reasonable interpretation: a function which doubles its input. So we should disallow substitution into the <code>x</code>s that come after the arrow (<code>-&gt;</code>) in the <code>fun</code> expression too. Our rationale for this is that the <code>x</code> in the binding position \"shields\" the other <code>x</code>s (which we refer to as being bound by the <code>x</code> in the binding position) from substitution. So we have yet another rule for the substitution model:</p> <p>Second extra rule for the substitution model</p> <p>Don't allow substituting into a variable which is shielded by the same variable in the binding position of a <code>fun</code> expression.</p> <p>We can combine both rules into a single rule:</p> <p>Shielding rule for the substitution model</p> <p>Don't allow substituting into a variable when it is either in the binding position of a <code>fun</code> expression or when it is a bound variable of a <code>fun</code> expression. We say that the variable in the binding position shields the bound variables from substitution.</p> <p>That's basically it for the substitution model. We will find eventually that this model has limitations that can only be overcome by switching to a new mode (the environment model), which we will discuss later in the course.</p> <ol> <li> <p>Technically speaking, this isn't a true expression, since it doesn't return a value. It would be more accurate to call this a top-level <code>let</code> binding.\u00a0\u21a9</p> </li> <li> <p>In a lazy functional language like Haskell, <code>if</code> could be a function, except for the syntax.\u00a0\u21a9</p> </li> <li> <p>This would make an awesome assignment problem, but I'm not quite that mean.\u00a0\u21a9</p> </li> </ol>"}]}