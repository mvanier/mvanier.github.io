<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Part A: Red-black trees &mdash; The CS 115 book</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Part B: Implementing sets using red-black trees" href="partB_sets.html" />
    <link rel="prev" title="Overview" href="Overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            The CS 115 book, Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Software.html">Installing the course software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin/index.html">Administrative information</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Assignments</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../1/index.html">Assignment 1: Evaluation and recursion</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Assignment 2: Algebraic datatypes</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Preamble.html">Preamble</a></li>
<li class="toctree-l3"><a class="reference internal" href="Overview.html">Overview</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Part A: Red-black trees</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#member">1. <code class="docutils literal notranslate"><span class="pre">member</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tolist">2. <code class="docutils literal notranslate"><span class="pre">toList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#insert">3. <code class="docutils literal notranslate"><span class="pre">insert</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#fromlist">4. <code class="docutils literal notranslate"><span class="pre">fromList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mindepth-and-maxdepth">5. <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> and <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#testinvariant1">6. <code class="docutils literal notranslate"><span class="pre">testInvariant1</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#testinvariant2">7. <code class="docutils literal notranslate"><span class="pre">testInvariant2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#testinvariant3">8. <code class="docutils literal notranslate"><span class="pre">testInvariant3</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="partB_sets.html">Part B: Implementing sets using red-black trees</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../3/index.html">Assignment 3: A touch of class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../4/index.html">Assignment 4: <code class="docutils literal notranslate"><span class="pre">IO</span></code>, <code class="docutils literal notranslate"><span class="pre">IO</span></code>, it’s off to work we go!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../5/index.html">Assignment 5: Monads and lists, oh my!</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">The CS 115 book, Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Assignments</a></li>
          <li class="breadcrumb-item"><a href="../index.html">Assignment 2: Algebraic datatypes</a></li>
      <li class="breadcrumb-item active">Part A: Red-black trees</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="part-a-red-black-trees">
<h1>Part A: Red-black trees<a class="headerlink" href="#part-a-red-black-trees" title="Permalink to this heading"></a></h1>
<p>In this section, you will implement the red-black tree datatype, along
with its associated functions.</p>
<p>As mentioned above, the file <code class="docutils literal notranslate"><span class="pre">RedBlackTree.hs</span></code> should start with this
module declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">RedBlackTree</span><span class="w"> </span><span class="kr">where</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">where</span></code> is not a mistake; it’s part of the syntax of module
declarations and implies that the entirety of the rest of the file is
part of the module.</p>
<p>After this, put the definition of the datatypes into your file:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- A color is either red or black.</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Black</span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span>

<span class="c1">-- A red-black tree is either a leaf or a tree node with a color,</span>
<span class="c1">-- two branches, both of which are trees, and a value of type a.</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">Node</span></code> constructor, the first <code class="docutils literal notranslate"><span class="pre">(Tree</span> <span class="pre">a)</span></code> argument is the left
subtree and the second is the right subtree.</p>
<p>Then implement the functions described below.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You are not allowed to convert any red-black tree function
arguments into lists of elements (or any other collection type of
elements <em>e.g.</em> arrays of elements) in any of these functions except
where specifically indicated. If you do, you will get a zero on
the problem.</p>
<ul class="simple">
<li><p>You may assume in all the functions that arguments that represent
red-black trees represent <em>valid</em> red-black trees <em>i.e.</em> trees that
obey all three tree invariants described above, unless we
explicitly tell you not to assume this. This will greatly
influence the way you write your functions. Failure to take
advantage of this where it’s advantageous will result in lost
marks. We’ll provide hints for the less obvious cases.</p></li>
<li><p>You can’t add anything to the type definitions given above; for
instance, you can’t make <code class="docutils literal notranslate"><span class="pre">Color</span></code> an instance of <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, because
you don’t need to compare colors for equality. (Don’t do this
indirectly either <em>e.g.</em> by defining an <code class="docutils literal notranslate"><span class="pre">eqColor</span></code> helper
function.) Pattern matching on the datatypes can do everything you
need.</p></li>
</ul>
</div>
<p>Here are the descriptions of the functions you need to implement.</p>
<section id="member">
<h2>1. <code class="docutils literal notranslate"><span class="pre">member</span></code><a class="headerlink" href="#member" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">member</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">member</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
</pre></div>
</div>
<p>This function takes an element and a red-black tree as its arguments and
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the element is in the tree. <em>Note</em>: the color of
nodes is not used in this function. (Unused arguments in patterns should
use the <code class="docutils literal notranslate"><span class="pre">_</span></code> notation to avoid compiler warnings.) Assume that the
input tree is ordered; use the ordering property to only search the
parts of the tree that can possibly contain the element.</p>
<p>Give zero marks if the function recurses on both branches of the tree
for a single input value <em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">member</span> <span class="pre">elem</span> <span class="pre">left</span> <span class="pre">||</span> <span class="pre">member</span> <span class="pre">elem</span> <span class="pre">right</span></code>.
Even though this will get the right answer, it’s much slower than the
correct answer, because it ignores the ordering property.</p>
</section>
<section id="tolist">
<h2>2. <code class="docutils literal notranslate"><span class="pre">toList</span></code><a class="headerlink" href="#tolist" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">toList</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>It takes as its argument a red-black tree and returns a list of all the
tree elements given by an in-order traversal. This means that for a
node, you collect all the left subtree values first, then the node
value, then the right subtree values. This function can be written in
two lines.</p>
<p>Clearly, here it’s OK to convert the tree to a list, because that’s the
whole point of the function! <span class="raw-html">&#128512;</span></p>
<p>If the order of the results is wrong, it’s wrong, so in that case give a
zero for this problem.</p>
</section>
<section id="insert">
<h2>3. <code class="docutils literal notranslate"><span class="pre">insert</span></code><a class="headerlink" href="#insert" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">insert</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>This is the hardest (and most interesting) function in the assignment.
The reason it’s tricky is because you can’t just naively add a node to
the tree; you also have to make sure that the tree is balanced when you
are finished. This is why we need the colors on the nodes. We’ll walk
you through this function in some detail.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since this is the most complicated function in the section, it’s
worth half the marks for the section (or 5 out of the 10 marks for
section A).</p>
</div>
<p>First of all, since Haskell is a functional language, although we say we
are “inserting” an element into a tree, what we are really doing is
creating a new tree with one extra element. The original tree is not
altered in any way. The new tree will share a lot of structure with the
original tree, so we won’t modify any part of the old tree that doesn’t
need to be changed in the new tree.</p>
<p>If it weren’t for the balancing constraints (the red and black
invariants), this would be an easy function to write:</p>
<ul class="simple">
<li><p>If a tree being inserted into is just a leaf, return a node whose
branches are leaves.</p></li>
<li><p>If the new element is the same as the element in the root node of the
tree, return the tree unchanged.</p></li>
<li><p>Otherwise, determine whether the new element needs to be added to the
left or right branch depending on whether it’s smaller or larger than
the element in the root node, add the element to the correct branch,
and reconstruct the final tree.</p></li>
</ul>
<p>Easy peasy. The only problem is that when you do that, you might be
causing the tree to violate the red or black invariants and thus become
unbalanced. Also, what color should the node containing the new element
be? If you think about it, you’ll realize that the new node will be put
at the base of the tree, right above the leaves. Since the leaves are
black, the new node should be colored red so as not to violate the black
invariant. However, when you do this, there is a chance that the parent
node of the new node will also be red, which violates the red invariant
(no red node can have a red parent node). So there has to be a way to
re-balance the tree after adding a node to preserve both the red and
black invariants. And that’s the tricky part.</p>
<p>Here’s a template version of the code you should write, with some parts
filled in:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
<span class="nf">insert</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">makeBlack</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="c1">-- Insert an element into a tree.</span>
<span class="w">    </span><span class="n">ins</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">ins</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="kt">Leaf</span><span class="w">  </span><span class="c1">-- new nodes are colored red</span>
<span class="w">    </span><span class="n">ins</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="n">right</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="cm">{- TODO: by analogy with the previous case -}</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w">  </span><span class="c1">-- element already in the tree; no insertion required</span>

<span class="w">    </span><span class="c1">-- Make the root of the tree black.</span>
<span class="w">    </span><span class="n">makeBlack</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">makeBlack</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Leaf</span>
<span class="w">    </span><span class="n">makeBlack</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">right</span>

<span class="w">    </span><span class="c1">-- Balance a red-black tree under construction which may not satisfy</span>
<span class="w">    </span><span class="c1">-- the red and black invariants.</span>
<span class="w">    </span><span class="n">balance</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">balance</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">    </span><span class="n">balance</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="cm">{- TODO: 3 more cases omitted -}</span>
<span class="w">    </span><span class="n">balance</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">r</span><span class="w">  </span><span class="c1">-- no balancing needed</span>
</pre></div>
</div>
<p>The basic insertion code is in the <code class="docutils literal notranslate"><span class="pre">ins</span></code> helper function. If we didn’t
care about balancing or colors, the line:</p>
<div class="highlight-haskell notranslate" id="code1"><div class="highlight"><pre><span></span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="n">right</span>
</pre></div>
</div>
<p>would be just:</p>
<div class="highlight-haskell notranslate" id="code2"><div class="highlight"><pre><span></span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="p">(</span><span class="n">ins</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">elem&#39;</span><span class="w"> </span><span class="n">right</span>
</pre></div>
</div>
<p>and similarly for the <code class="docutils literal notranslate"><span class="pre">elem</span> <span class="pre">&gt;</span> <span class="pre">elem'</span></code> case. However, adding the new
element <code class="docutils literal notranslate"><span class="pre">elem</span></code> creates a new red node, and this can make the tree
violate the red invariant. Therefore, we call the <code class="docutils literal notranslate"><span class="pre">balance</span></code> function
with the same arguments as the <code class="docutils literal notranslate"><span class="pre">Node</span></code> constructor would have gotten.
Its job is to create a new tree which is guaranteed to be balanced <em>i.e.</em>
which doesn’t violate any of the invariants. (The order invariant won’t
be violated, so we don’t have to worry about that.) Since we are adding
the new element to the left subtree (in this case), only the left
subtree could possibly violate the red invariant by having a red node
with a red parent. Nevertheless, we will need both subtrees in order to
re-balance the tree. It turns out that there are only four different
cases that need to be rebalanced.</p>
<p>Here is case 1:</p>
<figure class="align-default" id="id3">
<div class="graphviz"><img src="../../../../_images/graphviz-01f0e2fd161d8325d702c46330296fa4efbebdd4.png" alt="digraph {
  graph [pad=&quot;0.212,0.055&quot; bgcolor=&quot;#d8d8d8&quot;]
  node [
    style=filled, shape=circle, label=&quot;&quot;,
    fixedsize=true, width=0.5
    fontcolor=&quot;#f0f0f0&quot;, fontname=&quot;Courier New Bold&quot;, fontsize=&quot;16&quot;,
    fillcolor=black,
  ]
  n1 [pos=&quot;0,0!&quot;,label=z]
  n2 [pos=&quot;3.25,-1!&quot;,label=x]
  n3 [pos=&quot;4.75,-1!&quot;,label=z]
  node [fillcolor=red,fontcolor=black]
  n4 [pos=&quot;-0.5,-1!&quot;,label=y]
  n5 [pos=&quot;-1.0,-2!&quot;,label=x]
  n6 [pos=&quot;4,0!&quot;,label=y]
  node [shape=triangle,fillcolor=gray]
  n7 [pos=&quot;-1.5,-3!&quot;,label=a]
  n8 [pos=&quot;-0.5,-3!&quot;,label=b]
  n9 [pos=&quot;0,-2!&quot;,label=c]
  n10 [pos=&quot;0.5,-1!&quot;,label=d]
  n11 [pos=&quot;2.75,-2!&quot;,label=a]
  n12 [pos=&quot;3.625,-2!&quot;,label=b]
  n13 [pos=&quot;4.375,-2!&quot;,label=c]
  n14 [pos=&quot;5.25,-2!&quot;,label=d]
  arrow [
    pos=&quot;1.8,-1.25!&quot;,
    shape=rarrow,
    width=1.0, height=0.35,
    fillcolor=&quot;#808080&quot;,
  ]
  n1 -&gt; n4
  n1 -&gt; n10
  n4 -&gt; n5
  n4 -&gt; n9
  n5 -&gt; n7
  n5 -&gt; n8
  n6 -&gt; n2
  n6 -&gt; n3
  n2 -&gt; n11
  n2 -&gt; n12
  n3 -&gt; n13
  n3 -&gt; n14
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-text">Balance case #1</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Look at the tree on the left of the arrow. In this case, the left subtree is
the node labelled <code class="docutils literal notranslate"><span class="pre">y</span></code>, the right subtree is labelled <code class="docutils literal notranslate"><span class="pre">d</span></code>, and the root node
of the new tree is labelled <code class="docutils literal notranslate"><span class="pre">z</span></code>. (The gray triangle nodes (<code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">d</span></code>)
represent balanced subtrees.) You can see that the left subtree violates the red
invariant because node <code class="docutils literal notranslate"><span class="pre">y</span></code> is red and has a child node <code class="docutils literal notranslate"><span class="pre">x</span></code> which is also
red.</p>
<p>What you do is convert the tree on the left of the arrow
to the tree on the right.
This tree is still correctly ordered (because <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">z</span></code>)
but now node <code class="docutils literal notranslate"><span class="pre">y</span></code> is the root of the tree
and node <code class="docutils literal notranslate"><span class="pre">x</span></code> has changed color from red to black.
This new tree doesn’t violate any of the invariants;
ordering is preserved, no red node has a red parent,
and both branches have one black node
in addition to the black nodes along the paths
starting from <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, and <code class="docutils literal notranslate"><span class="pre">d</span></code>,
which all have the same number of black nodes.
This corresponds to the following line from the <code class="docutils literal notranslate"><span class="pre">balance</span></code> function:</p>
<div class="highlight-haskell notranslate" id="code3"><div class="highlight"><pre><span></span><span class="w">   </span><span class="n">balance</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span>
<span class="w">     </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">balance</span></code> doesn’t get an entire tree as its arguments; it
gets the pieces of a tree as separate arguments (color, left subtree,
element, right subtree). Nevertheless, the idea is the same. You can see
that the root’s color is <code class="docutils literal notranslate"><span class="pre">Black</span></code>, the left subtree (corresponding to
nodes <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the diagram) is
<code class="docutils literal notranslate"><span class="pre">Node</span> <span class="pre">Red</span> <span class="pre">(Node</span> <span class="pre">Red</span> <span class="pre">l1</span> <span class="pre">e1</span> <span class="pre">r1)</span> <span class="pre">e2</span> <span class="pre">r2</span></code>, the node element is <code class="docutils literal notranslate"><span class="pre">e</span></code>, and
the right subtree (corresponding to label <code class="docutils literal notranslate"><span class="pre">d</span></code> in the diagram) is
<code class="docutils literal notranslate"><span class="pre">t</span></code>. The label <code class="docutils literal notranslate"><span class="pre">a</span></code> in the diagram is <code class="docutils literal notranslate"><span class="pre">l1</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">r1</span></code>, and
<code class="docutils literal notranslate"><span class="pre">c</span></code> is <code class="docutils literal notranslate"><span class="pre">r2</span></code>. The output of the function is just the tree to the
right of the arrow.</p>
<p>Notice how Haskell’s algebraic datatypes have made a fairly complicated
transformation very simple to write! This is a key advantage of
algebraic datatypes when working with sophisticated data structures.</p>
<p>Make sure you understand this case! If you do, filling in the rest of
the cases of the <code class="docutils literal notranslate"><span class="pre">balance</span></code> function will be straightforward.</p>
<p>Here is the second case:</p>
<figure class="align-default" id="id4">
<div class="graphviz"><img src="../../../../_images/graphviz-aca33fee99f961ab46c66c124fb961fab121a7f2.png" alt="digraph {
  graph [pad=&quot;0.212,0.055&quot; bgcolor=&quot;#d8d8d8&quot;]
  node [
    style=filled, shape=circle, label=&quot;&quot;,
    fixedsize=true, width=0.5
    fontcolor=&quot;#f0f0f0&quot;, fontname=&quot;Courier New Bold&quot;, fontsize=&quot;16&quot;,
    fillcolor=black,
  ]
  n1 [pos=&quot;0,0!&quot;,label=z]
  n2 [pos=&quot;3.25,-1!&quot;,label=x]
  n3 [pos=&quot;4.75,-1!&quot;,label=z]
  node [fillcolor=red,fontcolor=black]
  n4 [pos=&quot;-0.5,-1!&quot;,label=x]
  n5 [pos=&quot;0,-2!&quot;,label=y]
  n6 [pos=&quot;4,0!&quot;,label=y]
  node [shape=triangle,fillcolor=gray]
  n7 [pos=&quot;-0.5,-3!&quot;,label=b]
  n8 [pos=&quot;0.5,-3!&quot;,label=c]
  n9 [pos=&quot;-1.0,-2!&quot;,label=a]
  n10 [pos=&quot;0.5,-1!&quot;,label=d]
  n11 [pos=&quot;2.75,-2!&quot;,label=a]
  n12 [pos=&quot;3.625,-2!&quot;,label=b]
  n13 [pos=&quot;4.375,-2!&quot;,label=c]
  n14 [pos=&quot;5.25,-2!&quot;,label=d]
  arrow [
    pos=&quot;1.8,-1.25!&quot;,
    shape=rarrow,
    width=1.0, height=0.35,
    fillcolor=&quot;#808080&quot;,
  ]
  n1 -&gt; n4
  n1 -&gt; n10
  n4 -&gt; n5
  n4 -&gt; n9
  n5 -&gt; n7
  n5 -&gt; n8
  n6 -&gt; n2
  n6 -&gt; n3
  n2 -&gt; n11
  n2 -&gt; n12
  n3 -&gt; n13
  n3 -&gt; n14
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-text">Balance case #2</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The output tree is the same as before, but the inputs will be different.
You have to fill in the code for this case.</p>
<p>Here are the last two cases:</p>
<figure class="align-default" id="id5">
<div class="graphviz"><img src="../../../../_images/graphviz-426149991f02b6ec31916354e2af7f445df43b4a.png" alt="digraph {
  graph [pad=&quot;0.212,0.055&quot; bgcolor=&quot;#d8d8d8&quot;]
  node [
    style=filled, shape=circle, label=&quot;&quot;,
    fixedsize=true, width=0.5
    fontcolor=&quot;#f0f0f0&quot;, fontname=&quot;Courier New Bold&quot;, fontsize=&quot;16&quot;,
    fillcolor=black,
  ]
  n1 [pos=&quot;0,0!&quot;,label=x]
  n2 [pos=&quot;3.25,-1!&quot;,label=x]
  n3 [pos=&quot;4.75,-1!&quot;,label=z]
  node [fillcolor=red,fontcolor=black]
  n4 [pos=&quot;0.5,-1!&quot;,label=z]
  n5 [pos=&quot;0,-2!&quot;,label=y]
  n6 [pos=&quot;4,0!&quot;,label=y]
  node [shape=triangle,fillcolor=gray]
  n7 [pos=&quot;-0.5,-3!&quot;,label=b]
  n8 [pos=&quot;0.5,-3!&quot;,label=c]
  n9 [pos=&quot;1,-2!&quot;,label=d]
  n10 [pos=&quot;-0.5,-1!&quot;,label=a]
  n11 [pos=&quot;2.75,-2!&quot;,label=a]
  n12 [pos=&quot;3.625,-2!&quot;,label=b]
  n13 [pos=&quot;4.375,-2!&quot;,label=c]
  n14 [pos=&quot;5.25,-2!&quot;,label=d]
  arrow [
    pos=&quot;1.8,-1.25!&quot;,
    shape=rarrow,
    width=1.0, height=0.35,
    fillcolor=&quot;#808080&quot;,
  ]
  n1 -&gt; n4
  n1 -&gt; n10
  n4 -&gt; n5
  n4 -&gt; n9
  n5 -&gt; n7
  n5 -&gt; n8
  n6 -&gt; n2
  n6 -&gt; n3
  n2 -&gt; n11
  n2 -&gt; n12
  n3 -&gt; n13
  n3 -&gt; n14
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-text">Balance case #3</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id6">
<div class="graphviz"><img src="../../../../_images/graphviz-2fe3d9e23d5b725ff4b19decc5bf5cbad44a4684.png" alt="digraph {
  graph [pad=&quot;0.212,0.055&quot; bgcolor=&quot;#d8d8d8&quot;]
  node [
    style=filled, shape=circle, label=&quot;&quot;,
    fixedsize=true, width=0.5
    fontcolor=&quot;#f0f0f0&quot;, fontname=&quot;Courier New Bold&quot;, fontsize=&quot;16&quot;,
    fillcolor=black,
  ]
  n1 [pos=&quot;0,0!&quot;,label=x]
  n2 [pos=&quot;3.25,-1!&quot;,label=x]
  n3 [pos=&quot;4.75,-1!&quot;,label=z]
  node [fillcolor=red,fontcolor=black]
  n4 [pos=&quot;0.5,-1!&quot;,label=y]
  n5 [pos=&quot;1,-2!&quot;,label=z]
  n6 [pos=&quot;4,0!&quot;,label=y]
  node [shape=triangle,fillcolor=gray]
  n7 [pos=&quot;0.5,-3!&quot;,label=c]
  n8 [pos=&quot;1.5,-3!&quot;,label=d]
  n9 [pos=&quot;0,-2!&quot;,label=b]
  n10 [pos=&quot;-0.5,-1!&quot;,label=a]
  n11 [pos=&quot;2.75,-2!&quot;,label=a]
  n12 [pos=&quot;3.625,-2!&quot;,label=b]
  n13 [pos=&quot;4.375,-2!&quot;,label=c]
  n14 [pos=&quot;5.25,-2!&quot;,label=d]
  arrow [
    pos=&quot;1.8,-1.25!&quot;,
    shape=rarrow,
    width=1.0, height=0.35,
    fillcolor=&quot;#808080&quot;,
  ]
  n1 -&gt; n4
  n1 -&gt; n10
  n4 -&gt; n5
  n4 -&gt; n9
  n5 -&gt; n7
  n5 -&gt; n8
  n6 -&gt; n2
  n6 -&gt; n3
  n2 -&gt; n11
  n2 -&gt; n12
  n3 -&gt; n13
  n3 -&gt; n14
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-text">Balance case #4</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>You need to fill in the code for these cases as well. Any other case
does not need to be balanced, so the default line:</p>
<div class="highlight-haskell notranslate" id="code4"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">balance</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">r</span><span class="w">  </span><span class="c1">-- no balancing needed</span>
</pre></div>
</div>
<p>is in effect.</p>
<p>You might be wondering what this helper function is for:</p>
<div class="highlight-haskell notranslate" id="code5"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">-- Make the root of the tree black.</span>
<span class="w">    </span><span class="n">makeBlack</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">makeBlack</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Leaf</span>
<span class="w">    </span><span class="n">makeBlack</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">right</span>
</pre></div>
</div>
<p>It turns out that when inserting into a red-black tree, you may end up
with a red node at the root with a red child node (violating the red
invariant), but with all other invariants satisfied. In this case we can
simply recolor the root node to black to make the black invariant hold.
This won’t affect the order invariant (obviously) and it won’t change
the fact that all paths from the root to the leaves have the same number
of black nodes (although that number will be one greater than before).
You won’t need to use <code class="docutils literal notranslate"><span class="pre">makeBlack</span></code> in any of the code you need to fill
in.</p>
<p>If you think that this code is complicated, you’d be right! Tree
balancing code is often quite complex, and there are some kinds of trees
whose balancing code is even worse than this. <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> The nice thing about
red-black trees is that they are very efficient in practice, so once we
get through writing the code, we have a very useful data structure.</p>
</section>
<section id="fromlist">
<h2>4. <code class="docutils literal notranslate"><span class="pre">fromList</span></code><a class="headerlink" href="#fromlist" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">fromList</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fromList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>This function takes a list as its argument and returns the red-black
tree obtained by inserting all the list elements into an empty tree.
This can be written in one line using <code class="docutils literal notranslate"><span class="pre">foldr</span></code>. (This is not a
requirement, but try to find the <code class="docutils literal notranslate"><span class="pre">foldr</span></code> definition; it’s very
simple.)</p>
</section>
<section id="mindepth-and-maxdepth">
<h2>5. <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> and <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code><a class="headerlink" href="#mindepth-and-maxdepth" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> and <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> functions, which have these type
signatures:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">minDepth</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">maxDepth</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
</pre></div>
</div>
<p>These functions return the minimum and maximum depths of the tree,
respectively. That is, <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> is the smallest distance from the
root node to a leaf, while <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> is the largest such distance. A
tree which is just a <code class="docutils literal notranslate"><span class="pre">Leaf</span></code> (<em>i.e.</em> an empty tree) has depth 0. Recall
that by “distance” to a leaf we mean the number of times you can go from
a node to one of its branch nodes before you hit a leaf.</p>
</section>
<section id="testinvariant1">
<h2>6. <code class="docutils literal notranslate"><span class="pre">testInvariant1</span></code><a class="headerlink" href="#testinvariant1" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">testInvariant1</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testInvariant1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
</pre></div>
</div>
<p>This function tests the order invariant.
This invariant requires all nodes to have values that are
strictly larger than all node values in the node’s left subtree
and strictly smaller than all node values in the node’s right subtree.
This function returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the tree obeys the invariant.</p>
<p>Obviously, in this function the node colors are irrelevant.
You probably want to write some helper functions to make this function
easier to write.</p>
<p>Your code should not be gratuitously inefficient. For instance, don’t
compare a node value against every single value in its left/right
subtree, because that isn’t necessary. Marks will be taken off for
inefficient solutions. Doing it right isn’t hard or tricky.</p>
</section>
<section id="testinvariant2">
<h2>7. <code class="docutils literal notranslate"><span class="pre">testInvariant2</span></code><a class="headerlink" href="#testinvariant2" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">testInvariant2</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testInvariant2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
</pre></div>
</div>
<p>This function tests the red invariant, which is that no red node has a
red parent. Don’t forget to use <code class="docutils literal notranslate"><span class="pre">_</span></code> for unused components of the
<code class="docutils literal notranslate"><span class="pre">Node</span></code> constructor, as usual.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Nested pattern matches are extremely helpful here! With them, you can
write this function in a few short lines of code. If you think you
need to use a <code class="docutils literal notranslate"><span class="pre">case</span></code> statement, think again.</p>
<p>You do <em>not</em> have to compare colors using the <code class="docutils literal notranslate"><span class="pre">==</span></code> or <code class="docutils literal notranslate"><span class="pre">/=</span></code>
operators, so don’t make <code class="docutils literal notranslate"><span class="pre">Color</span></code> an instance of the <code class="docutils literal notranslate"><span class="pre">Eq</span></code> type
class or define a color comparison function.</p>
</div>
</section>
<section id="testinvariant3">
<h2>8. <code class="docutils literal notranslate"><span class="pre">testInvariant3</span></code><a class="headerlink" href="#testinvariant3" title="Permalink to this heading"></a></h2>
<p>Write the <code class="docutils literal notranslate"><span class="pre">testInvariant3</span></code> function, which has this type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testInvariant3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
</pre></div>
</div>
<p>This function tests the black invariant, which is that all paths from
the root of the tree down through a sequence of nodes to any leaf have
the same number of black nodes.</p>
<p>Note that the color of the root node is irrelevant (because it’s present
in all sequences) and the “color” of the leaf nodes are also irrelevant
(because they are all the same).</p>
<p>This function is a bit tricky, so here is a template for you to fill in:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testInvariant3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">testInvariant3</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">allEqual</span><span class="w"> </span><span class="p">(</span><span class="n">leafCounts</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="c1">-- Given a tree, return a list of the count of black nodes on every path</span>
<span class="w">    </span><span class="c1">-- from the root of the tree to a leaf.</span>
<span class="w">    </span><span class="n">leafCounts</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="w">    </span><span class="n">leafCounts</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="w">    </span><span class="n">leafCounts</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Black</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="cm">{- TODO -}</span>
<span class="w">    </span><span class="n">leafCounts</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="cm">{- TODO -}</span>

<span class="w">    </span><span class="c1">-- Return True if all the elements of a list are equal.</span>
<span class="w">    </span><span class="n">allEqual</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
<span class="w">    </span><span class="n">allEqual</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span>
<span class="w">    </span><span class="n">allEqual</span><span class="w"> </span><span class="p">[</span><span class="kr">_</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span>
<span class="w">    </span><span class="n">allEqual</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">r</span><span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">allEqual</span><span class="w"> </span><span class="n">r</span>
<span class="w">                         </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span>
</pre></div>
</div>
<p>The code marked <code class="docutils literal notranslate"><span class="pre">{-</span> <span class="pre">TODO</span> <span class="pre">-</span></code>} is for you to fill in; please remove the
<code class="docutils literal notranslate"><span class="pre">{-</span> <span class="pre">TODO</span> <span class="pre">-}</span></code> comments! The amount of code you need to add is quite
small (one short line in each case).</p>
<hr class="docutils" />
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>You may have encountered this in a CS 4 midterm exam.</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Overview.html" class="btn btn-neutral float-left" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="partB_sets.html" class="btn btn-neutral float-right" title="Part B: Implementing sets using red-black trees" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Michael C. Vanier. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>