{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 115 book: Winter 2024","text":"<p>This book is the official document repository for the Caltech CS 115 course  (Functional Programming) for the Spring 2024 term.</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p> <p>Please read this page for an overview of the course.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 115 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare you or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>You are welcome to collaborate informally on your assignments with other individuals who are taking the course, but you must write all of your own code and you must not look at other students' code, except to help them as described below. Copying another student's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another student's file and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another student's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone dictate code while you type isn't acceptable either. Basically, you have to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine.</p> <p>All of the above also applies if you are getting tutored for the course, officially or unofficially.</p> <p>All of the above also applies to student work from previous years. We re-use some problems in assignments, and copying answers from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a student who is currently taking the course.</p>"},{"location":"admin/collab/#helping-others-and-the-50-foot-rule","title":"Helping others and the \"50-foot rule\"","text":"<p>It is common for students to want to help other students to write and debug their assignments. While we prefer that you go to one of the course teaching assistants when you need help on the assignments (it doesn't matter which one), we don't forbid you from seeking help from other students or offering your help to other students. However, we do insist on some guidelines to make the process fair for everyone.</p> <p>When you are helping another student with their homework, you are acting as an unofficial teaching assistant, and thus you must behave like one. A teaching assistant will not tell you the answer or dictate code to you; he/she will help you work through the problem so that you understand what you are doing wrong. If you don't have the time or the inclination to do this, do not assist other students. If you just give them your code, you are violating the Honor Code and both you and the people you are giving the code to may be in for some serious consequences.</p> <p>As a way of clarifying the way in which you can help other students (especially when it comes to debugging their code), we want you to obey the \"50 foot rule\". This rule states that if you help another student with their programming problems (including debugging), you must not consult your own code while doing so. Specifically, we ask that your own code be at least 50 feet away i.e. not visible to you or the person you are helping while you are helping them. (It doesn't have to be exactly 50 feet; the point is that you can't see your code while helping the other person and you shouldn't run back and forth between your computer with your code and the computer of the person you're helping.) The slogan of the 50-foot rule is: \"Help them with your brain, not with your code.\" Please do not try to find a loophole kind of way around this e.g. projecting your code on a building 50 feet away; that is clearly not what we mean. Posting your code on a pastebin-like internet site, emailing your code to other people, sharing your screen with your code on it, printing it out, or even referring to it on your laptop while helping someone else, are all clear violations of the collaboration policy for this course. Also, we don't want you to put your code up on a computer in a room 50 feet away from where you're helping someone and run back and forth, dictating a line at a time. If you can't help them without consulting your code, don't help them. Refer them to a teaching assistant.</p> <p>Note</p> <p>The 50-foot rule only applies when helping another student in person.</p> <p>Helping another student using teleconferencing software like Zoom, Skype, Discord etc. is covered below, but one aspect of it is that screen sharing is not permitted.</p> <p>We realize that it's more convenient to ask someone in your house for help than to walk all the way to the Annenberg building. A possible solution is to get to know a TA and meet with them in their dorm room (if they are willing). Another possibility is to meet with a TA on Zoom or Discord, or in a room that's closer than Annenberg (e.g. in a library).</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord), you may not share your screen with other students, whether to help them or to get help from them. This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software. This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs. If this happens you may lose the ability to use the discussion board for any purpose.</p> <p>This also applies to other programs with chat features that are not used in the course (like Slack, Discord, or Discourse), or even email for that matter.</p>"},{"location":"admin/collab/#use-of-public-websites","title":"Use of public websites","text":"<p>It is strictly forbidden to post any of the problems from the assignments onto websites (for instance, Stack Overflow), and anyone caught doing this will be charged with an Honor Code violation. This includes problems that are similar to assignment problems even if not identical. If you find a discussion of course-related material on internet websites, you may read it as long as the discussion is not about a problem that is identical to or very similar to a problem on one of the course assignments. However, do not transcribe code from the internet into your homework submissions.</p> <p>It is strictly forbidden to look at any solutions to any previous years' work posted on internet code repository sites (including but not limited to GitHub, GitLab, BitBucket, etc.). It is also strictly forbidden to put your own code on such a repository unless (a) it is a private repository, and (b) you do not allow anyone else access to this private repository. You may also not fork any such repositories that you might happen to find; we will consider this evidence of intent to plagiarize.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-github-copilot-or-chatgpt","title":"Use of code hinting software (Github Copilot or ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. (This should be obvious.)</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments and exams.</p> Item Status Course book OK Official Haskell documentation OK Other Haskell documentation OK Other Haskell books OK Your notes OK Notes of other students Not allowed Your graded assignments OK Other students' graded assignments Not allowed Other students' ungraded assignments Not allowed Other code written by anyone else that answers an assigned problem Not allowed Solutions to assignment/exam problems from a previous year Not allowed Material posted on internet forums that answers specific problems Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor. Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the course syllabus for CS 115 (Functional Programming) for the Spring 2024 term.</p>"},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor/lecturer for the course is Mike Vanier (mvanier@cms.caltech.edu). Mike's pronouns are he/him.</p>"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held in room 105 of the Annenberg building on Mondays, Wednesdays, and Fridays from 2 PM to 3 PM.</p>"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for the course. TA contact information and office hours will be posted  on the course Piazza page.</p> <ul> <li>Sahithi Ankireddy</li> <li>Bea Avila-Rimer</li> <li>Sreemanti Dey</li> <li>Leo Yang</li> </ul>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>From the Caltech catalog:</p> <p>This course is a both a theoretical and practical introduction to functional programming, a paradigm which allows programmers to work at an extremely high level of abstraction while simultaneously avoiding large classes of bugs that plague more conventional imperative and object-oriented languages. The course will introduce and use the lazy functional language Haskell exclusively. Topics include: recursion, first-class functions, higher-order functions, algebraic data types, polymorphic types, function composition, point-free style, proving functions correct, lazy evaluation, pattern matching, lexical scoping, type classes, modules, and monads. Some advanced topics such as monad transformers, parser combinators, dynamic typing, and existential types are also covered.</p>"},{"location":"admin/syllabus/#textbooks","title":"Textbook(s)","text":"<p>There is no required textbook.</p> <p>See the Books and resources page for a list of recommended books on Haskell and functional programming. None of these books are required reading, but they may be useful as supplementary reading.</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There is a course Piazza site, which you will be enrolled in if you are registered for this course.</p> <p>For homework submission and grading, we will use CodePost.</p>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Office hours will either be held in-person or on Zoom, at the discretion of the teaching assistant. Mike will hold his office hours on Zoom. Office hour times will be posted on Piazza.</p>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>CS 115 is on grades. There are no exams.</p> <p>There will be 6 assignments, worth 10 marks each. Each assignment is given a grade from 0 to 100 points, which is divided by 10 to get the actual number of marks for the assignment.</p> <p>The maximum number of marks is thus 60 points, which will be scaled to 100. Given your grade out of 100, letter grades will be assigned as follows:</p> Numerical grade (out of 100%) Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 65-70% C+ 62-65% C 60-62% C- 58-60% D+ 55-58% D &lt; 55% F"},{"location":"admin/syllabus/#redoing-assignments","title":"Redoing assignments","text":"<p>After you receive your initial grade on an assignment, you have one week to submit a redo. Redos will be submitted as a separate CodePost assignment called <code>Assignment N (rework)</code> (for assignment <code>N</code>). Late redos (received after the 1-week redo window) will not be graded and your previous grade will stand. You may not submit more than one redo per assignment.</p>"},{"location":"admin/syllabus/#late-policy-for-assignments","title":"Late policy for assignments","text":"<p>If an assignment is late when first submitted, marks are deducted at the rate of 20 points/day (which is the same as 2 marks/day). These marks can't be regained through rework. If a rework is late (i.e. is submitted more than one week after the original grade was submitted), it doesn't count, and the previous grade stands.</p> <p>Note</p> <p>If an assignment is submitted on time, but is missing one or more sections, those sections will be graded as a 0. The assignment can be reworked, of course, but assuming the sections that were missing on the initial submission are submitted with the rework, there is no additional rework for these sections. This means that (for instance) if you don't submit a section on the initial submission but do submit it in the rework, the grade of that section in the rework is final \u2014 you don't get to rework it just because you hadn't submitted it before. So please don't leave out sections!</p> <p>Students may request extensions for assignments due to unusual circumstances. These extensions have to be approved by the course instructor (Mike). If you get an extension, you must indicate that in a comment at the top of the file(s) you submit e.g. something like this:</p> <pre><code>-- Extension granted by Mike Vanier until 3/17\n</code></pre> <p>This is so your grader knows not to take off late points.</p>"},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Friday at 2 AM unless otherwise indicated. Note that a due time of 2 AM means early that morning, so effectively it means very late the previous evening.</p>"},{"location":"admin/syllabus/#attendance-and-participation","title":"Attendance and participation","text":"<p>Attendance and participation currently do not count towards the final grade. However, we strive to make lectures interactive and do a lot of live coding during lectures. Missing out on this will deprive you of many of the benefits of the course (as well as a lot of the fun!). Lectures will not be recorded, but all slides will be posted.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech's Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this page.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>The course collaboration policies are listed in the Collaboration policies page in this book.</p> <p>Note</p> <p>Please read the collaboration policies! You are responsible for knowing what is an isn't acceptable collaboration, and if you over-collaborate you may be sent to the Board of Control, which is never pleasant.</p>"},{"location":"admin/syllabus/#software","title":"Software","text":"<p>See the software page for information on installing the course software.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated by your classmates and the course staff with respect. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructors know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student Wellness","text":"<p>It is very important to us that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made. Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See the CASS website for more information.</p> <p>Undergraduate students should contact Dr. Lesley Nye, interim Dean of Undergraduate Students (administrative contact: Beth Larranaga) and graduate students should contact Darrell Peterson, Associate Dean of Graduate Studies (administrative contact: Georgine Okura).</p>"},{"location":"assignments/1/assignment1/","title":"Assignment 1: Evaluation and recursion","text":""},{"location":"assignments/1/assignment1/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, April 19th at 2 AM.</p>"},{"location":"assignments/1/assignment1/#prerequisites","title":"Prerequisites","text":"<p>We will be assuming henceforth that you have taken and passed CS 1 or CS 1x (or placed out of one of them). We also hope that you have taken and passed CS 4, since knowing the material in CS 4 will make CS 115 much easier. We will also assume that you have a rudimentary knowledge of Linux/Unix terminal commands. If not, please read a Linux tutorial, because we will be using the terminal a lot in this course.</p> <p>Note</p> <p>You are not required to use Linux in this course. The terminal in MacOS works pretty much the same way (both Linux and MacOS are Unix systems), so the commands should work fine assuming that the software is installed correctly. Windows terminal commands are completely different. If you have Windows, you should install Windows Subsystem for Linux (also known as WSL), which gives you a full version of Linux running inside of Windows.  (Use that instead of trying to run Haskell natively on Windows.) Make sure you are installing WSL version 2 or later, since version 1 is known not to work properly with the GHC compiler used in this course.</p>"},{"location":"assignments/1/assignment1/#syllabus","title":"Syllabus","text":"<p>Please make sure you have read the Syllabus page and the Collaboration policies page before submitting any assignments, so you know how the course is organized, what the grading policies are, what is and is not acceptable collaboration etc..</p>"},{"location":"assignments/1/assignment1/#software-installation","title":"Software installation","text":"<p>See the Software page for instructions on how to install the course software.</p>"},{"location":"assignments/1/assignment1/#starting-code-base","title":"Starting code base","text":"<p>All assignments will have a code base, which includes test code and sometimes template code for modules. These are posted on the course Canvas site in the Modules section.</p>"},{"location":"assignments/1/assignment1/#external-websites","title":"External websites","text":"<p>In addition to this book, we will be using the following websites:</p> <ul> <li> <p>The course Canvas page, which is where lectures will be posted,   as well as source code for assignments, papers of interest,   and teaching assistant contact information.</p> </li> <li> <p>The course Piazza page, which is where most course-related announcements   will be posted, as well as serving as a question-and-answer forum.</p> </li> <li> <p>The course CodePost page, which is where assignments will be submitted and graded.</p> </li> </ul> <p>Students will be enrolled in Piazza and CodePost by the course instructor. If you added the course late, you may need to remind the instructor to add you.</p> <p>In addition, some TAs and the instructor may choose to host office hours online on Zoom.</p>"},{"location":"assignments/1/assignment1/#background-reading","title":"Background reading","text":"<p>We recommend that you read the first four chapters of the Gentle Introduction to Haskell. Warning: It isn't that gentle!<sup>1</sup></p>"},{"location":"assignments/1/assignment1/#writing-and-testing-your-code","title":"Writing and testing your code","text":"<p>Here are some general guidelines for writing your code. These apply to all assignments, not just to this one. We won't repeat these in future assignments, but you can reread this later if necessary.</p>"},{"location":"assignments/1/assignment1/#compiler-warnings-and-the-ghci-file","title":"Compiler warnings and the <code>.ghci</code> file","text":"<p>All of your Haskell functions, even internal ones, should have explicit type signatures. This is not a Haskell requirement, but we consider it to be good style as well as good documentation, and it is likely to save you from some problems that might occur if you let <code>ghc</code> infer the types. Also, error messages will be easier to understand.</p> <p>All of your code should be tested using <code>ghci</code> with the <code>-W</code> (warnings enabled) command-line option. Any warnings will be considered errors, so make sure your code does not give any warnings. (NOTE: On rare cases, we may make exceptions to this for specific problems, but if so we will tell you.)</p> <p>You can invoke <code>ghci</code> explicitly with the <code>-W</code> option as follows:</p> <pre><code>$ ghci -W\n</code></pre> <p>However, since you always want the <code>-W</code> option to be enabled, a better solution is to define this once and for all in a <code>.ghci</code> file. The <code>.ghci</code> file is just a regular file that contains stuff to be automatically loaded into <code>ghci</code> when it's launched. Put these lines in the file:</p> <pre><code>:set -W\n:set -Wno-x-partial\n</code></pre> <p>and you are all set. We recommend that this file be placed in your home directory, because <code>ghc</code> will look for it there.</p> <p>Note</p> <p>The <code>:set -Wno-x-partial</code> will allow you to use non-total functions like <code>tail</code> without getting a warning.</p> <p>Warning</p> <p>If your code generates any warnings (and we haven't explicitly said that it's OK for that problem), you will lose half marks for each problem that generates a warning. (If the code for multiple problems generates warnings, you will lose half marks for each of them.) Your TA is also allowed to not grade your assignment until you fix the warnings, but they must inform you of this so you know what you need to do.</p> <p>Also, if you are using an old version of <code>ghc</code>, you may get more or fewer warnings than you get on the latest version. Make sure you have the latest version of <code>ghc</code> installed, or you may get marked down for code that gives no warnings on your <code>ghc</code> but gives warnings on the grader's!</p> <p>If you are getting a warning but don't understand it or don't know how to fix it, post a question to Piazza or come to office hours.</p>"},{"location":"assignments/1/assignment1/#essayevaluation-questions","title":"Essay/evaluation questions","text":"<p>Evaluations and answers to questions should be written as Haskell comments. We recommend that you use the multi-line comment syntax <code>{- ... -}</code>, for example:</p> <pre><code>{-\n\nThe answer to this question is...\n\n-}\n</code></pre>"},{"location":"assignments/1/assignment1/#test-script","title":"Test script","text":"<p>We are supplying you with a short test script called <code>Tests_Lab1.hs</code> which you should download into the directory where your <code>Lab1.hs</code> file is. Before running the test script, make sure that the <code>HUnit</code> and <code>HUnit-approx</code> libraries are installed. In a terminal, type:</p> <pre><code>$ cabal install --lib HUnit\n$ cabal install --lib HUnit-approx\n</code></pre> <p>To run the tests, just load the test script into <code>ghci</code> and type <code>main</code> like this:</p> <pre><code>ghci&gt; :l Tests_Lab1.hs\nghci&gt; main\n</code></pre> <p>We are also supplying you with a <code>Makefile</code> so you can run the test script without using <code>ghci</code>. To do this, make sure that the <code>Makefile</code> is in the same directory as the files <code>Lab1.hs</code> and <code>Tests_Lab1.hs</code>, <code>cd</code> into that directory, and type</p> <pre><code>$ make\n</code></pre> <p>to compile and run the test script, and </p> <pre><code>$ make clean\n</code></pre> <p>to remove all files generated during compilation.</p>"},{"location":"assignments/1/assignment1/#what-to-hand-in","title":"What to hand in","text":"<p>Write all of your code in a single text file called <code>Lab1.hs</code>. This file should start with this line:</p> <pre><code>module Lab1 where\n</code></pre> <p>followed by the rest of the code on subsequent lines. Submit your assignment as the CodePost assignment called <code>Assignment 1</code>.</p> <ol> <li> <p>This document is quite old, but it describes the most basic aspects of Haskell that haven't changed over the years.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/partA_exercises/","title":"Part A: Exercises (50 points)","text":""},{"location":"assignments/1/partA_exercises/#1-defining-new-operators","title":"1. Defining new operators","text":"<p>[5 points]</p> <p>Haskell lets you define your own operators. Here are a couple of simple examples. (See lecture 2 for how to define new operators.)</p>"},{"location":"assignments/1/partA_exercises/#a-sum-of-squares","title":"a. <code>+*</code> (sum of squares)","text":"<p>Write a definition for an operator called <code>+*</code> that computes the sum of the squares of its arguments. Assume both arguments are <code>Double</code>s. Make it left-associative and give it a precedence of 7.</p> <p>Note</p> <p>Define this operator directly\u2009\u2014 don't just define a function and make the operator another name for the function. This applies for the next problem as well.</p>"},{"location":"assignments/1/partA_exercises/#b-exclusive-or","title":"b. <code>^||</code> (exclusive-or)","text":"<p>Write a definition for an operator called <code>^||</code> that computes the exclusive-OR of its two (boolean) arguments. Make it right-associative with a precedence of 3. Your definition should be only two (very simple) lines (not counting the type declaration) and shouldn't use <code>if</code>.</p> <p>Hint</p> <p>Use pattern matching; if the first argument is <code>False</code>, what must the answer be?</p>"},{"location":"assignments/1/partA_exercises/#2-rangeproduct","title":"2. <code>rangeProduct</code>","text":"<p>[5 points]</p> <p>Write a recursive function called <code>rangeProduct</code> that takes two <code>Integers</code> and computes the product of all the integers in the range from one integer to the other (inclusive). For instance:</p> <pre><code>rangeProduct 10 20\n{-\n--&gt; 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20\n--&gt; 6704425728000\n-}\n</code></pre> <p>If the first argument is greater than the second argument, signal an error using the <code>error</code> function. If the two arguments are the same, return the argument value (so <code>rangeProduct 42 42</code> is just <code>42</code>). Use pattern guards instead of explicit <code>if</code> expressions to test the cases. Make sure all cases are exhaustive!</p>"},{"location":"assignments/1/partA_exercises/#3-prod","title":"3. <code>prod</code>","text":"<p>[5 points]</p> <p>Use <code>foldr</code> to define a one-line point-free function called <code>prod</code> that returns the product of all the numbers in a list of <code>Integer</code>s (or <code>1</code> if the list is empty). Use this function to define a one-line (not including the type signature) non-recursive definition for <code>rangeProduct</code>, which you should call <code>rangeProduct2</code>. (This will be a two-line definition if you also include the line containing <code>error</code>.)</p>"},{"location":"assignments/1/partA_exercises/#4-map-and-variations","title":"4. <code>map</code> and variations","text":"<p>[5 points]</p> <p>You learned about the <code>map</code> higher-order function in class. Here you will write some variations on <code>map</code>.</p>"},{"location":"assignments/1/partA_exercises/#a-map2","title":"a. <code>map2</code>","text":"<p>First, write a function <code>map2</code> which maps a two-argument function over two lists. Write it as a recursive function (there is a trivial definition using <code>zipWith</code> which you shouldn't use). It could be used like this:</p> <pre><code>ghci&gt; map2 (*) [1, 2, 3] [4, 5, 6]\n[4,10,18]\n</code></pre> <p>Your solution should have a completely polymorphic type signature (i.e. the most general type signature). Extra elements in either list should be ignored.</p>"},{"location":"assignments/1/partA_exercises/#b-map3","title":"b. <code>map3</code>","text":"<p>Now, write a <code>map3</code> function that will work for functions of 3 arguments. For instance:</p> <pre><code>ghci&gt; map3 (\\x y z -&gt; x + y + z) [1, 2, 3] [4, 5, 6] [7, 8, 9]\n[12,15,18]\n</code></pre>"},{"location":"assignments/1/partA_exercises/#5-dot-product","title":"5. Dot product","text":"<p>[10 points]</p> <p>It's easy to use <code>map2</code> along with the <code>sum</code> function to define a function to compute the dot product of two lists of integers, as follows:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot lst1 lst2 = sum (map2 (*) lst1 lst2)\n</code></pre> <p>or we can save some parentheses by writing it as:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot lst1 lst2 = sum $ map2 (*) lst1 lst2\n</code></pre> <p>You might think that you can write this as a point-free version using the <code>(.)</code> function composition operator as follows:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot = sum . map2 (*)\n</code></pre> <p>However, this does not type check! The correct point-free version is:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot = (sum .) . map2 (*)\n</code></pre> <p>Write out a short (less than 10 lines) evaluation showing that <code>dot lst1 lst2</code> using the point-free definition is equivalent to the explicit (point-wise) definition given above. Note that <code>(sum .)</code> is an operator section equivalent to <code>\\x -&gt; sum . x</code>.</p> <p>Hint</p> <p>Don't forget about currying!</p> <p>Expand out the <code>.</code> operator as follows:</p> <pre><code>f . g == \\x -&gt; f (g x)\n</code></pre> <p>It's a good idea to expand out the <code>dot</code> function as much as possible before you apply it to <code>lst1</code> and <code>lst2</code>.</p> <p>Finally, it's sometimes helpful to put in extra parentheses to clarify what subexpressions the operators are working on.</p> <p>Note</p> <p>Fun fact: there's an obscure Haskell library called <code>Data.Composition</code> that contains a composition operator called <code>.:</code> which can compose a unary function with a binary one. Using this operator, <code>dot</code> can be written as:</p> <pre><code>dot = sum .: map2 (*)\n</code></pre> <p>The definition is simply:</p> <pre><code>(.:) :: (c -&gt; d) -&gt; (a -&gt; b -&gt; c) -&gt; a -&gt; b -&gt; d\n(f .: g) x y = f (g x y)\n</code></pre> <p>The moral of the story is: if you think Haskell's <code>.</code> composition operator isn't good enough for a particular task, you can always define a new composition operator!</p>"},{"location":"assignments/1/partA_exercises/#6-fun-with-list-comprehensions","title":"6. Fun with list comprehensions","text":"<p>[5 points]</p> <p>Using a list comprehension, write a one-line expression which computes the sum of the natural numbers below one thousand which are multiples of 3 or 5. Write the result in a comment. You may use the Haskell <code>sum</code> function to do the actual sum.</p>"},{"location":"assignments/1/partA_exercises/#7-sum-of-primes","title":"7. Sum of primes","text":"<p>[5 points]</p> <p>Calculate the sum of all the prime numbers below 10000.</p> <p>Do this as follows:</p> <ol> <li> <p>First, generate an infinite list of prime numbers using the \"Sieve of Eratosthenes\" algorithm. This consists of generating all positive integers and removing all multiples of successive prime numbers. Write a function called <code>sieve</code> which takes a list of integers, retains the first one, removes all multiples of the first one from the rest, and then sieves the rest. Name the infinite list of primes <code>primes</code>. Note that <code>sieve</code> is a two-line definition (not including type declaration) and <code>primes</code> is trivial given <code>sieve</code>. Make sure your code doesn't generate any compiler warnings.</p> </li> <li> <p>Then, use the <code>takeWhile</code> function on the primes list to take the appropriate prime numbers and compute their sum.</p> </li> <li> <p>Write the answer as a Haskell comment.</p> </li> </ol>"},{"location":"assignments/1/partA_exercises/#8-balanced-parentheses","title":"8. Balanced parentheses","text":"<p>[10 points]</p> <p>For this problem we are going to write functions that take in a string and return a boolean value. This returned value will be <code>True</code> if the parentheses in the string are \"balanced\" and <code>False</code> otherwise. By \"balanced\" we mean:</p> <ul> <li> <p>there are an equal number of open and close parentheses (they pair up),</p> </li> <li> <p>and a close parenthesis never occurs before its matching open parenthesis.</p> </li> </ul> <p>Here are some strings that have balanced parentheses:</p> <pre><code>\"\",\n\"foo\",\n\"()\",\n\"(foo)\",\n\"()()()\",\n\"(()())\",\n\"(((())))\",\n\"(((()())()))\"\n</code></pre> <p>Here are some strings with unbalanced parentheses:</p> <pre><code>\"(\"\n\")\"\n\")(\"\n\")a(\"\n\"()()(\"\n\"(()))(()\"\n</code></pre> <p>Note that characters other than <code>'('</code> or <code>')'</code> are irrelevant to determining if parentheses are balanced or not.</p> <p>You have to write three different functions to determine if a string has balanced parentheses. We will use this to contrast writing a function using explicit recursion vs. using higher-order functions.</p> <p>Note</p> <p>Remember that strings in Haskell are (by default) just lists of characters i.e. lists of <code>Char</code> values. So you can use list functions on strings as you would on any list.</p>"},{"location":"assignments/1/partA_exercises/#a-balancedparentheses","title":"a. <code>balancedParentheses</code>","text":"<p>Write a function called <code>balancedParentheses</code> that takes a <code>String</code> and returns a <code>Bool</code> which is <code>True</code> if the string has balanced parentheses or <code>False</code> otherwise. Use a recursive helper function which traverses the string one character at a time and keeps a running count of the \"parenthesis imbalance\". This can be done by starting the count at zero, adding 1 every time a left parenthesis is encountered, and subtracting 1 every time a right parenthesis is encountered. At the end of the string, the imbalance count will be 0 if the string has balanced parentheses. In addition, the count should never go negative; if it does, the string doesn't have balanced parentheses (there are too many close parentheses at that point in the string), so <code>False</code> should immediately be returned.</p> <p>Put the helper function in a <code>where</code> clause of the <code>balancedParentheses</code> function.</p>"},{"location":"assignments/1/partA_exercises/#b-balancedparentheses2","title":"b. <code>balancedParentheses2</code>","text":"<p>In general, Haskell programmers prefer to use higher-order functions instead of writing explicitly recursive functions. Rewrite <code>balancedParentheses</code> into a new version called <code>balancedParentheses2</code> which is not recursive but which uses the <code>foldl</code> (left fold) higher-order function. (Don't use <code>foldr</code>, even though you could make it work that way.) The function being folded has the type <code>Int -&gt; Char -&gt; Int</code>. It takes the existing imbalance count at some location in the string and the current character in the string, and returns the new count (1 higher if the character is a <code>'('</code>, 1 lower if it's a <code>')'</code>, or the same otherwise). The fold as a whole will return the final imbalance count of the string; if it's 0, the string has balanced parentheses.</p> <p>Some hints and advice:</p> <ol> <li> <p>This function should be shorter than <code>balancedParentheses</code>.</p> </li> <li> <p>If the imbalance count ever goes negative, it should stay negative through the entire fold. Basically, once the count is negative, then the string has unbalanced parentheses, and you can just propagate the negative value through to the end of the fold. This can be done simply by writing the folded function a particular way. If the fold returns a negative number, you know that the string has unbalanced parentheses.</p> </li> <li> <p>We've seen in class that some functions in Haskell can lead to large expressions being generated because of Haskell's lazy evaluation rule. Careless use of <code>foldl</code> can easily do this, and this function is no exception. To avoid a \"space leak\" (where a function that should run in constant space instead runs in e.g. O(N) space), use <code>foldl'</code> (called \"fold-ell-prime\") instead of <code>foldl</code>, which makes the function being folded evaluate strictly.<sup>1</sup> Other than the single <code>'</code> character, <code>foldl'</code> is used the exact same way as <code>foldl</code>.</p> </li> <li> <p>In order to use <code>foldl'</code>, you will need to import the <code>Data.List</code> library. Put this line at the top of your code (after the <code>module Lab1 where</code> line):</p> <pre><code>import Data.List\n</code></pre> <p>Note</p> <p>Even using <code>foldl'</code> may not be enough to guarantee strict evaluation. There are more tricks for ensuring strict evaluation that we will teach you later in the course, but don't worry too much about this for now.</p> </li> </ol>"},{"location":"assignments/1/partA_exercises/#c-balancedparentheses3","title":"c. <code>balancedParentheses3</code>","text":"<p>One problem with <code>balancedParentheses2</code> is that using <code>foldl'</code> doesn't exit early if the imbalance count goes negative. This means that <code>balancedParentheses2</code> is less efficient than <code>balancedParentheses</code>. It seems a shame that converting from a crude recursive definition to an elegant definition using higher-order functions costs us in efficiency. It would be nice to have the best of both worlds.</p> <p>Write a function called <code>balancedParentheses3</code> which solves the balanced parentheses problem using this algorithm:</p> <ol> <li> <p>Write a function called <code>ctoi</code> which converts <code>Char</code> values (characters) to <code>Int</code> values. This should return <code>1</code> if the input character is <code>'('</code>, <code>-1</code> if it's <code>')'</code>, and <code>0</code> otherwise.</p> </li> <li> <p>Use <code>map</code> to convert each character in the string to an <code>Int</code> using <code>ctoi</code>. This will return a list of <code>Int</code>s.</p> </li> <li> <p>The sum of all the <code>Int</code> values will be <code>0</code> for a string with balanced parentheses. However, we also want to make sure that for each prefix of the string (i.e. each string that starts on the first character of the original string and ends before the last character), the imbalance count isn't negative (which would imply unbalanced parentheses for the entire string). For this, we can use the <code>scanl</code> function. <code>scanl</code> works a lot like <code>foldl</code> but collects up the results for all prefixes of the list (string) argument. For instance:</p> <pre><code>foldl (+) 0 [1..5] --&gt; 0 + 1 + 2 + 3 + 4 + 5 = 15\nscanl (+) 0 [1..5]\n  --&gt; [0, 0 + 1, 0 + 1 + 2, 0 + 1 + 2 + 3, 0 + 1 + 2 + 3 + 4, 0 + 1 + 2 + 3 + 4 + 5]\n  --&gt; [0, 1, 3, 6, 10, 15]\n</code></pre> <p>Using <code>scanl</code> on the results of the <code>map</code> gives us the list of partial imbalance counts of the string. (To avoid problems with laziness, use the strict version <code>scanl'</code> instead of just <code>scanl</code> itself.)</p> </li> <li> <p>Now that we have a list of the imbalance counts at each character, we can test if this corresponds to a string with balanced parentheses. If so, either the list is empty (corresponding to an empty string), or its last element is <code>0</code> and none of its elements are negative. Write a function called <code>test</code> that takes a list of <code>Int</code>s and returns a <code>Bool</code> which is <code>True</code> if the list has the desired properties. (The <code>all</code> and <code>last</code> functions will probably be useful to you; look them up in Hoogle.) You can write this as a recursive function if you must, but try not to. Also, the function <code>null</code> returns <code>True</code> if its argument is an empty list.</p> </li> <li> <p>Assemble the <code>test</code>, <code>scanl'</code>, and <code>map</code> functions in a (short!) single line to write the <code>balancedParentheses3</code> function. Put the <code>test</code> and <code>ctoi</code> functions as helper functions in a <code>where</code> clause. (They can be more than one line long.)</p> </li> </ol> <p>If you do this right, you will have an elegant function to compute balanced parentheses which will quit at the first character which guarantees unbalanced parentheses.</p> <p>Note</p> <p>Haskell's lazy evaluation is key to understanding why this function will exit when the imbalance count first goes negative. Basically, the <code>scanl'</code> call will generate one prefix count at a time, and the <code>test</code> function will look at each of these and return <code>False</code> immediately if a negative count is ever seen.</p> <p>Also, the fact that you use <code>scanl'</code> instead of <code>scanl</code> doesn't mean that the entire list of partial counts will be generated strictly (this would ruin the efficiency of the function). It just means that the function which is being folded over the list is applied strictly, which is what you want.</p> <p>If this seems like a lot of mental effort to write a simple function, be aware that this is the nature of Haskell: you write much less code, but you think more about the code you do write. (Some people like this trade off, and some don't.) The good news is that the more you do it, the less thinking it will require.</p> <ol> <li> <p>Technically, it makes it evaluate more strictly, as we will see later in the course.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/partB_pitfalls/","title":"Part B: Pitfalls (20 points)","text":"<p>In this section we'll see some examples of bad code and ask you to fix them. By \"bad code\" we don't mean \"the code doesn't work\" but rather \"the code isn't optimal in some way\". By \"optimal\" we don't necessarily always mean \"inefficient\"; there are other kinds of non-optimality too.</p> <p>Write both the corrected code and (in a Haskell comment) the reason why the original code is bad.</p>"},{"location":"assignments/1/partB_pitfalls/#1-sumlist","title":"1. <code>sumList</code>","text":"<p>[10 points]</p> <p>The following recursive definition has poor Haskell style. How would you improve the style by making a simple change (i.e. keep it a recursive definition, but with better style)?</p> <pre><code>sumList :: [Integer] -&gt; Integer\nsumList [] = 0\nsumList lst = head lst + sumList (tail lst)\n</code></pre>"},{"location":"assignments/1/partB_pitfalls/#2-largest","title":"2. <code>largest</code>","text":"<p>[10 points]</p> <p>What is wrong with this recursive definition? How would you fix it, while keeping it a recursive definition? (The function works, but it is still not \"good\" in some sense.)</p> <pre><code>-- Return the largest value in a list of integers.\nlargest :: [Integer] -&gt; Integer\nlargest xs | length xs == 0 = error \"empty list\"\nlargest xs | length xs == 1 = head xs\nlargest xs = max (head xs) (largest (tail xs))\n</code></pre>"},{"location":"assignments/1/partC_evaluation/","title":"Part C: Evaluation (30 points)","text":"<p>In this section, you'll have to write out the results of evaluating some Haskell expressions step-by-step. These evaluations should look like this:</p> <pre><code>double (3 + 4)\n--&gt; (3 + 4) + (3 + 4)\n--&gt; 7 + (3 + 4)\n--&gt; 7 + 7\n--&gt; 14\n</code></pre> <p>with one reduction step per line. Even more explicit would be the following:</p> <pre><code>double (3 + 4)\n--&gt; (3 + 4) + (3 + 4)  [expand from definition]\n[outermost redex is + operator]\n[+ is strict, needs both operands]\n--&gt; 7 + (3 + 4)        [evaluate leftmost branch of + operator]\n--&gt; 7 + 7              [evaluate rightmost branch of + operator]\n[outermost redex is + operator]\n--&gt; 14                 [evaluate + application]\n</code></pre> <p>though we won't require you to do this (but you may find it helpful to do it this way).</p> <p>Pay particular attention to the fact that Haskell is a lazy language. You may assume that the result of the expression being evaluated is going to be printed in its entirety after evaluation. You may also assume that primitive arithmetic expressions evaluate strictly. If the function evaluation does not terminate, compute enough of the evaluation to make it clear that non-termination is the outcome.</p> <p>Note</p> <p>Since Haskell uses lazy evaluation, it will evaluate copies of one subexpression at the same time, so the above example should really be:</p> <pre><code>double (3 + 4)\n--&gt; (3 + 4) + (3 + 4)\n--&gt; 7 + 7    -- evaluate both (3 + 4)s together\n--&gt; 14\n</code></pre> <p>However, for the evaluations here, assume that all subexpressions are distinct i.e. each one should be evaluated separately.</p> <p>Evaluating Haskell expressions by hand should use the following guidelines:</p> <ol> <li> <p>Find the outermost redex (reducible expression) first. If there is more than one choice (which is very common), choose the leftmost of the outermost redexes.</p> </li> <li> <p>If the redex is inside a lambda expression (i.e. an anonymous function), leave it alone. Otherwise, evaluate it.</p> </li> <li> <p>Continue until you get the result you need. Don't evaluate beyond that point.</p> </li> <li> <p>When expanding a function application using its definition, keep the result in parentheses until it is fully evaluated so as to make clear what the subexpression is.</p> </li> <li> <p>Note that an expression in parentheses can still be a redex. \"Outermost\" does not refer to parentheses but to the presence of other language constructs. For instance, an expression inside a data constructor or inside a lambda expression is not at the outermost level.</p> </li> </ol>"},{"location":"assignments/1/partC_evaluation/#1-fibonacci","title":"1. Fibonacci","text":"<p>[5 points]</p> <p>Consider this function to compute fibonacci numbers:</p> <pre><code>fib :: Integer -&gt; Integer\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n - 1) + fib (n - 2)\n</code></pre> <p>Evaluate <code>fib 3</code>.</p>"},{"location":"assignments/1/partC_evaluation/#2-factorial","title":"2. Factorial","text":"<p>[5 points]</p> <p>Consider this definition of the factorial function:</p> <pre><code>fact :: Integer -&gt; Integer\nfact n = n * fact (n - 1)\nfact 0 = 1\n</code></pre> <p>Evaluate <code>fact 3</code>. What is wrong with this definition? Fix the definition, and then evaluate the fixed definition too.</p> <p>Note</p> <p>Pay special attention to the consequences of lazy evaluation here. Assume that the <code>*</code> operator applied to <code>Integer</code>s evaluates its arguments strictly from left to right.</p>"},{"location":"assignments/1/partC_evaluation/#3-reverse","title":"3. <code>reverse</code>","text":"<p>[5 points]</p> <p>We talked about the <code>reverse</code> function in lecture 3. One definition was as follows:</p> <pre><code>reverse :: [a] -&gt; [a]\nreverse xs = iter xs []\n  where\n    iter :: [a] -&gt; [a] -&gt; [a]\n    iter [] ys = ys\n    iter (x:xs) ys = iter xs (x:ys)\n</code></pre> <p>Evaluate the expression <code>reverse [1,2,3]</code> with this definition. What is the asymptotic time complexity of this function as a function of the length of the input list? Write your answer in a comment. Don't just give the answer, explain why it's correct.</p>"},{"location":"assignments/1/partC_evaluation/#4-reverse-again","title":"4. <code>reverse</code> again","text":"<p>[5 points]</p> <p>Another definition of <code>reverse</code> is as follows:</p> <pre><code>reverse :: [a] -&gt; [a]\nreverse [] = []\nreverse (x:xs) = reverse xs ++ [x]\n</code></pre> <p>For reference: The definition of the <code>(++)</code> operator is:</p> <pre><code>(++) :: [a] -&gt; [a] -&gt; [a]\n(++) []     ys = ys\n(++) (x:xs) ys = x : (xs ++ ys)\n</code></pre> <p>and the <code>++</code> operator is also right-associative.</p> <p>Ben Bitfiddle claims that this definition of <code>reverse</code> has an asymptotic time complexity which is linear in the length of the input list, giving this argument: \"Evaluating <code>reverse [1, 2, 3]</code> eventually results in <code>[] ++ [3] ++ [2] ++ [1]</code> after a linear number of steps, and since appending a singleton list to another list is an <code>O(1)</code> operation, constructing the result list from this point is also linear.\" What is wrong with this argument? Write out a full evaluation of <code>reverse [1, 2, 3]</code> and explain where Ben made his mistake and what the mistake was. What is the actual asymptotic time complexity of this version of <code>reverse</code>?</p> <p>Warning</p> <p>This is tricky! We want a full explanation, not just a couple of sentences.</p> <p>Hints</p> <ul> <li>The <code>++</code> operator is right-associative.</li> <li>Parentheses are your friend.</li> </ul>"},{"location":"assignments/1/partC_evaluation/#5-insertion-sort","title":"5. Insertion sort","text":"<p>[5 points]</p> <p>An \"insertion sort\" is a particular way to sort lists. The first item in the list is inserted at the right place in the result of insertion sorting the rest of the list. For lists of integers, the code might look like this:</p> <pre><code>isort :: [Integer] -&gt; [Integer]\nisort [] = []\nisort (n:ns) = insert n (isort ns)\n  where\n    insert :: Integer -&gt; [Integer] -&gt; [Integer]\n    insert n [] = [n]\n    insert n m@(m1:_) | n &lt; m1 = n : m\n    insert n (m1:ms) = m1 : insert n ms\n</code></pre> <p>For reference, <code>head</code> is defined as:</p> <pre><code>head :: [a] -&gt; a\nhead [] = error \"empty list\"\nhead (x:_) = x\n</code></pre> <p>Evaluate <code>head (isort [3, 1, 2, 5, 4])</code>. Don't evaluate more than you need to!</p>"},{"location":"assignments/1/partC_evaluation/#6-foldr-and-foldl","title":"6. <code>foldr</code> and <code>foldl</code>","text":"<p>[5 points]</p> <p>We discussed the <code>foldr</code> (fold right) and <code>foldl</code> (fold left) higher-order functions in class. Assume that their definitions are as follows:</p> <pre><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b\nfoldr _ init [] = init\nfoldr f init (x:xs) = f x (foldr f init xs)\n</code></pre> <pre><code>foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a\nfoldl _ init [] = init\nfoldl f init (x:xs) = foldl f (f init x) xs\n</code></pre> <p>Note</p> <p>The actual definitions of these functions in GHC are slightly different.</p> <p>Evaluate the following expressions using the above definitions:</p> <ul> <li><code>foldr max 0 [1, 5, 3, -2, 4]</code></li> <li><code>foldl max 0 [1, 5, 3, -2, 4]</code></li> </ul> <p>where <code>max</code> gives the maximum of two values (which you can assume to be <code>Integers</code> for this problem). What can you say about the space complexity of <code>foldr</code> compared to <code>foldl</code>? Hint: Don't forget about lazy evaluation!</p>"},{"location":"assignments/2/assignment2/","title":"Assignment 2: Algebraic datatypes","text":""},{"location":"assignments/2/assignment2/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, April 26th at 2 AM.</p>"},{"location":"assignments/2/assignment2/#what-to-hand-in","title":"What to hand in","text":"<p>Write all your code in a single file called <code>RedBlackTree.hs</code>. This file should be submitted to CodePost as <code>Assignment 2</code>.</p>"},{"location":"assignments/2/assignment2/#writing-your-code","title":"Writing your code","text":"<p>The file you will submit will be a Haskell module, which means it must begin with a module declaration of the form:</p> <pre><code>module MODULENAME(EXPORTLIST) where\n</code></pre> <p>In this case, we are exporting everything from the module (mostly for ease of testing), so the line should just be:</p> <pre><code>module RedBlackTree where\n</code></pre>"},{"location":"assignments/2/assignment2/#testing-your-code","title":"Testing your code","text":"<p>For this week's assignment's code base, we are supplying you with a test script called <code>Tests_Lab2.hs</code>, as well as a <code>Makefile</code>. You can run the tests by putting both files into the same directory and typing</p> <pre><code>$ make\n$ make test\n</code></pre> <p>(where <code>$</code> is the terminal prompt, of course).</p> <p>This test script will run a number of tests on your code; any failure indicates that you have some debugging to do. The test script relies on the Haskell testing packages <code>HUnit</code> (which we installed and used last week) and <code>QuickCheck</code>. Install <code>QuickCheck</code> by starting up a terminal and entering these commands:</p> <pre><code>$ cabal update\n$ cabal install QuickCheck --lib\n</code></pre> <p><code>QuickCheck</code> is a randomized testing framework that tests that functions obey particular properties, automatically synthesizing large numbers of random data values to test the functions.<sup>1</sup> <code>HUnit</code> is a more traditional unit testing framework where you supply expected results for certain computations.</p> <p>Some of the functions you will be writing in this assignment are only used for testing; if they are buggy, your tests may pass but your code may still be wrong. We'll be testing your code on our own test script, which is more stringent. Moral: don't let test scripts lull you into a false sense of security! Just because code passes a test script doesn't mean it's automatically correct.</p>"},{"location":"assignments/2/assignment2/#interactive-testing","title":"Interactive testing","text":"<p>You can also test your code interactively by starting <code>ghci</code> and loading the test script:</p> <pre><code>$ ghci\nghci&gt; :l Tests_Lab2.hs\nghci&gt; main\n</code></pre> <p>If you do this, you may see this error message:</p> <pre><code>Tests_Lab2.hs:12:1: error: [GHC-87110]\n    Could not load module \u2018Data.Set\u2019.\n    It is a member of the hidden package \u2018containers-0.6.8\u2019.\n    You can run \u2018:set -package containers\u2019 to expose it.\n    (Note: this unloads all the modules in the current scope.)\n    Use :set -v to see a list of the files searched for.\n   |\n12 | import qualified Data.Set as S\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre> <p>There are two ways to fix this. The first is simply to do what it says:</p> <pre><code>$ ghci\nghci&gt; :set -package containers\nghci&gt; :l Tests_Lab2.hs\nghci&gt; main\n</code></pre> <p>The second is to invoke <code>ghci</code> with the <code>-package containers</code> option:</p> <pre><code>$ ghci -package containers\nghci&gt; :l Tests_Lab2.hs\nghci&gt; main\n</code></pre> <p>Both ways work.</p> <ol> <li> <p>The <code>QuickCheck</code> library has been quite influential. A number of other languages have built <code>QuickCheck</code> clones to do the same kind of randomized testing.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/background/","title":"Background information","text":"<p>The purpose of this assignment is to get you comfortable working with algebraic datatypes in Haskell. To do this, you will be implementing a data structure called a red-black tree and you'll use it to implement a set data type. You'll see that once you've implemented a red-black tree, implementing set operations will be very simple.</p> <p>A red-black tree is an ordered binary tree where all the elements are stored in the nodes and not the leaves. In addition, each node has a \"color\" which is either \"red\" or \"black\"; this will be used to make sure that the tree is balanced. A perfectly balanced binary tree has all the leaves at the same depth (distance from the root node), but we won't require that our trees be perfectly balanced, just \"balanced enough\". Having a balanced tree is very important, because if the tree is balanced the tree operations can all be done in \\(\\Theta(log\\ n)\\) time. If the tree is not balanced, some operations can take up to \\(\\Theta(n)\\) time, which completely negates all the benefits of using a tree in the first place.</p> <p>Let's be more specific. In Haskell, we'll define the tree using two datatypes:</p> <pre><code>-- A color is either red or black.\ndata Color = Red | Black\n  deriving Show\n\n-- A red-black tree is either empty (a \"leaf\") or a tree node with a color,\n-- two branches (both of which are red-black trees), and a value of type a.\ndata Tree a = Leaf | Node Color (Tree a) a (Tree a)\n  deriving Show\n</code></pre> <p>We see from the definition of the <code>Tree</code> datatype that trees are parameterized around a type <code>a</code>. We will be using integers as tree elements for testing, but you can use this with any orderable type.</p> <p>Note</p> <p>The <code>deriving Show</code> part is just to make it possible to display trees interactively in <code>ghci</code>.</p> <p>The tree needs to obey these invariants:</p> Order invariant <p>The elements (of type <code>a</code>) are orderable.   (Consequently, type <code>a</code> should be an instance of the type class <code>Ord</code>.)   All elements in the left subtree of a node   are strictly smaller than the element stored in the node,   and all elements in the right subtree of a node   are strictly larger than the element stored in the node.   (This also implies that there can be no duplicated elements in the tree.)</p> Red invariant <p>No red node has a red parent.   (Leaves are considered to be black,   so they can have either red or black nodes as parents.)</p> Black invariant <p>Every path from the root node to a leaf   contains the same number of black nodes.   We will refer below to the distance from the root node to a leaf node;   this means the number of nodes in such a path.   More specifically, the distance from the root node to a leaf   is the number of times you can go from a node to one of its branch nodes   before you hit the leaf, starting from the root node.   (For a particular node and leaf, there can be only one such path.)</p> <p>The order invariant is simply the definition of an ordered binary tree, and applies to all such trees, not just red-black trees. The red and black invariants are what ensure that the red-black tree is balanced. By \"balanced\" we don't mean that all leaves must be exactly the same distance from the root of the tree, but that there is some constraint on the tree that guarantees \\(\\Theta(log\\ n)\\) performance for all tree operations. In this case, the red and black invariants guarantee that the longest path from the root node to a leaf is no more than twice as long as the shortest path. When you think about it, it makes sense: the shortest such path would be all black nodes, whereas the longest path would be alternating black and red nodes (since you can't have red nodes with red parents). Since all paths from the root to a leaf have the same number of black nodes, the shortest path would be half the length of the longest path. This is enough to guarantee \\(\\Theta(log\\ n)\\) performance.</p> <p>Here is a diagram of a red-black tree of integers:</p> <p></p> <p>Note that in this diagram, <code>Leaf</code> nodes are represented by the small black unlabelled circles (leaves are considered to be black). Also notice how the tree obeys all three invariants. However, don't think that red-black trees have to have alternating red and black nodes like this one does; they can have more black nodes than red nodes, or even have only black nodes in some cases. Note also that each path from the root to a leaf contains exactly three black nodes.</p> <p>Here are the type signatures of the core red-black tree operations you will need to implement:</p> <pre><code>-- Return `True` if the given element is in the tree.\nmember :: Ord a =&gt; a -&gt; Tree a -&gt; Bool\n\n-- Insert a new element into a tree.\ninsert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\n\n-- Convert a tree to a list.\ntoList :: Tree a -&gt; [a]\n\n-- Convert a list to a tree.\nfromList :: Ord a =&gt; [a] -&gt; Tree a\n</code></pre> <p>In addition, we want you to write several functions which will help in testing the correctness of your implementation, as well as helper functions that will be used in implementing the above operations. Details are given in the following sections.</p> <p>One fundamental tree operation that we will not ask you to implement is removing an element from a tree. This turns out to be surprisingly complicated<sup>1</sup>, and would probably not increase your understanding of how to use algebraic datatypes in Haskell, so we're leaving it out.</p> <p>Once you've implemented red-black trees, you will use them to implement sets. A red-black tree can be used as a set without changing it at all, but in addition to the operations given above, you will implement subset testing, set equality testing, union, intersection and set difference in terms of the fundamental tree operations. By using higher-order functions, you can implement all these operations in one line each.</p> <ol> <li> <p>At least, it's complicated if you do it purely functionally. This may be one reason why Haskell doesn't use red-black trees as the base type for the set and map types (in the libraries <code>Data.Set</code> and <code>Data.Map</code> respectively); those are implemented using weight-balanced trees.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partA_red_black_trees/","title":"Part A: Red-black trees (75 points)","text":"<p>In this section, you will implement the red-black tree datatype, along with its associated functions.</p> <p>As mentioned previously, the file <code>RedBlackTree.hs</code> should start with this module declaration:</p> <pre><code>module RedBlackTree where\n</code></pre> <p>The <code>where</code> is not a mistake; it's part of the syntax of module declarations and implies that the entirety of the rest of the file is part of the module.</p> <p>After this, put the definition of the datatypes into your file:</p> <pre><code>-- A color is either red or black.\ndata Color = Red | Black\n  deriving Show\n\n-- A red-black tree is either a leaf or a tree node with a color,\n-- two branches, both of which are trees, and a value of type a.\ndata Tree a = Leaf | Node Color (Tree a) a (Tree a)\n  deriving Show\n</code></pre> <p>In the <code>Node</code> constructor, the first <code>(Tree a)</code> argument is the left subtree and the second is the right subtree.</p> <p>Then implement the functions described below.</p> <p>Warning</p> <p>You are not allowed to convert any red-black tree function arguments into lists of elements (or any other collection type of elements e.g. arrays of elements) in any of these functions except where specifically indicated. If you do, you will get a zero on the problem.</p> <ul> <li> <p>You may assume in all the functions that arguments that represent red-black trees represent valid red-black trees i.e. trees that obey all three tree invariants described previously, unless we explicitly tell you not to assume this. This will greatly influence the way you write your functions. Failure to take advantage of this where it's advantageous will result in lost marks. We'll provide hints for the less obvious cases.</p> </li> <li> <p>You can't add anything to the type definitions given above; for instance, you can't make <code>Color</code> an instance of <code>Eq</code>, because you don't need to compare colors for equality. (Don't do this indirectly either e.g. by defining an <code>eqColor</code> helper function.) Pattern matching on the datatypes can do everything you need.</p> </li> </ul> <p>Here are the descriptions of the functions you need to implement.</p>"},{"location":"assignments/2/partA_red_black_trees/#1-member","title":"1. <code>member</code>","text":"<p>[5 points]</p> <p>Write the <code>member</code> function, which has this type signature:</p> <pre><code>member :: Ord a =&gt; a -&gt; Tree a -&gt; Bool\n</code></pre> <p>This function takes an element and a red-black tree as its arguments and returns <code>True</code> if the element is in the tree. Note: the color of nodes is not used in this function. (Unused arguments in patterns should use the <code>_</code> notation so as not to trigger compiler warnings.) Assume that the input tree is ordered; use the ordering property to only search the parts of the tree that can possibly contain the element.</p>"},{"location":"assignments/2/partA_red_black_trees/#2-tolist","title":"2. <code>toList</code>","text":"<p>[5 points]</p> <p>Write the <code>toList</code> function, which has this type signature:</p> <pre><code>toList :: Tree a -&gt; [a]\n</code></pre> <p>It takes as its argument a red-black tree and returns a list of all the tree elements given by an in-order traversal. This means that for a node, you collect all the left subtree values first, then the node value, then the right subtree values. This function can be written in two lines.</p> <p>Clearly, here it's OK to convert the tree to a list, because that's the whole point of the function! </p>"},{"location":"assignments/2/partA_red_black_trees/#3-insert","title":"3. <code>insert</code>","text":"<p>[25 points]</p> <p>Write the <code>insert</code> function, which has this type signature:</p> <pre><code>insert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\n</code></pre> <p>This is the hardest (and most interesting) function in the assignment. The reason it's tricky is because you can't just naively add a node to the tree; you also have to make sure that the tree is balanced when you are finished. This is why we need the colors on the nodes. We'll walk you through this function in some detail.</p> <p>First of all, since Haskell is a functional language, although we say we are \"inserting\" an element into a tree, what we are really doing is creating a new tree with one extra element. The original tree is not altered in any way. The new tree will share a lot of structure with the original tree, so we won't modify any part of the old tree that doesn't need to be changed in the new tree.</p> <p>If it weren't for the balancing constraints (the red and black invariants), this would be an easy function to write:</p> <ul> <li> <p>If a tree being inserted into is just a leaf, return a node whose branches are leaves.</p> </li> <li> <p>If the new element is the same as the element in the root node of the tree, return the tree unchanged.</p> </li> <li> <p>Otherwise, determine whether the new element needs to be added to the left or right branch depending on whether it's smaller or larger than the element in the root node, add the element to the correct branch, and reconstruct the final tree.</p> </li> </ul> <p>The only problem is that when you do the last step, you might be causing the tree to violate the red or black invariants and thus become unbalanced. Also, what color should the node containing the new element be? If you think about it, you'll realize that the new node will be put at the base of the tree, right above the leaves. Since the leaves are black, the new node should be colored red so as not to violate the black invariant. However, when you do this, there is a chance that the parent node of the new node will also be red, which violates the red invariant (no red node can have a red parent node). So there has to be a way to re-balance the tree after adding a node to preserve both the red and black invariants. And that's the tricky part.</p> <p>Here's a template version of the code you should write, with some parts filled in:</p> <pre><code>insert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\ninsert elem t = makeBlack (ins elem t)\n  where\n    -- Insert an element into a tree.\n    ins :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\n    ins elem Leaf = Node Red Leaf elem Leaf  -- new nodes are colored red\n    ins elem t@(Node color left elem' right)\n      | elem &lt; elem' = balance color (ins elem left) elem' right\n      | elem &gt; elem' = {- TODO: by analogy with the previous case -}\n      | otherwise = t  -- element already in the tree; no insertion required\n\n    -- Make the root of the tree black.\n    makeBlack :: Tree a -&gt; Tree a\n    makeBlack Leaf = Leaf\n    makeBlack (Node _ left elem right) = Node Black left elem right\n\n    -- Balance a red-black tree under construction which may not satisfy\n    -- the red and black invariants.\n    balance :: Ord a =&gt; Color -&gt; Tree a -&gt; a -&gt; Tree a -&gt; Tree a\n    balance Black (Node Red (Node Red l1 e1 r1) e2 r2) e t =\n      Node Red (Node Black l1 e1 r1) e2 (Node Black r2 e t)\n    balance = {- TODO: 3 more cases omitted -}\n    balance color l e r = Node color l e r  -- no balancing needed\n</code></pre> <p>The basic insertion code is in the <code>ins</code> helper function. If we didn't care about balancing or colors, the line:</p> <pre><code> | elem &lt; elem' = balance color (ins elem left) elem' right\n</code></pre> <p>would be just:</p> <pre><code> | elem &lt; elem' = Node color (ins elem left) elem' right\n</code></pre> <p>and similarly for the <code>elem &gt; elem'</code> case. However, adding the new element <code>elem</code> creates a new red node, and this can make the tree violate the red invariant. Therefore, we call the <code>balance</code> function with the same arguments as the <code>Node</code> constructor would have gotten. Its job is to create a new tree which is guaranteed to be balanced i.e. which doesn't violate any of the invariants. (The order invariant won't be violated, so we don't have to worry about that.) Since we are adding the new element to the left subtree (in this case), only the left subtree could possibly violate the red invariant by having a red node with a red parent. Nevertheless, we will need both subtrees in order to re-balance the tree. It turns out that there are only four different cases that need to be rebalanced.</p> <p>Here is case 1:</p> <p></p> <p>Look at the tree on the left of the arrow. In this case, the left subtree is the node labelled <code>y</code>, the right subtree is labelled <code>d</code>, and the root node of the new tree is labelled <code>z</code>. (The gray triangle nodes (<code>a</code> to <code>d</code>) represent balanced subtrees.) You can see that the left subtree violates the red invariant because node <code>y</code> is red and has a child node <code>x</code> which is also red.</p> <p>What you do is convert the tree on the left of the arrow to the tree on the right. This tree is still correctly ordered (because <code>x &lt; y &lt; z</code>) but now node <code>y</code> is the root of the tree and node <code>x</code> has changed color from red to black. This new tree doesn't violate any of the invariants; ordering is preserved, no red node has a red parent, and both branches have one black node in addition to the black nodes along the paths starting from <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>, which all have the same number of black nodes. This corresponds to the following line from the <code>balance</code> function:</p> <pre><code>balance Black (Node Red (Node Red l1 e1 r1) e2 r2) e t =\n  Node Red (Node Black l1 e1 r1) e2 (Node Black r2 e t)\n</code></pre> <p>Note that <code>balance</code> doesn't get an entire tree as its arguments; it gets the pieces of a tree as separate arguments (color, left subtree, element, right subtree). Nevertheless, the idea is the same. You can see that the root's color is <code>Black</code>, the left subtree (corresponding to nodes <code>y</code> and <code>x</code> in the diagram) is <code>Node Red (Node Red l1 e1 r1) e2 r2</code>, the node element is <code>e</code>, and the right subtree (corresponding to label <code>d</code> in the diagram) is <code>t</code>. The label <code>a</code> in the diagram is <code>l1</code>, <code>b</code> is <code>r1</code>, and <code>c</code> is <code>r2</code>. The output of the function is just the tree to the right of the arrow.</p> <p>These kinds of tree manipulations are referred to as \"tree rotations\" for obvious reasons.</p> <p>Notice how Haskell's algebraic datatypes have made a fairly complicated transformation very simple to write! This is a key advantage of algebraic datatypes when working with sophisticated data structures.</p> <p>Make sure you understand this case! If you do, filling in the rest of the cases of the <code>balance</code> function will be straightforward.</p> <p>Here is the second case:</p> <p></p> <p>The output tree is the same as before, but the inputs will be different. You have to fill in the code for this case.</p> <p>Here are the last two cases:</p> <p></p> <p></p> <p>You need to fill in the code for these cases as well. Any other case does not need to be balanced, so the default line:</p> <pre><code>balance color l e r = Node color l e r  -- no balancing needed\n</code></pre> <p>is in effect.</p> <p>You might be wondering what this helper function is for:</p> <pre><code>-- Make the root of the tree black.\nmakeBlack :: Tree a -&gt; Tree a\nmakeBlack Leaf = Leaf\nmakeBlack (Node _ left elem right) = Node Black left elem right\n</code></pre> <p>It turns out that when inserting into a red-black tree, you may end up with a red node at the root with a red child node (violating the red invariant), but with all other invariants satisfied. In this case we can simply recolor the root node to black to make the black invariant hold. This won't affect the order invariant (obviously) and it won't change the fact that all paths from the root to the leaves have the same number of black nodes (although that number will be one greater than before). You won't need to use <code>makeBlack</code> in any of the code you need to fill in.</p> <p>If you think that this code is complicated, you'd be right! Tree balancing code is often quite complex, and there are some kinds of trees whose balancing code is even worse than this.<sup>1</sup> The nice thing about red-black trees is that they are very efficient in practice, so once we get through writing the code, we have a very useful data structure.</p>"},{"location":"assignments/2/partA_red_black_trees/#4-fromlist","title":"4. <code>fromList</code>","text":"<p>[5 points]</p> <p>Write the <code>fromList</code> function, which has this type signature:</p> <pre><code>fromList :: Ord a =&gt; [a] -&gt; Tree a\n</code></pre> <p>This function takes a list as its argument and returns the red-black tree obtained by inserting all the list elements into an empty tree. This can be written in one line using <code>foldr</code>. (This is not a requirement, but try to find the <code>foldr</code> definition; it's very simple.)</p>"},{"location":"assignments/2/partA_red_black_trees/#5-mindepth-and-maxdepth","title":"5. <code>minDepth</code> and <code>maxDepth</code>","text":"<p>[5 points]</p> <p>Write the <code>minDepth</code> and <code>maxDepth</code> functions, which have these type signatures:</p> <pre><code>minDepth :: Tree a -&gt; Int\nmaxDepth :: Tree a -&gt; Int\n</code></pre> <p>These functions return the minimum and maximum depths of the tree, respectively. That is, <code>minDepth</code> is the smallest distance from the root node to a leaf, while <code>maxDepth</code> is the largest such distance. A tree which is just a <code>Leaf</code> (i.e. an empty tree) has depth 0. Recall that by \"distance\" to a leaf we mean the number of times you can go from a node to one of its branch nodes before you hit a leaf.</p>"},{"location":"assignments/2/partA_red_black_trees/#6-testinvariant1","title":"6. <code>testInvariant1</code>","text":"<p>[10 points]</p> <p>Write the <code>testInvariant1</code> function, which has this type signature:</p> <pre><code>testInvariant1 :: Ord a =&gt; Tree a -&gt; Bool\n</code></pre> <p>This function tests the order invariant. This invariant requires all nodes to have values that are strictly larger than all node values in the node's left subtree and strictly smaller than all node values in the node's right subtree. This function returns <code>True</code> if the tree obeys the invariant.</p> <p>Obviously, in this function the node colors are irrelevant. You probably want to write some helper functions to make this function easier to write.</p> <p>Your code should not be gratuitously inefficient. For instance, don't compare a node value against every single value in its left/right subtree, because that isn't necessary. Marks will be taken off for inefficient solutions. Doing it right isn't hard or tricky.</p>"},{"location":"assignments/2/partA_red_black_trees/#7-testinvariant2","title":"7. <code>testInvariant2</code>","text":"<p>[10 points]</p> <p>Write the <code>testInvariant2</code> function, which has this type signature:</p> <pre><code>testInvariant2 :: Tree a -&gt; Bool\n</code></pre> <p>This function tests the red invariant, which is that no red node has a red parent. Don't forget to use <code>_</code> for unused components of the <code>Node</code> constructor, as usual.</p> <p>Tip</p> <p>Nested pattern matches are extremely helpful here! With them, you can write this function in a few short lines of code. If you think you need to use a <code>case</code> statement, think again.</p> <p>You do not have to compare colors using the <code>==</code> or <code>/=</code> operators, so don't make <code>Color</code> an instance of the <code>Eq</code> type class or define a color comparison function.</p>"},{"location":"assignments/2/partA_red_black_trees/#8-testinvariant3","title":"8. <code>testInvariant3</code>","text":"<p>[10 points]</p> <p>Write the <code>testInvariant3</code> function, which has this type signature:</p> <pre><code>testInvariant3 :: Tree a -&gt; Bool\n</code></pre> <p>This function tests the black invariant, which is that all paths from the root of the tree down through a sequence of nodes to any leaf have the same number of black nodes.</p> <p>Note that the color of the root node is irrelevant (because it's present in all sequences) and the \"color\" of the leaf nodes are also irrelevant (because they are all the same).</p> <p>This function is a bit tricky, so here is a template for you to fill in:</p> <pre><code>testInvariant3 :: Tree a -&gt; Bool\ntestInvariant3 t = allEqual (leafCounts t 0)\n  where\n    -- Given a tree, return a list of the count of black nodes on every path\n    -- from the root of the tree to a leaf.\n    leafCounts :: Tree a -&gt; Int -&gt; [Int]\n    leafCounts Leaf n = [n]\n    leafCounts (Node Black left _ right) n = {- TODO -}\n    leafCounts (Node Red left _ right) n = {- TODO -}\n\n    -- Return True if all the elements of a list are equal.\n    allEqual :: Ord a =&gt; [a] -&gt; Bool\n    allEqual [] = True\n    allEqual [_] = True\n    allEqual (x:r@(y:_)) | x == y = allEqual r\n                         | otherwise = False\n</code></pre> <p>The code marked <code>{- TODO -</code>} is for you to fill in; please remove the <code>{- TODO -}</code> comments! The amount of code you need to add is quite small (one short line in each case).</p> <ol> <li> <p>You may have encountered this phenomenon in a CS 4 midterm exam.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partB_sets/","title":"Part B: Implementing sets using red-black trees (25 points)","text":"<p>In this section, you will use the red-black tree implementation you wrote in the last section to build a reasonably featureful set implementation. All code for this section will still go into the file <code>RedBlackTree.hs</code>. Put it after the code for the red-black trees. (This isn't necessary for it to work, but it will make the code easier to read and grade.)</p> <p>If you don't know much about sets, the Wikipedia article contains everything you need to know for this section.<sup>1</sup></p> <p>This section of your code should start like this:</p> <pre><code>-- We define Set as a type synonym for Tree.\ntype Set a = Tree a\n\n-- Empty set.\nempty :: Set a\nempty = Leaf\n\n-- Convert a list to a set.\ntoSet :: Ord a =&gt; [a] -&gt; Set a\ntoSet = fromList\n</code></pre> <p>From this, we see that a <code>Set</code> is nothing more than an alias for a red-black tree. The empty set is just a <code>Leaf</code>, and the function <code>toSet</code> for converting a list to a set is just the <code>fromList</code> function on red-black trees.</p> <p>Now write the following set functions, using the red-black tree functions you defined above as needed. Every one of them can be written in a single line of code, so you will be penalized if your functions are much longer than this (pay attention to the hints!).</p> <p>Warning</p> <p>Don't write any of these functions by converting both set arguments to lists and then just using list operations. (Doing that will get you no marks for the function.) Also, don't import the <code>Data.List</code> module.</p> <p>For each problem in this section, we will allow you to convert one of the set arguments to a list using <code>toList</code> if you need to (which you may not).</p>"},{"location":"assignments/2/partB_sets/#1-issubset","title":"1. <code>isSubset</code>","text":"<p>[5 points]</p> <p>Write the <code>isSubset</code> function, which has this type signature:</p> <pre><code>isSubset :: Ord a =&gt; Set a -&gt; Set a -&gt; Bool\n</code></pre> <p>This function takes two sets as its arguments and returns <code>True</code> if the first one is a subset of the second (it doesn't have to be a proper subset)</p> <p>Hint</p> <p>Look up the <code>all</code> function on Hoogle.</p>"},{"location":"assignments/2/partB_sets/#2-eqset","title":"2. <code>eqSet</code>","text":"<p>[5 points]</p> <p>Write the <code>eqSet</code> function, which has this type signature:</p> <pre><code>eqSet :: Ord a =&gt; Set a -&gt; Set a -&gt; Bool\n</code></pre> <p>This function takes two sets as its arguments and returns <code>True</code> if the two sets are equal (i.e. if they have the same elements).</p> <p>Hint</p> <p>Define this in terms of <code>isSubset</code>.</p>"},{"location":"assignments/2/partB_sets/#3-union","title":"3. <code>union</code>","text":"<p>[5 points]</p> <p>Write the <code>union</code> function, which has this type signature:</p> <pre><code>union :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\n</code></pre> <p>This function takes two sets as its arguments and returns a new set which is the union of the input sets.</p> <p>Hint</p> <p>Convert one of the set arguments to a list and use <code>foldr</code>. If it's useful, write a skeleton for the function argument of <code>foldr</code> as <code>(\\x r -&gt; ...)</code>, where <code>x</code> is the current element of a list and <code>r</code> is the rest of the list after processing by <code>foldr</code>.</p>"},{"location":"assignments/2/partB_sets/#4-intersection","title":"4. <code>intersection</code>","text":"<p>[5 points]</p> <p>Write the <code>intersection</code> function, which has this type signature:</p> <pre><code>intersection :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\n</code></pre> <p>This function takes two sets as its arguments and returns a new set which is the intersection of the input sets. Fill in the following skeleton code to get the solution:</p> <pre><code>intersection :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\nintersection s1 s2 = foldr (\\x r -&gt; if ... then ... else ...) ... (toList s2)\n</code></pre>"},{"location":"assignments/2/partB_sets/#5-difference","title":"5. <code>difference</code>","text":"<p>[5 points]</p> <p>Write the <code>difference</code> function, which has this type signature:</p> <pre><code>difference :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\n</code></pre> <p>This function takes two sets as its arguments and returns a new set which is the set difference of the input sets, which means that it contains all elements of the first set that are not in the second set. Fill in the following skeleton code to get the solution:</p> <pre><code>difference :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\ndifference s1 s2 = foldr (\\x r -&gt; if ... then ... else ...) ... (toList s1)\n</code></pre> <p>This is the same skeleton function we used above for <code>intersection</code>, and the contents of the function argument are also very similar.</p> <ol> <li> <p>Actually, it contains much more information than you need for this assignment.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/3/assignment3/","title":"Assignment 3: A touch of class","text":""},{"location":"assignments/3/assignment3/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, May 3rd at 2 AM.</p>"},{"location":"assignments/3/assignment3/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 8.</p>"},{"location":"assignments/3/assignment3/#what-to-hand-in","title":"What to hand in","text":"<p>Write all of your code for the first two sections in a single text file called <code>Lab3ab.hs</code>. The sparse matrix code should be a separate file called <code>SparseMatrix.hs</code>. These two files should be submitted to CodePost as <code>Assignment 3</code>.</p>"},{"location":"assignments/3/assignment3/#writing-and-testing-your-code","title":"Writing and testing your code","text":"<p>In the code base for the assignment (available on Canvas) we are supplying automated test scripts for part A and part C. The test script for part A is <code>SignedNatTests.hs</code> and the one for part C is <code>SparseMatrixTests.hs</code>. In addition, we are supplying a <code>Makefile</code>. You can run the tests by putting all three files in the same directory as your code (which must have the correct module names i.e. <code>Lab3ab.hs</code> for part A and <code>SparseMatrix.hs</code> for part C). Then type:</p> <pre><code>$ make test_partA\n</code></pre> <p>to test part A only, or</p> <pre><code>$ make test_partC\n</code></pre> <p>to test part C only, or</p> <pre><code>$ make test\n</code></pre> <p>to test both parts A and C.</p> <p>As in assignment 2, the test code relies on the <code>HUnit</code> and <code>QuickCheck</code> modules for unit testing and randomized testing, respectively. The test script cannot test for everything, but it should catch the most serious problems.</p> <p>One trick you might want to try in case you have a test failure which is difficult to debug is to use the <code>trace</code> function from the <code>Debug.Trace</code> module. This function takes a string and a value, prints the string and returns the value. The trick is that it does this without being in the <code>IO</code> monad, so it uses the dreaded <code>unsafePerformIO</code> function. This is OK since all it does is print output before returning a value.</p> <p>If you want to use this, you need to import the <code>Debug.Trace</code> module. Put this at the top of your file (after the <code>module</code> line):</p> <pre><code>import Debug.Trace\n</code></pre> <p>Then, for a particular value in a computation, you can do this:</p> <pre><code>-- Somewhere inside an expression, you want to print the value of x.\n-- Instead of just `x`, write:\n(trace (\"x = \" ++ show x) x)\n</code></pre> <p>Then, when this code is run, you will get a printout indicating what the value of <code>x</code> was at that point in the program. This is the Haskell way of emulating the common style of debugging used in other languages using print statements.</p>"},{"location":"assignments/3/assignment3/#haskell-note-infinite-loops-in-tests","title":"Haskell note: Infinite loops in tests","text":"<p>One thing to be wary of with the randomized tests in parts A and C is infinite loops. The test framework can't detect this, so it will seem that the tests have just stopped producing output.</p> <p>It turns out that reporting failures on infinite loops is very hard to do reliably in GHC Haskell. There is a <code>timeout</code> function, but it doesn't work when the infinite loop happens in a tight inner loop of a function that doesn't internally allocate memory.</p> <p>Note</p> <p>If you're curious, there is a discussion on this topic at this link.</p> <p>The bottom line is that if you see your tests hanging, you probably have an infinite loop in the code being tested, and you need to look at it carefully.</p>"},{"location":"assignments/3/assignment3/#haskell-note-the-scopedtypevariables-pragma","title":"Haskell note: The <code>ScopedTypeVariables</code> pragma","text":"<p>Note</p> <p>You can skip this section for now, but if you get a weird error message involving \"rigid type variables\", please read it for an explanation of what's going on.</p> <p>For part C (the sparse matrix implementation), there will be one function (sparse matrix multiplication) which is naturally done by dividing it up into helper functions. If you do this, you may well encounter a strange kind of type error that you haven't seen before.</p> <p>The problem arises when a function is polymorphic i.e. its type depends on a type variable, say <code>a</code>. Let's assume that this function has an explicit type signature, as most top-level functions do in Haskell. Let's also assume that there is a helper function, probably defined in a <code>where</code> clause, which is also polymorphic (its type depends on a type variable <code>a</code>) and which also has an explicit type signature. So the function looks something like this:</p> <pre><code>foo :: a -&gt; Foo a\nfoo x = ...\n  where\n    bar :: a -&gt; Int -&gt; Foo a\n    bar y n = ...\n</code></pre> <p>The issue here is that Haskell can't assume that the <code>a</code> type variable in the type declaration of the <code>bar</code> function (defined in the <code>where</code> clause) is the same type variable as the <code>a</code> type variable in the type declaration of the <code>foo</code> function (defined at the top level).</p> <pre><code>foo :: a -&gt; Foo a   -- type variable `a` (top level)\nfoo x = ...\n  where\n    bar :: a -&gt; Int -&gt; Foo a  -- `a` is not necessarily the same type variable!\n    bar y n = ...\n</code></pre> <p>In some cases, this doesn't cause any problems. Specifically, if you can move the function <code>bar</code> to the top level with no errors, then everything should still work. On the other hand, if <code>bar</code> is using anything defined in <code>foo</code> that has a type which depends on <code>a</code>, you're in trouble. That's this scenario:</p> <pre><code>foo :: a -&gt; Foo a\nfoo x = ...  -- N.B. `x` has type `a`\n  where\n    bar :: a -&gt; Int -&gt; Foo a\n    bar y n =\n      ... x ... -- `bar` uses `x` (from the outer scope)\n                -- but `x` was not an argument to `bar`\n</code></pre> <p>What happens here is that <code>x</code> has the type <code>a</code> (the outer <code>a</code>) but inside <code>bar</code>, you probably expect that <code>x</code> and <code>y</code> both have the same type (<code>a</code>) when in fact Haskell considers them to be (possibly) different. If you try to use <code>x</code> inside <code>bar</code> as if it has the same type as <code>y</code>, your code won't compile and you'll see errors describing something called <code>rigid type variables</code>, which isn't very helpful.</p> <p>There are three different ways to fix this.</p> <p>First, you can remove the type signature of <code>bar</code>, leading to this:</p> <pre><code>foo :: a -&gt; Foo a\nfoo x = ...\n  where\n    bar y n = ... [bar uses x but x was not an argument to bar] ...\n</code></pre> <p>Here you are depending on the type inference engine to sort things out, and it usually does what you want. We don't like this, because we like having explicit type signatures on all of our functions.</p> <p>The second way is to add extra arguments instead of using arguments in an outer scope:</p> <pre><code>foo :: a -&gt; Foo a\nfoo x = ... bar x ... -- `bar` called with `x` as its first argument\n  where\n    bar :: a -&gt; a -&gt; Int -&gt; Foo a\n    bar x y n = ...\n</code></pre> <p>This will work fine, but the code can get significantly messier. Basically, you are rewriting <code>bar</code> so that it could be a top-level function.</p> <p>The third way is the slickest. First, at the top of the entire file (before any imports and the <code>module</code> line), add a language pragma that looks like this:</p> <pre><code>{-# LANGUAGE ScopedTypeVariables #-}\n</code></pre> <p>Language pragmas are optional opt-in features of GHC. This turns on one such feature called <code>ScopedTypeVariables</code>.</p> <p>Then, rewrite the type signature of the <code>foo</code> function as follows:</p> <pre><code>foo :: forall a . a -&gt; Foo a  -- note the `forall` keyword\nfoo x = ...\n  where\n    bar :: a -&gt; Int -&gt; Foo a\n    bar y n = ...\n</code></pre> <p>All you've done is add the <code>forall a .</code> before the type signature of <code>foo</code>. What this does (along with the <code>ScopedTypeVariables</code> pragma) is say \"in any helper function of <code>foo</code> that uses the type variable <code>a</code>, the <code>a</code> in the helper function must refer to the same <code>a</code> as the <code>a</code> in <code>foo</code>'s type signature\". In other words, the type variable <code>a</code> is scoped which means that the outer declaration which includes <code>a</code> applies to the entire function. This is exactly what you want, and this fixes the compilation error.</p> <p>Note</p> <p>If you have a type class qualifier, it has to come after the <code>forall</code>:</p> <pre><code>foo :: forall a . Eq a =&gt; a -&gt; Foo a\nfoo x = ...\n  where\n    bar :: a -&gt; Int -&gt; Foo a\n    bar y n = ...\n</code></pre> <p>You are allowed to use the <code>ScopedTypeVariables</code> pragma in this assignment, and in all assignments from now on. It's never necessary but it can be convenient.</p>"},{"location":"assignments/3/partA_exercises/","title":"Part A: Basic exercises (40 points)","text":"<p>This assignment is mainly concerned with algebraic data types and type classes. In this section, we will do some exercises involving the <code>Eq</code>, <code>Ord</code> and <code>Num</code> type classes. There is also a test script for this section (see below), which you should run to see if your code works correctly before submitting your assignment.</p>"},{"location":"assignments/3/partA_exercises/#1-eq-and-show-for-nat1","title":"1. <code>Eq</code> and <code>Show</code> for <code>Nat1</code>","text":"<p>[5 points]</p> <p>In class, we saw the definition of a simple algebraic data type for natural numbers:</p> <pre><code>data Nat = Zero | Succ Nat\n</code></pre> <p>We'll be creating our own variants of this type to experiment with type class instances. First, we'll write the <code>Nat1</code> type:</p> <pre><code>data Nat1 = Zero1 | Succ1 Nat1\n</code></pre> <p>Write out manual definitions of instances of the <code>Eq</code> and <code>Show</code> type classes for <code>Nat1</code>. Make sure that <code>show (Succ1 Zero1)</code> returns <code>\"Succ1 Zero1\"</code> and not e.g. <code>\"Succ1 (Zero1)\"</code>. For larger numbers, put parentheses around all arguments to <code>Succ1</code> except for <code>Zero1</code> (for instance <code>Succ1 (Succ1 Zero1)</code> for 2.)</p> <p>Note</p> <p>In this and all the problems involving <code>Nat</code> and <code>Nat</code>-like types in this section, do not convert your <code>Nat</code>s (or related types) to integers (or to other <code>Nat</code>-like types) and do the required operations on the other type unless we specifically say to do so. In fact, the only time we will allow this is when the problem is to convert a <code>Nat</code> (or related types) to integers. If you violate this rule, you will get no credit for those problems.</p>"},{"location":"assignments/3/partA_exercises/#2-deriving-eq-and-show-for-nat2","title":"2. Deriving <code>Eq</code> and <code>Show</code> for <code>Nat2</code>","text":"<p>[2 points]</p> <p>Next, we'll define the <code>Nat2</code> type:</p> <pre><code>data Nat2 = Zero2 | Succ2 Nat2\n</code></pre> <p>Make Haskell derive the <code>Eq</code> and <code>Show</code> instances for <code>Nat2</code> by adding a <code>deriving</code> annotation to this type.</p>"},{"location":"assignments/3/partA_exercises/#3-ord-for-nat2","title":"3. <code>Ord</code> for <code>Nat2</code>","text":"<p>[3 points]</p> <p>Write out an explicit instance definition of the <code>Ord</code> type class for the <code>Nat2</code> type. This can be done with a single method definition (for the <code>&lt;=</code> operator) since all other <code>Ord</code> methods can be defined in terms of <code>&lt;=</code>.</p> <p>Also, note that if we wanted, we could have Haskell derive the <code>Ord</code> instance for us. Sometimes this will give us the definition we want, and sometimes it won't. Will it work in this case? Why or why not? (Include your answer in a comment.)</p>"},{"location":"assignments/3/partA_exercises/#4-eq-and-ord-for-signednat","title":"4. <code>Eq</code> and <code>Ord</code> for <code>SignedNat</code>","text":"<p>[5 points]</p> <p>Note</p> <p>For the rest of this section, we'll be using the <code>Nat</code> type defined as:</p> <pre><code>data Nat = Zero | Succ Nat\n  deriving (Eq, Show, Ord)\n</code></pre> <p>Make sure you include this code in your submission.</p> <p>Let's say we would like to represent negative numbers as well as natural numbers, while keeping a unary representation. I'm not sure why we would want this, but let's say we do. We define this datatype:</p> <pre><code>data SignedNat =\n  Neg Nat | Pos Nat\n  deriving (Show)\n</code></pre> <p>The <code>Eq</code> and <code>Ord</code> instances for <code>Nat</code> exist (since we're deriving them). Write out the <code>Eq</code> and <code>Ord</code> instance definitions for the <code>SignedNat</code> type. Could you just use automatically-derived definitions for the <code>Eq</code> and <code>Ord</code> instances? Write the answer in a comment.</p>"},{"location":"assignments/3/partA_exercises/#5-num-for-signednat","title":"5. <code>Num</code> for <code>SignedNat</code>","text":"<p>[10 points]</p> <p>Write out the <code>Num</code> instance definition for <code>SignedNat</code>.</p> <p>Tip</p> <ul> <li> <p>For details on the <code>Num</code> methods see this page (It's actually more detail than you need.)</p> </li> <li> <p>Note that <code>signum n</code> should be <code>-1</code> if <code>n &lt; 0</code>, <code>0</code> if <code>n == 0</code>, and <code>+1</code> if <code>n &gt; 0</code>, where <code>-1</code>, <code>0</code>, and <code>1</code> are expressed as their <code>SignedNat</code> equivalents.</p> </li> <li> <p>A clean way to do this for longer method definitions is to implement the <code>Num</code> methods as separate stand-alone functions e.g. <code>addSignedNat</code>, <code>mulSignedNat</code> etc. and then write the instance definition by referring to those functions. Also note that you don't have to implement all 7 <code>Num</code> methods; specifically, you only have to implement one of (<code>(-)</code>, <code>negate</code>) because the other can be defined trivially in terms of it.</p> </li> <li> <p>Beware of subtle problems involving zero.</p> </li> <li> <p>You'll probably find it useful to define some helper functions to do arithmetic operation on <code>Nat</code>s.</p> </li> <li> <p>Watch out for compiler warnings about non-exhaustive pattern matches! It's easy to miss cases.</p> </li> </ul>"},{"location":"assignments/3/partA_exercises/#6-signednattointeger","title":"6. <code>signedNatToInteger</code>","text":"<p>[5 points]</p> <p>Write a function called <code>signedNatToInteger</code> which converts a <code>signedNat</code> value to an <code>Integer</code>, as the name suggests. This is used by the test suite.</p> <p>Of course, here you are allowed (required) to convert <code>Nat</code>s and <code>signedNat</code>s to integers.</p>"},{"location":"assignments/3/partA_exercises/#7-unaryinteger","title":"7. <code>UnaryInteger</code>","text":"<p>[5 points]</p> <p>Is there anything about the <code>SignedNat</code> datatype that strikes you as a bit ugly and redundant? Come up with a different datatype to represent positive and negative integers called <code>UnaryInteger</code> in the spirit of <code>Nat</code> (i.e. a unary encoding) that doesn't have this redundancy. Does it have any other problems? Can you think of a way to fix even those problems, possibly at the cost of increased complexity?</p> <p>The purpose of this exercise is to illustrate the fact that designing datatypes involves tradeoffs, and it's not always possible to do a perfect job. In particular, there are invariants that you may want Haskell to enforce that Haskell can't enforce.</p> <p>Note</p> <p>For this problem, we're not demanding that you come up with the exact datatypes we did, just that you try some alternatives and think about the problems that come up.</p> <p>Also, note that you don't have to implement the new datatype's operations. Just write up the <code>data</code> declarations and describe them in words in a comment.</p>"},{"location":"assignments/3/partA_exercises/#8-generic-factorial","title":"8. Generic <code>factorial</code>","text":"<p>[5 points]</p> <p>Write a definition of the factorial function called <code>factorial</code> which will work for any instance of <code>Num</code> and <code>Ord</code>. Make sure that it reports an error when given a negative number. Verify that it works for the <code>SignedNat</code> datatype by computing the result of <code>factorial (Pos (Succ (Succ (Succ Zero))))</code>. Write the answer in a comment. (You don't have to do a manual evaluation; just enter the expression into <code>ghci</code> and write the result.)</p> <p>Note</p> <p>Remember that integer literals can represent any type which is an instance of the <code>Num</code> type class.</p>"},{"location":"assignments/3/partB_operators/","title":"Part B: Operators (10 points)","text":"<p>In mathematics, an associative operator <code>OP</code> is one that has the property that <code>x OP (y OP z) == (x OP y) OP z</code>. In other words, in a chained operator expression of the form <code>x OP y OP z</code>, where you put the parentheses doesn't matter; you can interpret the expression as either <code>x OP (y OP z)</code> or <code>(x OP y) OP z</code> and it will mean the same thing.</p> <p>Associativity in programming languages like Haskell doesn't usually mean this kind of associativity, because most programming languages (including Haskell) aren't powerful enough to express the concept of mathematical associativity. Instead, associativity (more technically known as fixity) is just a syntactic property of an operator which allows the parser to correctly interpret expressions of the form <code>x OP y OP z</code>.</p> <p>If the operator <code>OP</code> is \"left-associative\", this will be interpreted as <code>(x OP y) OP z</code> (put the parentheses around the leftmost operator subexpression). If it's \"right-associative\", it will be interpreted as <code>x OP (y OP z)</code> (put the parentheses around the rightmost operator subexpression). If it's \"non-associative\", simply disallow the expression altogether (i.e. require the programmer to explicitly put the parentheses in to indicate what the intended meaning is).</p> <p>Note</p> <p>Some operators can only be non-associative, because they can't be chained in this way due to their types.</p> <p>Haskell allows you to define your own operators and to set both the precedence of the operators (from 0 to 9) and their associativities/fixities (<code>infix</code> for non-associative, <code>infixl</code> for left-associative, or <code>infixr</code> for right-associative). The default associativity (in case you don't set it) is left-associative.</p> <p>Some operators have type signatures which require a particular associativity to work in chained operator expressions, while with other operators, you have a choice, though sometimes one choice is much better than another.</p> <p>For instance, the \"cons\" operator (<code>:</code>) must be right-associative for expressions like <code>1 : 2 : [3]</code> to work, while the addition operator (<code>+</code>) can be either right- or left-associative (it's actually left-associative, but it would work correctly either way). Some operators like the division operator (<code>/</code>) could theoretically be either right- or left-associative but are left-associative to conform to mathematical practice (because the <code>/</code> operator is not associative in the mathematical sense, so right-associative and left-associative interpretations of chained operators give different results). Some operators like the equality operator (<code>==</code>) are non-associative; you might wish that an expression like <code>x == y == z</code> means the same thing as <code>(x == y) &amp;&amp; (x == z)</code> but it doesn't (in fact, it's a syntax error). This makes sense, because <code>x == (y == z)</code> requires that <code>x</code> but not <code>y</code> or <code>z</code> be a <code>Bool</code>, while <code>(x == y) == z</code> requires that <code>z</code> but not <code>x</code> or <code>y</code> be a <code>Bool</code>. The point is, you sometimes have to think a bit in order to set the associativity of a user-defined operator correctly.</p> <p>Note also that Haskell allows you to set invalid associativities for your operators! Any operator can be declared <code>infix</code>, which simply means that chained operator expressions using that operator become parse errors and are rejected. Or an operator which should be declared <code>infixr</code> could be declared <code>infixl</code> instead, which means that chained operator expressions will be interpreted incorrectly, leading to type errors in some cases and other kinds of errors in other cases.</p> <p>Also, operators in Haskell (including user-defined operators) can only be made from \"operator characters\", which means symbolic characters (not <code>A-Z</code> or <code>a-z</code> or <code>0-9</code> or <code>_</code>) and not including some characters with special functions (like parentheses, square brackets etc.).</p>"},{"location":"assignments/3/partB_operators/#1-what-is-the-associativity-of-this-operator","title":"1. What is the associativity of this operator?","text":"<p>[8 points]</p> <p>For the first part of this problem, we will show you some new operators we've defined, and you should indicate what the associativity (fixity) should be. Here are your choices:</p> <ul> <li> <p>If neither <code>infixr</code> or <code>infixl</code> will work with chained operator expressions (i.e. both of them lead to type errors), declare it to be <code>infix</code> (non-associative).</p> </li> <li> <p>If the operator can be declared either <code>infixr</code> or <code>infixl</code> without resulting in a type error for chained operator expressions, declare it <code>infixl</code> but add a comment stating that it could be <code>infixr</code> as well.</p> </li> <li> <p>If the operator can be declared as only one of <code>infixr</code> or <code>infixl</code> without resulting in a type error for chained operator expressions, declare it to be the correct associativity (either <code>infixr</code> or <code>infixl</code>; whichever works).</p> </li> </ul> <p>When figuring out if a \"chained operator expression\" works for either the <code>infixr</code> or <code>infixl</code> associativity, choose whichever values you like as arguments to the operator; if any choice of arguments works, it's valid for that associativity. Give one example of a chained operator expression in that case. No examples are needed if the correct associativity is <code>infix</code> (i.e. non-associative).</p> <p>Here are the operators (just a description, not a definition):</p> <ul> <li> <p>The operator <code>&gt;#&lt;</code> compares two integer scores and tells you the winner (as a string). For example, <code>51 &gt;#&lt; 40 = \"First Player\"</code>, and <code>21 &gt;#&lt; 21 = \"Tie\"</code>. It has type <code>Integer -&gt; Integer -&gt; String</code>.</p> </li> <li> <p>The operator <code>+|</code> adds two integers and takes the last digit of their sum. For example, <code>7 +| 6 = 3</code>. It has type <code>Integer -&gt; Integer -&gt; Integer</code>.</p> </li> <li> <p>The operator <code>&amp;&lt;</code> appends an integer to the end of a list. For example, <code>[1, 2] &amp;&lt; 3 = [1, 2, 3]</code>. It has type <code>[Integer] -&gt; Integer -&gt; [Integer]</code>, where <code>[Integer]</code> means a list of integers.</p> </li> <li> <p>The operator <code>&gt;&amp;&amp;</code> \"cons\"es an integer twice to the beginning of a list. For example, <code>1 &gt;&amp;&amp; [2, 3] = [1, 1, 2, 3]</code>. It has type <code>Integer -&gt; [Integer] -&gt; [Integer]</code>.</p> </li> </ul> <p>Write your answers in a Haskell comment, along with a brief explanation of why that answer is correct, plus examples (if needed).</p>"},{"location":"assignments/3/partB_operators/#2-a-curious-operator","title":"2. A curious operator","text":"<p>[2 points]</p> <p>Now consider an operator <code>+#</code> that adds two integers and tells you how many digits long their sum is. For example, <code>2 +# 800 = 3</code>, since <code>802</code> is three digits long. It has type <code>Integer -&gt; Integer -&gt; Integer</code>. What could its associativity be in order to allow chained operators to type check (give all answers that work). What should its associativity be for it to work in a reasonable way?</p> <p>Tip</p> <p>Try writing out some examples.</p> <p>Again, write your answers in a Haskell comment, and explain why the answers are correct.</p>"},{"location":"assignments/3/partC_sparse_matrices/","title":"Part C: Miniproject: Sparse Matrices (50 points)","text":"<p>In this section, you will be implementing a Haskell module which includes datatypes and functions to represent and compute with sparse matrices. A sparse matrix is a matrix which contains a large number of zero elements, which are not represented explicitly. Typically, the vast majority of the elements in the matrix are zeros. Sparse matrices arise naturally in a wide variety of applications.</p> <p>Because of the large number of zero elements, computing with sparse matrices requires different algorithms than with non-sparse (\"dense\") matrices, or else the resulting code will be very inefficient. (Note that here we use the term \"matrix\" to include not only square matrices but matrices with any number of rows or columns.) In this module, you will be implementing sparse matrix addition, subtraction, multiplication, and negation. While doing so, it is very important that you take advantage of the sparseness of the matrices in your implementation. If you implement any of the functions by treating sparse matrices as dense matrices, the code will be considered invalid and you will get no credit on the problem.</p> <p>In addition to the challenge of implementing efficient functions for computing with sparse matrices, this miniproject has some other goals. You will learn to work with some of the data structures from the Haskell libraries, and you will learn to use Hoogle to search through the APIs. The total amount of code you need to write for this section is not large; our code is about 100 lines of non-comment code. (Note that we do expect you to write a reasonable amount of comments in your code explaining what your functions do.)</p>"},{"location":"assignments/3/partC_sparse_matrices/#sparse-matrix-representation","title":"Sparse matrix representation","text":"<p>A particular element of each sparse matrix is identified by its row index and its column index. Row and column indices start at 1 (not 0!). Therefore, the basic representation for sparse matrices will be a map between pairs of <code>Integer</code>s (don't use <code>Int</code>s) and values, where the integers must be at least 1 and values can be any Haskell type which instantiates the <code>Num</code> type class. To represent the map you will use the <code>Data.Map</code> module and the <code>Map</code> datatype. Browse through the Hoogle documentation on <code>Data.Map</code> to learn how to use <code>Map</code>s. Note that you don't have to know how <code>Map</code>s are implemented, though you can browse the source code if you're curious; what's important here is that you know how to use them.</p> <p>Warning</p> <p>If you use 0-based indexing you will get at most half points on this section of the assignment.</p> <p>Note</p> <p>Don't confuse the <code>Map</code> type (which is a container type similar to a Python dictionary, but immutable) to the <code>map</code> higher-order function. There is no connection between them.</p> <p>In addition to the map between pairs of <code>Integer</code>s and values, we need some extra bookkeeping information in each sparse matrix. Specifically, we have to store:</p> <ul> <li> <p>The bounds of the matrix (number of rows and columns), as a pair of <code>Integer</code>s.</p> </li> <li> <p>A set of row indices, representing all rows that have nonzero elements.</p> </li> <li> <p>A set of column indices, representing all columns that have nonzero elements.</p> </li> </ul> <p>The row and column indices are stored to allow us to skip rows and columns that contain only zeros. This is particularly important when implementing multiplication. To implement sets, use the <code>Set</code> datatype contained in the <code>Data.Set</code> module. Again, see Hoogle for details.</p> <p>Here is the definition of the sparse matrix datatype you should use:</p> <pre><code>import qualified Data.Map as M\nimport qualified Data.Set as S\n\ndata SparseMatrix a =\n  SM { bounds     :: (Integer, Integer),  -- number of rows, columns\n       rowIndices :: S.Set Integer,       -- row indices with nonzeros\n       colIndices :: S.Set Integer,       -- column indices with nonzeros\n       vals       :: (M.Map (Integer, Integer) a) }  -- values\n  deriving (Eq, Show)\n</code></pre> <p>Note that this is a polymorphic type where the type <code>a</code> must be an instance of the <code>Num</code> type class. (We don't include that as a datatype context because Haskell doesn't allow adding contexts to datatypes by default, so this must be enforced by functions that act on the datatype.)</p> <p>Note</p> <p>You are not allowed to choose a different sparse matrix representation.</p> <p>The <code>import qualified ... as ...</code> lines indicate that you should import the indicated modules and give a one-letter prefix to names in those modules. (It doesn't have to be one-letter, but that's what we're doing here.) So the <code>Set</code> datatype in <code>Data.Set</code> becomes <code>S.Set</code> instead of <code>Data.Set.Set</code>, and the <code>Map</code> datatype in <code>Data.Map</code> becomes <code>M.Map</code> instead of <code>Data.Map.Map</code>. This allows you to keep different namespaces separate without having to do too much extra typing. This is important here because the <code>Set</code> and <code>Map</code> modules contain a number of functions with the same names.</p> <p>One important point about the data representation is that after any sparse matrix operation (including the function to construct a sparse matrix!), you must make sure that:</p> <ul> <li> <p>there are no zeros stored in the matrix (i.e. in the <code>vals</code> map)</p> </li> <li> <p>the <code>rowIndices</code> and <code>colIndices</code> fields have been updated so that they contain all (and only!) the rows/columns with nonzero elements.</p> </li> </ul>"},{"location":"assignments/3/partC_sparse_matrices/#structure-of-the-code","title":"Structure of the code","text":"<p>The Haskell code for the sparse matrix module will be called <code>SparseMatrix.hs</code> and will implement the <code>SparseMatrix</code> module. The first few lines will be as follows (add comments as you see fit):</p> <pre><code>module SparseMatrix where\n\nimport qualified Data.Map as M\nimport qualified Data.Set as S\n\ndata SparseMatrix a =\n  SM { bounds     :: (Integer, Integer),  -- number of rows, columns\n       rowIndices :: S.Set Integer,       -- row indices with nonzeros\n       colIndices :: S.Set Integer,       -- column indices with nonzeros\n       vals       :: (M.Map (Integer, Integer) a) }  -- values\n  deriving (Eq, Show)\n</code></pre> <p>Following this, write the code for your function/operator definitions, along with any helper functions you may want to write.</p>"},{"location":"assignments/3/partC_sparse_matrices/#useful-library-functions","title":"Useful library functions","text":"<p>Here are the names of some library functions you may find useful. Look them up in Hoogle to find out how they work. You aren't required to use them if you don't need to.  You may also find other functions in these modules to be useful; use whichever ones you like. Don't use other modules.</p>"},{"location":"assignments/3/partC_sparse_matrices/#from-datamap","title":"From <code>Data.Map</code>","text":"<ul> <li><code>elems</code></li> <li><code>filter</code></li> <li><code>filterWithKey</code></li> <li><code>findWithDefault</code></li> <li><code>foldr</code></li> <li><code>fromList</code></li> <li><code>intersectionWith</code></li> <li><code>keys</code></li> <li><code>lookup</code></li> <li><code>map</code></li> <li><code>mapKeys</code></li> <li><code>toList</code></li> <li><code>unionWith</code></li> </ul> <p>Note that the functions called <code>map</code> and <code>filter</code> in this module are not the same as those called <code>map</code> and <code>filter</code> in the Prelude (i.e. that work on lists). This is another reason why we use <code>import qualified</code> when importing this module.</p>"},{"location":"assignments/3/partC_sparse_matrices/#from-dataset","title":"From <code>Data.Set</code>","text":"<ul> <li><code>fromList</code></li> <li><code>toList</code></li> </ul> <p>Again, note that these two functions are not the same as the functions with the same name from the <code>Data.Map</code> module. (And again, this is why we use <code>import qualified</code> when importing these modules.)</p> <p>Warning</p> <p>Avoid converting <code>Set</code>s to or from lists unless you have to. (For one thing, this can make your functions much less efficient.) If a <code>Set</code> function can do the same thing as a similar list function, use the <code>Set</code> version.</p> <p>Similarly, avoid converting <code>Map</code>s to or from lists unless you have to. Check to see if one of the <code>Map</code> functions referred to above can do what you need before doing a conversion to lists.</p>"},{"location":"assignments/3/partC_sparse_matrices/#from-datalist","title":"From <code>Data.List</code>","text":"<ul> <li><code>all</code></li> </ul> <p>Here are the functions you have to implement.</p>"},{"location":"assignments/3/partC_sparse_matrices/#1-sparsematrix","title":"1. <code>sparseMatrix</code>","text":"<p>[5 points]</p> <p>Implement a function called <code>sparseMatrix</code> which creates a sparse matrix from a list of index/value pairs and the array bounds.</p> <p>The type signature of this function will be:</p> <pre><code>sparseMatrix :: (Eq a, Num a) =&gt;\n  [((Integer, Integer), a)] -&gt; (Integer, Integer) -&gt; SparseMatrix a\n</code></pre> <p>Note that the indices in the index/value pairs are themselves pairs of integers. The function must check that the given bounds are valid (i.e. at least 1 each), and that all the index pairs given are within those bounds. If not, an error must be signalled.</p> <p>The function must not put zero values into the sparse matrix, even if some of the values in the input index/value pair list are zeros. Similarly, the function must store the row indices and column indices of only the rows/columns that have nonzero values.</p> <p>You can assume that the list of index/value pairs will not have duplicated indices. If there are duplicated indices, you can do whatever is most convenient.</p> <p>Note</p> <p>The number <code>0</code> is a valid value of any type that is an instance of the <code>Num</code> type class.</p>"},{"location":"assignments/3/partC_sparse_matrices/#2-addsm","title":"2. <code>addSM</code>","text":"<p>[5 points]</p> <p>Implement a function called <code>addSM</code> which adds two compatible sparse matrices.</p> <p>The type signature of this function will be:</p> <pre><code>addSM :: (Eq a, Num a) =&gt; SparseMatrix a -&gt; SparseMatrix a -&gt; SparseMatrix a\n</code></pre> <p>If the two sparse matrices cannot be added (i.e. they don't have the same number of rows or columns) an error must be signalled. Be sure to adjust the <code>rowIndices</code> and <code>colIndices</code> after adding, and make sure that there are no zero elements in the matrix after adding.</p>"},{"location":"assignments/3/partC_sparse_matrices/#3-negatesm","title":"3. <code>negateSM</code>","text":"<p>[5 points]</p> <p>Implement a function called <code>negateSM</code> which negates a sparse matrix.</p>"},{"location":"assignments/3/partC_sparse_matrices/#4-subsm","title":"4. <code>subSM</code>","text":"<p>[5 points]</p> <p>Implement a function called <code>subSM</code> which subtracts two compatible sparse matrices.</p> <p>Tip</p> <p>This function can trivially be defined in terms of the previous two.</p>"},{"location":"assignments/3/partC_sparse_matrices/#5-mulsm","title":"5. <code>mulSM</code>","text":"<p>[15 points]</p> <p>Implement a function called <code>mulSM</code> which multiplies two compatible sparse matrices.</p> <p>Recall that for two matrices to be compatible for multiplication, the number of columns in the first matrix must equal the number of rows in the second matrix. Your function must check for this and signal an error if the two matrices cannot be multiplied.</p> <p>Warning</p> <p>This function is by far the trickiest one to implement of all the sparse matrix functions in this miniproject. We recommend that you write a helper function to multiply a row of one matrix (a row vector) by a column of the other (a column vector), and use that to construct the product matrix. Use the <code>rowIndices</code> and <code>colIndices</code> fields of the matrices to avoid multiplying empty rows or columns.</p> <p>As always, make sure that none of the stored entries of the sparse matrix are zeros.</p>"},{"location":"assignments/3/partC_sparse_matrices/#6-accessors","title":"6. Accessors","text":"<p>[5 points]</p> <p>Define three accessor functions for sparse matrices:</p> <ul> <li> <p><code>getSM</code>, which retrieves a value from a sparse matrix given the row and column</p> </li> <li> <p><code>rowsSM</code>, which returns the number of rows in a sparse matrix</p> </li> <li> <p><code>colsSM</code>, which returns the number of columns in a sparse matrix</p> </li> </ul> <p>Note</p> <p><code>rowsSM</code>/<code>colsSM</code> return the total number of rows/columns in the sparse matrix, not the number of nonzero rows/columns.</p> <p>Here are the type signatures:</p> <pre><code>getSM :: Num a =&gt; SparseMatrix a -&gt; (Integer, Integer) -&gt; a\nrowsSM :: Num a =&gt; SparseMatrix a -&gt; Integer\ncolsSM :: Num a =&gt; SparseMatrix a -&gt; Integer\n</code></pre> <p><code>getSM</code> retrieves the value at the index represented by the pair of integers. If this row/column location is invalid (out of bounds of the matrix), signal an error. If it's in bounds but there is no value stored in the matrix at that location, return a zero.</p>"},{"location":"assignments/3/partC_sparse_matrices/#7-operators","title":"7. Operators","text":"<p>[5 points]</p> <p>Define operator shortcuts for the <code>addSM</code>, <code>subSM</code>, <code>mulSM</code>, and <code>getSM</code> functions defined previously.</p> <p>Use <code>&lt;|+|&gt;</code> as the operator for <code>addSM</code>, <code>&lt;|-|&gt;</code> for <code>subSM</code>, <code>&lt;|*|&gt;</code> for <code>mulSM</code> and <code>&lt;!&gt;</code> for <code>getSM</code>. The type signatures of these operators are identical to those of the corresponding functions (but you should write them out anyway).</p>"},{"location":"assignments/3/partC_sparse_matrices/#8-num-instance-of-sparsematrix","title":"8. <code>Num</code> instance of <code>SparseMatrix</code>?","text":"<p>[5 points]</p> <p>Why doesn't it make sense to define the <code>SparseMatrix</code> datatype as an instance of the <code>Num</code> type class? Write your answer in a comment.</p>"},{"location":"assignments/3/partC_sparse_matrices/#things-to-watch-out-for","title":"Things to watch out for","text":"<p>By far the biggest pitfall when writing sparse matrix code is writing code that inadvertently breaks the sparse matrix invariants i.e. where explicit zero elements are stored in the sparse matrix, or where the row/column indices stored are invalid (e.g. by containing indices for rows with no nonzero elements). Pay special attention to this when writing the code, especially the <code>sparseMatrix</code> function and the addition and multiplication functions.</p> <p>Tip</p> <p>Don't forget to run the test suite on your code!</p>"},{"location":"assignments/4/assignment4/","title":"Assignment 4: <code>IO</code>, <code>IO</code>, it's off to work we go!","text":""},{"location":"assignments/4/assignment4/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, May 10nd at 2 AM.</p>"},{"location":"assignments/4/assignment4/#objectives","title":"Objectives","text":"<p>The theme of this assignment is working with the <code>IO</code> monad. We will do so in various ways: with some simple exercises, some simple stand-alone programs, and a more complicated program. When you've finished this assignment you should be very comfortable working with the <code>IO</code> monad and with the <code>do</code> notation for monads.</p>"},{"location":"assignments/4/assignment4/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 13.</p>"},{"location":"assignments/4/assignment4/#what-to-hand-in","title":"What to hand in","text":"<p>You will hand in four files for this assignment. The exercises will be in a file called <code>Lab4a.hs</code>. The three standalone programs should each be in separate files called <code>Reverse.hs</code>, <code>Columns.hs</code> and <code>Sudoku.hs</code>. These files should be submitted to CodePost as <code>Assignment 4</code>.</p>"},{"location":"assignments/4/assignment4/#writing-and-testing-your-code","title":"Writing and testing your code","text":"<p>The code base for the assignment is available on Canvas as <code>lab4.zip</code>.</p> <p>We don't have automated tests for this assignment, since most of the assignment is creating and running standalone programs. We do expect that all of your standalone programs should compile successfully (without warnings) and run correctly on inputs of varying kinds. You should test these manually to convince yourself of this. The writeup contains some suggested inputs for you to try.</p> <p>Note</p> <p>Although automated tests are awesome, many students get far too dependent on them, to the point where they never actually run their programs themselves. This assignment will hopefully help you to step out of that mindset!</p> <p>The last part of the assignment (the Sudoku solver) has both a template file called <code>Sudoku.hs</code> and a directory containing sample input boards. The solver should successfully solve all the sample boards in a reasonable amount of time (certainly no more than 30 seconds for any given board).</p>"},{"location":"assignments/4/partA_exercises/","title":"Part A: Exercises (20 points)","text":"<p>In order to work with the <code>IO</code> monad (or with any monad), you need to understand how to desugar monadic code using the <code>do</code> notation to code using the monad operators (<code>&gt;&gt;=</code> and <code>&gt;&gt;</code>). As we discussed in class, there are two ways to do this, and we will explore both of them here.</p>"},{"location":"assignments/4/partA_exercises/#1-desugaring-do","title":"1. Desugaring <code>do</code>","text":"<p>[3 points]</p> <p>Consider the following function, which is a manual implementation of the <code>putStrLn</code> function:</p> <pre><code>myPutStrLn :: String -&gt; IO ()\nmyPutStrLn \"\" = putChar '\\n'\nmyPutStrLn (c:cs) =\n  do putChar c\n     myPutStrLn cs\n</code></pre> <p>Desugar this into a function that does not use the <code>do</code> notation. Either kind of desugaring will give the same answer.</p> <p>Note</p> <p>A very common way to write this function would be as follows:</p> <pre><code>myPutStrLn :: String -&gt; IO ()\nmyPutStrLn \"\" = putChar '\\n'\nmyPutStrLn (c:cs) = do\n  putChar c\n  myPutStrLn cs\n</code></pre> <p>This is perfectly acceptable, even though the <code>do</code> is situated far to the right of the lines inside the <code>do</code>. Haskell's indentation rules only require that these lines be indented relative to the line in which <code>do</code> is located, not relative to <code>do</code> itself. Feel free to use this style when writing your own code, though you don't have to. You can also write it in a non-indentation-dependent style as follows:</p> <pre><code>myPutStrLn :: String -&gt; IO ()\nmyPutStrLn \"\" = putChar '\\n'\nmyPutStrLn (c:cs) = do {\n  ; putChar c\n  ; myPutStrLn cs\n  }\n</code></pre> <p>I rarely use this style myself, but some programmers prefer it.</p>"},{"location":"assignments/4/partA_exercises/#2-a-style-mistake","title":"2. A style mistake","text":"<p>[1 point]</p> <p>Ben Bitfiddle wrote this code as a way to get familiar with the <code>IO</code> monad:</p> <pre><code>greet :: String -&gt; IO ()\ngreet name = do putStrLn (\"Hello, \" ++ name ++ \"!\")\n</code></pre> <p>Although this code works fine, it exhibits poor style because some of it is redundant. Can you simplify it a little without changing its behavior?</p> <p>Hint</p> <p>We don't mean replacing the parentheses with a <code>$</code> operator, though you can do that too.</p>"},{"location":"assignments/4/partA_exercises/#3-two-desugarings","title":"3. Two desugarings","text":"<p>[8 points]</p> <p>Here is a more complicated version of the <code>greet</code> function:</p> <pre><code>-- Ask the user for his/her name, then print a greeting.\ngreet2 :: IO ()\ngreet2 = do\n  putStr \"Enter your name: \"\n  name &lt;- getLine\n  putStr \"Hello, \"\n  putStr name\n  putStrLn \"!\"\n</code></pre> <p>Desugar this function in two ways, both described in lecture 12: the simple desugaring, and the more complicated desugaring involving an explicit <code>case</code> statement. In both cases, preserve the binding of the name to the identifier <code>name</code> (in other words, don't try to write it in a point-free manner; that's not what we're after here). Does the complex desugaring behave differently than the simple desugaring here? Write your answer in a comment. If there is a pattern match failure for the complex desugaring, use the error message <code>\"Pattern match failure in do expression\"</code>, which is close to what would actually be printed. Recall that we use the <code>fail</code> method from the <code>MonadFail</code> type class to handle pattern match failures in <code>do</code> expressions for monads that support it (which includes <code>IO</code>).</p> <p>Call the function desugared in the first way <code>greet2a</code>, and the function desugared in the second way <code>greet2b</code>.</p> <p>Note</p> <ul> <li> <p>For the desugarings (this problem and the next) don't just write the desugarings in a comment; write new versions of the functions and rename them. This will allow you to test them to make sure they behave correctly.</p> </li> <li> <p>Coding style: Using indentation and formatting in a judicious manner will make the desugared code much easier to read. For instance, don't write the entire definition on one line, even if you can.</p> </li> <li> <p>Some desugarings may give rise to warnings which you can ignore. (This is an exception to our usual rule that warnings are errors.) On the other hand, if your code generates warnings that are not the result of a correct desugaring you will lose points.</p> </li> </ul>"},{"location":"assignments/4/partA_exercises/#4-two-desugarings-part-2","title":"4. Two desugarings, part 2","text":"<p>[8 points]</p> <p>Let's say we want to change the <code>greet</code> function so that it will capitalize the name given to it (in case the user entered his/her name without bothering to capitalize it correctly). That might lead to a function like this:</p> <pre><code>-- Need to import this to get the definition of toUpper:\nimport Data.Char\n\n-- Ask the user for his/her name, then print a greeting.\n-- Capitalize the first letter of the name.\ngreet3 :: IO ()\ngreet3 = do\n  putStr \"Enter your name: \"\n  (n:ns) &lt;- getLine\n  let name = toUpper n : ns\n  putStr \"Hello, \"\n  putStr name\n  putStrLn \"!\"\n</code></pre> <p>Again, desugar this in the two different ways (also making sure to handle the <code>let</code> expression correctly in both cases). Does the more complex desugaring have any effects here? Write your answer in a comment. Hint: What kind of user input could be used to check which desugaring was being used? If there is a pattern match failure for the complex desugaring, again use the error message <code>\"Pattern match failure in do expression\"</code>.</p> <p>Call the function desugared in the first way <code>greet3a</code>, and the function desugared in the second way <code>greet3b</code>.</p>"},{"location":"assignments/4/partB_standalone/","title":"Part B: Simple standalone programs (30 points)","text":"<p>In this section you will write two fairly simple standalone programs that do input/output.</p> <p>Warning</p> <p>Do not use <code>unsafePerformIO</code> at all in this assignment! If you think you need it, keep thinking.</p>"},{"location":"assignments/4/partB_standalone/#1-reverse","title":"1. <code>reverse</code>","text":"<p>[10 points]</p> <p>Write a program called <code>reverse</code> that reads in all the lines of a file and prints them, in reverse order, to standard output (i.e. to the terminal).</p>"},{"location":"assignments/4/partB_standalone/#usage","title":"Usage","text":"<p>Your program should be invoked as follows (<code>$</code> is the prompt):</p> <pre><code>$ ./reverse filename\n</code></pre> <p>(for some file <code>filename</code>). If there are too many or too few command-line arguments, print out a usage message like this:</p> <pre><code>usage: reverse filename\n</code></pre> <p>and exit with a failure status. Upon successful completion, exit with a success status (see the documentation in the <code>System.Exit</code> module for more on exit status.)</p> <p>Note</p> <p>You may assume that the file exists and is a text file (you don't have to handle the error cases where this isn't true). This applies to all the programs in this section.</p>"},{"location":"assignments/4/partB_standalone/#example","title":"Example","text":"<pre><code>$ cat myfile\nThis is my file.\nIt has five lines.\nThis is the third line.\nTo be or not to be,\nthat is the question.\n$ reverse myfile\nthat is the question.\nTo be or not to be,\nThis is the third line.\nIt has five lines.\nThis is my file.\n</code></pre>"},{"location":"assignments/4/partB_standalone/#useful-modulesfunctions","title":"Useful modules/functions","text":"<p>You may want to look the following modules/functions up in Hoogle before writing your program.</p> <ul> <li><code>Prelude</code> module: <code>reverse</code>, <code>lines</code>, <code>mapM_</code>, <code>readFile</code></li> <li><code>System.Environment</code> module: <code>getProgName</code>, <code>getArgs</code></li> <li><code>System.Exit</code> module: <code>exitFailure</code>, <code>exitSuccess</code></li> </ul>"},{"location":"assignments/4/partB_standalone/#writing-and-compiling-the-program","title":"Writing and compiling the program","text":"<p>Write the program in a file called <code>Reverse.hs</code>. The program should define a module called <code>Main</code> and there should be a function called <code>main</code> of type <code>IO ()</code>. All functions must have explicit type signatures! Compile the program by typing this line:</p> <pre><code>$ ghc -W -o reverse Reverse.hs -package base\n</code></pre> <p>(Without the <code>$</code> prompt, of course.) Any compiler warnings should be considered as errors (with some obscure exceptions that you're unlikely to run into; if in doubt, email me).</p> <p>Note</p> <p>If you use the <code>head</code> function in this program or in any of the other programs you may get this warning:</p> <pre><code>Reverse.hs: warning: [GHC-63394] [-Wx-partial]\nIn the use of \u2018head\u2019\n(imported from Prelude, but defined in GHC.List):\n\"This is a partial function, it throws an error on empty lists. Use pattern matching or Data.List.uncons instead. Consider refactoring to use Data.List.NonEmpty.\n</code></pre> <p>What this is saying is that <code>head</code> is a partial function, which means that it will give an error when applied to an empty list. Haskell has gotten very picky about this sort of thing. You could rewrite the code to use pattern matching, but sometimes you know that the list you are taking the head of isn't empty!</p> <p>The easy way to fix this is to turn off that warning. Add the <code>-Wno-x-partial</code> command-line option e.g.</p> <pre><code>$ ghc -W -Wno-x-partial -o reverse Reverse.hs -package base\n</code></pre> <p>and watch the warning disappear!</p> <p>All other standalone programs described below should be compiled in a similar way.</p> <p>Note</p> <p>This program only needs to be a few lines long.</p>"},{"location":"assignments/4/partB_standalone/#2-columns","title":"2. <code>columns</code>","text":"<p>[20 points]</p> <p>Write a program called <code>columns</code> which will take some numbers and a filename as command-line arguments, and output the corresponding columns of the input to standard output. Column N of a line is defined to be the Nth item in a list which is obtained by splitting the line on whitespace (starting from 1 for the first item).</p>"},{"location":"assignments/4/partB_standalone/#usage_1","title":"Usage","text":"<p>Your program should be invoked as follows:</p> <pre><code>$ ./columns n1 n2 ... filename\n</code></pre> <p>where <code>n1</code>, <code>n2</code>, etc. are positive integers (there should be at least one), and where <code>filename</code> is the name of the file to read from. If <code>filename</code> is <code>-</code> (a single dash character), then read from <code>stdin</code> (standard input i.e. the terminal).</p> <p>Given invalid inputs (numbers that aren't numbers or are negative or 0), print a usage message and exit as in the previous program. Your usage message must indicate what the proper inputs need to be. Missing columns are not an error; just ignore them. If all the requested columns are missing in a line, output a blank line for that line.</p> <p>Column numbers may occur in the command line out of order or duplicated; print the correct value for each column number in the order that it occurs. For instance, if the command line was <code>columns 1 1 1 foobar</code> then each output line will have three copies of the first column of that line of the input file <code>foobar</code>, and <code>columns 3 2 1 foobar</code> would print the first three columns of the file <code>foobar</code> in reverse order.</p> <p>Again, you may assume that the filename argument corresponds to a real text file; you don't have to check for nonexistent files or non-text files.</p>"},{"location":"assignments/4/partB_standalone/#examples","title":"Examples","text":"<p>Please run the examples below to check your program. Create the file <code>myfile</code> yourself with the indicated contents.</p> <pre><code>$ cat myfile\na b c d\nfoo bar baz\nnow is the time for all good men\nthese go to eleven\n$ ./columns 1 3 myfile\na c\nfoo baz\nnow the\nthese to\n$ cat myfile | ./columns 1 3 -\na c\nfoo baz\nnow the\nthese to\n$ ./columns 2 4 5 myfile\nb d\nbar\nis time for\ngo eleven\n$ ./columns 2 1000 myfile\nb\nbar\nis\ngo\n</code></pre>"},{"location":"assignments/4/partB_standalone/#useful-modulesfunctions_1","title":"Useful modules/functions","text":"<p>In addition to the functions mentioned in the previous problem, you might want to look at:</p> <ul> <li><code>Prelude:</code> <code>read</code>, <code>words</code>, <code>all</code>, <code>mapM</code>, the <code>!!</code> operator</li> <li><code>Control.Monad</code>: <code>guard</code></li> <li><code>Data.Char</code>: <code>isDigit</code></li> <li><code>Data.List</code>: <code>intercalate</code>, <code>unwords</code></li> <li><code>Data.Maybe</code>: <code>mapMaybe</code></li> <li><code>System.IO</code>: <code>stdin</code>, <code>openFile</code>, <code>hGetContents</code></li> </ul> <p>You won't necessarily need to use all of these functions, but many of them should be useful. Note particularly the <code>read</code> function, which can parse arbitrary datatypes (as long as they are instance of the <code>Read</code> type class, which we haven't discussed in class). For instance, you can parse an integer this way (in <code>ghci</code> for illustration):</p> <pre><code>ghci&gt; read \"1286\" :: Integer\n1286\n</code></pre> <p>Normally you don't need to put the <code>:: Integer</code> into the code, because the context requires the result to be of a particular type (here, an <code>Integer</code>).</p>"},{"location":"assignments/4/partB_standalone/#writing-and-compiling-the-program_1","title":"Writing and compiling the program","text":"<p>See the last problem for the coding guidelines. Compile the program like this:</p> <pre><code>$ ghc -W -o columns Columns.hs -package base\n</code></pre>"},{"location":"assignments/4/partB_standalone/#design-hints","title":"Design hints","text":""},{"location":"assignments/4/partB_standalone/#program-structure","title":"Program structure","text":"<p>This program naturally breaks down into two parts:</p> <ol> <li> <p>The core of the program, which takes the contents of a file (represented as a list of strings) and the column indices to print (represented as a list of integers) and prints out the desired columns.</p> </li> <li> <p>The command-line argument processing.</p> </li> </ol> <p>Our strong advice is to get (1) working first before doing (2). You can test it interactively in <code>ghci</code> to make sure that it works. It's easy to spend way too much time on the command-line argument processing, but it will be less stressful if the rest of the program is working.</p>"},{"location":"assignments/4/partB_standalone/#reading-files","title":"Reading files","text":"<p>Use the <code>hGetContents</code> function to read the lines of a file, not the <code>readFile</code> function. The <code>hGetContents</code> function has this type:</p> <pre><code>hGetContents :: Handle -&gt; IO String\n</code></pre> <p>So you have to have a <code>Handle</code> as input to this function, not a string representing a filename. You get the handle by using <code>openFile</code>, which has this type:</p> <pre><code>openFile :: FilePath -&gt; IOMode -&gt; IO Handle\n</code></pre> <p><code>FilePath</code> is just an alias for <code>String</code>; it's the file name. <code>IOMode</code> is <code>ReadMode</code> if you are reading a file. This function will return a <code>Handle</code> (in the <code>IO</code> monad, of course).</p> <p>The advantage of doing it this way is that it makes it easy to deal with the case when the filename is <code>\"-\"</code>, representing reading from standard input (the terminal). In Haskell, standard input is called <code>stdin</code>, and is a <code>Handle</code>. So if you have a string representing either the file to read from, or <code>\"-\"</code> for standard input, you just have to write the code to compute the correct <code>Handle</code>, and then use that in all the remaining code.</p>"},{"location":"assignments/4/partB_standalone/#parsing-command-line-arguments","title":"Parsing command-line arguments","text":"<p>We very strongly recommend that you don't try to parse command-line arguments in the <code>main</code> function. Instead, write a helper function to do the parsing and call it from <code>main</code>. We called our function <code>parseArgs</code> (brilliant name choice, huh?) and it had this type signature:</p> <pre><code>parseArgs :: [String] -&gt; Maybe ([Int], String)\n</code></pre> <p>The <code>[String]</code> argument is the argument list of the entire program (not including the program name). The return value should be <code>None</code> if the list is empty. (This will require printing a usage message later.) Otherwise, this function returns two things: a list of integer indices, and the name of the file to read from.</p> <p>We also recommend that you define a <code>usage</code> function which will print the usage message and exit with an <code>exitFailure</code>.</p> <p>Note</p> <p>In functional languages (and arguably even in non-functional languages) it's very useful to keep functions short, and the best way to do this is to define lots of small helper functions. This will make the code more modular and also easier to understand.</p>"},{"location":"assignments/4/partC_sudoku/","title":"Part C: Miniproject: Sudoku (50 points)","text":"<p>Most of you probably already know how to play Sudoku. If by chance you don't, here is a page which will teach you the rules. Sudoku puzzles range from quite easy to extremely difficult. However, computers have a much easier time solving Sudoku puzzles than humans do, and in this section you'll be writing a Haskell program to do just that. Your program should be able to solve the sample Sudoku puzzles we'll supply you with in no more than about 30 seconds per puzzle, though it may take longer on other Sudoku puzzles.</p>"},{"location":"assignments/4/partC_sudoku/#program-description","title":"Program description","text":"<p>The program will read in a file containing a representation of a Sudoku puzzle, compute the solution to the puzzle, and print the solution to standard output (the terminal).</p>"},{"location":"assignments/4/partC_sudoku/#solution-algorithm","title":"Solution algorithm","text":"<p>We want you to solve this problem imperatively. It is possible to write very concise and elegant Sudoku solvers in a purely functional manner (which is a good exercise) but that's not how we want you to do it here.</p> <p>Note</p> <p>The whole purpose of this project is to demonstrate that it's possible to write imperative code even in a purely functional language like Haskell.</p> <p>Instead, the program will read the input board's contents into an array (specifically, an <code>IOArray</code>). From there, it will mutate the contents of the array until a solution is reached or until it can be determined that there is no solution.</p> <p>The solution algorithm works as follows.</p> <ul> <li> <p>Iterate over the 81 locations in the board row-by-row and column-by-column within rows.</p> </li> <li> <p>If the location is already filled (i.e. it contains a number between 1 and 9), leave it alone and keep going.</p> </li> <li> <p>If it's empty (it contains a 0), you have to pick a number to put into the location. Compute all the possible numbers that could be in this location (i.e. numbers that don't conflict with other numbers in the same row, column, or 3x3 box). For each of these numbers:</p> <ul> <li>Set the location to contain that number.</li> <li>Try to (recursively) solve the board starting from the next location.</li> </ul> <p>If this works, you have your solution, so return <code>True</code> (the board will have mutated to the solution value).</p> <p>If not, unmake the move (write a zero back into the location) and try the next move.</p> <p>Note</p> <p>Unmaking the move is very important! If you forget to do this, your program will not work!</p> </li> <li> <p>If you are at the last location and can't find a suitable number to put there, return <code>False</code>. The board is unsolvable.</p> </li> </ul>"},{"location":"assignments/4/partC_sudoku/#inputs-and-outputs","title":"Inputs and outputs","text":"<p>The compiled program will be called <code>sudoku</code> and will take a single argument, which is the name of a file containing a representation of a board. An example board looks like this:</p> <pre><code>.........\n....1..92\n.86....4.\n..156....\n.....362.\n......5.7\n.3.....8.\n.9.8.2...\n..7..43..\n</code></pre> <p>The (<code>.</code>)s represent empty squares, and numbers from 1 to 9 mean that this location in the board has that (fixed) number. The file must contain nothing else but these characters (not even whitespace at the ends of lines, other than the necessary newline character).</p> <p>The internal representation of the board is as a two-dimensional <code>IOArray</code> (indexed by (<code>Int</code>, <code>Int</code>) pairs) where an empty square is represented by a zero and a digit from 1 to 9 is represented by the corresponding <code>Int</code> value.</p> <p>The job of the program is to fill in the locations marked with (<code>.</code>)s so that the board is solved. In this case, the program would output the following (unique) solution to the Sudoku puzzle:</p> <pre><code>412985763\n753416892\n986327145\n271568934\n549173628\n368249517\n634751289\n195832476\n827694351\n</code></pre> <p>This output is printed to standard output (the terminal).</p>"},{"location":"assignments/4/partC_sudoku/#template-file","title":"Template file","text":"<p>To get you started, in the <code>lab4.zip</code> file on Canvas, we are supplying you with a template file called <code>Sudoku.hs</code> that contains some of the less interesting function definitions pre-written for you. This will allow you to concentrate on the interesting part (the board solving code). You are not absolutely required to use our code (if you think you can do things better all on your own, you may), but using it will probably significantly cut down on the time requirement for this problem. If you do use our code as a template, you should substitute your own code in the location marked <code>{- TODO -}</code>. Please remove the <code>{- TODO -}</code> comment as well!</p> <p>We are also including the type signatures and comments of all the helper functions we used in the <code>solveSudoku</code> function. You may use these to guide you in your solution, or you may write different helper functions as you see fit. Note, though, that the solution has to be imperative, not functional. Nevertheless, it will be recursive, as described above.</p> <p>Note that one thing you are not allowed to change is the representation of the Sudoku board i.e. the type definition:</p> <pre><code>type Sudoku = IOArray (Int, Int) Int\n</code></pre> <p>Since this problem is an exercise in doing imperative programming in Haskell, we want you to solve this program using the <code>IO</code> monad and <code>IOArray</code>s.</p>"},{"location":"assignments/4/partC_sudoku/#compiling-the-program","title":"Compiling the program","text":"<p>Compile the program by typing this line:</p> <pre><code>$ ghc -W -o sudoku Sudoku.hs -package base -package array\n</code></pre>"},{"location":"assignments/4/partC_sudoku/#sample-input-boards-and-running-the-program","title":"Sample input boards and running the program","text":"<p>In the <code>lab4.zip</code> file, we are including a directory called <code>boards</code> containing ten input boards. You should use these board files to test your program. None of them should take your program more than 30 seconds to solve, and most should take much less time than that.</p> <p>Test a particular board by running it like this:</p> <pre><code>$ ./sudoku boards/board1\n412985763\n753416892\n986327145\n271568934\n549173628\n368249517\n634751289\n195832476\n827694351\n</code></pre> <p>If you want to time it, this should work on any Unix-like system (Linux, MacOS, Windows using WSL):</p> <pre><code>$ /usr/bin/time ./sudoku boards/board1\n412985763\n753416892\n986327145\n271568934\n549173628\n368249517\n634751289\n195832476\n827694351\n        4.74 real         4.68 user         0.04 sys\n</code></pre> <p>The <code>user</code> time gives the actual elapsed time for the run in seconds.</p>"},{"location":"assignments/5/assignment5/","title":"Assignment 5: Monads and lists","text":""},{"location":"assignments/5/assignment5/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, May 17th at 2 AM.</p>"},{"location":"assignments/5/assignment5/#objectives","title":"Objectives","text":"<p>The theme of this assignment is working with (and understanding) the list monad.</p>"},{"location":"assignments/5/assignment5/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 15.</p>"},{"location":"assignments/5/assignment5/#submitting-your-assignment","title":"Submitting your assignment","text":"<p>Write your code in a single text file called <code>Lab5.hs</code>. These files should be submitted to CodePost as <code>Assignment 5</code>.</p>"},{"location":"assignments/5/assignment5/#writing-and-testing-your-code","title":"Writing and testing your code","text":"<p>There is no code base for this assignment, so don't go looking for a <code>lab5.zip</code> file on Canvas .</p> <p>There are no test scripts for this assignment. Some of the problems have very specific answers, so you can easily test them interactively. Others are written derivations, which don't lend themselves to tests.</p>"},{"location":"assignments/5/partA_list_monad/","title":"Part A: The List Monad (60 points)","text":"<p>In this section you will do some exercises involving the list monad.</p>"},{"location":"assignments/5/partA_list_monad/#1-the-hardy-ramanujan-problem","title":"1. The Hardy-Ramanujan problem","text":"<p>[10 points]</p> <p>A classic problem in number theory is to find positive integers that can be expressed as the sum of two cubes in two different ways. This problem dates back to the mathematicians Hardy and Ramanujan; supposedly Ramanujan could tell at a glance that 1729 was the smallest such integer.</p> <p>Ben Bitfiddle has written a very elegant list comprehension to generate all these numbers (up to infinity!):</p> <pre><code>hr_solutions :: [((Integer, Integer), (Integer, Integer), Integer)]\nhr_solutions =\n  [((i, l), (j, k), i^3 + l^3) |\n   i &lt;- [1..],\n   j &lt;- [1..i-1],\n   k &lt;- [1..j-1],\n   l &lt;- [1..k-1],\n   i^3 + l^3 == j^3 + k^3]\n\n-- Note that (^) is the integer power operator.\n</code></pre> <p>Here's an example of a run in <code>ghci</code>:</p> <pre><code>ghci&gt; take 5 hr_solutions\n[((12,1),(10,9),1729),((16,2),(15,9),4104),((24,2),(20,18),13832),((27,10),(24,19),20683),((32,4),(30,18),32832)]\n</code></pre> <p>Rewrite Ben's code using the list monad instead of a list comprehension. Use the <code>do</code>-notation and the <code>guard</code> function (in the module <code>Control.Monad</code>) where appropriate.</p>"},{"location":"assignments/5/partA_list_monad/#2-blast-from-the-past","title":"2. Blast from the past","text":"<p>[10 points]</p> <p>Redo problem A.6 of assignment 1 (\"Fun with list comprehensions\") using the list monad instead of a list comprehension. Write two different solutions: one using the <code>guard</code> function and one which doesn't use <code>guard</code> but which does use <code>mzero</code> from the <code>MonadPlus</code> instance for lists to filter out undesired values. Don't use the <code>filter</code> function.</p> <p>The problem is:</p> <p>Write an expression which computes the sum of the natural numbers below one thousand which are multiples of 3 or 5.</p> <p>Your expression doesn't have to fit on one line this time.</p>"},{"location":"assignments/5/partA_list_monad/#3-project-euler-problem-4","title":"3. Project Euler problem #4","text":"<p>[10 points]</p> <p>Solve Euler problem 4 using the list monad.</p> <p>The problem description is as follows:</p> <p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99. Find the largest palindrome made from the product of two 3-digit numbers.</p> <p>Write a one-line function called <code>isPalindrome</code> which takes an <code>Integer</code> and returns <code>True</code> if the integer's decimal representation is a palindrome. (Hint: Convert the integer to a string; note that <code>Integer</code> is an instance of the <code>Show</code> type class.) Then write a function called <code>largestPalindrome</code> which computes the desired quantity. Do not use a list comprehension or recursion, but do use the list monad. The <code>maximum</code> function from the Haskell Prelude will probably be useful to you.</p> <p>Try to make your solution as efficient as possible. For instance, do you need to multiply all pairs of three-digit numbers?</p> <p>Write the solution to the problem in a comment.</p>"},{"location":"assignments/5/partA_list_monad/#4-a-combinatorial-puzzle","title":"4. A combinatorial puzzle","text":"<p>[30 points]</p> <p>The list monad is a great tool for solving combinatorial problems. Consider this puzzle:</p> <p>Take the digits 1 to 9 in sequence. Put either a <code>+</code>, a <code>-</code>, or nothing between each digit to get an arithmetic expression. Print out all such expressions that evaluate to 100.</p> <p>In this problem we will use the list monad to solve this problem.</p> <p>We will start by defining some datatypes to represent expressions.</p> <pre><code>type Expr = [Item]\n\ndata Item = N Int | O Op\n  deriving Show\n\ndata Op = Add | Sub | Cat\n  deriving Show\n</code></pre> <p>In words: an expression is a list of items, an item is either a number or an operator, and an operator is either addition, subtraction, or concatenation. Note that these datatypes don't enforce any reasonable invariants; you can have an \"expression\" which is just operators, for instance. We could design more clever datatypes to enforce such invariants, but we won't for simplicity. However, that means we'll have to detect invalid cases in our functions.</p> <p>We'll also define a list of all operators, for convenience:</p> <pre><code>ops :: [Item]\nops = [O Add, O Sub, O Cat]\n</code></pre> <p><code>Cat</code> means concatenation; two numbers with nothing between them are implicitly concatenated (so <code>1</code> next to <code>2</code> would be <code>12</code>).</p> <p>Here are the functions/values we want you to define.</p>"},{"location":"assignments/5/partA_list_monad/#a-exprs","title":"a. <code>exprs</code>","text":"<p>Define a value called <code>exprs</code> which consists of a list of all possible valid expressions from the puzzle description i.e. all possible combinations of the digits 1 to 9 (in order) with one of the operators from the <code>Op</code> datatype between each digit. Use the list monad. (This is not optional.) Your function shouldn't be more than about a dozen lines long. There should be exactly <code>3^8</code> or <code>6561</code> possible expressions in the list. (Please don't write a brute-force expression that is 6561 lines long! That would take way longer than solving the problem would.)</p> <p>Note</p> <p>The numbers can only be one thing at any position in the expression, but between each pair of adjacent numbers you can have any one of three operators.</p>"},{"location":"assignments/5/partA_list_monad/#b-normalize","title":"b. <code>normalize</code>","text":"<p>Define a function called <code>normalize</code> that takes an expression and removes all instances of the <code>Cat</code> operator by applying this transformation: <code>N i, Cat, N j --&gt; N (ij)</code> anywhere in the list. So, for instance, <code>N 1, Cat, N 2</code> would become <code>N 12</code> (the digits get concatenated). (Note that digits are represented as <code>Int</code>s, not <code>String</code>s, so you can't use string concatenation.) This should work for longer stretches of <code>Cat</code>s; for instance: <code>N 1, Cat, N 2, Cat, N 3</code> becomes <code>N 123</code>. Anything that doesn't match the patterns described is just passed through unchanged, except that illegitimate patterns (e.g. multiple operators/numbers in a row or expressions that begin or end with operators) give rise to errors. This function has the type <code>Expr -&gt; Expr</code> and our implementation is five lines long.</p> <p>Tip</p> <p>Pattern match all valid subexpressions, and anything else becomes an error.</p> <p>Signal errors using the <code>error</code> function.</p>"},{"location":"assignments/5/partA_list_monad/#c-evaluate","title":"c. <code>evaluate</code>","text":"<p>Define a function called <code>evaluate</code> that will take a normalized expression (i.e. one with no <code>Cat</code> operators) and evaluate it to give an <code>Int</code>. Again, this function should only be a few lines long. One thing to be careful about is that subtraction associates to the left, so <code>a - b - c</code> is <code>(a - b) - c</code>, not <code>a - (b - c)</code>. Therefore, start evaluating from the beginning of the expression towards the end, not the other way around.</p> <p>Note</p> <p>Your <code>evaluate</code> function should signal an error if it is asked to evaluate an expression containing a <code>Cat</code> operator.</p> <p>We are also giving you the functions <code>find</code>, <code>pprint</code> and <code>run</code> which are defined as follows:</p> <pre><code>-- Pick out the expressions that evaluate to a particular number.\nfind :: Int -&gt; [Expr] -&gt; [Expr]\nfind n = filter (\\e -&gt; evaluate (normalize e) == n)\n\n-- Pretty-print an expression.\npprint :: Expr -&gt; String\npprint [N i] = show i\npprint (N i : O Add : es) = show i ++ \" + \" ++ pprint es\npprint (N i : O Sub : es) = show i ++ \" - \" ++ pprint es\npprint (N i : O Cat : es) = show i ++ pprint es\npprint _ = error \"pprint: invalid argument\"\n\n-- Run the computation and print out the answers.\nrun :: IO ()\nrun = mapM_ putStrLn $ map pprint $ find 100 exprs\n</code></pre> <p>You should include these in your submitted code for testing purposes.</p> <p>You can run your code for this problem by loading it into <code>ghci</code> and typing <code>run</code> at the prompt. Your output should look something like this (the vertical order may be different):</p> <pre><code>1 + 2 + 3 - 4 + 5 + 6 + 78 + 9\n1 + 2 + 34 - 5 + 67 - 8 + 9\n1 + 23 - 4 + 5 + 6 + 78 - 9\n1 + 23 - 4 + 56 + 7 + 8 + 9\n12 + 3 + 4 + 5 - 6 - 7 + 89\n12 + 3 - 4 + 5 + 67 + 8 + 9\n12 - 3 - 4 + 5 - 6 + 7 + 89\n123 + 4 - 5 + 67 - 89\n123 + 45 - 67 + 8 - 9\n123 - 4 - 5 - 6 - 7 + 8 - 9\n123 - 45 - 67 + 89\n</code></pre> <p>You can check that all of these expressions evaluate to 100.</p>"},{"location":"assignments/5/partB_puzzles/","title":"Part B. Puzzles and derivations (40 points)","text":"<p>Solve the first three of the following puzzles by desugaring the monadic code from the <code>do</code> notation to the <code>return</code> method and the <code>&gt;&gt;=</code> and <code>&gt;&gt;</code> operators. Then substitute the definitions of <code>return</code>, <code>&gt;&gt;=</code> and <code>&gt;&gt;</code> and derive the result.</p> <p>Note</p> <p>For the first two problems, you do not need to desugar a <code>do</code> expression using the complete desugaring to a <code>case</code> expression to handle possible pattern-match failures. Simply rewrite it in terms of the \"simple\" desugaring involving the <code>return</code> and the <code>&gt;&gt;=</code> operator. For the third problem, you will need to desugar the <code>do</code> expression using the full <code>case</code> expression desugaring (see lecture 11 for more on this).</p> <p>One way to shorten your derivations a little is to use <code>concatMap</code> instead of <code>concat (map ...)</code>. For these exercises, you may consider the definition of <code>concatMap</code> to be:</p> <pre><code>concatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]\nconcatMap f lst = concat (map f lst)\n</code></pre> <p>Note that <code>concatMap &lt;anything&gt; []</code> is the empty list, and <code>concatMap (\\n -&gt; []) &lt;anything&gt;</code> is also the empty list. You can then write the definition of the <code>&gt;&gt;=</code> operator for the list monad as:</p> <pre><code>(&gt;&gt;=) :: [a] -&gt; (a -&gt; [b]) -&gt; [b]\nmv &gt;&gt;= f = concatMap f mv\n</code></pre> <p>Write your solutions in Haskell comments. Note that the order of evaluation is not important for this problem; you can reduce the expressions in whatever order is most convenient.</p>"},{"location":"assignments/5/partB_puzzles/#1-in-the-list-monad","title":"1. <code>[]</code> in the list monad","text":"<p>[10 points]</p> <p>Why does this expression:</p> <pre><code>do n1 &lt;- [1..6]\n   n2 &lt;- [1..6]\n   []\n   return (n1, n2)\n</code></pre> <p>evaluate to <code>[]</code>?  Show all the steps in your derivation.</p>"},{"location":"assignments/5/partB_puzzles/#2-the-case-of-the-useless-return","title":"2. The case of the useless <code>return</code>","text":"<p>[10 points]</p> <p>Why does this expression:</p> <pre><code>do n1 &lt;- [1..6]\n   n2 &lt;- [1..6]\n   return &lt;anything&gt;\n   return (n1, n2)\n</code></pre> <p>return the same thing as this expression:</p> <pre><code>do n1 &lt;- [1..6]\n   n2 &lt;- [1..6]\n   return (n1, n2)\n</code></pre> <p>?</p> <p>Answer this by reducing both expressions to the same expression. Show all the steps in your derivations.</p>"},{"location":"assignments/5/partB_puzzles/#3-a-trivial-pattern-matcher","title":"3. A trivial pattern-matcher","text":"<p>[10 points]</p> <p>You can use the list monad to perform simple pattern-matching tasks. Consider this code:</p> <pre><code>let s = [\"aaxybb\", \"aazwbb\", \"foobar\", \"aaccbb\", \"baz\"] in\n  do ['a', 'a', c1, c2, 'b', 'b'] &lt;- s\n     return [c1, c2]\n</code></pre> <p>This returns this result:</p> <pre><code>[\"xy\", \"zw\", \"cc\"]\n</code></pre> <p>Explain why by deriving the result, using the full <code>case</code>-style desugaring of <code>do</code> expressions we covered in lecture 11. Note that the <code>fail</code> method of the <code>MonadFail</code> type class has this definition in the list monad:</p> <pre><code>fail _ = []\n</code></pre> <p>Explain what would happen if instead <code>fail</code> for the list monad was this instead:</p> <pre><code>fail s = error s\n</code></pre> <p>Would it still work?  If not, why not?</p> <p>Note</p> <p>Don't forget that the <code>String</code> datatype in Haskell is just a list of <code>Char</code>s, which is why the <code>String</code> type can also be written as <code>[Char]</code>.</p>"},{"location":"assignments/5/partB_puzzles/#4-an-equivalence","title":"4. An equivalence","text":"<p>[10 points]</p> <p>In the lecture on the list monad we mentioned that in GHC the real definition of <code>&gt;&gt;=</code> for lists is:</p> <pre><code>m &gt;&gt;= k = foldr ((++) . k) [] m\n</code></pre> <p>and we claimed that this is the same as the definition we used:</p> <pre><code>m &gt;&gt;= k = concat (map k m)\n</code></pre> <p>(except that the first version may run faster, which you don't need to concern yourself with here). Show that the two expressions <code>foldr ((++) . k) [] m</code> and <code>concat (map k m)</code> do indeed compute the same thing. Write your answer in a comment, as usual.  </p> <p>Tip</p> <p>Show that given <code>m = [x1, x2, ...]</code> both expressions evaluate to the same thing. Also show this for <code>m = []</code>. Expand <code>(++) . k</code> into an explicit lambda expression (anonymous function). Hint: As an argument to the <code>foldr</code> function, how many arguments should this anonymous function take?</p>"},{"location":"intro/books/","title":"Books and other resources","text":"<p>CS 115 doesn't have an official textbook. However, some students like to have a book that they can refer to while they are learning Haskell. This can be used for a number of purposes:</p> <ul> <li>as a longer-form, gentler tutorial in the language;</li> <li>as a way to learn more advanced features of the language   than those we cover in this course;</li> <li>as a reference;</li> <li>or just for a different perspective on the same material.</li> </ul> <p>There are a number of good books and texts that have been written on Haskell. Some of these are a few years old, so they may not be usable with modern versions of GHC without some modifications, but these modifications are likely to be minor.</p> <p>Note</p> <p>This list is not comprehensive! There are other books on Haskell we haven't included here, mainly because we haven't gone over them in detail. If you find a book which is useful to you and which is not on this list, let us know and we'll add it!</p>"},{"location":"intro/books/#online-books","title":"Online books","text":"<ul> <li> <p>A Gentle Introduction to Haskell</p> <p>This is a classic (and fairly short) introduction to Haskell. It's definitely outdated; it refers to \"Haskell 98\", which means the version of Haskell from 1998. However, most of the material included is still valid.</p> </li> </ul>"},{"location":"intro/books/#textbooks","title":"Textbooks","text":"<p>These books are roughly ordered from easiest to hardest.</p> <ul> <li> <p>Get Programming with Haskell by Will Kurt </p> <p>I haven't read this book, but the reviews on Amazon are quite positive.</p> </li> <li> <p>Effective Haskell by Rebecca Skinner</p> <p>This is a new book which covers most of the material in CS 115, except for some of the more theoretical parts. It's very beginner-friendly and readable.</p> </li> <li> <p>Programming in Haskell, 2nd. edition by Graham Hutton</p> <p>This is a solid book by a well-known researcher and lecturer. He also has Haskell courses on YouTube which cover the same material.</p> </li> <li> <p>Haskell Programming from First Principles   by Christopher Allen and Julie Moronuki</p> <p>I haven't read this book, but it looks good. It's available from https://haskellbook.com/.</p> </li> <li> <p>Haskell, the Craft of Functional Programming, 3rd. edition   by Simon Thompson</p> <p>I learned Haskell from the first edition of this book. The third edition is greatly expanded, but it's quite readable and understandable.</p> </li> <li> <p>Learn You a Haskell For Great Good by Miran Lipovaca</p> <p>This is a good book which is available for free in its entirety at https://learnyouahaskell.github.io</p> </li> <li> <p>Thinking Functionally with Haskell by Richard Bird   and Algorithm Design with Haskell by Richard Bird and Jeremy Gibbons</p> <p>The late Richard Bird wrote a number of books on Haskell and functional programmming. Bird's primary emphasis is on how to use equational laws to transform code into more efficient forms. Although he restricts himself to fairly basic Haskell, his books are quite sophisticated and demanding. However, this material is difficult to find anywhere else. If you are willing to put in the effort, you will get a lot out of these books.</p> </li> </ul>"},{"location":"intro/books/#discussions","title":"Discussions","text":"<p>We recommend the Haskell Discourse server as a site for general Haskell discussions. Be aware, though, that some of the discussions cover advanced topics, so don't be surprised if you can't follow everything (yet).</p>"},{"location":"intro/papers/","title":"Interesting papers","text":"<p>A lot of interesting material about Haskell is first published in academic papers, and much of this hasn't found its way into textbooks yet. As a result, to become a really accomplished Haskell programmer, you are going to want to read these papers. Here is a selection of interesting papers that give additional insights into Haskell. Some of this material goes well beyond what we cover in CS 115.</p> <ul> <li> <p>A Gentle Introduction to Haskell 98, by Paul Hudak, John Peterson, and Joseph Fasel.</p> <p>This is a tutorial on the first \"standard\" version of Haskell: Haskell 98 (the \"98\" means the year 1998). It's a good introduction to the most basic aspects of Haskell, though some of it is obsolete. You can also read it here.</p> </li> <li> <p>Why Functional Programming Matters, by John Hughes.</p> <p>This is a classic paper, written before Haskell even existed. Its main topic is lazy evaluation, and how this allows a more modular style of programming where functions can be built up easily by composing other functions. The language used is Miranda, a precursor of Haskell, but it's easy to follow if you know Haskell.</p> </li> <li> <p>A History of Haskell: Being Lazy with Class, by Paul Hudak, John Hughes, Simon Peyton-Jones, and Philip Wadler.</p> <p>This is a historical survey of the development of Haskell up to 2007. The title is a play on words (\"lazy\" and \"class\" having specific meanings in Haskell) which is typical of many Haskell papers.</p> </li> <li> <p>Imperative Functional Programming, by Simon Peyton-Jones and Philip Wadler.</p> <p>This was the paper that introduced monads to Haskell.</p> </li> <li> <p>Monads for Functional Programming, by Philip Wadler.</p> <p>This is an in-depth discussion of monads in Haskell. Unusually for Phil Wadler, the title doesn't contain any puns.</p> </li> <li> <p>Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell, by Simon Peyton-Jones.</p> <p>This is a deep dive into how to use the <code>IO</code> monad and related constructs to allow Haskell to handle very non-functional kinds of programming.</p> </li> <li> <p>Lazy Functional State Threads, by John Launchbury and Simon Peyton-Jones.</p> <p>This paper introduced the <code>ST</code> monad, which allows you to perform imperative computations \"internally\" i.e. without having to move all your code into the <code>IO</code> monad. (We mention this in the lectures but don't go into detail.)</p> </li> <li> <p>Monadic Parser Combinators, by Graham Hutton and Erik Meijer.</p> <p>This paper introduced monadic parser combinators, which are one of the most-used ways of writing parsers in Haskell.</p> </li> <li> <p>Monadic Parsing in Haskell, by Graham Hutton and Erik Meijer.</p> <p>This is a shorter tutorial paper on parser combinators. </p> </li> <li> <p>Type Classes with Functional Dependencies, by Mark P. Jones.</p> <p>This paper introduced functional dependencies for type classes.</p> </li> <li> <p>Template Meta-programming for Haskell, by Tim Sheard and Simon Peyton-Jones.</p> <p>This paper introduced the template metaprogramming system in Haskell (called \"Template Haskell\") which is basically a macro system which allows you to do compile-time code generation.</p> </li> <li> <p>Why It's Nice to be Quoted: Quasiquoting for Haskell, by Geoffrey Mainland.</p> <p>This paper introduced quasiquoting, which is a way of making Template Haskell more useful by allowing you to do code generation in a much more natural manner.</p> </li> <li> <p>Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire, by Erik Meijer, Maarten Fokkinga, and Ross Paterson.</p> <p>This paper is not specifically about Haskell but about lazy functional programming as a whole. It develops a calculus of high-level operators which allow you to define functions in an amazingly concise manner. This is the most \"theoretical\" paper on this list, but it has been hugely influential.</p> </li> </ul>"},{"location":"intro/software/","title":"Installing the course software","text":""},{"location":"intro/software/#installing-the-ghc-compiler","title":"Installing the GHC compiler","text":"<p>In this course, we will be using the  Haskell programming language. Specifically, we will be using the GHC Haskell compiler. We also assume a certain level of familiarity with a (Unix-like) terminal, such as you would get in CS 1 or CS 4.</p> <p>The easiest way to install GHC is to use the ghcup installer. See the ghcup user guide for instructions on how to use it.</p> <p><code>ghcup</code> is a program intended to be run from a Unix-like terminal. If your computer runs any flavor of Linux or MacOS, you have direct access to such a terminal. If your computer runs Windows, you should install the  Windows Subsystem for Linux (WSL). Once this is done, you can run a Unix terminal on Windows and install <code>ghcup</code> on that.</p> <p>Note</p> <p>If you intend to use WSL, make sure you install the latest version! Early versions (e.g. version 1) do not work with GHC. In some cases, especially with older computers, installation will default to version 1, which will cause GHC installation to fail. In that case, contact the instuctor on Piazza.</p> <p>Also, once you have installed WSL, you can run it directly from the terminal embedded in Visual Studio Code, which we recommend for Windows users. Be sure not to select the Powershell terminal when starting a terminal; that isn't part of WSL.</p> <p>After installing GHC, you want to make sure you are running the latest version, which as of this writing is 9.8.2. To verify this, type this in a terminal:</p> <pre><code>$ ghc --version\n</code></pre> <p>You should see:</p> <pre><code>The Glorious Glasgow Haskell Compilation System, version 9.8.2\n</code></pre> <p>If you see a lower version number, you need to upgrade. In a terminal, enter these commands:</p> <pre><code>$ ghcup install ghc 9.8.2\n$ ghcup set ghc 9.8.2\n</code></pre> <p>This should install the latest version. Type</p> <pre><code>$ ghc --version\n</code></pre> <p>to verify that. If that doesn't work, see a TA or the instructor.</p> <p>You can also run</p> <pre><code>$ ghcup tui\n</code></pre> <p>to get a nice text user interface (TUI) which allows you to interactively upgrade all GHC software and tells you all the versions you've installed. This will work on MacOS, Linux, and (maybe) on Windows with WSL. It's not essential, but it is pleasant to use. Use the arrows to select items, type <code>i</code> to install an item, and type <code>s</code> to make the item the \"selected\" item (so entering <code>ghc</code> or <code>ghci</code> will get that version).</p> <p>Note</p> <p>You may have to adjust your terminal's <code>PATH</code> environment variable to include the location of the <code>ghc</code> and <code>ghci</code> programs. This is normally <code>$HOME/.ghcup/bin</code>.</p>"},{"location":"intro/software/#the-cabal-package-manager","title":"The <code>cabal</code> package manager","text":"<p>When you install GHC, the <code>cabal</code> package manager will be installed as well. <code>cabal</code> is for Haskell what <code>opam</code> is for OCaml. We will need <code>cabal</code> to install some code libraries. You can check the installation status of <code>cabal</code> using <code>ghcup tui</code> as described above. Make sure you install the most recent version.</p>"},{"location":"intro/software/#the-hls-language-server","title":"The <code>HLS</code> language server","text":"<p><code>ghcup</code> will also let you install the <code>HLS</code> language server. This is not essential, but if you are using Visual Studio Code as your editor, it will enable code completion and other IDE-like functionality. In this case, after starting VS Code you should also install the Haskell for Visual Studio Code extension to make best use of <code>HLS</code>.</p>"},{"location":"intro/software/#the-hoogle-documentation-browser","title":"The Hoogle documentation browser","text":"<p>When writing Haskell, your best friend is the Hoogle web site. This is a site which allows you to search the documentation of Haskell functions and modules. You can enter the name of a function, a module, or even a type signature (!) and find the relevant documentation (including source code) very easily. You should bookmark this site as long as you're using Haskell.</p>"},{"location":"intro/welcome/","title":"Welcome to CS 115!","text":"<p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about the material.  In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>interesting papers</li> </ul> <p>and anything else we consider useful. Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>lecture slides</li> <li>code supplied to students for assignments</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"intro/welcome/#instructor-and-course-staff","title":"Instructor and course staff","text":"<p>The course instructor is Mike Vanier (mvanier@cms.caltech.edu).</p> <p>The teaching assistants are listed in the syllabus. Their contact information will be posted on the course Piazza page.</p>"},{"location":"intro/welcome/#what-this-course-is-about","title":"What this course is about","text":"<p>This course is an introduction to lazy functional programming using the Haskell programming language. The prerequisite for taking this course is to have already taken CS 4 (which means that you know how to do functional programming in the OCaml language); this is therefore not a course for students who have never done functional programming before. In a sense, if CS 4 is the introductory functional programming course, this is the advanced functional programming course.</p> <p>This course exists for the following reasons.</p> <ul> <li> <p>Haskell is one of the best-known and most-used functional programming   languages in use today.</p> </li> <li> <p>Haskell has a unique evaluation model (lazy evaluation);   it is the only programming language in wide use that uses this   evaluation strategy.</p> </li> <li> <p>Haskell is a pure functional language, in contrast to OCaml,   which is impure (has non-functional features).   This has a number of interesting consequences.</p> </li> <li> <p>Haskell has a number of abstractions that are either not found   in other functional languages, or are not nearly as easy to use   in those languages.</p> </li> <li> <p>Haskell has some features (notably monads) which are notoriously   difficult for new Haskell programmers to learn;   this course will make it much easier for you to understand them.</p> </li> </ul> <p>You might think that having a different evaluation model is not very significant, but as we will see, it turns out to have very far-reaching effects on the way that we write functional code. Some ways of writing code in OCaml (e.g. tail recursion) are much less useful in Haskell, while other ways (e.g. function composition) are much more useful because of lazy evaluation.</p> <p>In general, programming in Haskell feels more \"high-level\" than programming in OCaml, and it's worth experiencing this to be able to make an informed judgment about which language is best suited for which tasks. Haskell is also very productive and great fun to program in!</p> <p>Note</p> <p>We don't want to take sides when comparing OCaml and Haskell. Both are excellent languages which have useful features the other doesn't.  OCaml has a much more powerful module system, while Haskell has many abstractions that OCaml lacks. Well-rounded functional programmers should know both languages.</p> <p>We hope you enjoy the course!</p>"}]}