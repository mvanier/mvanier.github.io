{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 115 book: Winter 2024","text":"<p>This book is the official document repository for the Caltech CS 115 course  (Functional Programming) for the Spring 2024 term.</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p> <p>Please read this page for an overview of the course.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 115 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare you or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>You are welcome to collaborate informally on your assignments with other individuals who are taking the course, but you must write all of your own code and you must not look at other students' code, except to help them as described below. Copying another student's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another student's file and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another student's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone dictate code while you type isn't acceptable either. Basically, you have to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine.</p> <p>All of the above also applies if you are getting tutored for the course, officially or unofficially.</p> <p>All of the above also applies to student work from previous years. We re-use some problems in assignments, and copying answers from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a student who is currently taking the course.</p>"},{"location":"admin/collab/#helping-others-and-the-50-foot-rule","title":"Helping others and the \"50-foot rule\"","text":"<p>It is common for students to want to help other students to write and debug their assignments. While we prefer that you go to one of the course teaching assistants when you need help on the assignments (it doesn't matter which one), we don't forbid you from seeking help from other students or offering your help to other students. However, we do insist on some guidelines to make the process fair for everyone.</p> <p>When you are helping another student with their homework, you are acting as an unofficial teaching assistant, and thus you must behave like one. A teaching assistant will not tell you the answer or dictate code to you; he/she will help you work through the problem so that you understand what you are doing wrong. If you don't have the time or the inclination to do this, do not assist other students. If you just give them your code, you are violating the Honor Code and both you and the people you are giving the code to may be in for some serious consequences.</p> <p>As a way of clarifying the way in which you can help other students (especially when it comes to debugging their code), we want you to obey the \"50 foot rule\". This rule states that if you help another student with their programming problems (including debugging), you must not consult your own code while doing so. Specifically, we ask that your own code be at least 50 feet away i.e. not visible to you or the person you are helping while you are helping them. (It doesn't have to be exactly 50 feet; the point is that you can't see your code while helping the other person and you shouldn't run back and forth between your computer with your code and the computer of the person you're helping.) The slogan of the 50-foot rule is: \"Help them with your brain, not with your code.\" Please do not try to find a loophole kind of way around this e.g. projecting your code on a building 50 feet away; that is clearly not what we mean. Posting your code on a pastebin-like internet site, emailing your code to other people, sharing your screen with your code on it, printing it out, or even referring to it on your laptop while helping someone else, are all clear violations of the collaboration policy for this course. Also, we don't want you to put your code up on a computer in a room 50 feet away from where you're helping someone and run back and forth, dictating a line at a time. If you can't help them without consulting your code, don't help them. Refer them to a teaching assistant.</p> <p>Note</p> <p>The 50-foot rule only applies when helping another student in person.</p> <p>Helping another student using teleconferencing software like Zoom, Skype, Discord etc. is covered below, but one aspect of it is that screen sharing is not permitted.</p> <p>We realize that it's more convenient to ask someone in your house for help than to walk all the way to the Annenberg building. A possible solution is to get to know a TA and meet with them in their dorm room (if they are willing). Another possibility is to meet with a TA on Zoom or Discord, or in a room that's closer than Annenberg (e.g. in a library).</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord), you may not share your screen with other students, whether to help them or to get help from them. This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software. This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs. If this happens you may lose the ability to use the discussion board for any purpose.</p> <p>This also applies to other programs with chat features that are not used in the course (like Slack, Discord, or Discourse), or even email for that matter.</p>"},{"location":"admin/collab/#use-of-public-websites","title":"Use of public websites","text":"<p>It is strictly forbidden to post any of the problems from the assignments onto websites (for instance, Stack Overflow), and anyone caught doing this will be charged with an Honor Code violation. This includes problems that are similar to assignment problems even if not identical. If you find a discussion of course-related material on internet websites, you may read it as long as the discussion is not about a problem that is identical to or very similar to a problem on one of the course assignments. However, do not transcribe code from the internet into your homework submissions.</p> <p>It is strictly forbidden to look at any solutions to any previous years' work posted on internet code repository sites (including but not limited to GitHub, GitLab, BitBucket, etc.). It is also strictly forbidden to put your own code on such a repository unless (a) it is a private repository, and (b) you do not allow anyone else access to this private repository. You may also not fork any such repositories that you might happen to find; we will consider this evidence of intent to plagiarize.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-github-copilot-or-chatgpt","title":"Use of code hinting software (Github Copilot or ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. (This should be obvious.)</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments and exams.</p> Item Status Course book OK Official Haskell documentation OK Other Haskell documentation OK Other Haskell books OK Your notes OK Notes of other students Not allowed Your graded assignments OK Other students' graded assignments Not allowed Other students' ungraded assignments Not allowed Other code written by anyone else that answers an assigned problem Not allowed Solutions to assignment/exam problems from a previous year Not allowed Material posted on internet forums that answers specific problems Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor. Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the course syllabus for CS 115 (Functional Programming) for the Spring 2024 term.</p>"},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor/lecturer for the course is Mike Vanier (mvanier@cms.caltech.edu). Mike's pronouns are he/him.</p>"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held in room 105 of the Annenberg building on Mondays, Wednesdays, and Fridays from 2 PM to 3 PM.</p>"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for the course. TA contact information and office hours will be posted  on the course Piazza page.</p> <ul> <li>Sahithi Ankireddy</li> <li>Bea Avila-Rimer</li> <li>Sreemanti Dey</li> <li>Leo Yang</li> </ul>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>From the Caltech catalog:</p> <p>This course is a both a theoretical and practical introduction to functional programming, a paradigm which allows programmers to work at an extremely high level of abstraction while simultaneously avoiding large classes of bugs that plague more conventional imperative and object-oriented languages. The course will introduce and use the lazy functional language Haskell exclusively. Topics include: recursion, first-class functions, higher-order functions, algebraic data types, polymorphic types, function composition, point-free style, proving functions correct, lazy evaluation, pattern matching, lexical scoping, type classes, modules, and monads. Some advanced topics such as monad transformers, parser combinators, dynamic typing, and existential types are also covered.</p>"},{"location":"admin/syllabus/#textbooks","title":"Textbook(s)","text":"<p>There is no required textbook.</p> <p>See the Books and resources page for a list of recommended books on Haskell and functional programming. None of these books are required reading, but they may be useful as supplementary reading.</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There is a course Piazza site, which you will be enrolled in if you are registered for this course.</p> <p>For homework submission and grading, we will use CodePost.</p>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Office hours will either be held in-person or on Zoom, at the discretion of the teaching assistant. Mike will hold his office hours on Zoom. Office hour times will be posted on Piazza.</p>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>CS 115 is on grades. There are no exams.</p> <p>There will be 6 assignments, worth 10 marks each. Each assignment is given a grade from 0 to 100 points, which is divided by 10 to get the actual number of marks for the assignment.</p> <p>The maximum number of marks is thus 60 points, which will be scaled to 100. Given your grade out of 100, letter grades will be assigned as follows:</p> Numerical grade (out of 100%) Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 65-70% C+ 62-65% C 60-62% C- 58-60% D+ 55-58% D &lt; 55% F"},{"location":"admin/syllabus/#redoing-assignments","title":"Redoing assignments","text":"<p>After you receive your initial grade on an assignment, you have one week to submit a redo. Redos will be submitted as a separate CodePost assignment called <code>Assignment N (rework)</code> (for assignment <code>N</code>). Late redos (received after the 1-week redo window) will not be graded and your previous grade will stand. You may not submit more than one redo per assignment.</p>"},{"location":"admin/syllabus/#late-policy-for-assignments","title":"Late policy for assignments","text":"<p>If an assignment is late when first submitted, marks are deducted at the rate of 20 points/day (which is the same as 2 marks/day). These marks can't be regained through rework. If a rework is late (i.e. is submitted more than one week after the original grade was submitted), it doesn't count, and the previous grade stands.</p> <p>Note</p> <p>If an assignment is submitted on time, but is missing one or more sections, those sections will be graded as a 0. The assignment can be reworked, of course, but assuming the sections that were missing on the initial submission are submitted with the rework, there is no additional rework for these sections. This means that (for instance) if you don't submit a section on the initial submission but do submit it in the rework, the grade of that section in the rework is final \u2014 you don't get to rework it just because you hadn't submitted it before. So please don't leave out sections!</p> <p>Students may request extensions for assignments due to unusual circumstances. These extensions have to be approved by the course instructor (Mike). If you get an extension, you must indicate that in a comment at the top of the file(s) you submit e.g. something like this:</p> <pre><code>-- Extension granted by Mike Vanier until 3/17\n</code></pre> <p>This is so your grader knows not to take off late points.</p>"},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Friday at 2 AM unless otherwise indicated. Note that a due time of 2 AM means early that morning, so effectively it means very late the previous evening.</p>"},{"location":"admin/syllabus/#attendance-and-participation","title":"Attendance and participation","text":"<p>Attendance and participation currently do not count towards the final grade. However, we strive to make lectures interactive and do a lot of live coding during lectures. Missing out on this will deprive you of many of the benefits of the course (as well as a lot of the fun!). Lectures will not be recorded, but all slides will be posted.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech's Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this page.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>The course collaboration policies are listed in the Collaboration policies page in this book.</p> <p>Note</p> <p>Please read the collaboration policies! You are responsible for knowing what is an isn't acceptable collaboration, and if you over-collaborate you may be sent to the Board of Control, which is never pleasant.</p>"},{"location":"admin/syllabus/#software","title":"Software","text":"<p>See the software page for information on installing the course software.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated by your classmates and the course staff with respect. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructors know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student Wellness","text":"<p>It is very important to us that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made. Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See the CASS website for more information.</p> <p>Undergraduate students should contact Dr. Lesley Nye, interim Dean of Undergraduate Students (administrative contact: Beth Larranaga) and graduate students should contact Darrell Peterson, Associate Dean of Graduate Studies (administrative contact: Georgine Okura).</p>"},{"location":"assignments/1/assignment1/","title":"Assignment 1: Evaluation and recursion","text":""},{"location":"assignments/1/assignment1/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, April 19th at 2 AM.</p>"},{"location":"assignments/1/assignment1/#prerequisites","title":"Prerequisites","text":"<p>We will be assuming henceforth that you have taken and passed CS 1 or CS 1x (or placed out of one of them). We also hope that you have taken and passed CS 4, since knowing the material in CS 4 will make CS 115 much easier. We will also assume that you have a rudimentary knowledge of Linux/Unix terminal commands. If not, please read a Linux tutorial, because we will be using the terminal a lot in this course.</p> <p>Note</p> <p>You are not required to use Linux in this course. The terminal in MacOS works pretty much the same way (both Linux and MacOS are Unix systems), so the commands should work fine assuming that the software is installed correctly. Windows terminal commands are completely different. If you have Windows, you should install Windows Subsystem for Linux (also known as WSL), which gives you a full version of Linux running inside of Windows.  (Use that instead of trying to run Haskell natively on Windows.) Make sure you are installing WSL version 2 or later, since version 1 is known not to work properly with the GHC compiler used in this course.</p>"},{"location":"assignments/1/assignment1/#syllabus","title":"Syllabus","text":"<p>Please make sure you have read the Syllabus page and the Collaboration policies page before submitting any assignments, so you know how the course is organized, what the grading policies are, what is and is not acceptable collaboration etc..</p>"},{"location":"assignments/1/assignment1/#software-installation","title":"Software installation","text":"<p>See the Software page for instructions on how to install the course software.</p>"},{"location":"assignments/1/assignment1/#starting-code-base","title":"Starting code base","text":"<p>All assignments will have a code base, which includes test code and sometimes template code for modules. These are posted on the course Canvas site in the Modules section.</p>"},{"location":"assignments/1/assignment1/#external-websites","title":"External websites","text":"<p>In addition to this book, we will be using the following websites:</p> <ul> <li> <p>The course Canvas page, which is where lectures will be posted,   as well as source code for assignments, papers of interest,   and teaching assistant contact information.</p> </li> <li> <p>The course Piazza page, which is where most course-related announcements   will be posted, as well as serving as a question-and-answer forum.</p> </li> <li> <p>The course CodePost page, which is where assignments will be submitted and graded.</p> </li> </ul> <p>Students will be enrolled in Piazza and CodePost by the course instructor. If you added the course late, you may need to remind the instructor to add you.</p> <p>In addition, some TAs and the instructor may choose to host office hours online on Zoom.</p>"},{"location":"assignments/1/assignment1/#background-reading","title":"Background reading","text":"<p>We recommend that you read the first four chapters of the Gentle Introduction to Haskell. Warning: It isn't that gentle!<sup>1</sup></p>"},{"location":"assignments/1/assignment1/#writing-and-testing-your-code","title":"Writing and testing your code","text":"<p>Here are some general guidelines for writing your code. These apply to all assignments, not just to this one. We won't repeat these in future assignments, but you can reread this later if necessary.</p>"},{"location":"assignments/1/assignment1/#compiler-warnings-and-the-ghci-file","title":"Compiler warnings and the <code>.ghci</code> file","text":"<p>All of your Haskell functions, even internal ones, should have explicit type signatures. This is not a Haskell requirement, but we consider it to be good style as well as good documentation, and it is likely to save you from some problems that might occur if you let <code>ghc</code> infer the types. Also, error messages will be easier to understand.</p> <p>All of your code should be tested using <code>ghci</code> with the <code>-W</code> (warnings enabled) command-line option. Any warnings will be considered errors, so make sure your code does not give any warnings. (NOTE: On rare cases, we may make exceptions to this for specific problems, but if so we will tell you.)</p> <p>You can invoke <code>ghci</code> explicitly with the <code>-W</code> option as follows:</p> <pre><code>$ ghci -W\n</code></pre> <p>However, since you always want the <code>-W</code> option to be enabled, a better solution is to define this once and for all in a <code>.ghci</code> file. The <code>.ghci</code> file is just a regular file that contains stuff to be automatically loaded into <code>ghci</code> when it's launched. Put these lines in the file:</p> <pre><code>:set -W\n:set -Wno-x-partial\n</code></pre> <p>and you are all set. We recommend that this file be placed in your home directory, because <code>ghc</code> will look for it there.</p> <p>Note</p> <p>The <code>:set -Wno-x-partial</code> will allow you to use non-total functions like <code>tail</code> without getting a warning.</p> <p>Warning</p> <p>If your code generates any warnings (and we haven't explicitly said that it's OK for that problem), you will lose half marks for each problem that generates a warning. (If the code for multiple problems generates warnings, you will lose half marks for each of them.) Your TA is also allowed to not grade your assignment until you fix the warnings, but they must inform you of this so you know what you need to do.</p> <p>Also, if you are using an old version of <code>ghc</code>, you may get more or fewer warnings than you get on the latest version. Make sure you have the latest version of <code>ghc</code> installed, or you may get marked down for code that gives no warnings on your <code>ghc</code> but gives warnings on the grader's!</p> <p>If you are getting a warning but don't understand it or don't know how to fix it, post a question to Piazza or come to office hours.</p>"},{"location":"assignments/1/assignment1/#essayevaluation-questions","title":"Essay/evaluation questions","text":"<p>Evaluations and answers to questions should be written as Haskell comments. We recommend that you use the multi-line comment syntax <code>{- ... -}</code>, for example:</p> <pre><code>{-\n\nThe answer to this question is...\n\n-}\n</code></pre>"},{"location":"assignments/1/assignment1/#test-script","title":"Test script","text":"<p>We are supplying you with a short test script called <code>Tests_Lab1.hs</code> which you should download into the directory where your <code>Lab1.hs</code> file is. Before running the test script, make sure that the <code>HUnit</code> and <code>HUnit-approx</code> libraries are installed. In a terminal, type:</p> <pre><code>$ cabal install --lib HUnit\n$ cabal install --lib HUnit-approx\n</code></pre> <p>To run the tests, just load the test script into <code>ghci</code> and type <code>main</code> like this:</p> <pre><code>ghci&gt; :l Tests_Lab1.hs\nghci&gt; main\n</code></pre> <p>We are also supplying you with a <code>Makefile</code> so you can run the test script without using <code>ghci</code>. To do this, make sure that the <code>Makefile</code> is in the same directory as the files <code>Lab1.hs</code> and <code>Tests_Lab1.hs</code>, <code>cd</code> into that directory, and type</p> <pre><code>$ make\n</code></pre> <p>to compile and run the test script, and </p> <pre><code>$ make clean\n</code></pre> <p>to remove all files generated during compilation.</p>"},{"location":"assignments/1/assignment1/#what-to-hand-in","title":"What to hand in","text":"<p>Write all of your code in a single text file called <code>Lab1.hs</code>. This file should start with this line:</p> <pre><code>module Lab1 where\n</code></pre> <p>followed by the rest of the code on subsequent lines. Submit your assignment as the CodePost assignment called <code>Assignment 1</code>.</p> <ol> <li> <p>This document is quite old, but it describes the most basic aspects of Haskell that haven't changed over the years.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/partA_exercises/","title":"Part A: Exercises (50 points)","text":""},{"location":"assignments/1/partA_exercises/#1-defining-new-operators","title":"1. Defining new operators","text":"<p>[5 points]</p> <p>Haskell lets you define your own operators. Here are a couple of simple examples. (See lecture 2 for how to define new operators.)</p>"},{"location":"assignments/1/partA_exercises/#a-sum-of-squares","title":"a. <code>+*</code> (sum of squares)","text":"<p>Write a definition for an operator called <code>+*</code> that computes the sum of the squares of its arguments. Assume both arguments are <code>Double</code>s. Make it left-associative and give it a precedence of 7.</p> <p>Note</p> <p>Define this operator directly\u2009\u2014 don't just define a function and make the operator another name for the function. This applies for the next problem as well.</p>"},{"location":"assignments/1/partA_exercises/#b-exclusive-or","title":"b. <code>^||</code> (exclusive-or)","text":"<p>Write a definition for an operator called <code>^||</code> that computes the exclusive-OR of its two (boolean) arguments. Make it right-associative with a precedence of 3. Your definition should be only two (very simple) lines (not counting the type declaration) and shouldn't use <code>if</code>.</p> <p>Hint</p> <p>Use pattern matching; if the first argument is <code>False</code>, what must the answer be?</p>"},{"location":"assignments/1/partA_exercises/#2-rangeproduct","title":"2. <code>rangeProduct</code>","text":"<p>[5 points]</p> <p>Write a recursive function called <code>rangeProduct</code> that takes two <code>Integers</code> and computes the product of all the integers in the range from one integer to the other (inclusive). For instance:</p> <pre><code>rangeProduct 10 20\n{-\n--&gt; 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20\n--&gt; 6704425728000\n-}\n</code></pre> <p>If the first argument is greater than the second argument, signal an error using the <code>error</code> function. If the two arguments are the same, return the argument value (so <code>rangeProduct 42 42</code> is just <code>42</code>). Use pattern guards instead of explicit <code>if</code> expressions to test the cases. Make sure all cases are exhaustive!</p>"},{"location":"assignments/1/partA_exercises/#3-prod","title":"3. <code>prod</code>","text":"<p>[5 points]</p> <p>Use <code>foldr</code> to define a one-line point-free function called <code>prod</code> that returns the product of all the numbers in a list of <code>Integer</code>s (or <code>1</code> if the list is empty). Use this function to define a one-line (not including the type signature) non-recursive definition for <code>rangeProduct</code>, which you should call <code>rangeProduct2</code>. (This will be a two-line definition if you also include the line containing <code>error</code>.)</p>"},{"location":"assignments/1/partA_exercises/#4-map-and-variations","title":"4. <code>map</code> and variations","text":"<p>[5 points]</p> <p>You learned about the <code>map</code> higher-order function in class. Here you will write some variations on <code>map</code>.</p>"},{"location":"assignments/1/partA_exercises/#a-map2","title":"a. <code>map2</code>","text":"<p>First, write a function <code>map2</code> which maps a two-argument function over two lists. Write it as a recursive function (there is a trivial definition using <code>zipWith</code> which you shouldn't use). It could be used like this:</p> <pre><code>ghci&gt; map2 (*) [1, 2, 3] [4, 5, 6]\n[4,10,18]\n</code></pre> <p>Your solution should have a completely polymorphic type signature (i.e. the most general type signature). Extra elements in either list should be ignored.</p>"},{"location":"assignments/1/partA_exercises/#b-map3","title":"b. <code>map3</code>","text":"<p>Now, write a <code>map3</code> function that will work for functions of 3 arguments. For instance:</p> <pre><code>ghci&gt; map3 (\\x y z -&gt; x + y + z) [1, 2, 3] [4, 5, 6] [7, 8, 9]\n[12,15,18]\n</code></pre>"},{"location":"assignments/1/partA_exercises/#5-dot-product","title":"5. Dot product","text":"<p>[10 points]</p> <p>It's easy to use <code>map2</code> along with the <code>sum</code> function to define a function to compute the dot product of two lists of integers, as follows:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot lst1 lst2 = sum (map2 (*) lst1 lst2)\n</code></pre> <p>or we can save some parentheses by writing it as:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot lst1 lst2 = sum $ map2 (*) lst1 lst2\n</code></pre> <p>You might think that you can write this as a point-free version using the <code>(.)</code> function composition operator as follows:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot = sum . map2 (*)\n</code></pre> <p>However, this does not type check! The correct point-free version is:</p> <pre><code>dot :: [Integer] -&gt; [Integer] -&gt; Integer\ndot = (sum .) . map2 (*)\n</code></pre> <p>Write out a short (less than 10 lines) evaluation showing that <code>dot lst1 lst2</code> using the point-free definition is equivalent to the explicit (point-wise) definition given above. Note that <code>(sum .)</code> is an operator section equivalent to <code>\\x -&gt; sum . x</code>.</p> <p>Hint</p> <p>Don't forget about currying!</p> <p>Expand out the <code>.</code> operator as follows:</p> <pre><code>f . g == \\x -&gt; f (g x)\n</code></pre> <p>It's a good idea to expand out the <code>dot</code> function as much as possible before you apply it to <code>lst1</code> and <code>lst2</code>.</p> <p>Finally, it's sometimes helpful to put in extra parentheses to clarify what subexpressions the operators are working on.</p> <p>Note</p> <p>Fun fact: there's an obscure Haskell library called <code>Data.Composition</code> that contains a composition operator called <code>.:</code> which can compose a unary function with a binary one. Using this operator, <code>dot</code> can be written as:</p> <pre><code>dot = sum .: map2 (*)\n</code></pre> <p>The definition is simply:</p> <pre><code>(.:) :: (c -&gt; d) -&gt; (a -&gt; b -&gt; c) -&gt; a -&gt; b -&gt; d\n(f .: g) x y = f (g x y)\n</code></pre> <p>The moral of the story is: if you think Haskell's <code>.</code> composition operator isn't good enough for a particular task, you can always define a new composition operator!</p>"},{"location":"assignments/1/partA_exercises/#6-fun-with-list-comprehensions","title":"6. Fun with list comprehensions","text":"<p>[5 points]</p> <p>Using a list comprehension, write a one-line expression which computes the sum of the natural numbers below one thousand which are multiples of 3 or 5. Write the result in a comment. You may use the Haskell <code>sum</code> function to do the actual sum.</p>"},{"location":"assignments/1/partA_exercises/#7-sum-of-primes","title":"7. Sum of primes","text":"<p>[5 points]</p> <p>Calculate the sum of all the prime numbers below 10000.</p> <p>Do this as follows:</p> <ol> <li> <p>First, generate an infinite list of prime numbers using the \"Sieve of Eratosthenes\" algorithm. This consists of generating all positive integers and removing all multiples of successive prime numbers. Write a function called <code>sieve</code> which takes a list of integers, retains the first one, removes all multiples of the first one from the rest, and then sieves the rest. Name the infinite list of primes <code>primes</code>. Note that <code>sieve</code> is a two-line definition (not including type declaration) and <code>primes</code> is trivial given <code>sieve</code>. Make sure your code doesn't generate any compiler warnings.</p> </li> <li> <p>Then, use the <code>takeWhile</code> function on the primes list to take the appropriate prime numbers and compute their sum.</p> </li> <li> <p>Write the answer as a Haskell comment.</p> </li> </ol>"},{"location":"assignments/1/partA_exercises/#8-balanced-parentheses","title":"8. Balanced parentheses","text":"<p>[10 points]</p> <p>For this problem we are going to write functions that take in a string and return a boolean value. This returned value will be <code>True</code> if the parentheses in the string are \"balanced\" and <code>False</code> otherwise. By \"balanced\" we mean:</p> <ul> <li> <p>there are an equal number of open and close parentheses (they pair up),</p> </li> <li> <p>and a close parenthesis never occurs before its matching open parenthesis.</p> </li> </ul> <p>Here are some strings that have balanced parentheses:</p> <pre><code>\"\",\n\"foo\",\n\"()\",\n\"(foo)\",\n\"()()()\",\n\"(()())\",\n\"(((())))\",\n\"(((()())()))\"\n</code></pre> <p>Here are some strings with unbalanced parentheses:</p> <pre><code>\"(\"\n\")\"\n\")(\"\n\")a(\"\n\"()()(\"\n\"(()))(()\"\n</code></pre> <p>Note that characters other than <code>'('</code> or <code>')'</code> are irrelevant to determining if parentheses are balanced or not.</p> <p>You have to write three different functions to determine if a string has balanced parentheses. We will use this to contrast writing a function using explicit recursion vs. using higher-order functions.</p> <p>Note</p> <p>Remember that strings in Haskell are (by default) just lists of characters i.e. lists of <code>Char</code> values. So you can use list functions on strings as you would on any list.</p>"},{"location":"assignments/1/partA_exercises/#a-balancedparentheses","title":"a. <code>balancedParentheses</code>","text":"<p>Write a function called <code>balancedParentheses</code> that takes a <code>String</code> and returns a <code>Bool</code> which is <code>True</code> if the string has balanced parentheses or <code>False</code> otherwise. Use a recursive helper function which traverses the string one character at a time and keeps a running count of the \"parenthesis imbalance\". This can be done by starting the count at zero, adding 1 every time a left parenthesis is encountered, and subtracting 1 every time a right parenthesis is encountered. At the end of the string, the imbalance count will be 0 if the string has balanced parentheses. In addition, the count should never go negative; if it does, the string doesn't have balanced parentheses (there are too many close parentheses at that point in the string), so <code>False</code> should immediately be returned.</p> <p>Put the helper function in a <code>where</code> clause of the <code>balancedParentheses</code> function.</p>"},{"location":"assignments/1/partA_exercises/#b-balancedparentheses2","title":"b. <code>balancedParentheses2</code>","text":"<p>In general, Haskell programmers prefer to use higher-order functions instead of writing explicitly recursive functions. Rewrite <code>balancedParentheses</code> into a new version called <code>balancedParentheses2</code> which is not recursive but which uses the <code>foldl</code> (left fold) higher-order function. (Don't use <code>foldr</code>, even though you could make it work that way.) The function being folded has the type <code>Int -&gt; Char -&gt; Int</code>. It takes the existing imbalance count at some location in the string and the current character in the string, and returns the new count (1 higher if the character is a <code>'('</code>, 1 lower if it's a <code>')'</code>, or the same otherwise). The fold as a whole will return the final imbalance count of the string; if it's 0, the string has balanced parentheses.</p> <p>Some hints and advice:</p> <ol> <li> <p>This function should be shorter than <code>balancedParentheses</code>.</p> </li> <li> <p>If the imbalance count ever goes negative, it should stay negative through the entire fold. Basically, once the count is negative, then the string has unbalanced parentheses, and you can just propagate the negative value through to the end of the fold. This can be done simply by writing the folded function a particular way. If the fold returns a negative number, you know that the string has unbalanced parentheses.</p> </li> <li> <p>We've seen in class that some functions in Haskell can lead to large expressions being generated because of Haskell's lazy evaluation rule. Careless use of <code>foldl</code> can easily do this, and this function is no exception. To avoid a \"space leak\" (where a function that should run in constant space instead runs in e.g. O(N) space), use <code>foldl'</code> (called \"fold-ell-prime\") instead of <code>foldl</code>, which makes the function being folded evaluate strictly.<sup>1</sup> Other than the single <code>'</code> character, <code>foldl'</code> is used the exact same way as <code>foldl</code>.</p> </li> <li> <p>In order to use <code>foldl'</code>, you will need to import the <code>Data.List</code> library. Put this line at the top of your code (after the <code>module Lab1 where</code> line):</p> <pre><code>import Data.List\n</code></pre> <p>Note</p> <p>Even using <code>foldl'</code> may not be enough to guarantee strict evaluation. There are more tricks for ensuring strict evaluation that we will teach you later in the course, but don't worry too much about this for now.</p> </li> </ol>"},{"location":"assignments/1/partA_exercises/#c-balancedparentheses3","title":"c. <code>balancedParentheses3</code>","text":"<p>One problem with <code>balancedParentheses2</code> is that using <code>foldl'</code> doesn't exit early if the imbalance count goes negative. This means that <code>balancedParentheses2</code> is less efficient than <code>balancedParentheses</code>. It seems a shame that converting from a crude recursive definition to an elegant definition using higher-order functions costs us in efficiency. It would be nice to have the best of both worlds.</p> <p>Write a function called <code>balancedParentheses3</code> which solves the balanced parentheses problem using this algorithm:</p> <ol> <li> <p>Write a function called <code>ctoi</code> which converts <code>Char</code> values (characters) to <code>Int</code> values. This should return <code>1</code> if the input character is <code>'('</code>, <code>-1</code> if it's <code>')'</code>, and <code>0</code> otherwise.</p> </li> <li> <p>Use <code>map</code> to convert each character in the string to an <code>Int</code> using <code>ctoi</code>. This will return a list of <code>Int</code>s.</p> </li> <li> <p>The sum of all the <code>Int</code> values will be <code>0</code> for a string with balanced parentheses. However, we also want to make sure that for each prefix of the string (i.e. each string that starts on the first character of the original string and ends before the last character), the imbalance count isn't negative (which would imply unbalanced parentheses for the entire string). For this, we can use the <code>scanl</code> function. <code>scanl</code> works a lot like <code>foldl</code> but collects up the results for all prefixes of the list (string) argument. For instance:</p> <pre><code>foldl (+) 0 [1..5] --&gt; 0 + 1 + 2 + 3 + 4 + 5 = 15\nscanl (+) 0 [1..5]\n  --&gt; [0, 0 + 1, 0 + 1 + 2, 0 + 1 + 2 + 3, 0 + 1 + 2 + 3 + 4, 0 + 1 + 2 + 3 + 4 + 5]\n  --&gt; [0, 1, 3, 6, 10, 15]\n</code></pre> <p>Using <code>scanl</code> on the results of the <code>map</code> gives us the list of partial imbalance counts of the string. (To avoid problems with laziness, use the strict version <code>scanl'</code> instead of just <code>scanl</code> itself.)</p> </li> <li> <p>Now that we have a list of the imbalance counts at each character, we can test if this corresponds to a string with balanced parentheses. If so, either the list is empty (corresponding to an empty string), or its last element is <code>0</code> and none of its elements are negative. Write a function called <code>test</code> that takes a list of <code>Int</code>s and returns a <code>Bool</code> which is <code>True</code> if the list has the desired properties. (The <code>all</code> and <code>last</code> functions will probably be useful to you; look them up in Hoogle.) You can write this as a recursive function if you must, but try not to. Also, the function <code>null</code> returns <code>True</code> if its argument is an empty list.</p> </li> <li> <p>Assemble the <code>test</code>, <code>scanl'</code>, and <code>map</code> functions in a (short!) single line to write the <code>balancedParentheses3</code> function. Put the <code>test</code> and <code>ctoi</code> functions as helper functions in a <code>where</code> clause. (They can be more than one line long.)</p> </li> </ol> <p>If you do this right, you will have an elegant function to compute balanced parentheses which will quit at the first character which guarantees unbalanced parentheses.</p> <p>Note</p> <p>Haskell's lazy evaluation is key to understanding why this function will exit when the imbalance count first goes negative. Basically, the <code>scanl'</code> call will generate one prefix count at a time, and the <code>test</code> function will look at each of these and return <code>False</code> immediately if a negative count is ever seen.</p> <p>Also, the fact that you use <code>scanl'</code> instead of <code>scanl</code> doesn't mean that the entire list of partial counts will be generated strictly (this would ruin the efficiency of the function). It just means that the function which is being folded over the list is applied strictly, which is what you want.</p> <p>If this seems like a lot of mental effort to write a simple function, be aware that this is the nature of Haskell: you write much less code, but you think more about the code you do write. (Some people like this trade off, and some don't.) The good news is that the more you do it, the less thinking it will require.</p> <ol> <li> <p>Technically, it makes it evaluate more strictly, as we will see later in the course.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/partB_pitfalls/","title":"Part B: Pitfalls (20 points)","text":"<p>In this section we'll see some examples of bad code and ask you to fix them. By \"bad code\" we don't mean \"the code doesn't work\" but rather \"the code isn't optimal in some way\". By \"optimal\" we don't necessarily always mean \"inefficient\"; there are other kinds of non-optimality too.</p> <p>Write both the corrected code and (in a Haskell comment) the reason why the original code is bad.</p>"},{"location":"assignments/1/partB_pitfalls/#1-sumlist","title":"1. <code>sumList</code>","text":"<p>[10 points]</p> <p>The following recursive definition has poor Haskell style. How would you improve the style by making a simple change (i.e. keep it a recursive definition, but with better style)?</p> <pre><code>sumList :: [Integer] -&gt; Integer\nsumList [] = 0\nsumList lst = head lst + sumList (tail lst)\n</code></pre>"},{"location":"assignments/1/partB_pitfalls/#2-largest","title":"2. <code>largest</code>","text":"<p>[10 points]</p> <p>What is wrong with this recursive definition? How would you fix it, while keeping it a recursive definition? (The function works, but it is still not \"good\" in some sense.)</p> <pre><code>-- Return the largest value in a list of integers.\nlargest :: [Integer] -&gt; Integer\nlargest xs | length xs == 0 = error \"empty list\"\nlargest xs | length xs == 1 = head xs\nlargest xs = max (head xs) (largest (tail xs))\n</code></pre>"},{"location":"assignments/1/partC_evaluation/","title":"Part C: Evaluation (30 points)","text":"<p>In this section, you'll have to write out the results of evaluating some Haskell expressions step-by-step. These evaluations should look like this:</p> <pre><code>double (3 + 4)\n--&gt; (3 + 4) + (3 + 4)\n--&gt; 7 + (3 + 4)\n--&gt; 7 + 7\n--&gt; 14\n</code></pre> <p>with one reduction step per line. Even more explicit would be the following:</p> <pre><code>double (3 + 4)\n--&gt; (3 + 4) + (3 + 4)  [expand from definition]\n[outermost redex is + operator]\n[+ is strict, needs both operands]\n--&gt; 7 + (3 + 4)        [evaluate leftmost branch of + operator]\n--&gt; 7 + 7              [evaluate rightmost branch of + operator]\n[outermost redex is + operator]\n--&gt; 14                 [evaluate + application]\n</code></pre> <p>though we won't require you to do this (but you may find it helpful to do it this way).</p> <p>Pay particular attention to the fact that Haskell is a lazy language. You may assume that the result of the expression being evaluated is going to be printed in its entirety after evaluation. You may also assume that primitive arithmetic expressions evaluate strictly. If the function evaluation does not terminate, compute enough of the evaluation to make it clear that non-termination is the outcome.</p> <p>Note</p> <p>Since Haskell uses lazy evaluation, it will evaluate copies of one subexpression at the same time, so the above example should really be:</p> <pre><code>double (3 + 4)\n--&gt; (3 + 4) + (3 + 4)\n--&gt; 7 + 7    -- evaluate both (3 + 4)s together\n--&gt; 14\n</code></pre> <p>However, for the evaluations here, assume that all subexpressions are distinct i.e. each one should be evaluated separately.</p> <p>Evaluating Haskell expressions by hand should use the following guidelines:</p> <ol> <li> <p>Find the outermost redex (reducible expression) first. If there is more than one choice (which is very common), choose the leftmost of the outermost redexes.</p> </li> <li> <p>If the redex is inside a lambda expression (i.e. an anonymous function), leave it alone. Otherwise, evaluate it.</p> </li> <li> <p>Continue until you get the result you need. Don't evaluate beyond that point.</p> </li> <li> <p>When expanding a function application using its definition, keep the result in parentheses until it is fully evaluated so as to make clear what the subexpression is.</p> </li> <li> <p>Note that an expression in parentheses can still be a redex. \"Outermost\" does not refer to parentheses but to the presence of other language constructs. For instance, an expression inside a data constructor or inside a lambda expression is not at the outermost level.</p> </li> </ol>"},{"location":"assignments/1/partC_evaluation/#1-fibonacci","title":"1. Fibonacci","text":"<p>[5 points]</p> <p>Consider this function to compute fibonacci numbers:</p> <pre><code>fib :: Integer -&gt; Integer\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n - 1) + fib (n - 2)\n</code></pre> <p>Evaluate <code>fib 3</code>.</p>"},{"location":"assignments/1/partC_evaluation/#2-factorial","title":"2. Factorial","text":"<p>[5 points]</p> <p>Consider this definition of the factorial function:</p> <pre><code>fact :: Integer -&gt; Integer\nfact n = n * fact (n - 1)\nfact 0 = 1\n</code></pre> <p>Evaluate <code>fact 3</code>. What is wrong with this definition? Fix the definition, and then evaluate the fixed definition too.</p> <p>Note</p> <p>Pay special attention to the consequences of lazy evaluation here. Assume that the <code>*</code> operator applied to <code>Integer</code>s evaluates its arguments strictly from left to right.</p>"},{"location":"assignments/1/partC_evaluation/#3-reverse","title":"3. <code>reverse</code>","text":"<p>[5 points]</p> <p>We talked about the <code>reverse</code> function in lecture 3. One definition was as follows:</p> <pre><code>reverse :: [a] -&gt; [a]\nreverse xs = iter xs []\n  where\n    iter :: [a] -&gt; [a] -&gt; [a]\n    iter [] ys = ys\n    iter (x:xs) ys = iter xs (x:ys)\n</code></pre> <p>Evaluate the expression <code>reverse [1,2,3]</code> with this definition. What is the asymptotic time complexity of this function as a function of the length of the input list? Write your answer in a comment. Don't just give the answer, explain why it's correct.</p>"},{"location":"assignments/1/partC_evaluation/#4-reverse-again","title":"4. <code>reverse</code> again","text":"<p>[5 points]</p> <p>Another definition of <code>reverse</code> is as follows:</p> <pre><code>reverse :: [a] -&gt; [a]\nreverse [] = []\nreverse (x:xs) = reverse xs ++ [x]\n</code></pre> <p>For reference: The definition of the <code>(++)</code> operator is:</p> <pre><code>(++) :: [a] -&gt; [a] -&gt; [a]\n(++) []     ys = ys\n(++) (x:xs) ys = x : (xs ++ ys)\n</code></pre> <p>and the <code>++</code> operator is also right-associative.</p> <p>Ben Bitfiddle claims that this definition of <code>reverse</code> has an asymptotic time complexity which is linear in the length of the input list, giving this argument: \"Evaluating <code>reverse [1, 2, 3]</code> eventually results in <code>[] ++ [3] ++ [2] ++ [1]</code> after a linear number of steps, and since appending a singleton list to another list is an <code>O(1)</code> operation, constructing the result list from this point is also linear.\" What is wrong with this argument? Write out a full evaluation of <code>reverse [1, 2, 3]</code> and explain where Ben made his mistake and what the mistake was. What is the actual asymptotic time complexity of this version of <code>reverse</code>?</p> <p>Warning</p> <p>This is tricky! We want a full explanation, not just a couple of sentences.</p> <p>Hints</p> <ul> <li>The <code>++</code> operator is right-associative.</li> <li>Parentheses are your friend.</li> </ul>"},{"location":"assignments/1/partC_evaluation/#5-insertion-sort","title":"5. Insertion sort","text":"<p>[5 points]</p> <p>An \"insertion sort\" is a particular way to sort lists. The first item in the list is inserted at the right place in the result of insertion sorting the rest of the list. For lists of integers, the code might look like this:</p> <pre><code>isort :: [Integer] -&gt; [Integer]\nisort [] = []\nisort (n:ns) = insert n (isort ns)\n  where\n    insert :: Integer -&gt; [Integer] -&gt; [Integer]\n    insert n [] = [n]\n    insert n m@(m1:_) | n &lt; m1 = n : m\n    insert n (m1:ms) = m1 : insert n ms\n</code></pre> <p>For reference, <code>head</code> is defined as:</p> <pre><code>head :: [a] -&gt; a\nhead [] = error \"empty list\"\nhead (x:_) = x\n</code></pre> <p>Evaluate <code>head (isort [3, 1, 2, 5, 4])</code>. Don't evaluate more than you need to!</p>"},{"location":"assignments/1/partC_evaluation/#6-foldr-and-foldl","title":"6. <code>foldr</code> and <code>foldl</code>","text":"<p>[5 points]</p> <p>We discussed the <code>foldr</code> (fold right) and <code>foldl</code> (fold left) higher-order functions in class. Assume that their definitions are as follows:</p> <pre><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b\nfoldr _ init [] = init\nfoldr f init (x:xs) = f x (foldr f init xs)\n</code></pre> <pre><code>foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a\nfoldl _ init [] = init\nfoldl f init (x:xs) = foldl f (f init x) xs\n</code></pre> <p>Note</p> <p>The actual definitions of these functions in GHC are slightly different.</p> <p>Evaluate the following expressions using the above definitions:</p> <ul> <li><code>foldr max 0 [1, 5, 3, -2, 4]</code></li> <li><code>foldl max 0 [1, 5, 3, -2, 4]</code></li> </ul> <p>where <code>max</code> gives the maximum of two values (which you can assume to be <code>Integers</code> for this problem). What can you say about the space complexity of <code>foldr</code> compared to <code>foldl</code>? Hint: Don't forget about lazy evaluation!</p>"},{"location":"assignments/2/assignment2/","title":"Assignment 2: Algebraic datatypes","text":""},{"location":"assignments/2/assignment2/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, April 26th at 2 AM.</p>"},{"location":"assignments/2/assignment2/#what-to-hand-in","title":"What to hand in","text":"<p>Write all your code in a single file called <code>RedBlackTree.hs</code>. This file should be submitted to CodePost as <code>Assignment 2</code>.</p>"},{"location":"assignments/2/assignment2/#writing-your-code","title":"Writing your code","text":"<p>The file you will submit will be a Haskell module, which means it must begin with a module declaration of the form:</p> <pre><code>module MODULENAME(EXPORTLIST) where\n</code></pre> <p>In this case, we are exporting everything from the module (mostly for ease of testing), so the line should just be:</p> <pre><code>module RedBlackTree where\n</code></pre>"},{"location":"assignments/2/assignment2/#testing-your-code","title":"Testing your code","text":"<p>For this week's assignment's code base, we are supplying you with a test script called <code>Tests_Lab2.hs</code>, as well as a <code>Makefile</code>. You can run the tests by putting both files into the same directory and typing</p> <pre><code>$ make\n$ make test\n</code></pre> <p>(where <code>$</code> is the terminal prompt, of course).</p> <p>This test script will run a number of tests on your code; any failure indicates that you have some debugging to do. The test script relies on the Haskell testing packages <code>HUnit</code> (which we installed and used last week) and <code>QuickCheck</code>. Install <code>QuickCheck</code> by starting up a terminal and entering these commands:</p> <pre><code>$ cabal update\n$ cabal install QuickCheck --lib\n</code></pre> <p><code>QuickCheck</code> is a randomized testing framework that tests that functions obey particular properties, automatically synthesizing large numbers of random data values to test the functions.<sup>1</sup> <code>HUnit</code> is a more traditional unit testing framework where you supply expected results for certain computations.</p> <p>Some of the functions you will be writing in this assignment are only used for testing; if they are buggy, your tests may pass but your code may still be wrong. We'll be testing your code on our own test script, which is more stringent. Moral: don't let test scripts lull you into a false sense of security! Just because code passes a test script doesn't mean it's automatically correct.</p> <ol> <li> <p>The <code>QuickCheck</code> library has been quite influential. A number of other languages have built <code>QuickCheck</code> clones to do the same kind of randomized testing.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/background/","title":"Background information","text":"<p>The purpose of this assignment is to get you comfortable working with algebraic datatypes in Haskell. To do this, you will be implementing a data structure called a red-black tree and you'll use it to implement a set data type. You'll see that once you've implemented a red-black tree, implementing set operations will be very simple.</p> <p>A red-black tree is an ordered binary tree where all the elements are stored in the nodes and not the leaves. In addition, each node has a \"color\" which is either \"red\" or \"black\"; this will be used to make sure that the tree is balanced. A perfectly balanced binary tree has all the leaves at the same depth (distance from the root node), but we won't require that our trees be perfectly balanced, just \"balanced enough\". Having a balanced tree is very important, because if the tree is balanced the tree operations can all be done in \\(\\Theta(log\\ n)\\) time. If the tree is not balanced, some operations can take up to \\(\\Theta(n)\\) time, which completely negates all the benefits of using a tree in the first place.</p> <p>Let's be more specific. In Haskell, we'll define the tree using two datatypes:</p> <pre><code>-- A color is either red or black.\ndata Color = Red | Black\n  deriving Show\n\n-- A red-black tree is either empty (a \"leaf\") or a tree node with a color,\n-- two branches (both of which are red-black trees), and a value of type a.\ndata Tree a = Leaf | Node Color (Tree a) a (Tree a)\n  deriving Show\n</code></pre> <p>We see from the definition of the <code>Tree</code> datatype that trees are parameterized around a type <code>a</code>. We will be using integers as tree elements for testing, but you can use this with any orderable type.</p> <p>Note</p> <p>The <code>deriving Show</code> part is just to make it possible to display trees interactively in <code>ghci</code>.</p> <p>The tree needs to obey these invariants:</p> Order invariant <p>The elements (of type <code>a</code>) are orderable.   (Consequently, type <code>a</code> should be an instance of the type class <code>Ord</code>.)   All elements in the left subtree of a node   are strictly smaller than the element stored in the node,   and all elements in the right subtree of a node   are strictly larger than the element stored in the node.   (This also implies that there can be no duplicated elements in the tree.)</p> Red invariant <p>No red node has a red parent.   (Leaves are considered to be black,   so they can have either red or black nodes as parents.)</p> Black invariant <p>Every path from the root node to a leaf   contains the same number of black nodes.   We will refer below to the distance from the root node to a leaf node;   this means the number of nodes in such a path.   More specifically, the distance from the root node to a leaf   is the number of times you can go from a node to one of its branch nodes   before you hit the leaf, starting from the root node.   (For a particular node and leaf, there can be only one such path.)</p> <p>The order invariant is simply the definition of an ordered binary tree, and applies to all such trees, not just red-black trees. The red and black invariants are what ensure that the red-black tree is balanced. By \"balanced\" we don't mean that all leaves must be exactly the same distance from the root of the tree, but that there is some constraint on the tree that guarantees \\(\\Theta(log\\ n)\\) performance for all tree operations. In this case, the red and black invariants guarantee that the longest path from the root node to a leaf is no more than twice as long as the shortest path. When you think about it, it makes sense: the shortest such path would be all black nodes, whereas the longest path would be alternating black and red nodes (since you can't have red nodes with red parents). Since all paths from the root to a leaf have the same number of black nodes, the shortest path would be half the length of the longest path. This is enough to guarantee \\(\\Theta(log\\ n)\\) performance.</p> <p>Here is a diagram of a red-black tree of integers:</p> <p></p> <p>Note that in this diagram, <code>Leaf</code> nodes are represented by the small black unlabelled circles (leaves are considered to be black). Also notice how the tree obeys all three invariants. However, don't think that red-black trees have to have alternating red and black nodes like this one does; they can have more black nodes than red nodes, or even have only black nodes in some cases. Note also that each path from the root to a leaf contains exactly three black nodes.</p> <p>Here are the type signatures of the core red-black tree operations you will need to implement:</p> <pre><code>-- Return `True` if the given element is in the tree.\nmember :: Ord a =&gt; a -&gt; Tree a -&gt; Bool\n\n-- Insert a new element into a tree.\ninsert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\n\n-- Convert a tree to a list.\ntoList :: Tree a -&gt; [a]\n\n-- Convert a list to a tree.\nfromList :: Ord a =&gt; [a] -&gt; Tree a\n</code></pre> <p>In addition, we want you to write several functions which will help in testing the correctness of your implementation, as well as helper functions that will be used in implementing the above operations. Details are given in the following sections.</p> <p>One fundamental tree operation that we will not ask you to implement is removing an element from a tree. This turns out to be surprisingly complicated<sup>1</sup>, and would probably not increase your understanding of how to use algebraic datatypes in Haskell, so we're leaving it out.</p> <p>Once you've implemented red-black trees, you will use them to implement sets. A red-black tree can be used as a set without changing it at all, but in addition to the operations given above, you will implement subset testing, set equality testing, union, intersection and set difference in terms of the fundamental tree operations. By using higher-order functions, you can implement all these operations in one line each.</p> <ol> <li> <p>At least, it's complicated if you do it purely functionally. This may be one reason why Haskell doesn't use red-black trees as the base type for the set and map types (in the libraries <code>Data.Set</code> and <code>Data.Map</code> respectively); those are implemented using weight-balanced trees.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partA_red_black_trees/","title":"Part A: Red-black trees (75 points)","text":"<p>In this section, you will implement the red-black tree datatype, along with its associated functions.</p> <p>As mentioned previously, the file <code>RedBlackTree.hs</code> should start with this module declaration:</p> <pre><code>module RedBlackTree where\n</code></pre> <p>The <code>where</code> is not a mistake; it's part of the syntax of module declarations and implies that the entirety of the rest of the file is part of the module.</p> <p>After this, put the definition of the datatypes into your file:</p> <pre><code>-- A color is either red or black.\ndata Color = Red | Black\n  deriving Show\n\n-- A red-black tree is either a leaf or a tree node with a color,\n-- two branches, both of which are trees, and a value of type a.\ndata Tree a = Leaf | Node Color (Tree a) a (Tree a)\n  deriving Show\n</code></pre> <p>In the <code>Node</code> constructor, the first <code>(Tree a)</code> argument is the left subtree and the second is the right subtree.</p> <p>Then implement the functions described below.</p> <p>Warning</p> <p>You are not allowed to convert any red-black tree function arguments into lists of elements (or any other collection type of elements e.g. arrays of elements) in any of these functions except where specifically indicated. If you do, you will get a zero on the problem.</p> <ul> <li> <p>You may assume in all the functions that arguments that represent red-black trees represent valid red-black trees i.e. trees that obey all three tree invariants described previously, unless we explicitly tell you not to assume this. This will greatly influence the way you write your functions. Failure to take advantage of this where it's advantageous will result in lost marks. We'll provide hints for the less obvious cases.</p> </li> <li> <p>You can't add anything to the type definitions given above; for instance, you can't make <code>Color</code> an instance of <code>Eq</code>, because you don't need to compare colors for equality. (Don't do this indirectly either e.g. by defining an <code>eqColor</code> helper function.) Pattern matching on the datatypes can do everything you need.</p> </li> </ul> <p>Here are the descriptions of the functions you need to implement.</p>"},{"location":"assignments/2/partA_red_black_trees/#1-member","title":"1. <code>member</code>","text":"<p>[5 points]</p> <p>Write the <code>member</code> function, which has this type signature:</p> <pre><code>member :: Ord a =&gt; a -&gt; Tree a -&gt; Bool\n</code></pre> <p>This function takes an element and a red-black tree as its arguments and returns <code>True</code> if the element is in the tree. Note: the color of nodes is not used in this function. (Unused arguments in patterns should use the <code>_</code> notation so as not to trigger compiler warnings.) Assume that the input tree is ordered; use the ordering property to only search the parts of the tree that can possibly contain the element.</p>"},{"location":"assignments/2/partA_red_black_trees/#2-tolist","title":"2. <code>toList</code>","text":"<p>[5 points]</p> <p>Write the <code>toList</code> function, which has this type signature:</p> <pre><code>toList :: Tree a -&gt; [a]\n</code></pre> <p>It takes as its argument a red-black tree and returns a list of all the tree elements given by an in-order traversal. This means that for a node, you collect all the left subtree values first, then the node value, then the right subtree values. This function can be written in two lines.</p> <p>Clearly, here it's OK to convert the tree to a list, because that's the whole point of the function! </p>"},{"location":"assignments/2/partA_red_black_trees/#3-insert","title":"3. <code>insert</code>","text":"<p>[25 points]</p> <p>Write the <code>insert</code> function, which has this type signature:</p> <pre><code>insert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\n</code></pre> <p>This is the hardest (and most interesting) function in the assignment. The reason it's tricky is because you can't just naively add a node to the tree; you also have to make sure that the tree is balanced when you are finished. This is why we need the colors on the nodes. We'll walk you through this function in some detail.</p> <p>First of all, since Haskell is a functional language, although we say we are \"inserting\" an element into a tree, what we are really doing is creating a new tree with one extra element. The original tree is not altered in any way. The new tree will share a lot of structure with the original tree, so we won't modify any part of the old tree that doesn't need to be changed in the new tree.</p> <p>If it weren't for the balancing constraints (the red and black invariants), this would be an easy function to write:</p> <ul> <li> <p>If a tree being inserted into is just a leaf, return a node whose branches are leaves.</p> </li> <li> <p>If the new element is the same as the element in the root node of the tree, return the tree unchanged.</p> </li> <li> <p>Otherwise, determine whether the new element needs to be added to the left or right branch depending on whether it's smaller or larger than the element in the root node, add the element to the correct branch, and reconstruct the final tree.</p> </li> </ul> <p>The only problem is that when you do the last step, you might be causing the tree to violate the red or black invariants and thus become unbalanced. Also, what color should the node containing the new element be? If you think about it, you'll realize that the new node will be put at the base of the tree, right above the leaves. Since the leaves are black, the new node should be colored red so as not to violate the black invariant. However, when you do this, there is a chance that the parent node of the new node will also be red, which violates the red invariant (no red node can have a red parent node). So there has to be a way to re-balance the tree after adding a node to preserve both the red and black invariants. And that's the tricky part.</p> <p>Here's a template version of the code you should write, with some parts filled in:</p> <pre><code>insert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\ninsert elem t = makeBlack (ins elem t)\n  where\n    -- Insert an element into a tree.\n    ins :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a\n    ins elem Leaf = Node Red Leaf elem Leaf  -- new nodes are colored red\n    ins elem t@(Node color left elem' right)\n      | elem &lt; elem' = balance color (ins elem left) elem' right\n      | elem &gt; elem' = {- TODO: by analogy with the previous case -}\n      | otherwise = t  -- element already in the tree; no insertion required\n\n    -- Make the root of the tree black.\n    makeBlack :: Tree a -&gt; Tree a\n    makeBlack Leaf = Leaf\n    makeBlack (Node _ left elem right) = Node Black left elem right\n\n    -- Balance a red-black tree under construction which may not satisfy\n    -- the red and black invariants.\n    balance :: Ord a =&gt; Color -&gt; Tree a -&gt; a -&gt; Tree a -&gt; Tree a\n    balance Black (Node Red (Node Red l1 e1 r1) e2 r2) e t =\n      Node Red (Node Black l1 e1 r1) e2 (Node Black r2 e t)\n    balance = {- TODO: 3 more cases omitted -}\n    balance color l e r = Node color l e r  -- no balancing needed\n</code></pre> <p>The basic insertion code is in the <code>ins</code> helper function. If we didn't care about balancing or colors, the line:</p> <pre><code> | elem &lt; elem' = balance color (ins elem left) elem' right\n</code></pre> <p>would be just:</p> <pre><code> | elem &lt; elem' = Node color (ins elem left) elem' right\n</code></pre> <p>and similarly for the <code>elem &gt; elem'</code> case. However, adding the new element <code>elem</code> creates a new red node, and this can make the tree violate the red invariant. Therefore, we call the <code>balance</code> function with the same arguments as the <code>Node</code> constructor would have gotten. Its job is to create a new tree which is guaranteed to be balanced i.e. which doesn't violate any of the invariants. (The order invariant won't be violated, so we don't have to worry about that.) Since we are adding the new element to the left subtree (in this case), only the left subtree could possibly violate the red invariant by having a red node with a red parent. Nevertheless, we will need both subtrees in order to re-balance the tree. It turns out that there are only four different cases that need to be rebalanced.</p> <p>Here is case 1:</p> <p></p> <p>Look at the tree on the left of the arrow. In this case, the left subtree is the node labelled <code>y</code>, the right subtree is labelled <code>d</code>, and the root node of the new tree is labelled <code>z</code>. (The gray triangle nodes (<code>a</code> to <code>d</code>) represent balanced subtrees.) You can see that the left subtree violates the red invariant because node <code>y</code> is red and has a child node <code>x</code> which is also red.</p> <p>What you do is convert the tree on the left of the arrow to the tree on the right. This tree is still correctly ordered (because <code>x &lt; y &lt; z</code>) but now node <code>y</code> is the root of the tree and node <code>x</code> has changed color from red to black. This new tree doesn't violate any of the invariants; ordering is preserved, no red node has a red parent, and both branches have one black node in addition to the black nodes along the paths starting from <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>, which all have the same number of black nodes. This corresponds to the following line from the <code>balance</code> function:</p> <pre><code>balance Black (Node Red (Node Red l1 e1 r1) e2 r2) e t =\n  Node Red (Node Black l1 e1 r1) e2 (Node Black r2 e t)\n</code></pre> <p>Note that <code>balance</code> doesn't get an entire tree as its arguments; it gets the pieces of a tree as separate arguments (color, left subtree, element, right subtree). Nevertheless, the idea is the same. You can see that the root's color is <code>Black</code>, the left subtree (corresponding to nodes <code>y</code> and <code>x</code> in the diagram) is <code>Node Red (Node Red l1 e1 r1) e2 r2</code>, the node element is <code>e</code>, and the right subtree (corresponding to label <code>d</code> in the diagram) is <code>t</code>. The label <code>a</code> in the diagram is <code>l1</code>, <code>b</code> is <code>r1</code>, and <code>c</code> is <code>r2</code>. The output of the function is just the tree to the right of the arrow.</p> <p>These kinds of tree manipulations are referred to as \"tree rotations\" for obvious reasons.</p> <p>Notice how Haskell's algebraic datatypes have made a fairly complicated transformation very simple to write! This is a key advantage of algebraic datatypes when working with sophisticated data structures.</p> <p>Make sure you understand this case! If you do, filling in the rest of the cases of the <code>balance</code> function will be straightforward.</p> <p>Here is the second case:</p> <p></p> <p>The output tree is the same as before, but the inputs will be different. You have to fill in the code for this case.</p> <p>Here are the last two cases:</p> <p></p> <p></p> <p>You need to fill in the code for these cases as well. Any other case does not need to be balanced, so the default line:</p> <pre><code>balance color l e r = Node color l e r  -- no balancing needed\n</code></pre> <p>is in effect.</p> <p>You might be wondering what this helper function is for:</p> <pre><code>-- Make the root of the tree black.\nmakeBlack :: Tree a -&gt; Tree a\nmakeBlack Leaf = Leaf\nmakeBlack (Node _ left elem right) = Node Black left elem right\n</code></pre> <p>It turns out that when inserting into a red-black tree, you may end up with a red node at the root with a red child node (violating the red invariant), but with all other invariants satisfied. In this case we can simply recolor the root node to black to make the black invariant hold. This won't affect the order invariant (obviously) and it won't change the fact that all paths from the root to the leaves have the same number of black nodes (although that number will be one greater than before). You won't need to use <code>makeBlack</code> in any of the code you need to fill in.</p> <p>If you think that this code is complicated, you'd be right! Tree balancing code is often quite complex, and there are some kinds of trees whose balancing code is even worse than this.<sup>1</sup> The nice thing about red-black trees is that they are very efficient in practice, so once we get through writing the code, we have a very useful data structure.</p>"},{"location":"assignments/2/partA_red_black_trees/#4-fromlist","title":"4. <code>fromList</code>","text":"<p>[5 points]</p> <p>Write the <code>fromList</code> function, which has this type signature:</p> <pre><code>fromList :: Ord a =&gt; [a] -&gt; Tree a\n</code></pre> <p>This function takes a list as its argument and returns the red-black tree obtained by inserting all the list elements into an empty tree. This can be written in one line using <code>foldr</code>. (This is not a requirement, but try to find the <code>foldr</code> definition; it's very simple.)</p>"},{"location":"assignments/2/partA_red_black_trees/#5-mindepth-and-maxdepth","title":"5. <code>minDepth</code> and <code>maxDepth</code>","text":"<p>[5 points]</p> <p>Write the <code>minDepth</code> and <code>maxDepth</code> functions, which have these type signatures:</p> <pre><code>minDepth :: Tree a -&gt; Int\nmaxDepth :: Tree a -&gt; Int\n</code></pre> <p>These functions return the minimum and maximum depths of the tree, respectively. That is, <code>minDepth</code> is the smallest distance from the root node to a leaf, while <code>maxDepth</code> is the largest such distance. A tree which is just a <code>Leaf</code> (i.e. an empty tree) has depth 0. Recall that by \"distance\" to a leaf we mean the number of times you can go from a node to one of its branch nodes before you hit a leaf.</p>"},{"location":"assignments/2/partA_red_black_trees/#6-testinvariant1","title":"6. <code>testInvariant1</code>","text":"<p>[10 points]</p> <p>Write the <code>testInvariant1</code> function, which has this type signature:</p> <pre><code>testInvariant1 :: Ord a =&gt; Tree a -&gt; Bool\n</code></pre> <p>This function tests the order invariant. This invariant requires all nodes to have values that are strictly larger than all node values in the node's left subtree and strictly smaller than all node values in the node's right subtree. This function returns <code>True</code> if the tree obeys the invariant.</p> <p>Obviously, in this function the node colors are irrelevant. You probably want to write some helper functions to make this function easier to write.</p> <p>Your code should not be gratuitously inefficient. For instance, don't compare a node value against every single value in its left/right subtree, because that isn't necessary. Marks will be taken off for inefficient solutions. Doing it right isn't hard or tricky.</p>"},{"location":"assignments/2/partA_red_black_trees/#7-testinvariant2","title":"7. <code>testInvariant2</code>","text":"<p>[10 points]</p> <p>Write the <code>testInvariant2</code> function, which has this type signature:</p> <pre><code>testInvariant2 :: Tree a -&gt; Bool\n</code></pre> <p>This function tests the red invariant, which is that no red node has a red parent. Don't forget to use <code>_</code> for unused components of the <code>Node</code> constructor, as usual.</p> <p>Tip</p> <p>Nested pattern matches are extremely helpful here! With them, you can write this function in a few short lines of code. If you think you need to use a <code>case</code> statement, think again.</p> <p>You do not have to compare colors using the <code>==</code> or <code>/=</code> operators, so don't make <code>Color</code> an instance of the <code>Eq</code> type class or define a color comparison function.</p>"},{"location":"assignments/2/partA_red_black_trees/#8-testinvariant3","title":"8. <code>testInvariant3</code>","text":"<p>[10 points]</p> <p>Write the <code>testInvariant3</code> function, which has this type signature:</p> <pre><code>testInvariant3 :: Tree a -&gt; Bool\n</code></pre> <p>This function tests the black invariant, which is that all paths from the root of the tree down through a sequence of nodes to any leaf have the same number of black nodes.</p> <p>Note that the color of the root node is irrelevant (because it's present in all sequences) and the \"color\" of the leaf nodes are also irrelevant (because they are all the same).</p> <p>This function is a bit tricky, so here is a template for you to fill in:</p> <pre><code>testInvariant3 :: Tree a -&gt; Bool\ntestInvariant3 t = allEqual (leafCounts t 0)\n  where\n    -- Given a tree, return a list of the count of black nodes on every path\n    -- from the root of the tree to a leaf.\n    leafCounts :: Tree a -&gt; Int -&gt; [Int]\n    leafCounts Leaf n = [n]\n    leafCounts (Node Black left _ right) n = {- TODO -}\n    leafCounts (Node Red left _ right) n = {- TODO -}\n\n    -- Return True if all the elements of a list are equal.\n    allEqual :: Ord a =&gt; [a] -&gt; Bool\n    allEqual [] = True\n    allEqual [_] = True\n    allEqual (x:r@(y:_)) | x == y = allEqual r\n                         | otherwise = False\n</code></pre> <p>The code marked <code>{- TODO -</code>} is for you to fill in; please remove the <code>{- TODO -}</code> comments! The amount of code you need to add is quite small (one short line in each case).</p> <ol> <li> <p>You may have encountered this phenomenon in a CS 4 midterm exam.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/partB_sets/","title":"Part B: Implementing sets using red-black trees (25 points)","text":"<p>In this section, you will use the red-black tree implementation you wrote in the last section to build a reasonably featureful set implementation. All code for this section will still go into the file <code>RedBlackTree.hs</code>. Put it after the code for the red-black trees. (This isn't necessary for it to work, but it will make the code easier to read and grade.)</p> <p>If you don't know much about sets, the Wikipedia article contains everything you need to know for this section.<sup>1</sup></p> <p>This section of your code should start like this:</p> <pre><code>-- We define Set as a type synonym for Tree.\ntype Set a = Tree a\n\n-- Empty set.\nempty :: Set a\nempty = Leaf\n\n-- Convert a list to a set.\ntoSet :: Ord a =&gt; [a] -&gt; Set a\ntoSet = fromList\n</code></pre> <p>From this, we see that a <code>Set</code> is nothing more than an alias for a red-black tree. The empty set is just a <code>Leaf</code>, and the function <code>toSet</code> for converting a list to a set is just the <code>fromList</code> function on red-black trees.</p> <p>Now write the following set functions, using the red-black tree functions you defined above as needed. Every one of them can be written in a single line of code, so you will be penalized if your functions are much longer than this (pay attention to the hints!).</p> <p>Warning</p> <p>Don't write any of these functions by converting both set arguments to lists and then just using list operations. (Doing that will get you no marks for the function.) Also, don't import the <code>Data.List</code> module.</p> <p>For each problem in this section, we will allow you to convert one of the set arguments to a list using <code>toList</code> if you need to (which you may not).</p>"},{"location":"assignments/2/partB_sets/#1-issubset","title":"1. <code>isSubset</code>","text":"<p>[5 points]</p> <p>Write the <code>isSubset</code> function, which has this type signature:</p> <pre><code>isSubset :: Ord a =&gt; Set a -&gt; Set a -&gt; Bool\n</code></pre> <p>This function takes two sets as its arguments and returns <code>True</code> if the first one is a subset of the second (it doesn't have to be a proper subset)</p> <p>Hint</p> <p>Look up the <code>all</code> function on Hoogle.</p>"},{"location":"assignments/2/partB_sets/#2-eqset","title":"2. <code>eqSet</code>","text":"<p>[5 points]</p> <p>Write the <code>eqSet</code> function, which has this type signature:</p> <pre><code>eqSet :: Ord a =&gt; Set a -&gt; Set a -&gt; Bool\n</code></pre> <p>This function takes two sets as its arguments and returns <code>True</code> if the two sets are equal (i.e. if they have the same elements).</p> <p>Hint</p> <p>Define this in terms of <code>isSubset</code>.</p>"},{"location":"assignments/2/partB_sets/#3-union","title":"3. <code>union</code>","text":"<p>[5 points]</p> <p>Write the <code>union</code> function, which has this type signature:</p> <pre><code>union :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\n</code></pre> <p>This function takes two sets as its arguments and returns a new set which is the union of the input sets.</p> <p>Hint</p> <p>Convert one of the set arguments to a list and use <code>foldr</code>. If it's useful, write a skeleton for the function argument of <code>foldr</code> as <code>(\\x r -&gt; ...)</code>, where <code>x</code> is the current element of a list and <code>r</code> is the rest of the list after processing by <code>foldr</code>.</p>"},{"location":"assignments/2/partB_sets/#4-intersection","title":"4. <code>intersection</code>","text":"<p>[5 points]</p> <p>Write the <code>intersection</code> function, which has this type signature:</p> <pre><code>intersection :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\n</code></pre> <p>This function takes two sets as its arguments and returns a new set which is the intersection of the input sets. Fill in the following skeleton code to get the solution:</p> <pre><code>intersection :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\nintersection s1 s2 = foldr (\\x r -&gt; if ... then ... else ...) ... (toList s2)\n</code></pre>"},{"location":"assignments/2/partB_sets/#5-difference","title":"5. <code>difference</code>","text":"<p>[5 points]</p> <p>Write the <code>difference</code> function, which has this type signature:</p> <pre><code>difference :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\n</code></pre> <p>This function takes two sets as its arguments and returns a new set which is the set difference of the input sets, which means that it contains all elements of the first set that are not in the second set. Fill in the following skeleton code to get the solution:</p> <pre><code>difference :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a\ndifference s1 s2 = foldr (\\x r -&gt; if ... then ... else ...) ... (toList s1)\n</code></pre> <p>This is the same skeleton function we used above for <code>intersection</code>, and the contents of the function argument are also very similar.</p> <ol> <li> <p>Actually, it contains much more information than you need for this assignment.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/books/","title":"Books and other resources","text":"<p>CS 115 doesn't have an official textbook. However, some students like to have a book that they can refer to while they are learning Haskell. This can be used for a number of purposes:</p> <ul> <li>as a longer-form, gentler tutorial in the language;</li> <li>as a way to learn more advanced features of the language   than those we cover in this course;</li> <li>as a reference;</li> <li>or just for a different perspective on the same material.</li> </ul> <p>There are a number of good books and texts that have been written on Haskell. Some of these are a few years old, so they may not be usable with modern versions of GHC without some modifications, but these modifications are likely to be minor.</p> <p>Note</p> <p>This list is not comprehensive! There are other books on Haskell we haven't included here, mainly because we haven't gone over them in detail. If you find a book which is useful to you and which is not on this list, let us know and we'll add it!</p>"},{"location":"intro/books/#online-books","title":"Online books","text":"<ul> <li> <p>A Gentle Introduction to Haskell</p> <p>This is a classic (and fairly short) introduction to Haskell. It's definitely outdated; it refers to \"Haskell 98\", which means the version of Haskell from 1998. However, most of the material included is still valid.</p> </li> </ul>"},{"location":"intro/books/#textbooks","title":"Textbooks","text":"<p>These books are roughly ordered from easiest to hardest.</p> <ul> <li> <p>Get Programming with Haskell by Will Kurt </p> <p>I haven't read this book, but the reviews on Amazon are quite positive.</p> </li> <li> <p>Effective Haskell by Rebecca Skinner</p> <p>This is a new book which covers most of the material in CS 115, except for some of the more theoretical parts. It's very beginner-friendly and readable.</p> </li> <li> <p>Programming in Haskell, 2nd. edition by Graham Hutton</p> <p>This is a solid book by a well-known researcher and lecturer. He also has Haskell courses on YouTube which cover the same material.</p> </li> <li> <p>Haskell Programming from First Principles   by Christopher Allen and Julie Moronuki</p> <p>I haven't read this book, but it looks good. It's available from https://haskellbook.com/.</p> </li> <li> <p>Haskell, the Craft of Functional Programming, 3rd. edition   by Simon Thompson</p> <p>I learned Haskell from the first edition of this book. The third edition is greatly expanded, but it's quite readable and understandable.</p> </li> <li> <p>Learn You a Haskell For Great Good by Miran Lipovaca</p> <p>This is a good book which is available for free in its entirety at https://learnyouahaskell.github.io</p> </li> <li> <p>Thinking Functionally with Haskell by Richard Bird   and Algorithm Design with Haskell by Richard Bird and Jeremy Gibbons</p> <p>The late Richard Bird wrote a number of books on Haskell and functional programmming. Bird's primary emphasis is on how to use equational laws to transform code into more efficient forms. Although he restricts himself to fairly basic Haskell, his books are quite sophisticated and demanding. However, this material is difficult to find anywhere else. If you are willing to put in the effort, you will get a lot out of these books.</p> </li> </ul>"},{"location":"intro/books/#discussions","title":"Discussions","text":"<p>We recommend the Haskell Discourse server as a site for general Haskell discussions. Be aware, though, that some of the discussions cover advanced topics, so don't be surprised if you can't follow everything (yet).</p>"},{"location":"intro/papers/","title":"Interesting papers","text":"<p>A lot of interesting material about Haskell is first published in academic papers, and much of this hasn't found its way into textbooks yet. As a result, to become a really accomplished Haskell programmer, you are going to want to read these papers. Here is a selection of interesting papers that give additional insights into Haskell. Some of this material goes well beyond what we cover in CS 115.</p> <ul> <li> <p>A Gentle Introduction to Haskell 98, by Paul Hudak, John Peterson, and Joseph Fasel.</p> <p>This is a tutorial on the first \"standard\" version of Haskell: Haskell 98 (the \"98\" means the year 1998). It's a good introduction to the most basic aspects of Haskell, though some of it is obsolete. You can also read it here.</p> </li> <li> <p>Why Functional Programming Matters, by John Hughes.</p> <p>This is a classic paper, written before Haskell even existed. Its main topic is lazy evaluation, and how this allows a more modular style of programming where functions can be built up easily by composing other functions. The language used is Miranda, a precursor of Haskell, but it's easy to follow if you know Haskell.</p> </li> <li> <p>A History of Haskell: Being Lazy with Class, by Paul Hudak, John Hughes, Simon Peyton-Jones, and Philip Wadler.</p> <p>This is a historical survey of the development of Haskell up to 2007. The title is a play on words (\"lazy\" and \"class\" having specific meanings in Haskell) which is typical of many Haskell papers.</p> </li> <li> <p>Imperative Functional Programming, by Simon Peyton-Jones and Philip Wadler.</p> <p>This was the paper that introduced monads to Haskell.</p> </li> <li> <p>Monads for Functional Programming, by Philip Wadler.</p> <p>This is an in-depth discussion of monads in Haskell. Unusually for Phil Wadler, the title doesn't contain any puns.</p> </li> <li> <p>Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell, by Simon Peyton-Jones.</p> <p>This is a deep dive into how to use the <code>IO</code> monad and related constructs to allow Haskell to handle very non-functional kinds of programming.</p> </li> <li> <p>Lazy Functional State Threads, by John Launchbury and Simon Peyton-Jones.</p> <p>This paper introduced the <code>ST</code> monad, which allows you to perform imperative computations \"internally\" i.e. without having to move all your code into the <code>IO</code> monad. (We mention this in the lectures but don't go into detail.)</p> </li> <li> <p>Monadic Parser Combinators, by Graham Hutton and Erik Meijer.</p> <p>This paper introduced monadic parser combinators, which are one of the most-used ways of writing parsers in Haskell.</p> </li> <li> <p>Monadic Parsing in Haskell, by Graham Hutton and Erik Meijer.</p> <p>This is a shorter tutorial paper on parser combinators. </p> </li> <li> <p>Type Classes with Functional Dependencies, by Mark P. Jones.</p> <p>This paper introduced functional dependencies for type classes.</p> </li> <li> <p>Template Meta-programming for Haskell, by Tim Sheard and Simon Peyton-Jones.</p> <p>This paper introduced the template metaprogramming system in Haskell (called \"Template Haskell\") which is basically a macro system which allows you to do compile-time code generation.</p> </li> <li> <p>Why It's Nice to be Quoted: Quasiquoting for Haskell, by Geoffrey Mainland.</p> <p>This paper introduced quasiquoting, which is a way of making Template Haskell more useful by allowing you to do code generation in a much more natural manner.</p> </li> <li> <p>Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire, by Erik Meijer, Maarten Fokkinga, and Ross Paterson.</p> <p>This paper is not specifically about Haskell but about lazy functional programming as a whole. It develops a calculus of high-level operators which allow you to define functions in an amazingly concise manner. This is the most \"theoretical\" paper on this list, but it has been hugely influential.</p> </li> </ul>"},{"location":"intro/software/","title":"Installing the course software","text":""},{"location":"intro/software/#installing-the-ghc-compiler","title":"Installing the GHC compiler","text":"<p>In this course, we will be using the  Haskell programming language. Specifically, we will be using the GHC Haskell compiler. We also assume a certain level of familiarity with a (Unix-like) terminal, such as you would get in CS 1 or CS 4.</p> <p>The easiest way to install GHC is to use the ghcup installer. See the ghcup user guide for instructions on how to use it.</p> <p><code>ghcup</code> is a program intended to be run from a Unix-like terminal. If your computer runs any flavor of Linux or MacOS, you have direct access to such a terminal. If your computer runs Windows, you should install the  Windows Subsystem for Linux (WSL). Once this is done, you can run a Unix terminal on Windows and install <code>ghcup</code> on that.</p> <p>Note</p> <p>If you intend to use WSL, make sure you install the latest version! Early versions (e.g. version 1) do not work with GHC. In some cases, especially with older computers, installation will default to version 1, which will cause GHC installation to fail. In that case, contact the instuctor on Piazza.</p> <p>Also, once you have installed WSL, you can run it directly from the terminal embedded in Visual Studio Code, which we recommend for Windows users. Be sure not to select the Powershell terminal when starting a terminal; that isn't part of WSL.</p> <p>After installing GHC, you want to make sure you are running the latest version, which as of this writing is 9.8.2. To verify this, type this in a terminal:</p> <pre><code>$ ghc --version\n</code></pre> <p>You should see:</p> <pre><code>The Glorious Glasgow Haskell Compilation System, version 9.8.2\n</code></pre> <p>If you see a lower version number, you need to upgrade. In a terminal, enter these commands:</p> <pre><code>$ ghcup install ghc 9.8.2\n$ ghcup set ghc 9.8.2\n</code></pre> <p>This should install the latest version. Type</p> <pre><code>$ ghc --version\n</code></pre> <p>to verify that. If that doesn't work, see a TA or the instructor.</p> <p>You can also run</p> <pre><code>$ ghcup tui\n</code></pre> <p>to get a nice text user interface (TUI) which allows you to interactively upgrade all GHC software and tells you all the versions you've installed. This will work on MacOS, Linux, and (maybe) on Windows with WSL. It's not essential, but it is pleasant to use. Use the arrows to select items, type <code>i</code> to install an item, and type <code>s</code> to make the item the \"selected\" item (so entering <code>ghc</code> or <code>ghci</code> will get that version).</p> <p>Note</p> <p>You may have to adjust your terminal's <code>PATH</code> environment variable to include the location of the <code>ghc</code> and <code>ghci</code> programs. This is normally <code>$HOME/.ghcup/bin</code>.</p>"},{"location":"intro/software/#the-cabal-package-manager","title":"The <code>cabal</code> package manager","text":"<p>When you install GHC, the <code>cabal</code> package manager will be installed as well. <code>cabal</code> is for Haskell what <code>opam</code> is for OCaml. We will need <code>cabal</code> to install some code libraries. You can check the installation status of <code>cabal</code> using <code>ghcup tui</code> as described above. Make sure you install the most recent version.</p>"},{"location":"intro/software/#the-hls-language-server","title":"The <code>HLS</code> language server","text":"<p><code>ghcup</code> will also let you install the <code>HLS</code> language server. This is not essential, but if you are using Visual Studio Code as your editor, it will enable code completion and other IDE-like functionality. In this case, after starting VS Code you should also install the Haskell for Visual Studio Code extension to make best use of <code>HLS</code>.</p>"},{"location":"intro/software/#the-hoogle-documentation-browser","title":"The Hoogle documentation browser","text":"<p>When writing Haskell, your best friend is the Hoogle web site. This is a site which allows you to search the documentation of Haskell functions and modules. You can enter the name of a function, a module, or even a type signature (!) and find the relevant documentation (including source code) very easily. You should bookmark this site as long as you're using Haskell.</p>"},{"location":"intro/welcome/","title":"Welcome to CS 115!","text":"<p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about the material.  In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>interesting papers</li> </ul> <p>and anything else we consider useful. Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>lecture slides</li> <li>code supplied to students for assignments</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"intro/welcome/#instructor-and-course-staff","title":"Instructor and course staff","text":"<p>The course instructor is Mike Vanier (mvanier@cms.caltech.edu).</p> <p>The teaching assistants are listed in the syllabus. Their contact information will be posted on the course Piazza page.</p>"},{"location":"intro/welcome/#what-this-course-is-about","title":"What this course is about","text":"<p>This course is an introduction to lazy functional programming using the Haskell programming language. The prerequisite for taking this course is to have already taken CS 4 (which means that you know how to do functional programming in the OCaml language); this is therefore not a course for students who have never done functional programming before. In a sense, if CS 4 is the introductory functional programming course, this is the advanced functional programming course.</p> <p>This course exists for the following reasons.</p> <ul> <li> <p>Haskell is one of the best-known and most-used functional programming   languages in use today.</p> </li> <li> <p>Haskell has a unique evaluation model (lazy evaluation);   it is the only programming language in wide use that uses this   evaluation strategy.</p> </li> <li> <p>Haskell is a pure functional language, in contrast to OCaml,   which is impure (has non-functional features).   This has a number of interesting consequences.</p> </li> <li> <p>Haskell has a number of abstractions that are either not found   in other functional languages, or are not nearly as easy to use   in those languages.</p> </li> <li> <p>Haskell has some features (notably monads) which are notoriously   difficult for new Haskell programmers to learn;   this course will make it much easier for you to understand them.</p> </li> </ul> <p>You might think that having a different evaluation model is not very significant, but as we will see, it turns out to have very far-reaching effects on the way that we write functional code. Some ways of writing code in OCaml (e.g. tail recursion) are much less useful in Haskell, while other ways (e.g. function composition) are much more useful because of lazy evaluation.</p> <p>In general, programming in Haskell feels more \"high-level\" than programming in OCaml, and it's worth experiencing this to be able to make an informed judgment about which language is best suited for which tasks. Haskell is also very productive and great fun to program in!</p> <p>Note</p> <p>We don't want to take sides when comparing OCaml and Haskell. Both are excellent languages which have useful features the other doesn't.  OCaml has a much more powerful module system, while Haskell has many abstractions that OCaml lacks. Well-rounded functional programmers should know both languages.</p> <p>We hope you enjoy the course!</p>"}]}