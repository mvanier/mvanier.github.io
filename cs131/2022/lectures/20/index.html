<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- <section data-background-color="#ffffd0"> -->
          <section data-markdown>
            <textarea data-template>
# CS 131:<br/>Programming Languages
## _Lecture 20_:<br/>The _Nano-ML_ Language: Type inference

---
## Previously

* The _Nano-ML_ language
* Type inference
* Operational semantics of type checking

---
## Today

* How type inference works
* Principal types
* The method of type equality constraints
* Solving constraints

---
## The problem

* Operational semantics of _Nano-ML_ is _nondeterministic_

* This means that for some rules, many possible type assignments exist
  that would satisfy the rules

* We have to pick a _single_ type assignment, and it has to be the
  _best_ type assignment possible

* This is the job of _type inference_

---
## Principal types

* We will need to concept of _principal types_ to guide us in assigning types

* If a term has a type at all, it has a principal type

* A principal type is _at least as general_ as any other possible type of the
  term

---
## Principal types: definition

* A type $\tau_p$ is the _principal type_ of a term $e$ if and only if both:

  * $\Gamma \vdash e : \tau_p$  ($e$ can have type $\tau_p$)

  * $\forall \tau$ such that $\Gamma \vdash e : \tau$, $\tau <: \tau_p$
    <br/>(any type $\tau$ such that $\Gamma \vdash e : \tau$ is _more specific_
    than $\tau_p$)

---
## The $<:$ notation (types)

* We use the notation $\tau <: \tau_p$ to mean both

  * $\tau$ is an _instance_ of $\tau_p$

  * $\tau_p$ is _at least as general_ than $\tau$

* You get from $\tau_p$ to $\tau$ by _substituting_
  for the free type variables in $\tau_p$

---
## Types and type schemes

* In _Nano-ML_, we distinguish between _types_ and _type schemes_

* Types: no quantifiers ($\forall$) even though they may have type variables

* Type schemes: have quantifiers

  * "Empty" quantifiers allowed (_e.g._ $\forall . \text{int}$)

---
## Types and type schemes

* In _Nano-ML_, we distinguish between _types_ and _type schemes_

* Type environments $\Gamma$ bind _type schemes_, not types

  * Non-quantified type can still be bound using empty quantifier

---
## Types and type schemes

* In _Nano-ML_, we distinguish between _types_ and _type schemes_

* Non-quantified types also referred to as "monotypes"

* Quantified types referred to as "polytypes"

---
## The $<:$ notation<br/>(type schemes)

* This definition of $<:$ just given refers to _types_, not type _schemes_

* We can extend this to also make it refer to type schemes as well

* We say that $\sigma_i <: \sigma_g$ if you can get from $\sigma_g$ to
  $\sigma_i$ by substituting for some of the type variables in $\sigma_g$

---
## Principal type (scheme)

* Type scheme $\sigma_p$ is a _principal type_ of a term $e$
  in type environment $\Gamma$ if there is a derivation of

$$
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma\\{x \mapsto \sigma_p \\}
$$

* and whenever there is a type scheme $\sigma$ such that

$$
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma\\{x \mapsto \sigma \\}
$$

* then $\sigma <: \sigma_p$

---
## Types _vs._ principal types

* The `check_type` form only checks to see if an expression _can_
  have a particular type

  * The type doesn't have to be the most general type!

* Example:

<pre class="smaller"><code>(define k (x y) x)
;; Both unit tests pass:
(check-type k (forall ['a 'b] <em>('a 'b -&gt; 'a)</em>)) ; principal type
(check-type k (forall ['a 'a] <em>('a 'a -&gt; 'a)</em>)) ; less general
</code></pre>

---
## Types _vs._ principal types

* To be sure of the principal type, use `check-principal-type`:

<pre class="smaller"><code>(define k (x y) x)
(check-principal-type k (forall ['a 'b] <em>('a 'b -&gt; 'a)</em>)) ; pass
(check-principal-type k (forall ['a 'a] <em>('a 'a -&gt; 'a)</em>)) ; fail
</code></pre>

---
## Principal types and type inference

* The job of the type inference system is to:

  * find the principal type of each term

  * assign a principal type scheme to each bound name

---
## Type rules to type inference

* Some of the type rules of _Nano-ML_ are nondeterministic

---
## Type rules to type inference

* Some of the type rules of _Nano-ML_ are nondeterministic

* $\text{VAR}$ rule:

$$
\frac
{
\Gamma(x) = \sigma \quad \tau <: \sigma
}
{
\Gamma \vdash \text{VAR}(x) : \tau
}
$$

$$
\label{}\tag{Var}
$$

* Which instance of the type scheme $\sigma$ should we use as the type $\tau$?

---
## Type rules to type inference

* Some of the type rules of _Nano-ML_ are nondeterministic

* $\text{LAMBDA}$ rule:

$$
\frac
{
\Gamma\\{
x_1 \mapsto \tau_1, \dots,
x_n \mapsto \tau_n
\\} \vdash e : \tau
}
{
\Gamma \vdash \text{LAMBDA}(\langle
x_1, \dots, x_n
\rangle, e) : \tau_1 \times \cdots \times \tau_n \rightarrow \tau
}
$$

$$
\label{}\tag{Lambda}
$$

* What should the argument types $\tau_i$ be?
  * (No type annotations on arguments!)

---
## Type rules to type inference

* In order to assign types to terms and names, we need a deterministic
  algorithm

* We start by assigning fresh type variables $\alpha_i$ to all unknown types
  * "Fresh" means "not used anywhere else in the program"

* We will use contextual information to assign types to these fresh type
  variables

---
## Type rules to type inference

* Example: if a variable $x$ with unknown type $\alpha_i$ is added to $1$,
  then $\alpha_i$ must be `int`

* We would use this information to substitute `int` for $\alpha_i$

* There are two broad classes of algorithms that we can use to do type
  inference:

  * the method of _explicit substitutions_

  * the method of _type equality constraints_

---
## Substitutions

* Both methods involve finding appropriate _substitutions_ for type variables

* A substitution is a map between type variables and types

* Substitutions are denoted by $\theta$

* The goal of type inference is to compute substitutions

---
## The method of explicit substitutions

* Define a function `unify` such that:

  * `unify($\tau_1,\tau_2$)` returns a substitution $\theta$
     such that $\theta(\tau_1) = \theta(\tau_2)$

  * $\theta$ is called a _unifier_ of $\tau_1$ and $\tau_2$

* Different $\theta$s can be composed to implement type inference:

  * Given $\Gamma$ and $e$, find $\theta$ and $\tau$ such that
    $\theta \Gamma \vdash e : \tau$

---
## The method of explicit substitutions

* Advantages:

  * the "original" type inference method (Damas and Milner 1982)

  * easier to work with mathematically (_e.g._ to prove that type inference is
    consistent with nondeterministic type rules)

---
## The method of explicit substitutions

* Disadvantage:

  * Much trickier to write correct code that applies all substitutions in the
    right order!

* We won't use this method

---
## The method of type equality constraints

* We have types $\tau_1$ and $\tau_2$ that we want to be equal

* Instead of unifying them right away, we write down a _constraint_
  that they must be equal

* Constraints use the syntax $\tau_1 \sim \tau_2$, which we can read as
  "$\tau_1$ must equal $\tau_2$"

---
## The method of type equality constraints

* Constraints $C_1$ and $C_2$ can be combined
  using the logical AND operator ($\land$) to make bigger constraints
  ($C_1 \land C_2$)

* The $\land$ operator is associative and commutative, so the order of
  constraints doesn't matter

* We put constraints $C$ in type inference in judgments of the form
  $C, \Gamma \vdash e : \tau$

---
## The method of type equality constraints

* To turn type judgments with constraints into actual type judgments
  of the form $\Gamma \vdash e : \tau$, we need to compute a substitution
  $\theta$ that makes _all_ the constraints true

* We do this by writing a _constraint solver_, which is like a "super-`unify`"

* Constraint solvers are a bit tricky to write,
  but once that's done, type inference is easy!

---
## The method of type equality constraints

* Advantages:

  * The code is much easier to write and get correct

* Disadvantage:

  * Harder to write mathematical proofs of correctness

* We will use this method

---
## Overview of the method

* Convert type rules to use constraints

* Show how to combine constraints

* Introduce fresh type variables for unknown types

* Generalize types of names bound in type environments

* Show examples

* Show how to solve constraints to get substitutions

---
## Adding constraints to type rules

* Recall type rule for `if`:

$$
\frac
{
\Gamma \vdash e_1 : \text{bool}
\quad
\Gamma \vdash e_2 : \tau
\quad
\Gamma \vdash e_3 : \tau
}
{
\Gamma \vdash \text{IF}(e_1, e_2, e_3) : \tau
}
$$

$$
\label{}\tag{If}
$$

---
## Adding constraints to type rules

* This rule is implicitly saying these things:
  * The type of $e_1$ has to be $\text{bool}$
  * The types of $e_2$ and $e_3$ have to be the same

---
## Adding constraints to type rules

* Another way of describing this is in terms of _contraints_
  * The type of $e_1$ is $\tau_1$, and $\tau_1$ is _constrained_
    to be the same as $\text{bool}$
  * The types of $e_2$ and $e_3$ are _constrained_ to be the same

* We can express this mathematically as this constraint:
  $\tau_1 \sim \text{bool} \land \tau_2 \sim \tau_3$

---
## Constraint operators

* There are two constraint operators: $\sim$ and $\land$

* $\sim$ is used to express type equality:

  * $\tau_1 \sim \tau_2$ means that we need to find a substitution
    $\theta$ which makes $\tau_1$ and $\tau_2$ equal
    _i.e._ $\theta \tau_1 = \theta \tau_2$

---
## Constraint operators

* There are two constraint operators: $\sim$ and $\land$

* $\land$ is used to join two conjunctions to make a composite
  conjunction:

  * $C_1 \land C_2$ means that we need to find a substitution
    $\theta$ which satisfies _both_ the constraint $C_1$ and
    the constraint $C_2$

  * Conjunction of constraints is commutative and associative,
    as you'd expect

---
## Constraint operators

* There are two constraint operators: $\sim$ and $\land$

* Using $\sim$ and $\land$ we can build up arbitrarily complex
  constraints

---
## Constraint operators

* We also add a "trivial constraint" $\text{\bf T}$ which is
  always considered satisfied

* This simplifies the math and programming

* So our "constraint language" consists of these kinds of statements:

$$
C ::= \tau_1 \sim \tau_2 \\; | \\; C_1 \land C_2 \\; | \\; \text{\bf T}
$$

---
## Typing judgments with constraints

* Typing judgments used to look like this:

$$
\Gamma \vdash e : \tau
$$

* but now look like this:

$$
C, \Gamma \vdash e : \tau
$$

* If the constraint $C$ isn't needed, just use the trivial constraint
  $\text{\bf T}$

---
## Typing judgments with constraints

* In the typing judgment with constraints:

$$
\Gamma \vdash e : \tau
$$

* the _inputs_ to the type checker are the expression $e$ and the type
  environment $\Gamma$

* the _outputs_ from the type checker are the type $\tau$
  and the constraint $C$

---
## Typing judgments with constraints: example

* The $\text{IF}$ rule with constraints looks like this:

$$
\frac
{
C_1, \Gamma \vdash e_1 : \tau_1
\quad
C_2, \Gamma \vdash e_2 : \tau_2
\quad
C_3, \Gamma \vdash e_3 : \tau_3
}
{
C_1 \land C_2 \land C_3 \land
\tau_1 \sim \text{bool} \land
\tau_2 \sim \tau_3,
\Gamma \vdash \text{IF}(e_1, e_2, e_3) : \tau_2
}
$$

$$
\label{}\tag{If}
$$

* Note that all subexpressions have their own constraints $C_i$ that were used
  to establish their types $\tau_i$;
  these propagate to the conclusion

* New constraints: $\tau_1 \sim \text{bool}$, $\tau_2 \sim \tau_3$

---
## Typing judgments with constraints: example

* The $\text{IF}$ rule with constraints looks like this:

$$
\frac
{
C_1, \Gamma \vdash e_1 : \tau_1
\quad
C_2, \Gamma \vdash e_2 : \tau_2
\quad
C_3, \Gamma \vdash e_3 : \tau_3
}
{
C_1 \land C_2 \land C_3 \land
\tau_1 \sim \text{bool} \land
\tau_2 \sim \tau_3,
\Gamma \vdash \text{IF}(e_1, e_2, e_3) : \tau_2
}
$$

$$
\label{}\tag{If}
$$


* If all constraints are satisfied, then $\tau_1 = \text{bool}$ and
  $\tau_2 = \tau_3$, so the rule is equivalent to the original
  $\text{IF}$ rule

---
## Simpler notation for compound constraints

* We can define a shorthand notation for a bunch of type judgments
  with constraints:

$$
\frac{
C_1, \Gamma \vdash e_1 : \tau_1
\quad \cdots \quad
C_n, \Gamma \vdash e_n : \tau_n
}{
\color{#cc0000}
C_1 \land \cdots \land C_n, \Gamma \vdash
e_1, \ldots, e_n : \tau_1, \ldots, \tau_n
}
$$

* Often shorten $C_1 \land \ldots \land C_n$ to just $C$

$$
\label{}\tag{TypesOf}
$$

---
## Simpler notation for compound constraints

* With this, the $\text{IF}$ rule becomes:

$$
\frac
{
C, \Gamma \vdash e_1, e_2, e_3 : \tau_1, \tau_2, \tau_3
}
{
C \land
\tau_1 \sim \text{bool} \land
\tau_2 \sim \tau_3,
\Gamma \vdash \text{IF}(e_1, e_2, e_3) : \tau_2
}
$$

$$
\label{}\tag{If}
$$

---
## Another rule

* Here's the rule for function application:

$$
\frac{
C, \Gamma \vdash e, e_1, \ldots, e_n :
\hat{\tau}, \tau_1, \ldots, \tau_n
\quad \alpha \\; \text{is fresh}
}{
C \land \hat{\tau} \sim
\tau_1 \times \cdots \times \tau_n \rightarrow \alpha, \Gamma
\vdash
\text{APPLY}(e, e_1, \ldots, e_n)  : \alpha
}
$$

$$
\label{}\tag{Apply}
$$

---
## Example

* Let's infer the type for `(+ 1 2)`

* Assume this environment:

$$
\Gamma =
\{+ : \forall . \text{int} \times \text{int} \rightarrow \text{int} \}
$$

* (Note the empty $\forall$ on the $+$ function, since this function
  isn't polymorphic)

---
## Example

* The derivation looks like this, with $\alpha_1$ a fresh type variable:

$$
\cfrac{
\cfrac{}{\text{\bf T}, \Gamma \vdash \text{\tt +} :
\text{int} \times \text{int}
\rightarrow \text{int}}
\quad
\cfrac{}{\text{\bf T}, \Gamma \vdash \text{\tt 1} : \text{int}}
\quad
\cfrac{}{\text{\bf T}, \Gamma \vdash \text{\tt 2} : \text{int}}
}{
\text{\bf T} \land \text{\bf T} \land \text{\bf T} \land
\text{int} \times \text{int} \rightarrow \text{int} \sim
\text{int} \times \text{int} \rightarrow \alpha_1,
\Gamma \vdash \text{\tt (+ 1 2)} : \alpha_1
}
$$

* Substituting $\text{int}$ for $\alpha_1$ satisfies all
  constraints and gives a valid type derivation in the
  original type system

---
## Example

* The derivation looks like this, with $\alpha_1$ a fresh type variable:

$$
\cfrac{
\cfrac{}{\text{\bf T}, \Gamma \vdash \text{\tt +} :
\text{int} \times \text{int}
\rightarrow \text{int}}
\quad
\cfrac{}{\text{\bf T}, \Gamma \vdash \text{\tt 1} : \text{int}}
\quad
\cfrac{}{\text{\bf T}, \Gamma \vdash \text{\tt 2} : \text{int}}
}{
\text{\bf T} \land \text{\bf T} \land \text{\bf T} \land
\text{int} \times \text{int} \rightarrow \text{int} \sim
\text{int} \times \text{int} \rightarrow \alpha_1,
\Gamma \vdash \text{\tt (+ 1 2)} : \alpha_1
}
$$

* Therefore, the substitution $\theta$ that is needed to
  satisfy the constraints is
  $\theta = \\{\alpha_1 \mapsto \text{int}\\}$

---
## Converting nondeterministic type rules to use constraints

* Two rules for converting nondeterministic type rules to
  rules with constraints:

  1. If a type $\tau$ occurs in more than one place, give
     each place a separate name (like $\tau_2$ and $\tau_3$
     for the $\text{If}$ rule) and add constraints which
     force the names to be equal

---
## Converting nondeterministic type rules to use constraints

* Two rules for converting nondeterministic type rules to
  rules with constraints:

  2. If a type $\tau$ appears in the original rule
     and we don't know what it's supposed to be,
     use a fresh type variable (like $\alpha_1$ in the example)

---
## Converting nondeterministic type rules to use constraints

* The $\text{If}$ rule is an example of rule 1

* The $\text{Apply}$ rule is an example of rule 2

* Let's look at a better example of rule 2

---
## Converting nondeterministic type rules to use constraints

* The (nondeterministic) $\text{VAR}$ rule is as follows:

$$
\frac{
\Gamma(x) = \sigma
\hspace{0.2in}
\tau <: \sigma
}{
\Gamma \vdash \text{VAR}(x) : \tau
}
$$

* Recall: $\tau' <: \sigma$ when
  $\sigma = \forall \\; \alpha_1, \ldots, \alpha_n \\, . \\, \tau$
  and some (unknown) types are substituted for the
  type variables $\alpha_1, \ldots, \alpha_n$

---
## Converting nondeterministic type rules to use constraints

* We don't know what types to pick for the $\alpha$s, so we
  pick fresh type variables $\alpha_1', \ldots, \alpha_n'$

* The rule with constraints then becomes:

$$
\frac{
\begin{gather*}
\Gamma(x) = \forall \\; \alpha_1, \ldots, \alpha_n \\, . \\, \tau
\\\\
\alpha_1, \ldots, \alpha_n
\\; \text{are fresh and distinct}
\end{gather*}
}{
\text{\bf T}, \Gamma \vdash \text{VAR}(x) :
((\alpha_1 \mapsto \alpha_1')
\circ \cdots \circ
(\alpha_n \mapsto \alpha_n')) \tau
}
$$

---
## Converting nondeterministic type rules to use constraints

* In other words, pick fresh type variables for all quantified variables

* They will eventually be constrained by how $x$ is used

* Let's see another example!

---
## Converting nondeterministic type rules to use constraints

* We will infer the type of `(cons 1 nil)`

  * (Obviously, this should be `(list int)`)

* Let's write out the derivation...

---
## Converting nondeterministic type rules to use constraints

$$
\small
\cfrac{
\cfrac{
\Gamma(\text{\tt cons}) = \forall \alpha .
\alpha \times (\text{\tt list} \\; \alpha)
\rightarrow (\text{\tt list} \\; \alpha)
}{
\text{\bf T}, \Gamma \vdash \text{\tt cons} :
\alpha_1 \times (\text{\tt list} \\; \alpha_1)
\rightarrow (\text{\tt list} \\; \alpha_1)
}
\quad
\cfrac{}{
\text{\bf T}, \Gamma \vdash \text{\tt 1} : \text{\tt int}
}
\quad
\cfrac{}{
\text{\bf T}, \Gamma \vdash \text{\tt nil} :
(\text{\tt list} \\; \alpha_2)
}
}{
\begin{gather*}
\text{\bf T} \land \text{\bf T} \land
\alpha_1 \times (\text{\tt list} \\; \alpha_1) \rightarrow
(\text{\tt list} \\; \alpha_1)
\sim
\text{\tt int} \times (\text{\tt list} \\; \alpha_2) \rightarrow \alpha_3,
\\\\
\Gamma \vdash \text{\tt (cons 1 nil)} : \alpha_3
\end{gather*}
}
$$

---
## Converting nondeterministic type rules to use constraints

* We can simplify the constraint to:

$$
\alpha_1 \sim \text{\tt int} \land
(\text{\tt list} \\; \alpha_1) \sim (\text{\tt list} \\; \alpha_2) \land
(\text{\tt list} \\; \alpha_1) \sim \alpha_3
$$

* Solution?

---
## Converting nondeterministic type rules to use constraints

* We can simplify the constraint to:

$$
\alpha_1 \sim \text{\tt int} \land
(\text{\tt list} \\; \alpha_1) \sim (\text{\tt list} \\; \alpha_2) \land
(\text{\tt list} \\; \alpha_1) \sim \alpha_3
$$

* $\small \theta = \\{ \alpha_1 \mapsto \text{\tt int},
\alpha_2 \mapsto \text{\tt int},
\alpha_3 \mapsto \text{\tt (list int)} \\}$

---
## Converting nondeterministic type rules to use constraints

* We can simplify the constraint to:

$$
\alpha_1 \sim \text{\tt int} \land
(\text{\tt list} \\; \alpha_1) \sim (\text{\tt list} \\; \alpha_2) \land
(\text{\tt list} \\; \alpha_1) \sim \alpha_3
$$

* So the type of `(cons 1 nil)` is `(list int)`

---
## Generalization: inferring types for bound names

* Bound names should have a "type scheme", not a type
  (_i.e._ a quantified ($\forall$) type)

* Even names that are bound to non-quantified types
  like $\text{\tt int}$ will be bound to "empty"
  quantified types ($\forall \\, . \\, \text{\tt int}$)

---
## Generalization: inferring types for bound names

* Bound names should have a "type scheme", not a type
  (_i.e._ a quantified ($\forall$) type)

* Names with inferred types that include type variables
  must be _generalized_ to actual quantified types
  (_e.g._ $\alpha \rightarrow \alpha$ becomes
  $\forall \alpha \\, . \\, \alpha \rightarrow \alpha$)
  before they can be added to the type environment $\Gamma$

---
## Generalization: definition

* Recall the definition of the $\text{generalize}$ function from the last
  lecture:

$$
\text{generalize}(\tau, \mathcal{A}) =
\forall \alpha_1, \dots, \alpha_n \\, . \\, \tau,
\\\\
\text{where} \\; \\{
\alpha_1, \dots, \alpha_n
\\} =
\text{ftv}(\tau) - \mathcal{A}
$$

* And $\mathcal{A}$ is usually the free type variables of $\Gamma$
  <br/>($\text{ftv}(\Gamma)$)


---
## Generalization: `val` bindings

* This gives us the rule for top-level `val` bindings:

$$
\frac{
\begin{gather*}
C, \Gamma \vdash e : \tau
\\\\
\theta C \\; \text{is satisfied}
\quad
\theta \Gamma = \Gamma
\\\\
\sigma = \text{generalize}(\theta \tau, \text{ftv}(\Gamma))
\end{gather*}
}{
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma \\{x \mapsto \sigma \\}
}
$$

---
## Generalization: `val` bindings

* This gives us the rule for top-level `val` bindings:

$$
\frac{
\begin{gather*}
C, \Gamma \vdash e : \tau
\\\\
\theta C \\; \text{is satisfied}
\quad
\theta \Gamma = \Gamma
\\\\
\sigma = \text{generalize}(\theta \tau, \text{ftv}(\Gamma))
\end{gather*}
}{
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma \\{x \mapsto \sigma \\}
}
$$

* Interpretation:

---
## Generalization: `val` bindings

* This gives us the rule for top-level `val` bindings:

$$
\frac{
\begin{gather*}
C, \Gamma \vdash e : \tau
\\\\
\theta C \\; \text{is satisfied}
\quad
\theta \Gamma = \Gamma
\\\\
\sigma = \text{generalize}(\theta \tau, \text{ftv}(\Gamma))
\end{gather*}
}{
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma \\{x \mapsto \sigma \\}
}
$$

* Typecheck $e$ in type environment $\Gamma$, giving type $\tau$
   and constraint $C$

---
## Generalization: `val` bindings

* This gives us the rule for top-level `val` bindings:

$$
\frac{
\begin{gather*}
C, \Gamma \vdash e : \tau
\\\\
\theta C \\; \text{is satisfied}
\quad
\theta \Gamma = \Gamma
\\\\
\sigma = \text{generalize}(\theta \tau, \text{ftv}(\Gamma))
\end{gather*}
}{
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma \\{x \mapsto \sigma \\}
}
$$

* Choose a substitution $\theta$ such that $\theta C$ is satisfied,
  making sure that $\theta$ doesn't affect free type variables of
  $\Gamma$ (this is called _solving_ $C$)

---
## Generalization: `val` bindings

* This gives us the rule for top-level `val` bindings:

$$
\frac{
\begin{gather*}
C, \Gamma \vdash e : \tau
\\\\
\theta C \\; \text{is satisfied}
\quad
\theta \Gamma = \Gamma
\\\\
\sigma = \text{generalize}(\theta \tau, \text{ftv}(\Gamma))
\end{gather*}
}{
\langle
\text{VAL}(x, e), \Gamma
\rangle
\rightarrow
\Gamma \\{x \mapsto \sigma \\}
}
$$

* Generalize the type $\theta \tau$ to get the type scheme $\sigma$;
  this becomes the type of $x$ in a new type environment
  $\Gamma \\{x \mapsto \sigma \\}$

---
## Generalization: example

* Let's walk through type inference for this definition:

<pre><code>(val singleton (lambda (x) (cons x nil)))
</code></pre>

* Naively, what type would you expect this to have?

---
## Generalization: example

* Let's walk through type inference for this definition:

<pre><code>(val singleton (lambda (x) (cons x nil)))
</code></pre>

* Answer:

<pre><code>(forall ('a) ('a -&gt; (list 'a)))
</code></pre>

* In math:

$$
\forall \alpha \\, . \\,
  \alpha \rightarrow (\text{\tt list} \\, \alpha)
$$

---
## Generalization: example

* Let's walk through type inference for this definition:

<pre><code>(val singleton (lambda (x) (cons x nil)))
</code></pre>

* We haven't shown a rule for `lambda`, but the `lambda` body will be
  checked in the type environment $\Gamma$ extended with a binding for
  `x` to a fresh type variable _e.g._
  $\Gamma' = \Gamma \\{ x \mapsto \forall \\, . \\, \alpha_1 \\}$

---
## Generalization: example

* Here is the derivation of the `lambda` part:

$$
\tiny
\cfrac{
\cfrac{
\cfrac{
\Gamma'(\text{\tt cons}) =
\forall \alpha \\, . \\, \alpha \times (\text{\tt list} \\; \alpha)
\rightarrow (\text{\tt list} \\; \alpha)
}{
\text{\bf T}, \Gamma' \vdash \text{\tt cons} :
\alpha_2 \times (\text{\tt list} \\; \alpha_2) \rightarrow
(\text{\tt list} \\; \alpha_2)
}
\quad
\cfrac{
\Gamma'(x) = \forall \\, . \\, \alpha_1
}{
\text{\bf T}, \Gamma' \vdash x : \alpha_1
}
\quad
\cfrac{
\Gamma'(\text{\tt nil}) =
\forall \alpha \\, . \\, (\text{\tt list} \\; \alpha)
}{
\text{\bf T}, \Gamma' \vdash \text{\tt nil} :
(\text{\tt list} \\; \alpha_3)
}
}{
\alpha_2 \times (\text{\tt list} \\; \alpha_2) \rightarrow
(\text{\tt list} \\; \alpha_2)
\sim
\alpha_1 \times (\text{\tt list} \\; \alpha_3) \rightarrow
\alpha_4,
\Gamma' \vdash \text{\tt (cons x nil)} : \alpha_4
}
}{
\alpha_2 \times (\text{\tt list} \\; \alpha_2) \rightarrow
(\text{\tt list} \\; \alpha_2)
\sim
\alpha_1 \times (\text{\tt list} \\; \alpha_3) \rightarrow
\alpha_4,
\Gamma \vdash \text{\tt (lambda (x) (cons x nil))} :
\alpha_1 \rightarrow \alpha_4
}
$$

* The resulting constraint equation is:

$$
\alpha_2 \times (\text{\tt list} \\; \alpha_2) \rightarrow
(\text{\tt list} \\; \alpha_2)
\sim
\alpha_1 \times (\text{\tt list} \\; \alpha_3) \rightarrow
\alpha_4
$$

---
## Generalization: example

* The resulting constraint equation is:

$$
\alpha_2 \times (\text{\tt list} \\; \alpha_2) \rightarrow
(\text{\tt list} \\; \alpha_2)
\sim
\alpha_1 \times (\text{\tt list} \\; \alpha_3) \rightarrow
\alpha_4
$$

* This simplifies to:

$$
\alpha_2 \sim \alpha_1 \land
(\text{\tt list} \\; \alpha_2) \sim
(\text{\tt list} \\; \alpha_3) \land
(\text{\tt list} \\; \alpha_2)
\sim \alpha_4
$$

* which can be further simplified to:

$$
C =
\alpha_2 \sim \alpha_1 \land
\alpha_2 \sim \alpha_3 \land
(\text{\tt list} \\; \alpha_2)
\sim \alpha_4
$$

---
## Generalization: example

* This constraint equation:

$$
C =
\alpha_2 \sim \alpha_1 \land
\alpha_2 \sim \alpha_3 \land
(\text{\tt list} \\; \alpha_2)
\sim \alpha_4
$$

* has the (non-unique) solution:

$$
\theta = \\{ \alpha_1 \rightarrow \alpha_2,
\alpha_3 \rightarrow \alpha_2,
\alpha_4 \rightarrow (\text{\tt list} \\, \alpha_2) \\}
$$

* which gives the `lambda` part the type:

$$
\alpha_2 \rightarrow (\text{\tt list} \\, \alpha_2)
$$

---
## Generalization: example

* Generalizing, the name `singleton` is bound to:

$$
\text{\tt singleton} :
\forall \alpha_2 \\, . \\,
\alpha_2 \rightarrow (\text{\tt list} \\, \alpha_2)
$$

* which we prefer to write more simply as:

$$
\text{\tt singleton} :
\forall \alpha \\, . \\,
\alpha \rightarrow (\text{\tt list} \\, \alpha)
$$

* which is the type we expected

* This gets added to the type environment $\Gamma$

---
## Unsolvable constraints

* If a constraint cannot be solved, that means the term being type-checked has
  no valid type

* Example: `(lambda (x) (cons x x))`

* Let's try to give it a type

---
## Unsolvable constraints

* Start with the term `(lambda (x) (cons x x))`

* Assume that:

---
## Unsolvable constraints

* Start with the term `(lambda (x) (cons x x))`

* Assume that:

  * we will add `x` to the type environment $\Gamma$ with the monotype
    $\forall \\; . \\; \alpha_1$

---
## Unsolvable constraints

* Start with the term `(lambda (x) (cons x x))`

* Assume that:

  * `cons` is in $\Gamma$ with the polytype<br/>
    $\forall \alpha \\; . \\; \alpha \times (\text{\tt list} \\; \alpha)
    \rightarrow (\text{\tt list} \\; \alpha)$

---
## Unsolvable constraints

* Start with the term `(lambda (x) (cons x x))`

* Assume that:

  * we instantiate `cons` with the monotype
    $\alpha_2 \times (\text{\tt list} \\; \alpha_2)
    \rightarrow (\text{\tt list} \\; \alpha_2)$

---
## Unsolvable constraints

* Start with the term `(lambda (x) (cons x x))`

* Assume that:

  * we assign the type variable $\alpha_3$ to the return type of the
    `lambda`

---
## Unsolvable constraints

* The type inference engine will derive a judgment like this:

$$
\alpha_2 \times (\text{\tt list} \\; \alpha_2)
\rightarrow (\text{\tt list} \\; \alpha_2)
\sim
\alpha_1 \times \alpha_1
\rightarrow \alpha_3, \newline
\Gamma \vdash \text{\tt (lambda (x) (cons x x))} :
\alpha_1 \rightarrow \alpha_3
$$

* which simplifies to:

$$
\alpha_2 \sim \alpha_1 \land
(\text{\tt list} \\; \alpha_2) \sim \alpha_1 \land
(\text{\tt list} \\; \alpha_2) \sim \alpha_3
$$

---
## Unsolvable constraints

$$
\alpha_2 \sim \alpha_1 \land
(\text{\tt list} \\; \alpha_2) \sim \alpha_1 \land
(\text{\tt list} \\; \alpha_2) \sim \alpha_3
$$

* We can satisfy the first and last constraints by
  setting:
  * $\alpha_3$ equal to $(\text{\tt list} \\; \alpha_2)$
  * $\alpha_1$ equal to $\alpha_2$

* which leaves us with:

$$
(\text{\tt list} \\; \alpha_2) \sim \alpha_2
$$

---
## Unsolvable constraints

* This constraint:

$$
(\text{\tt list} \\; \alpha_2) \sim \alpha_2
$$

* cannot be solved, so the original term<br/>
  `(lambda (x) (cons x x))`<br/>has no type

---
## Unsolvable constraints

* The type checker would report this as a type error, _e.g._

<pre><code>&gt;&gt;&gt; (val selfcons (lambda (x) (cons x x)))
<em>type error: cannot make 'a equal to (list 'a)</em>
</code></pre>

---
## Adding extra constraints

* We can also _add_ extra constraints to a rule, as long as the
  added constraints have a solution

* This is described by this rule:

$$
\frac{
C_i, \Gamma \vdash e_i : \tau_i
\quad
C\\; \text{has a solution}
}{
C \land C', \Gamma \vdash e_i : \tau_i
}
$$

$$
\label{}\tag{Overconstrained}
$$

---
## Generalizing `let` bindings

* The hardest part of constraint-based type inference is dealing with
  generalization at a `let` binding

* The problem: the type inference engine determines a type $\tau$
  (not a type scheme $\sigma$) for an expression $e$ that is bound
  in a `let` expression to a name $x$ _e.g._<br/>
  `(let ((x $e$)) ...)`

---
## Generalizing `let` bindings

* But in type environments $\Gamma$, we can't bind "raw" types
  $\tau$; we can only bind _type schemes_ $\sigma$

* The type scheme $\sigma$ should be a _generalization_ of
  the type $\tau$

  * (like `nil` may have the type $\alpha \rightarrow \alpha$
  but it will be stored in the type environment $\Gamma$
  as $\forall \alpha \\, . \\, \alpha \rightarrow \alpha$)

---
## Generalizing `let` bindings

* **_NOTE_**: generalization can/should occur at a `let` binding
  but does _not_ occur for a function argument!

  * function arguments are required to be monotypes, as we've discussed

  * (Yes, this is complicated stuff!)

* Question: what is the right way to generalize at a `let` binding
  from the computed monotype $\tau$ to a polytype $\sigma$?

---
## Generalizing `let` bindings

* At a `let` binding _e.g._ the `(x e)` part of<br/>
  `(let ((x e)) ...)`:

* The type checker will take in:
  * a type environment $\Gamma$
  * an expression $e$

* and return:
  * a type $\tau$
  * a constraint $C$

---
## Generalizing `let` bindings

* Before we type check the body of the `let`, we have to
  add a binding for `x` to the type environment $\Gamma$

* We want to generalize the type $\tau$ of `x`
  as much as possible so we have the most powerful
  type system

* How do we do this?

---
## Generalizing `let` bindings

* The algorithm:

  * type check $e$ in type environment $\Gamma$,
    giving type $\tau$ and constraint $C$

  * solve $C$ to get a substitution $\theta$

  * apply $\theta$ to $\tau$ to get $\theta \tau$,
    which still may have type variables

  * ...

---
## Generalizing `let` bindings

* The algorithm:

  * ...

  * compute a new constraint $C'$ which contains
    the substitutions in $C$ that apply to the
    free type variables in $\Gamma$ only

  * generalize $\theta \tau$ on all type variables
    _except_ those that are free in $\Gamma$ and $C'$
    to get a type scheme $\sigma$

  * ...

---
## Generalizing `let` bindings

* The algorithm:


  * ...

  * add $\sigma$ to the type environment $\Gamma$
    when type checking the body of the `let`

---
## Generalizing `let` bindings

* Of course, in an actual `let` expression, we may
  have to do this for many bindings simultaneously

* The algorithm is the same

---
## Generalizing `let` bindings

* This is fairly involved stuff, but the idea is that
  you can't generalize over type variables which are already
  fixed in $\Gamma$ or which are free in the new
  constraint $C'$

* If you follow this algorithm, the type scheme $\sigma$
  will be the most general type possible for that binding

---
## Generalizing `let` bindings

* In math:

$$
\small
\frac{
\begin{gather*}
C, \Gamma \vdash e_1, \ldots, e_n : \tau_1, \ldots, \tau_n
\newline
\theta C \\; \text{is satisfied}  % (also \theta is idempotent)
\newline
C' = \bigwedge \\{
\alpha \sim \theta \alpha \mid
\alpha \in \text{dom} \\; \theta \cap \text{ftv}(\Gamma)
\\}
\newline
\sigma_i = \text{generalize}(\theta \tau_i,
\text{ftv}(\Gamma) \cup \text{ftv}(C')),
\quad 1 \leq i \leq n
\newline
C_b, \Gamma \\{
x_1 \mapsto \sigma_1, \ldots,
x_n \mapsto \sigma_n
\\} \vdash e : \tau
\end{gather*}
}{
C' \land C_b, \Gamma \vdash
\text{LET}(
\langle
x_1, e_1, \ldots, x_n, e_n
\rangle, e) : \tau
}
$$

$$
\label{}\tag{Let}
$$

* _N.B._ the big $\bigwedge$ is an AND over multiple terms

---
## Generalizing `let` bindings

* In math:

$$
\small
\frac{
\begin{gather*}
C, \Gamma \vdash e_1, \ldots, e_n : \tau_1, \ldots, \tau_n
\newline
\theta C \\; \text{is satisfied}  % (also \theta is idempotent)
\newline
C' = \bigwedge \\{
\alpha \sim \theta \alpha \mid
\alpha \in \text{dom} \\; \theta \cap \text{ftv}(\Gamma)
\\}
\newline
\sigma_i = \text{generalize}(\theta \tau_i,
\text{ftv}(\Gamma) \cup \text{ftv}(C')),
\quad 1 \leq i \leq n
\newline
C_b, \Gamma \\{
x_1 \mapsto \sigma_1, \ldots,
x_n \mapsto \sigma_n
\\} \vdash e : \tau
\end{gather*}
}{
C' \land C_b, \Gamma \vdash
\text{LET}(
\langle
x_1, e_1, \ldots, x_n, e_n
\rangle, e) : \tau
}
$$

$$
\label{}\tag{Let}
$$

* $C_b$ is the constraint for the `let` body $e$

---
## Generalizing `letrec` bindings

* Here's the corresponding rule for `letrec`:

$$
\small
\frac{
\begin{gather*}
\color{#aa0000}
\Gamma' = \Gamma \\{
x_1 \mapsto \alpha_1,
\ldots,
x_n \mapsto \alpha_n
\\},
\\; \text{where all $\alpha_i$\\ are distinct and fresh}
\newline
\color{#aa0000}
C_r, \Gamma' \vdash e_1, \ldots, e_n : \tau_1, \ldots, \tau_n
\newline
\color{#aa0000}
C = C_r \land \tau_1 \sim \alpha_1 \land \ldots \land
\tau_n \sim \alpha_n
\newline
\theta C \\; \text{is satisfied}  % (also \theta is idempotent)
\newline
C' = \bigwedge \\{
\alpha \sim \theta \alpha \mid
\alpha \in \text{dom} \\; \theta \cap \text{ftv}(\Gamma)
\\}
\newline
\sigma_i = \text{generalize}(\theta \tau_i,
\text{ftv}(\Gamma) \cup \text{ftv}(C')),
\quad 1 \leq i \leq n
\newline
C_b, \Gamma \\{
x_1 \mapsto \sigma_1, \ldots,
x_n \mapsto \sigma_n
\\} \vdash e : \tau
\end{gather*}
}{
C' \land C_b, \Gamma \vdash
\text{LETREC}(
\langle
x_1, e_1, \ldots, x_n, e_n
\rangle, e) : \tau
}
$$

$$
\label{}\tag{LetRec}
$$

---
## Generalizing `letrec` bindings

* `letrec` rule is actually less "magical" than the nondeterministic rule

* Differences between `let` and `letrec`:

  * For each of the bound variables $x_i$, pick a fresh type variable
    $\alpha_i$

  * Extend the type environment $\Gamma$ to
    $\Gamma' =
    \Gamma \\{ x_1 \mapsto \alpha_1, \ldots, x_n \mapsto \alpha_n \\}$

---
## Generalizing `letrec` bindings

* `letrec` rule is actually less "magical" than the nondeterministic rule

* Differences between `let` and `letrec`:


  * Evaluate the bound expressions $e_i$ in $\Gamma'$, giving
    types $\tau_i$ and constraint $C_r$

  * Create a constraint $C$ from $C_r$ and all the type constraints
    $\tau_i \sim \alpha_i$

* Everything else is the same as with `let`

---
## Generalizing `letrec` bindings

* _N.B._ the constraint system and the fresh type variables
  $\alpha_i$ are serving the same purpose for _type-checking_
  `letrec` as the "unspecified" values in _$\mu$Scheme_ did
  in _evaluating_ `letrec`

---
## Example of `let` generalization

* Let's see how to type check this form:

<pre><code>(val ss
  (lambda (y)
    (let ([single (lambda (x) (cons x nil))])
      (single (single y)))))
</code></pre>

* The type we expect is:

<pre><code>ss : (forall ('a) ('a -&gt; (list (list 'a))))
</code></pre>

* (We'll skip a few steps to keep it to a reasonable length)

---
## Example of `let` generalization

* Assume that the body of the outer `lambda` is type checked
  in this environment:

$$
\Gamma = \\{
\text{\tt cons} :
\forall \alpha \\;. \\; \alpha \times
(\text{\tt list} \\; \alpha)
\rightarrow
(\text{\tt list} \\; \alpha),
\text{\tt y} : \alpha_1
\\}
$$

* `cons` type is part of the global type environment

* `y` type is assigned during type checking

---
## Example of `let` generalization

* This leads to this constraint corresponding to
  type checking of `(cons x nil)`:

$$
\small
C =
\alpha_{2} \times (\text{\tt list} \\; \alpha_{2})
\rightarrow (\text{\tt list} \\; \alpha_{2}) \sim
\alpha_{3} \times (\text{\tt list} \\; \alpha_{4})
\rightarrow \alpha_{5}
$$

* where: 
  * $\alpha_2$, $\alpha_{3}$, $\alpha_{4}$ and $\alpha_{5}$ :
    fresh type variables
  * `cons` : $\alpha_{2} \times (\text{\tt list} \\; \alpha_{2})
    \rightarrow (\text{\tt list} \\; \alpha_{2})$
  * `x` : $\alpha_{3}$, &nbsp; `nil` : $(\text{\tt list} \\; \alpha_{4})$
  * `(cons x nil)` : $\alpha_{5}$

---
## Example of `let` generalization

* This leads to:

$$
C, \Gamma \vdash
\text{\tt (lambda (x) (cons x nil))} :
\alpha_{3} \rightarrow \alpha_{5}
$$

* since $\alpha_3$ is the type of `x`
  and $\alpha_5$ is the type of `(cons x nil)`

---
## Example of `let` generalization

* These are the inputs to the $\text{LET}$ rule:

$$
\small
\begin{align*}
C &= \alpha_{2} \times (\text{\tt list} \\; \alpha_{2})
\rightarrow (\text{\tt list} \\; \alpha_{2})
\sim
\alpha_{3} \times (\text{\tt list} \\; \alpha_{4})
\rightarrow \alpha_{5}
\newline
\tau_1 &= \alpha_{3} \rightarrow \alpha_{5}
\newline
\theta &= \\{
\alpha_{3} \mapsto \alpha_{2}, \\;
\alpha_{4} \mapsto \alpha_{2}, \\;
\alpha_{5} \mapsto (\text{\tt list} \\; \alpha_{2})
\\}
\newline
C' &= \bigwedge \\{ \\; \\} = \text{\bf T}
\newline
\text{ftv}(\Gamma) &= \\{ \alpha_{1} \\}
\newline
\sigma_1 &=
\text{generalize}(\alpha_{2} \rightarrow
(\text{\tt list} \\; \alpha_{2}) , \\,
\text{ftv}(\Gamma)) =
\forall \alpha_{2} \\; . \\; \alpha_{2}
\rightarrow
(\text{\tt list} \\; \alpha_{2})
\end{align*}
$$

<div class="smaller">

* So `single` is bound to the polytype
  $\forall \alpha_{2} \\; . \\; \alpha_{2}
   \rightarrow
   (\text{\tt list} \\; \alpha_{2})$
  or just
  $\forall \alpha \\; . \\; \alpha
   \rightarrow
   (\text{\tt list} \\; \alpha)$

</div>

---
## Example of `let` generalization

* We therefore extend the type environment $\Gamma$ to

$$
\Gamma_e = \Gamma \\{
\text{\tt single} :
\forall \alpha \\; . \\; \alpha
\rightarrow
(\text{\tt list} \\; \alpha)
\\}
$$

* We use this function twice in the body of the `let`:
  `(single (single y))`
  * each time with a different type of argument,
    so we need the polytype

---
## Example of `let` generalization

* Here's the derivation of the type of<br/>
  `(single (single y))`:

$$
\tiny
\cfrac{
\cfrac{
\Gamma_e(\text{\tt single}) =
\forall \alpha \\; . \\;
\alpha \rightarrow (\text{\tt list} \\; \alpha)
}{
\text{\bf T}, \Gamma_e \vdash
\text{\tt single} :
\alpha_{7} \rightarrow (\text{\tt list} \\; \alpha_{7})
}
\quad
\cfrac{
\cfrac{
\Gamma_e(\text{\tt single}) : \forall \alpha \\; . \\;
\alpha \rightarrow (\text{\tt list} \\; \alpha)
}{
\text{\bf T}, \Gamma_e \vdash
\text{\tt single} :
\alpha_{6} \rightarrow (\text{\tt list} \\; \alpha_{6})
}
\quad
\cfrac{
\Gamma_e(\text{\tt y}) : \forall \\, . \\, \alpha_{1}
}{
\text{\bf T}, \Gamma_e \vdash \text{\tt y} : \alpha_{1}
}
}{
\alpha_{6} \rightarrow (\text{\tt list} \\; \alpha_{6}) \sim
\alpha_{1} \rightarrow \alpha_{8}, \\; \Gamma_e \vdash
\text{\tt (single y)} : \alpha_{8}
}
}{
\begin{gather*}
\alpha_{7} \rightarrow (\text{\tt list} \\; \alpha_{7})
\sim
\alpha_{8} \rightarrow \alpha_{9}
\\; \land
\alpha_{6} \rightarrow (\text{\tt list} \\; \alpha_{6})
\sim
\alpha_{1} \rightarrow \alpha_{8},
\\; \Gamma_e \vdash
\text{\tt (single (single y))} : \alpha_{9}
\end{gather*}
}
$$

* $\alpha_9$ is also the type of the `let` expression as a whole,
  with input type environment $\Gamma$

* So the type of the outer `lambda` is
  $\alpha_1 \rightarrow \alpha_9$, since `y` has type
  $\alpha_1$ and the `let` has type $\alpha_9$

---
## Example of `let` generalization

* The final constraint (which is $C' \land C_b$ in the
  conclusion of the $\text{LET}$ rule) is:

$$
\text{\bf T} \land
\alpha_{7} \rightarrow
(\text{\tt list} \\; \alpha_{7}) \sim
\alpha_{8} \rightarrow \alpha_{9} \land
\alpha_{6} \rightarrow (\text{\tt list} \\; \alpha_{6}) \sim
\alpha_{1} \rightarrow \alpha_{8}
$$

* Note that $C'$ is $\text{\bf T}$, so we can ignore that to get:

$$
\alpha_{7} \rightarrow
(\text{\tt list} \\; \alpha_{7}) \sim
\alpha_{8} \rightarrow \alpha_{9} \land
\alpha_{6} \rightarrow (\text{\tt list} \\; \alpha_{6}) \sim
\alpha_{1} \rightarrow \alpha_{8}
$$

* This constraint is equivalent to:

$$
\alpha_{7} \sim \alpha_{8} \land
(\text{\tt list} \\; \alpha_{7}) \sim \alpha_{9} \land
\alpha_{6} \sim \alpha_{1} \land
(\text{\tt list} \\; \alpha_{6}) \sim \alpha_{8}
$$

---
## Example of `let` generalization

* The constraint:

$$
\alpha_{7} \sim \alpha_{8} \land
(\text{\tt list} \\; \alpha_{7}) \sim \alpha_{9} \land
\alpha_{6} \sim \alpha_{1} \land
(\text{\tt list} \\; \alpha_{6}) \sim \alpha_{8}
$$

* is solved by this substitution:

$$
\small
\theta =
\\{
\alpha_{7} \mapsto (\text{\tt list} \\;\alpha_{1}), \\,
\alpha_{9} \mapsto (\text{\tt list} \\;\alpha_{7}), \\,
\alpha_{6} \mapsto \alpha_{1}, \\,
\alpha_{8} \mapsto (\text{\tt list} \\;\alpha_{6})
\\}
$$

* This can be simplified to:

$$
\small
\theta =
\\{
\alpha_{7} \mapsto (\text{\tt list} \\;\alpha_{1}), \\,
\alpha_{9} \mapsto
(\text{\tt list} \\; (\text{\tt list} \\;\alpha_{1})), \\,
\alpha_{6} \mapsto \alpha_{1}, \\,
\alpha_{8} \mapsto (\text{\tt list} \\;\alpha_{1})
\\}
$$

---
## Example of `let` generalization

* The type of the outer `lambda` is thus

$$
\alpha_1 \rightarrow
(\text{\tt list} \\; (\text{\tt list} \\; \alpha_{1}))
$$

* At the `val` binding, this monotype is generalized to the 
  polytype:

$$
\forall \alpha_1 \\; . \\;
\alpha_1 \rightarrow
(\text{\tt list} \\; (\text{\tt list} \\; \alpha_{1}))
$$

* or more simply:

$$
\forall \alpha \\; . \\;
\alpha \rightarrow
(\text{\tt list} \\; (\text{\tt list} \\; \alpha))
$$

---
## Example of `let` generalization

* Compare this type:

$$
\forall \alpha \\; . \\;
\alpha \rightarrow
(\text{\tt list} \\; (\text{\tt list} \\; \alpha))
$$

* to the predicted type:

<pre><code>ss : (forall ('a) ('a -&gt; (list (list 'a))))
</code></pre>

* They are identical modulo notation!
  * (Whew!)

---
## Take a break!

* Time to take a break and relax those mental muscles
  before covering our last topic &#9786;

---
## Solving the constraints

* Eventually, type inference reduces to a set of constraints that have to be
  solved

* Now we describe how to solve these constraints

---
## Satisfying the constraints

* What "satisfying" constraints means can be described by these equations:

$$
\frac{}{\text{{\bf T} is satisfied}}
$$

$$
\\
$$

$$
\frac{\tau_1 = \tau_2}{\tau_1 \sim \tau_2 \\; \text{is satisfied}}
$$

$$
\\
$$

$$
\frac{C_1 \\; \text{is satisfied} \hspace{0.2in} C_2 \\; \text{is satisfied}}
{C_1 \land C_2 \\; \text{is satisfied}}
$$

---
## Solving the constraints

* We solve a constraint by finding a substitution $\theta$ which, when applied
  to a constraint, gives a constraint that is satisfied

* Applying a substitution to a constraint is described by these rules:

$$
\theta(\tau_1 \sim \tau_2) = \theta\tau_1 \sim \theta\tau_2
$$

$$
\theta(C_1 \land C_2) = \theta C_1 \land \theta C_2
$$

$$
\theta \text{\bf T} = \text{\bf T}
$$

---
## Solving the constraints

* If $\theta C$ is satisfied, $\theta$ solves the constraint $C$

* Some constraints can't be satisfied, _e.g._
  * $\text{int} \sim \text{bool}$
  * $\alpha \sim (\text{list } \alpha)$

---
## Constraint solver

* A _constraint solver_ is a function which takes as its input a constraint $C$
  and outputs a substitution $\theta$ which solves $C$ (if one exists)

$$
csolve(C) = \theta
$$

---
## Constraint solver: cases

* Three cases:

  * $C = \text{\bf T}$, in which case $\theta_I$ solves $C$<br/>
    ($\theta_I$ is the identity substitution which leaves everything
    the same)

  * $C = C_1 \land C_2$, in which case both $C_1$ and $C_2$ must be solved

  * $C$ is a simple equality constraint between types of the form
    $\tau_1 \sim \tau_2$

---
## Constraint solver: cases

* Three cases:

  * $C = \text{\bf T}$, in which case $\theta_I$ solves $C$<br/>
    ($\theta_I$ is the identity substitution which leaves everything
    the same)

  * $C = C_1 \land C_2$, in which case both $C_1$ and $C_2$ must be solved

  * $C$ is a simple equality constraint between types of the form
    $\tau_1 \sim \tau_2$

* Case 1 is trivially solvable

---
## Constraint solver: cases

* Three cases:

  * $C = \text{\bf T}$, in which case $\theta_I$ solves $C$<br/>
    ($\theta_I$ is the identity substitution which leaves everything
    the same)

  * $C = C_1 \land C_2$, in which case both $C_1$ and $C_2$ must be solved

  * $C$ is a simple equality constraint between types of the form
    $\tau_1 \sim \tau_2$

* Cases 2 and 3 require specific algorithms

---
## Constraint solver: conjunctions

* Important fact: if $\theta_1 C_1$ is satisfied,
  then $\theta_2 (\theta_1 C_1)$ is satisfied for any $\theta_2$
  * also known as "satisfaction is preserved by substitution"

---
## Constraint solver: conjunctions

* For the case $C = C_1 \land C_2$, you might think that you could
  * find a substitution $\theta_1$ that solves $C_1$
  * find a substitution $\theta_2$ that solves $C_2$
  * compose them to get $\theta_2 \circ \theta_1$ which would solve $C$

* Unfortunately, this doesn't work!

---
## Constraint solver: conjunctions

* This doesn't work because we're applying $\theta_1$ to $C_2$ before
  $\theta_2$ gets a chance to act on it!

* Therefore, the real algorithm is:
  * find a substitution $\theta_1$ that solves $C_1$
  * find a substitution $\theta_2$ that solves $\theta_1 C_2$
  * compose them to get $\theta_2 \circ \theta_1$ which would solve $C$

---
## Constraint solver: conjunctions

* This can be expressed as an inference rule:

$$
\frac{
\theta_1 C_1 \\; \text{is satisfied}
\hspace{0.3in}
\theta_2 (\theta_1 C_2) \\; \text{is satisfied}
}{
(\theta_2 \circ \theta_1) (C_1 \land C_2) \\; \text{is satisfied}
}
$$

---
## Constraint solver: conjunctions

* This is also an algorithm:

  * Call $csolve(C_1)$ to get $\theta_1$
  * Call $csolve(\theta_1 C_2)$ to get $\theta_2$
  * Then $csolve(C_1 \land C_2)$ is $\theta_2 \circ \theta_1$

---
## Constraint solver: type equality constraints

* The last thing to do is solve "simple" equality constraints between types
  _i.e._ constraints of the form $\tau_1 \sim \tau_2$

---
## Constraint solver: type equality constraints

* Types ($\tau$) can be any of:

---
## Constraint solver: type equality constraints

* Types ($\tau$) can be any of:

  * Type variables ($\alpha$)

---
## Constraint solver: type equality constraints

* Types ($\tau$) can be any of:

  * Type constructors: ($\mu$)
    * includes `int`, `bool`, `unit` as well as `list`, `pair`
    * also includes `function` and `args` for constructing
      function types

---
## Constraint solver: type equality constraints

* Types ($\tau$) can be any of:

  * Constructor application $\tau (\tau_1, \tau_2, \ldots \tau_n)$
  * _N.B._ a function type is a special case of constructor application:
    $\text{function} (\tau_f, \text{args} (\tau_1, \tau_2, \ldots \tau_n))$
  * Function types are written this way to make constraint solving easier
    (fewer cases!)

---
## Constraint solver: type equality constraints

* To solve $\tau_1 \sim \tau_2$ we must find a substitution $\theta$
  such that $\theta \tau_1 = \theta \tau_2$

* Each type $\tau$ can be one of three forms: type variable, type constructor,
  or constructor application

* Total of 9 cases in all!

* Let's go through them

---
## Constraint solver: type equality constraints

* Case 1: $\tau_1$ is a type variable $\alpha$

* Plausible substitution: $\theta = (\alpha \mapsto \tau_2)$
  so $\theta(\tau_1) = \theta(\alpha) = \tau_2$

* We need to check if $\alpha$ occurs free in $\tau_2$
  (called an "occurs check")

---
## Constraint solver: type equality constraints

* If $\alpha$ doesn't occur free in $\tau_2$, this works,
  since $\theta(\alpha) = \theta(\tau_2) = \tau_2$

* If $\tau_2 = \alpha$, it also works

* If $\alpha$ _does_ occur free in $\tau_2$ but isn't $\alpha$,
  the constraint can't be solved
  (_e.g._ $\alpha \sim (\text{list } \alpha)$)

---
## Constraint solver: type equality constraints

* Case 2: $\tau_2$ is a type variable

* Just flip $\tau_1$ and $\tau_2$ and solve; the $\sim$
  relation is symmetric

---
## Constraint solver: type equality constraints

* Otherwise, both sides are either type constructors or
  type constructor applications

---
## Constraint solver: type equality constraints

* Otherwise, both sides are either type constructors or
  type constructor applications

* If one side is a type constructor and the other is a
  constructor application, the constraint is unsolvable
  (_e.g._ $\mu_1 \sim \mu_2 (\tau_1, \ldots)$ has no solutions)

---
## Constraint solver: type equality constraints

* Otherwise, both sides are either type constructors or
  type constructor applications

* If both sides are type constructors
  (_e.g._ $\mu_1 \sim \mu_2$), then it's trivially solvable
  (using the identity substitution $\theta_I$)
  iff $\mu_1 = \mu_2$ and unsolvable otherwise

---
## Constraint solver: type equality constraints

* Last case: both sides are type constructor applications

* If the constructors have different numbers of arguments,
  the constraint is unsolvable

* Otherwise, create a conjunction of constraints:
  * one for the type constructors...
  * one for each of the type constructor arguments...

* ...and solve that constraint!

---
## Constraint solver: type equality constraints

* In math:

$$
\\
$$

$$
\frac{
\theta(
\tau \sim \tau' \land \tau_1 \sim \tau_1' \land \ldots \land \tau_n \sim \tau_n'
)
\\;
\text{is satisfied}
}{
\theta(
\text{CONAPP}(\tau, \langle \tau_1, \ldots \tau_n \rangle)
\sim
\text{CONAPP}(\tau', \langle \tau_1', \ldots \tau_n' \rangle)
)
\\;
\text{is satisfied}
}{
}
$$

---
## Constraint solver: type equality constraints

* In code:

  * Start from the constraint on the bottom of the equation

  * Break it down / rearrange it to form the constraint on the
    top of the equation

  * Pass this to the constraint solver to get the appropriate
    substitution

---
## Constraint solver: type equality constraints

* Overall, solving constraints is relatively straightforward using pattern
  matching and recursion

---
## Summing up

* Type inference therefore involves:

  * Converting type rules to use constraints

  * Solving constraints to produce substitutions

  * Using substitutions to compute principal types

  * Generalizing principal types to compute principal
    type schemes for bound names

---
## Summing up

* We can see that type inference is nontrivial!

* However, without it, programming in a language with a polymorphic
  type system is not feasible

* With type inference, code is easy to write in a "natural" style

* Downside: some types can't be expressed
  * at least, not without adding annotations!

            </textarea>
          </section>
      </div>
    </div>
    <script src="plugin/math/math.js"></script>
    <script src="dist/reveal.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <!-- Uncomment if you want syntax highlighting. -->
    <!--
    <link rel="stylesheet" href="plugin/highlight/arduino-light.css">
    -->
    <style>
/* MCV: My new reveal.js styles. */

.reveal {
  font-family: "Arial", sans-serif;
  font-size: 28pt;
  font-weight: normal;
  color: #000; 
}

.reveal .slide-number {
  background: white;
  /* border: 1px solid black; */
}

.reveal .slide-number-a {
  background: white;
  color: black;
  font-size: 24px;
}

.reveal .slides h1 {
  text-align: center;
  text-transform: none;
  padding: 150px 0 20px 0;
  font-size: 64pt;
  font-family: Gill Sans MT, Gill Sans, Calibri, sans-serif;
  font-weight: normal;
  color: #4f271c;
  background: #d0d0f0;
  margin-bottom: 0.5em;
}

.reveal h2 { 
  text-transform: none;
  font-family: Gill Sans MT, Gill Sans, Calibri, sans-serif !important;
  /* text-shadow: 2px 2px 3px #a0a0a0; */
  color: #4f271c !important;
  font-size: 60pt !important;
  font-weight: normal !important;
  /* background: #d0d0d0; */
  width: 80% !important;
  margin-left: 10%;
}

/* First level bullet color. */
.reveal .slides ul li::marker {
  color: #3891a7;
}

/* Second level bullet spacing. */
.reveal .slides ul li ul {
  margin-top: 0px;
}

.reveal .slides li {
  margin-top: 10px;
}

/* Second level bullet color. */
.reveal .slides ul li ul li::marker {
  color: #3891a7;
}

.reveal li {
  font-size: 36pt !important;
}

.reveal .smaller li {
  font-size: 32pt !important;
}

.reveal li ul li {
  font-size: 32pt !important;
}

.reveal li .smaller ul li {
  font-size: 28pt !important;
}

.reveal ul {
  width: 80% !important;
  text-align: left !important;
}

.reveal code em {
  color: #800000 !important;
  font-style: italic !important;
  font-weight: bold !important;
}

.reveal em code {
  color: #800000 !important;
  font-style: italic !important;
  font-weight: bold !important;
}

.reveal code .comment {
  color: #cc44cc !important;
  font-style: italic !important;
  font-weight: normal !important;
}

.reveal blockquote {
  text-align: left !important;
  color: #668888 !important;
}

.katex-display > .katex {
  color: #0040b0 !important;
}

.katex-display > .katex > .katex-html > .tag {
  color: #808080 !important;
  margin-right: 100px !important;
}

.katex > .katex-html {
  color: #0040b0 !important;
  padding-left: 5px;
  padding-right: 5px;
}

.katex {
  font-size: 1.1em !important;
}

.reveal pre {
  margin-left: 200px !important;
  width: 75% !important;
  font-size: 24pt !important;
}

.reveal pre.smaller {
  font-size: 20pt !important;
}

.reveal code {
  color: #0040b0 !important;
  font-size: 90%;
}

.reveal pre code {
  /* max vertical size of code block */
  max-height: 700px !important;
}

.reveal li ul li code {
  font-size: 80%;
}

    </style>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        katex: {
          version: 'latest',
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
          macros: {
            "\\eqref": "\\href{###1}{(\\text{#1})}",
            "\\ref": "\\href{###1}{\\text{#1}}",
            "\\label": "\\htmlId{#1}{}",
          },
        },
        plugins: [ 
          RevealMarkdown,
          // RevealHighlight,
          RevealMath.KaTeX,
        ],
        center: false,
        controls: false,
        disableLayout: false,  // set to true to use custom CSS for layout
        showSlideNumber: 'all',
        slideNumber: true,
        transition: 'none',
        width: 1280,
        height: 800,
      });
    </script>
  </body>
</html>
