<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- <section data-background-color="#ffffd0"> -->
          <section data-markdown>
            <textarea data-template>
# CS 131:<br/>Programming Languages
## _Lecture 11_:<br/>The _$\mu$Scheme+_ Language:<br/>The Code, part 2

---
## Today

* The _$\mu$Scheme+_ language:<br/>finish the walkthrough of the code
* Specifically, go through the `eval_val_in_frame` function

---
## Recap

* _$\mu$Scheme+_ is _$\mu$Scheme_ extended with "control operators"
  * `break` and `continue`
  * `throw` and `try-catch`
  * `return`

* Adding control operators requires us to change our evaluator
  to use a stack of "contexts"

* Each "context" represents a partially-evaluated expression

---
## Previously...

* The difference between _$\mu$Scheme_ and<br/>_$\mu$Scheme+_
  is the `eval_expr` function

---
## Previously...

* `eval_expr` dispatches to `eval_item`,
  which can evaluate expressions or values:

  * Expressions are dispatched to the `reduce_expr` function (last lecture),
    which may push new frames onto the context stack

  * Values are dispatched to `eval_val_in_frame`,
    unless the context stack is empty,
    in which case the value is returned

---
## Today

* We will walk through the `eval_val_in_frame` function
* This function is where evaluated values
  are put back into the "holes" in frames
* Sometimes, this is sufficient to complete evaluation
* Otherwise, evaluation continues with _e.g._
  another subexpression from the frame

---
## `eval_val_in_frame`

* The `eval_val_in_frame` function has this structure:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ... (* different frame constructor cases *)
</code></pre>

---
## `eval_val_in_frame`

* The `eval_val_in_frame` function has this structure:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ... (* different frame constructor cases *)
</code></pre>

* The `frame` argument was the top frame of the context stack,
  so it's the "current" frame
---
## `eval_val_in_frame`

* The `eval_val_in_frame` function has this structure:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ... (* different frame constructor cases *)
</code></pre>

* The `context` argument is the rest of the context stack
---
## `eval_val_in_frame`

* The `eval_val_in_frame` function has this structure:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ... (* different frame constructor cases *)
</code></pre>

* The `v` argument is a value which is the result of a previous evaluation
---
## `eval_val_in_frame`

* The `eval_val_in_frame` function has this structure:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ... (* different frame constructor cases *)
</code></pre>

* What we need to do is to:
  * pick out what kind of frame `frame` is
  * combine it with the value `v` to continue/complete evaluation

---
## `SetFrame`

* If the frame is a `SetFrame`,
  we have a partially evaluated `set` expression

* We know the name and the value to set, so we can complete the evaluation

---
## `SetFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    | <em>SetFrame (l, var)</em> -&gt;
      begin
        match v with
          | ... (* check for unspecified value (error) *)
          | _ -&gt;
            begin
              Env.set l env var v;
              (Value UnitVal, env, context)
            end
      end
    ...
</code></pre>

---
## `SetFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    | SetFrame (l, var) -&gt;
      begin
        match v with
          | <em>... (* check for unspecified value (error) *)</em>
          | _ -&gt;
            begin
              Env.set l env var v;
              (Value UnitVal, env, context)
            end
      end
    ...
</code></pre>

* Can't set an unspecified value (from evaluating `letrec`)
  in a `set` expression

---
## `SetFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    | SetFrame (l, var) -&gt;
      begin
        match v with
          | ... (* check for unspecified value (error) *)
          | _ -&gt;
            begin
              <em>Env.set l env var v;</em>
              <em>(Value UnitVal, env, context)</em>
            end
      end
    ...
</code></pre>

* Update the environment `env`, return `#u`

---
## `IfFrame`

* An `IfFrame` represents an `if` expression
  where the test subexpression has been evaluated to the value `v`

* The `IfFrame` stores the "then" and "else" expressions,
  so pick out the right one to continue evaluation

---
## `IfFrame`

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>IfFrame (l, then_branch, else_branch)</em> -&gt;
      if Env.truthy l v then
        (Expr then_branch, env, context)
      else
        (Expr else_branch, env, context)
    ...
</code></pre>
---
## `IfFrame`

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | IfFrame (l, then_branch, else_branch) -&gt;
      if <em>Env.truthy l v</em> then
        (Expr then_branch, env, context)
      else
        (Expr else_branch, env, context)
    ...
</code></pre>

* Test `v` for "truthiness"
---
## `IfFrame`

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | IfFrame (l, then_branch, else_branch) -&gt;
      if Env.truthy l v then
        <em>(Expr then_branch, env, context)</em>
      else
        (Expr else_branch, env, context)
    ...
</code></pre>

* If `v` is "true", evaluate `then_branch`
---
## `IfFrame`

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | IfFrame (l, then_branch, else_branch) -&gt;
      if Env.truthy l v then
        (Expr then_branch, env, context)
      else
        <em>(Expr else_branch, env, context)</em>
    ...
</code></pre>

* If `v` is "false", evaluate `else_branch`

---
## `WhileFrame`

* A `WhileFrame` is put on the stack
  when a `while` expression is evaluating its test expression

---
## `WhileFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>WhileFrame (l, test, body)</em> -&gt;
      let lt = loc_of_expr test in
        if truthy lt v then
          let context' =
            stack_push l
              (WhileRunningBodyFrame (l, test, body))
              context
          in
            (Expr body, env, context')
        else
          (Value UnitVal, env, context)
    ...
</code></pre>
---
## `WhileFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | WhileFrame (l, test, body) -&gt;
      let lt = loc_of_expr test in
        if <em>truthy lt v</em> then
          let context' =
            stack_push l
              (WhileRunningBodyFrame (l, test, body))
              context
          in
            (Expr body, env, context')
        else
          (Value UnitVal, env, context)
    ...
</code></pre>

* If the test expression evaluates to a true value...
---
## `WhileFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | WhileFrame (l, test, body) -&gt;
      let lt = loc_of_expr test in
        if truthy lt v then
          <em>let context' =</em>
            <em>stack_push l</em>
              <em>(WhileRunningBodyFrame (l, test, body))</em>
              <em>context</em>
          <em>in</em>
            <em>(Expr body, env, context')</em>
        else
          (Value UnitVal, env, context)
    ...
</code></pre>

* ...push a `WhileRunningBodyFrame` onto the stack
  and evaluate the body expression
---
## `WhileFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | WhileFrame (l, test, body) -&gt;
      let lt = loc_of_expr test in
        if truthy lt v then
          let context' =
            stack_push l
              (WhileRunningBodyFrame (l, test, body))
              context
          in
            (Expr body, env, context')
        else
          <em>(Value UnitVal, env, context)</em>
    ...
</code></pre>

* Otherwise, just return `#u`

---
## `WhileRunningBodyFrame`

* We're not done with `while` expressions yet!

---
## `WhileRunningBodyFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>WhileRunningBodyFrame (l, test, body)</em> -&gt;
      let context' =
        stack_push l (WhileFrame (l, test, body)) context
      in
        (Expr test, env, context')
    ...
</code></pre>

* Once the body expression has been evaluated to a value...

---
## `WhileRunningBodyFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | WhileRunningBodyFrame (l, test, body) -&gt;
      let context' =
        <em>stack_push l (WhileFrame (l, test, body)) context</em>
      in
        (Expr test, env, context')
    ...
</code></pre>

* ...discard the value and restart the `while` loop
  by pushing a `WhileFrame` onto the stack...

---
## `WhileRunningBodyFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | WhileRunningBodyFrame (l, test, body) -&gt;
      let context' =
        stack_push l (WhileFrame (l, test, body)) context
      in
        <em>(Expr test, env, context')</em>
    ...
</code></pre>

* ...and evaluate the test expression again

---
## `WhileRunningBodyFrame`

* `WhileRunningBodyFrame` has one other important feature:
  * It has to be on the stack when a `break` or `continue` executes!
  * (Also need to check that you don't `break`/`continue`
    through a function call boundary)

---
## `BeginFrame`

* When `begin` expressions are evaluated,
  a `BeginFrame` is pushed onto the stack,
  containing all the unevaluated expressions in the `begin`
* When the `BeginFrame` has no more expressions, return the value `v`
* Otherwise, discard the value `v` and continue evaluating the `begin`

---
## `BeginFrame`

* The code is quite simple:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>BeginFrame (_, [])</em> -&gt; (Value v, env, context)
    | <em>BeginFrame (l, e :: es)</em> -&gt;
      let context' = stack_push l (BeginFrame (l, es)) context
      in (Expr e, env, context')
    ...
</code></pre>

---
## More complex frames

* We've shown the code for all the "simple" frame types
  * (other than the ones you'll be implementing yourself)

* Now we have to look at the more involved cases

---
## `ApplyFrame`

<div class="smaller">

* When a function call is evaluated,
  the function expression is evaluated first
  and the rest of the arguments
  are pushed on to the stack as an `ApplyFrame`,
  which has this structure:

<pre><code>  ApplyFrame of loc * value list * expr list
</code></pre>

* The `value list` part are the arguments (including the function)
  which have already been evaluated,
  and the `expr list` are the unevaluated arguments

</div>

---
## `ApplyFrame`

* The simplest case is when all the arguments
  (including the function) have been evaluated
* Then we just apply the function to its arguments

---
## `ApplyFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>ApplyFrame (l, values_so_far, rest)</em> -&gt;
      begin
        match <em>rest</em> with
          | <em>[]</em> -&gt;
            begin
              let vs      = List.rev (v :: values_so_far) in
              let f       = List.hd vs in
              let actuals = List.tl vs in
                <em>eval_call l f actuals env context</em>
            end
          | e :: remaining -&gt; ...
      end
</code></pre>

---
## `ApplyFrame`

* _N.B._ the value list is accumulated in reverse order,
  so it needs to be reversed again
  before applying the function to its arguments

* The actual evaluation of the function is in the `eval_call` function
  * (Need `eval_call` because functions can be either
    primitive or user-defined)

---
## `ApplyFrame`

* Otherwise:
  * we add the currently-evaluated value `v`
    to the previously-evaluated values list

  * we remove the head of the unevaluated expressions list

---
## `ApplyFrame`

* Otherwise:
  * we create a new `ApplyFrame` frame from the new values list
    and the new unevaluated expressions list

  * we wrap the head of the unevaluated expressions list
    in an `Expr` constructor and return it for evaluation

---
## `ApplyFrame`

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>ApplyFrame (l, values_so_far, rest)</em> -&gt;
      begin
        match rest with
          | [] -&gt; ...
          | <em>e :: remaining</em> -&gt;
            let context' =
              stack_push l
                <em>(ApplyFrame (l, v :: values_so_far, remaining)</em>)
                context
            in
              <em>(Expr e, env, context')</em>
      end
</code></pre>

---
## `eval_call`

* `eval_call` checks to see what kind of function it is,
  and dispatches accordingly:

<pre class="smaller"><code>let <em>eval_call l f actuals env context</em> =
  match f with
    | <em>PrimFuncVal f</em> -&gt; ...
    | <em>UserFuncVal (formals, body, fenv)</em> -&gt; ...
    | other -&gt; Error.type_err l
                 ~expected: "function"
                 ~found: (string_of_value other)
</code></pre>

---
## `eval_call`

* Primitive functions are just applied to their arguments:

<pre class="smaller"><code>let eval_call l f actuals env context =
  match f with
    | <em>PrimFuncVal f -&gt; (Value (f l actuals), env, context)</em>
    | UserFuncVal (formals, body, fenv) -&gt; ...
    | other -&gt; ...
</code></pre>

---
## `eval_call`

* User functions are more complicated:

<pre class="smaller"><code>    | PrimFuncVal f -&gt; ...
    | <em>UserFuncVal (formals, body, fenv)</em> -&gt;
      let context' =
        push_env_frame l (CallEnvFrame env) context in
        if List.length formals &lt;&#8203;&gt; List.length actuals then
          Error.call_err l
            ~expected: (List.length formals)
            ~found: (List.length actuals)
        else
          let fenv' = bind_all fenv
            (List.combine formals actuals)
          in
            (Expr body, fenv', context')
    | other -&gt; ...
</code></pre>

---
## `eval_call`

<pre class="smaller"><code>    | PrimFuncVal f -&gt; ...
    | UserFuncVal (formals, body, <em>fenv</em>) -&gt;
      let context' =
        push_env_frame l (CallEnvFrame env) context in
        if List.length formals &lt;&#8203;&gt; List.length actuals then
          Error.call_err l
            ~expected: (List.length formals)
            ~found: (List.length actuals)
        else
          let fenv' = bind_all fenv
            (List.combine formals actuals)
          in
            (Expr body, fenv', context')
    | other -&gt; ...
</code></pre>

* `fenv` is the environment stored with the user function

---
## `eval_call`

<pre class="smaller"><code>    | PrimFuncVal f -&gt; ...
    | UserFuncVal (formals, body, fenv) -&gt;
      let context' =
        <em>push_env_frame l (CallEnvFrame env) context</em> in
        if List.length formals &lt;&#8203;&gt; List.length actuals then
          Error.call_err l
            ~expected: (List.length formals)
            ~found: (List.length actuals)
        else
          let fenv' = bind_all fenv
            (List.combine formals actuals)
          in
            (Expr body, fenv', context')
    | other -&gt; ...
</code></pre>

* Push environment `env` so we can restore it later

---
## `eval_call`

<pre class="smaller"><code>    | PrimFuncVal f -&gt; ...
    | UserFuncVal (formals, body, fenv) -&gt;
      let context' =
        push_env_frame l (CallEnvFrame env) context in
        <em>if List.length formals &lt;&#8203;&gt; List.length actuals then</em>
          <em>Error.call_err l</em>
            <em>~expected: (List.length formals)</em>
            <em>~found: (List.length actuals)</em>
        else
          let fenv' = bind_all fenv
            (List.combine formals actuals)
          in
            (Expr body, fenv', context')
    | other -&gt; ...
</code></pre>

* Check the number of arguments

---
## `eval_call`

<pre class="smaller"><code>    | PrimFuncVal f -&gt; ...
    | UserFuncVal (formals, body, fenv) -&gt;
      let context' =
        push_env_frame l (CallEnvFrame env) context in
        if List.length formals &lt;&#8203;&gt; List.length actuals then
          Error.call_err l
            ~expected: (List.length formals)
            ~found: (List.length actuals)
        else
          <em>let fenv' = bind_all fenv</em>
            <em>List.combine formals actuals)</em>
          in
            (Expr body, fenv', context')
    | other -&gt; ...
</code></pre>

* Create a new environment

---
## `eval_call`

<pre class="smaller"><code>    | PrimFuncVal f -&gt; ...
    | UserFuncVal (formals, body, fenv) -&gt;
      let context' =
        push_env_frame l (CallEnvFrame env) context in
        if List.length formals &lt;&#8203;&gt; List.length actuals then
          Error.call_err l
            ~expected: (List.length formals)
            ~found: (List.length actuals)
        else
          let fenv' = bind_all fenv
            (List.combine formals actuals)
          in
            <em>(Expr body, fenv', context')</em>
    | other -&gt; ...
</code></pre>

* Evaluate the body in that environment

---
## `CallEnvFrame`

* We saw that before evaluating the body of a function,
  and before creating a new environment in which to evaluate that body...

* A `CallEnvFrame` with the old environment
  gets pushed onto the context stack

---
## `CallEnvFrame`

* When evaluated in `eval_val_in_frame`,
  the old environment replaces the current one:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>CallEnvFrame env' -&gt; (Value v, env', context)</em>
    ...
</code></pre>

---
## `LetFrame`

* Next, we look at `let` expressions

* Two kinds of frames are involved:
  * `LetFrame`
  * `LetEnvFrame`

---
## `LetFrame`

* `let` evaluation breaks down into these steps:
  * Evaluate all binding expressions
  * Create a new environment
  * Evaluate the `let` body
  * Restore the old environment

---
## `LetFrame`

* A `LetFrame` is used for the first two steps

---
## `LetFrame`

* Recall the definition of the `let_frame` type:

<pre><code>type let_frame = {
  evaled_bindings   : (id * value) list;
  current_binding   : id;
  unevaled_bindings : (id * expr) list;
  body              : expr
}
</code></pre>

* This contains everything except one of the binding expressions,
  which is assumed to be currently evaluating
* A `LetFrame` just wraps a `let_frame` value
  (with a `loc` in case errors occur)

---
## `LetFrame`

* Here is a skeleton of the `LetFrame` code in `eval_val_in_frame`:

<pre class="smaller"><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>LetFrame (l, { evaled_bindings;</em>
                     <em>current_binding;</em>
                     <em>unevaled_bindings;</em>
                     <em>body })</em> -&gt;
      begin
        match unevaled_bindings with
          | <em>[]</em> -&gt; ...
          | <em>(name, expr) :: remainder</em> -&gt; ...
      end
    ...
</code></pre>

---
## `LetFrame`

* The simplest case is when all the binding expressions have been evaluated:

<pre class="smaller"><code>    | LetFrame (l, { evaled_bindings;
                     current_binding;
                     unevaled_bindings;
                     body }) -&gt;
      begin
        match unevaled_bindings with
          | <em>[]</em> -&gt;   (* no more bindings *)
            let new_bindings =
              (current_binding, v) :: evaled_bindings
            in
            let env' = bind_all env new_bindings in
              (Expr body, env', context)
          | ...
      end
</code></pre>

---
## `LetFrame`

<pre class="smaller"><code>    | LetFrame (l, { evaled_bindings;
                     current_binding;
                     unevaled_bindings;
                     body }) -&gt;
      begin
        match unevaled_bindings with
          | [] -&gt;   (* no more bindings *)
            <em>let new_bindings =</em>
              <em>(current_binding, v) :: evaled_bindings</em>
            in
            let env' = bind_all env new_bindings in
              (Expr body, env', context)
          | ...
      end
</code></pre>

* Add the last (name, value) pair to `evaled_bindings`

---
## `LetFrame`

<pre class="smaller"><code>    | LetFrame (l, { evaled_bindings;
                     current_binding;
                     unevaled_bindings;
                     body }) -&gt;
      begin
        match unevaled_bindings with
          | [] -&gt;   (* no more bindings *)
            let new_bindings =
              (current_binding, v) :: evaled_bindings
            in
            <em>let env' = bind_all env new_bindings</em> in
              (Expr body, env', context)
          | ...
      end
</code></pre>

* Create the new environment `env'` including these bindings

---
## `LetFrame`

<pre class="smaller"><code>    | LetFrame (l, { evaled_bindings;
                     current_binding;
                     unevaled_bindings;
                     body }) -&gt;
      begin
        match unevaled_bindings with
          | [] -&gt;   (* no more bindings *)
            let new_bindings =
              (current_binding, v) :: evaled_bindings
            in
            let env' = bind_all env new_bindings in
              <em>(Expr body, env', context)</em>
          | ...
      end
</code></pre>

* Evaluate the body expression in the new environment

---
## _Aside:_ `LetEnvFrame`

* We still have to restore the old environment
  after the `let` has finished executing

* Last time we saw that before we put the `LetFrame` onto the context stack,
  we put a `LetEnvFrame` to preserve the old environment
  * (This happens in `reduce_expr`)

---
## _Aside:_ `LetEnvFrame`

* In `eval_val_in_frame`, there is a case for this:

<pre><code>let eval_val_in_frame v env frame context =
  match frame with
    ...
    | <em>LetEnvFrame env' -&gt; (Value v, env', context)</em>
    ...
</code></pre>

---
## `LetFrame`

* However, we haven't finished talking about `LetFrame` yet!
* Specifically, we haven't covered the case
  when there are still unevaluated binding expressions left
* So let's do that now

---
## `LetFrame`

<pre><code>  match unevaled_bindings with
    | [] -&gt; ...
    | <em>(name, expr) :: remainder</em> -&gt;
      let new_bindings =
        (current_binding, v) :: evaled_bindings in
      let new_frame =
        { evaled_bindings   = new_bindings;
          current_binding   = name;
          unevaled_bindings = remainder;
          body } in
      let context' =
        stack_push l (LetFrame (l, new_frame)) context in
        (Expr expr, env, context')
</code></pre>

---
## `LetFrame`

<pre><code>  match unevaled_bindings with
    | [] -&gt; ...
    | (name, expr) :: remainder -&gt;
      <em>let new_bindings =</em>
        <em>(current_binding, v) :: evaled_bindings</em> in
      let new_frame =
        { <em>evaled_bindings   = new_bindings;</em>
          current_binding   = name;
          unevaled_bindings = remainder;
          body } in
      let context' =
        stack_push l (LetFrame (l, new_frame)) context in
        (Expr expr, env, context')
</code></pre>

* Update `evaled_bindings` with `current_binding` and value `v`

---
## `LetFrame`

<pre><code>  match unevaled_bindings with
    | [] -&gt; ...
    | (<em>name</em>, expr) :: remainder -&gt;
      let new_bindings =
        (current_binding, v) :: evaled_bindings in
      let new_frame =
        { evaled_bindings   = new_bindings;
          <em>current_binding   = name;</em>
          unevaled_bindings = remainder;
          body } in
      let context' =
        stack_push l (LetFrame (l, new_frame)) context in
        (Expr expr, env, context')
</code></pre>

* Update `current_binding` with the first `name` in `unevaled_bindings`

---
## `LetFrame`

<pre><code>  match unevaled_bindings with
    | [] -&gt; ...
    | (name, expr) :: <em>remainder</em> -&gt;
      let new_bindings =
        (current_binding, v) :: evaled_bindings in
      let new_frame =
        { evaled_bindings   = new_bindings;
          current_binding   = name;
          <em>unevaled_bindings = remainder;</em>
          body } in
      let context' =
        stack_push l (LetFrame (l, new_frame)) context in
        (Expr expr, env, context')
</code></pre>

* Update `unevaled_bindings` with rest of `(name, expr)` pairs

---
## `LetFrame`

<pre><code>  match unevaled_bindings with
    | [] -&gt; ...
    | (name, expr) :: remainder -&gt;
      let new_bindings =
        (current_binding, v) :: evaled_bindings in
      let new_frame =
        { evaled_bindings   = new_bindings;
          current_binding   = name;
          unevaled_bindings = remainder;
          body } in
      <em>let context' =</em>
        <em>stack_push l (LetFrame (l, new_frame)) context</em> in
        (Expr expr, env, context')
</code></pre>

* Push the new `let_frame` onto the context stack

---
## `LetFrame`

<pre><code>  match unevaled_bindings with
    | [] -&gt; ...
    | (name, <em>expr</em>) :: remainder -&gt;
      let new_bindings =
        (current_binding, v) :: evaled_bindings in
      let new_frame =
        { evaled_bindings   = new_bindings;
          current_binding   = name;
          unevaled_bindings = remainder;
          body } in
      let context' =
        stack_push l (LetFrame (l, new_frame)) context in
        (Expr <em>expr</em>, env, context')
</code></pre>

* And evaluate the next binding `expr`

---
## `LetStarFrame`

* We also use a `let_frame` on the context stack
  when evaluating `let*` expressions

* Actually, we don't need the `evaled_bindings` field of `let_frame` (why?)

* We could have defined a special `let_star_frame` type,
  but we didn't because of laziness

* Instead, we leave `evaled_bindings` empty (empty list)

---
## `LetStarFrame`

<pre class="smaller"><code>    | LetStarFrame (l, { evaled_bindings;
                         current_binding;
                         unevaled_bindings;
                         body }) -&gt;
      begin
        match unevaled_bindings with
          | [] -&gt; ...
          | (name, expr) :: remainder -&gt; ...
      end
</code></pre>

---
## `LetStarFrame`

<pre class="smaller"><code>    | LetStarFrame (l, { evaled_bindings;
                         current_binding;
                         unevaled_bindings;
                         body }) -&gt;
      begin
        match unevaled_bindings with
          | <em>[] -&gt;</em>
            <em>let env' = Env.bind env current_binding v in</em>
              <em>(Expr body, env', context)</em>
          | (name, expr) :: remainder -&gt; ...
      end
</code></pre>

* If no more `unevaled_bindings`,
  add last name/value pair to environment and evaluate the body

---
## `LetStarFrame`

<pre class="smaller"><code>      | [] -&gt; ...
      | <em>(name, expr) :: remainder</em> -&gt;
        let env' = Env.bind env current_binding v in
        let new_frame = {
            evaled_bindings;
            current_binding   = name;
            unevaled_bindings = remainder;
            body } in
        let context' =
          stack_push l (LetStarFrame (l, new_frame)) context in
          (Expr expr, env', context')
</code></pre>

* Otherwise...

---
## `LetStarFrame`

<pre class="smaller"><code>      | [] -&gt; ...
      | <em>(name, expr) :: remainder</em> -&gt;
        <em>let env' = Env.bind env current_binding v</em> in
        let new_frame = {
            evaled_bindings;
            current_binding   = name;
            unevaled_bindings = remainder;
            body } in
        let context' =
          stack_push l (LetStarFrame (l, new_frame)) context in
          (Expr expr, env', context')
</code></pre>

* Update `env` with the next name/value pair...

---
## `LetStarFrame`

<pre class="smaller"><code>      | [] -&gt; ...
      | <em>(name, expr) :: remainder</em> -&gt;
        let env' = Env.bind env current_binding v in
        <em>let new_frame = {</em>
            <em>evaled_bindings;</em>
            <em>current_binding   = name;</em>
            <em>unevaled_bindings = remainder;</em>
            <em>body }</em> in
        let context' =
          stack_push l (LetStarFrame (l, new_frame)) context in
          (Expr expr, env', context')
</code></pre>

* Update `frame`

---
## `LetStarFrame`

<pre class="smaller"><code>      | [] -&gt; ...
      | <em>(name, expr) :: remainder</em> -&gt;
        let env' = Env.bind env current_binding v in
        let new_frame = {
            evaled_bindings;
            current_binding   = name;
            unevaled_bindings = remainder;
            body } in
        <em>let context' =</em>
          <em>stack_push l (LetStarFrame (l, new_frame)) context</em> in
          (Expr expr, env', context')
</code></pre>

* Push new `let_frame` onto `context`

---
## `LetStarFrame`

<pre class="smaller"><code>      | [] -&gt; ...
      | <em>(name, expr) :: remainder</em> -&gt;
        let env' = Env.bind env current_binding v in
        let new_frame = {
            evaled_bindings;
            current_binding   = name;
            unevaled_bindings = remainder;
            body } in
        let context' =
          stack_push l (LetStarFrame (l, new_frame)) context in
          <em>(Expr expr, env', context')</em>
</code></pre>

* And evaluate the next `expr`

---
## `LetRecFrame`

* The last "let" form to handle is `letrec`

* This is similar to what we've already seen

* The stack contains a `LetRecFrame` which also contains a `let_frame`

---
## `LetRecFrame`

<pre class="smaller"><code>  | LetRecFrame (l, <em>{ evaled_bindings; current_binding;</em>
                      <em>unevaled_bindings; body }</em>) -&gt;
    begin
      match unevaled_bindings with
        | [] -&gt;
          let new_bindings =
            List.rev ((current_binding, v) :: evaled_bindings)
          in
          begin
            List.iter
              (fun (name, v) -&gt;
                Env.set l env name v) new_bindings;
            (Expr body, env, context)
          end
        | (name, expr) :: remainder -&gt; ...
    end
</code></pre>

---
## `LetRecFrame`

<pre class="smaller"><code>  | LetRecFrame (l, { evaled_bindings; current_binding;
                      unevaled_bindings; body }) -&gt;
    begin
      match unevaled_bindings with
        | <em>[]</em> -&gt;
          <em>let new_bindings =</em>
            <em>List.rev ((current_binding, v) :: evaled_bindings)</em>
          <em>in</em>
          begin
            List.iter
              (fun (name, v) -&gt;
                Env.set l env name v) new_bindings;
            (Expr body, env, context)
          end
        | (name, expr) :: remainder -&gt; ...
    end
</code></pre>

<div class="smaller">

* When no more unevaluated bindings,
  use evaluated bindings to change the environment

</div>

---
## `LetRecFrame`

<pre class="smaller"><code>  | LetRecFrame (l, { evaled_bindings; current_binding;
                      unevaled_bindings; body }) -&gt;
    begin
      match unevaled_bindings with
        | <em>[]</em> -&gt;
          <em>let new_bindings =</em>
            <em>List.rev ((current_binding, v) :: evaled_bindings)</em>
          <em>in</em>
          begin
            List.iter
              (fun (name, v) -&gt;
                Env.set l env name v) new_bindings;
            (Expr body, env, context)
          end
        | (name, expr) :: remainder -&gt; ...
    end
</code></pre>

<div class="smaller">

* (Recall that the environment already had placeholder values installed
  for all of the binding names)

</div>

---
## `LetRecFrame`

<pre class="smaller"><code>  | LetRecFrame (l, { evaled_bindings; current_binding;
                      unevaled_bindings; body }) -&gt;
    begin
      match unevaled_bindings with
        | <em>[]</em> -&gt;
          let new_bindings =
            List.rev ((current_binding, v) :: evaled_bindings)
          in
          begin
            <em>List.iter</em>
              <em>(fun (name, v) -&gt;</em>
                <em>Env.set l env name v) new_bindings;</em>
            (Expr body, env, context)
          end
        | (name, expr) :: remainder -&gt; ...
    end
</code></pre>

<div class="smaller">

* After this, all placeholder values will be overwritten...

</div>

---
## `LetRecFrame`

<pre class="smaller"><code>  | LetRecFrame (l, { evaled_bindings; current_binding;
                      unevaled_bindings; body }) -&gt;
    begin
      match unevaled_bindings with
        | <em>[]</em> -&gt;
          let new_bindings =
            List.rev ((current_binding, v) :: evaled_bindings)
          in
          begin
            List.iter
              (fun (name, v) -&gt;
                Env.set l env name v) new_bindings;
            <em>(Expr body, env, context)</em>
          end
        | (name, expr) :: remainder -&gt; ...
    end
</code></pre>

<div class="smaller">

* ...and the body of the `letrec` will be evaluated

</div>

---
## `LetRecFrame`

<pre class="smaller"><code>  | LetRecFrame (l, { evaled_bindings; current_binding;
                      unevaled_bindings; body }) -&gt;
    begin
      match unevaled_bindings with
        | [] -&gt; ...
        | <em>(name, expr) :: remainder</em> -&gt;
           let new_bindings =
             (current_binding, v) :: evaled_bindings in
           let new_frame =
             { evaled_bindings   = new_bindings;
               current_binding   = <em>name</em>;
               unevaled_bindings = <em>remainder</em>;
               body } in
           let context' =
             stack_push l (LetRecFrame (l, new_frame)) context
           in (Expr <em>expr</em>, env, context')
    end
</code></pre>

<div class="smaller">

* If there are still bindings to evaluate,
  the code is identical to the corresponding code for `LetFrame`

</div>

---
## Control operators

* What's left is:
  * `ReturnFrame`
  * `TryCatchEvalHandlerFrame`
  * `TryCatchFrame`
  * `ThrowFrame`

* `TryCatchFrame` is implemented for you (trivial)
* The rest are left for you to implement
* Details will be in assignment 3

---
## Next time

* We will start looking at statically typed languages
* Our first language will be very simple: _Typed Imp_,
  a typed version of the _Imp_ language we started off with

            </textarea>
          </section>
      </div>
    </div>
    <script src="plugin/math/math.js"></script>
    <script src="dist/reveal.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <!-- Uncomment if you want syntax highlighting. -->
    <!--
    <link rel="stylesheet" href="plugin/highlight/arduino-light.css">
    -->
    <style>
/* MCV: My new reveal.js styles. */

.reveal {
  font-family: "Arial", sans-serif;
  font-size: 28pt;
  font-weight: normal;
  color: #000; 
}

.reveal .slide-number {
  background: white;
  /* border: 1px solid black; */
}

.reveal .slide-number-a {
  background: white;
  color: black;
  font-size: 24px;
}

.reveal .slides h1 {
  text-align: center;
  text-transform: none;
  padding: 150px 0 20px 0;
  font-size: 64pt;
  font-family: Gill Sans MT, Gill Sans, Calibri, sans-serif;
  font-weight: normal;
  color: #4f271c;
  background: #d0d0f0;
  margin-bottom: 0.5em;
}

.reveal h2 { 
  text-transform: none;
  font-family: Gill Sans MT, Gill Sans, Calibri, sans-serif !important;
  /* text-shadow: 2px 2px 3px #a0a0a0; */
  color: #4f271c !important;
  font-size: 60pt !important;
  font-weight: normal !important;
  /* background: #d0d0d0; */
  width: 80% !important;
  margin-left: 10%;
}

/* First level bullet color. */
.reveal .slides ul li::marker {
  color: #3891a7;
}

/* Second level bullet spacing. */
.reveal .slides ul li ul {
  margin-top: 0px;
}

.reveal .slides li {
  margin-top: 10px;
}

/* Second level bullet color. */
.reveal .slides ul li ul li::marker {
  color: #3891a7;
}

.reveal li {
  font-size: 36pt !important;
}

.reveal .smaller li {
  font-size: 32pt !important;
}

.reveal li ul li {
  font-size: 32pt !important;
}

.reveal li .smaller ul li {
  font-size: 28pt !important;
}

.reveal ul {
  width: 80% !important;
  text-align: left !important;
}

.reveal code em {
  color: #800000 !important;
  font-style: italic !important;
  font-weight: bold !important;
}

.reveal em code {
  color: #800000 !important;
  font-style: italic !important;
  font-weight: bold !important;
}

.katex-display > .katex {
  color: #0040b0 !important;
}

.katex-display > .katex > .katex-html > .tag {
  color: #808080 !important;
  margin-right: 100px !important;
}

.katex > .katex-html {
  color: #0040b0 !important;
  padding-left: 5px;
  padding-right: 5px;
}

.katex {
  font-size: 1.1em !important;
}

.reveal pre {
  margin-left: 200px !important;
  width: 75% !important;
  font-size: 24pt !important;
}

.reveal pre.smaller {
  font-size: 20pt !important;
}

.reveal code {
  color: #0040b0 !important;
  font-size: 90%;
}

.reveal pre code {
  /* max vertical size of code block */
  max-height: 700px !important;
}

.reveal li ul li code {
  font-size: 80%;
}

    </style>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        katex: {
          version: 'latest',
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
          macros: {
            "\\eqref": "\\href{###1}{(\\text{#1})}",
            "\\ref": "\\href{###1}{\\text{#1}}",
            "\\label": "\\htmlId{#1}{}",
          },
        },
        plugins: [ 
          RevealMarkdown,
          // RevealHighlight,
          RevealMath.KaTeX,
        ],
        center: false,
        controls: false,
        disableLayout: false,  // set to true to use custom CSS for layout
        showSlideNumber: 'all',
        slideNumber: true,
        transition: 'none',
        width: 1280,
        height: 800,
      });
    </script>
  </body>
</html>
