<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- <section data-background-color="#ffffd0"> -->
          <section data-markdown>
            <textarea data-template>
# CS 131:<br/>Programming Languages
## _Lecture 16_:<br/>The _Typed $\mu$Scheme_ Language:<br/>Operational semantics

---
## Previously

* Polymorphic types
* Concrete syntax of _Typed $\mu$Scheme_

---
## Today

* The type system of _Typed $\mu$Scheme_
* Kinds and kind formation
* Operational semantics of kind checking
* Types and type formation
* Operational semantics of type checking

---
## Overview

* The _Typed $\mu$Scheme_ type system has a number of interesting features:
  * Universally-quantified types _i.e._ `forall` types
  * Type variables _e.g._ `'a`
  * The `type-lambda` type abstraction form
  * The &nbsp; `@` &nbsp; type application form
  * The `val-rec` definition form

---
## `forall` types and type variables

* Types can include _type variables_

* Type variables are identifiers
  (usually single lowercase letters)
  written with a leading single quote mark (like `'a`, `'b`)
  * Don't confuse them with quoted symbols!

---
## `forall` types and type variables

* A type with type variables has to have a leading `forall` binding
  * _e.g._ `(forall ['a] ('a -> 'a))`
  * All type variables in type names need to be bound by some `forall` binder

---
## `forall` types and type variables

* A `forall` type says that the type (_e.g._ of a function)
  is valid "for all" concrete types that could be bound to the type variables
* For a particular call to the function,
  the type variables are _instantiated_
  to whatever particular type they need to be
---
## `forall` types and type variables

* We also refer to these types as "universally-quantified types",
  "quantified types", or just "polymorphic types" for short

---
## `forall` types and type variables

* Example: a function that computes a length of a list
  would have the type<br/>`(forall ['a] ((list 'a) -> int))`<br/>
  because if the list has element type `'a`
  the function has type `((list 'a) -> int)`
  * Mathematically, we write this as
    $\forall \alpha\\, . \\, (list\ \alpha) \rightarrow int$

---
## `forall` types and type variables

* If applied to a list of type `(list int)`,
  the type variable `'a` becomes `int` in this case,
  and the function as a whole has type<br/>`(list int) -> int)`

---
## The `type-lambda` form

* To create an expression which has a polymorphic type,
  we use the `type-lambda` form
* This is commonly found in definitions of functions
  with polymorphic types

---
## The `type-lambda` form

* Here's the function to compute the length of a list in regular _$\mu$Scheme_:

<pre><code>(define (length lst)
  (if (null? lst)
      0
      (+ 1 (cdr lst))))
</code></pre>

* What would this look like in Typed _$\mu$Scheme_?

---
## The `type-lambda` form

* This defines a polymorphic recursive function,
  so we need to use the `val-rec` definition form instead of just `define`:

<pre><code>(<em>val-rec</em>
  ...)
</code></pre>

---
## The `type-lambda` form

* The first argument in a `val-rec` form is the return type,
  which can be a polymorphic type:

<pre><code>(val-rec
  <em>(forall ['a] ((list 'a) -&gt; int))</em>
  ...)
</code></pre>

* Note that the `forall` keyword is part of the _type_ language,
  while `type-lambda` is part of the _expression_ language

---
## The `type-lambda` form

* Then we have the function name:

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  <em>length</em>
  ...)
</code></pre>

---
## The `type-lambda` form

* Then the `type-lambda` form which introduces type variables into expressions;
  these will be bound to concrete types during "type application"

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  length
  <em>(type-lambda ['a]</em>
    ...))
</code></pre>

* Here, there is only one type variable: `'a`
---
## The `type-lambda` form

* Then the `type-lambda` form which introduces type variables into expressions;
  these will be bound to concrete types during "type application"

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  length
  <em>(type-lambda ['a]</em>
    ...))
</code></pre>

* At run-time, this will be bound to a concrete type

---
## The `type-lambda` form

* Then we have the (value) `lambda` form:

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  length
  (type-lambda ['a]
    <em>(lambda ([lst : (list 'a)])</em>
      ...)))
</code></pre>

* Note that we have to spell out the type of the arguments to `lambda`
* This is the first place we use the type variable `'a` in the function body

---
## The `type-lambda` form

* The rest of the code is basically the same as the untyped version...

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  length
  (type-lambda ['a]
    (lambda ([lst : (list 'a)])
      <em>(if ((@ null? 'a) lst)</em>
          <em>0</em>
          <em>(+ 1 ((@ length 'a) ((@ cdr 'a) lst))))</em>)))
</code></pre>

* ... except that all polymorphic values/functions
  must be applied explicitly to types using the `@` type application operator

---
## The `type-lambda` form

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  length
  (type-lambda ['a]
    (lambda ([lst : (list 'a)])
      (if (<em>(@ null? 'a)</em> lst)
          0
          (+ 1 (<em>(@ length 'a)</em> (<em>(@ cdr 'a)</em> lst)))))))
</code></pre>

* Here, we apply them to the type variable `'a`
  * Forgetting to explicitly instantiate type-polymorphic values
    with `@` is the most common pitfall in this language
---
## The `type-lambda` form

<pre><code>(val-rec
  (forall ['a] ((list 'a) -&gt; int))
  length
  (type-lambda ['a]
    (lambda ([lst : (list 'a)])
      (if (<em>(@ null? 'a)</em> lst)
          0
          (+ 1 (<em>(@ length 'a)</em> (<em>(@ cdr 'a)</em> lst)))))))
</code></pre>

* Here, we apply them to the type variable `'a`
  * "Real" languages can infer this automatically most of the time

---
## Kinds

* We saw in _Typed Imp_ that adding a new polymorphic type (arrays)
  required changes to the abstract syntax of the language
  and new type-formation rules
* That approach is not scalable;
  there are potentially an unbound number of new polymorphic types
  we might want to add
  * ultimately, want to allow users to add them as well
    (but not in this language!)

* How do we do this?

---
## Kinds

* We can consider polymorphic types as "functions from types to types"
  and make it easy to add new such functions
* To make this more precise, we introduce the notion of "kinds"
* A "kind" is a "type of types"
* Kinds classify types in the same way that types classify values

---
## Kinds

* Informally, the rules for forming kinds are pretty simple:
  * Concrete types (`int`, `bool`, _etc._) have kind `*`
  * Type constructors (_e.g._ `list`) have function kinds
    * Arguments are a tuple of kinds (often just one)
    * Result is a kind

---
## Kinds

* So `list` has the kind `* -> *` because it is a "type function"
  taking a type argument of kind `*` and returning a type of kind `*`

* A 2-tuple type (perhaps called `pair`) would have the type
  `(* $\times$ *) -> *`
  because it takes a tuple of two input types
  (_e.g._ `(int, bool)`) which has kind
  `(* $\times$ *)`
  and returns a concrete type
  (`int $\times$ bool`) of kind `*`

---
## Kinds

* More complex kinds are possible

* _e.g._ Haskell monad transformers have the kind<br/>
  `(* -> *) -> (* -> *)`,
  which means they map a unary type constructor
  to another unary type constructor

* We won't need anything that complex here

---
## Kinds

* Mathematically, we can represent kinds as follows:

$$
\large{
\kappa ::= * \\, | \\, \kappa_1 \times \ldots \times \kappa_n \Rightarrow \kappa
}
$$

* A kind of `*` is the kind of a simple type

* A kind of
  `$\kappa_1 \  \times \ \ldots \  \times \kappa_n
   \Rightarrow \kappa$`
  is the kind of a "type function" (type constructor)

---
## Kinds

* Mathematically, we can represent kinds as follows:

$$
\large{
\kappa ::= * \\, | \\, \kappa_1 \times \ldots \times \kappa_n \Rightarrow \kappa
}
$$

* A different way of thinking of kinds
  is to consider _all_ kinds as the kinds of type constructors
  where simple types (of kind `$*$`)
  are "nullary" type constructors (_i.e._ having no type arguments)

---
## Kind formation rules

* Abstractly, the "typing rules" for forming kinds
  ("kind formation rules") are quite simple:

$$
\frac{}{* \\, \text{is a kind}}
$$

$$
\label{}\tag{KindFormationType}
$$

$$
\frac{\kappa_1, \ldots , \kappa_n \ \text{are kinds}
\hskip{1em}\text{$\kappa$ is a kind}
}
{\kappa_1 \times \ldots \times \kappa_n
 \Rightarrow \kappa \ \\, \text{is a kind}}
$$

$$
\label{}\tag{KindFormationArrow}
$$

* That's it!

---
## Kind Environment

* Actually, these kind formation rules are more general than we will need

* In our language,
  the function kinds will always have arguments and types that have kind `*`

---
## Kind Environment

* To determine which type constructors have which kinds,
  we define a "kind environment",
  which we represent symbolically as `$\Delta$`

* We represent membership in `$\Delta$`
  by the notation `$\tau :: \kappa$`
  where `$\tau$` is a type constructor and `$\kappa$` is a kind

---
## Kind Environment

* A sample kind environment:

$$
\Delta_0 = \\{
int :: *, \\ bool :: *, \\ unit :: *, \\\\
pair :: * \times * \Rightarrow *, \\\\
list :: * \Rightarrow *
\\}
$$

---
## Kind Environment

* Advantage of having a kind environment:
  we can add new type constructors
  simply by adding them to the kind environment (no new rules!)

* However, in _Typed $\mu$Scheme_
  the set of type constructors will be fixed (not user-extensible)

---
## Type formation rules (informal)

* Now we'll present the (informal) rules for constructing types,
  assuming a kind environment `$\Delta$`

---
## Type formation rules (informal)

* A type can be formed by writing a type constructor

* This is valid as long as the type constructor
  is bound in the kind environment `$\Delta$`

* For instance, in the kind environment `$\Delta_0$` presented previously,
  we can immediately get the types `int`, `bool`, and `unit`

---
## Type formation rules (informal)

* A type can be formed by writing a type constructor

* This is valid as long as the type constructor
  is bound in the kind environment `$\Delta$`

* Confusingly, we can also get the "types" `list` and `pair`,
  but if we do, type checking will fail later

---
## Type formation rules (informal)

* A type can be formed by applying a type to other types

* For instance, `(list int)` is the type of lists of integers,
  and `(pair int bool)` is the type of integer/boolean pairs

---
## Type formation rules (informal)

* A type can be formed by applying a type to other types

* For a type application to be well-formed,
  the type arguments must have the right number
  and kind for the type constructor
  * So `(list int bool)` is invalid, as is<br/>`(list list)`

---
## Type formation rules (informal)

* A type can be formed as a function type,
  by specifying the argument and result types

* We restrict ourselves to function types
  where the argument and result types have kind `*`
  * This is a common restriction in typed functional languages
  * Some languages (_e.g._ Haskell) don't have this restriction!

---
## Type formation rules (informal)

* _Note_: Don't confuse function _types_ (the types of functions)
  with function _kinds_
  (the kinds of non-nullary type constructors like `list`)

---
## Type formation rules (informal)

* So if:
  * the argument types are `$\tau_1, \ldots, \tau_n$`<br/>(all of kind `*`)
  * ... and the result type is `$\tau$` (of kind `*`)
  * ... and all types are bound in the kind environment `$\Delta$`
  * ... then the function type
    `$\tau_1 \times \cdots \times \tau_n \Rightarrow \tau$`
    is well-formed (valid)

---
## Type formation rules (informal)

* We also need rules for type variables and universally-quantified types

* We stipulate that all type variables are well-formed and have kind `*`
  * We don't allow type variables
    to be instantiated with non-nullary type constructors
    like `list`, for instance

---
## Type formation rules (informal)

* A universally-quantified type (`forall` type) is well-formed if:
  * Given an initial kind environment `$\Delta_0$`
  * ... add all the type variables of the `forall` type
    with kinds `*`, and call the resulting kind environment `$\Delta_1$`
  * ... and assuming that in `$\Delta_1$` the type `$\tau$` has kind `*` too
  * ... then the original `forall` type is well-formed

---
## Type formation rules (formal)

* You can see that the type formation rules get complicated pretty fast
* Fortunately, we have a secret weapon: math!

---
## Type formation rules (formal)

* We'll now spell out
  the formal versions of the previous type formation rules
* For any given type,
  we deduce a _kinding judgment_ of the form
  `$\Delta \vdash \tau :: \kappa$`; this gives the kind of the given type
* Note that this only tells us which types are _valid_
  _i.e._ have valid kinds ("kind checking");
  we haven't even gotten to type checking yet!

---
## Note 1

* Note that conceptually,
  our kind environment only binds type _constructors_ to kinds

---
## Note 1

* We can use type _variables_ to stand for (unknown, nullary) constructors

* We can add type variables to kind environments
  as constructors with special names,
  because type variable names
  are distinct from actual type constructor names
  * (they have to start with the quote character `(')`)
  * This is a bit of a hack, but it works

---
## Type formation rules (formal)

* Here is the rule for type constructors:

$$
\frac{\mu \in \text{dom}\ \Delta}
{\Delta \vdash \text{TYCON}(\mu) :: \Delta(\mu)}
$$

$$
\label{}\tag{KindIntroCon}
$$

* This says that for a type expression
  of the form `$\text{TYCON}(\mu)$`,
  where `$\mu$` is a type constructor,
  just look up `$\mu$` in the kind environment `$\Delta$`

---
## Type formation rules (formal)

* Here is the rule for type constructors:

$$
\frac{\mu \in \text{dom}\ \Delta}
{\Delta \vdash \text{TYCON}(\mu) :: \Delta(\mu)}
$$

$$
\label{}\tag{KindIntroCon}
$$

* Note that `$\text{TYCON}(\mu)$` is abstract syntax
  * We'll be seeing more abstract syntax
    for type expressions in the next few slides

---
## Type formation rules (formal)

* Here is the rule for applying type constructors to type arguments:

$$
\frac
{\Delta \vdash \tau :: \kappa_1 \times \cdots \times \kappa_n
\Rightarrow \kappa \hskip{1em}
\Delta \vdash \tau_i :: \kappa_i, \hskip{1em}
1 \leq i \leq n}
{\Delta \vdash \text{CONAPP}(\tau, [\tau_1, \ldots, \tau_n]) :: \kappa}
$$

$$
\label{}\tag{KindApp}
$$

---
## Type formation rules (formal)

* This says that for a type expression
  `$\text{CONAPP}(\tau, [\tau_1, \ldots, \tau_n])$`,
  where the type constructor `$\tau$`
  is applied to type arguments
  `$\tau_1, \ldots, \tau_n$`,
  the type expression is valid
  (and has kind `$\kappa$`)
  if the type constructor `$\tau$`
  is in the kind environment `$\Delta$`,
  has a function kind,
  there are the right number of argument type constructors `$\tau_i$`,
  and each of them is in `$\Delta$` and has the right kind `$\kappa_i$`

---
## Type formation rules (formal)

* Here is the rule for forming function types:

$$
\frac
{
\Delta \vdash
\tau_i :: *, \\ 1 \leq i \leq n
\hskip{1em}
\Delta \vdash
\tau :: *
}
{
\Delta \vdash
\tau_1 \times \cdots \times \tau_n \Rightarrow
\tau :: *
}
$$

$$
\label{}\tag{KindFunction}
$$

---
## Type formation rules (formal)

* This says that if all the `$\tau_i$` have kinds `*` in `$\Delta$`
  and there are the right number of them,
  and the result type `$\tau$` also has kind `*` in `$\Delta$`,
  then we can form the function type

$$
\tau_1 \times \cdots \times \tau_n \Rightarrow \tau :: *
$$

* which will have kind `*`

---
## Note 2

* It's important to realize
  that the kind environment `$\Delta$` _only_ has kind bindings
  for type constructors and type variables,
  _not_ for every possible type in the program

---
## Note 2

* Having kinds for every possible type would be impossible
  since there are an infinite number of possible types
  (`int`, `(list int)`, `(list (list int))`, ...

* Instead, the kinds of all valid types
  can be _deduced_ from the kind environment

---
## Type formation rules (formal)

* We still have to have formal type formation rules
  for type variables and universally-quantified types

* Type variables are simple: just look them up in the kind environment:

$$
\frac
{
\alpha \in dom\ \Delta
}
{
\Delta \vdash \text{TYVAR}(\alpha) :: \Delta(\alpha)
}
$$

* We will assume that type variables always have kind `*`

---
## Type formation rules (formal)

* The rule for forming universally-quantified types is:

$$
\frac
{
\Delta\\{\alpha_1 :: *, \ldots, \alpha_n :: *\\} \vdash \tau :: *
}
{
\Delta \vdash
\text{FORALL}(\langle
\alpha_1, \ldots, \alpha_n
\rangle, \tau) :: *
}
$$

$$
\label{}\tag{KindForAll}
$$

---
## Type formation rules (formal)

* This says that if you add to the kind environment `$\Delta$`
  the type variables `$\alpha_i$`, each with kind `*`,
  and can then deduce that type `$\tau$` has kind `*`,
  then the type
  $\text{FORALL}(\langle \alpha_1, \ldots, \alpha_n \rangle, \tau)$
  is a valid type with kind `*`

* (Presumably, `$\tau$` will contain some/all
  of the type variables `$\alpha_i$`)

---
## Type checking

* OK, now we're done with kinds and type formation

* Now it's time to do the real work:
  type checking expressions and definitions!

---
## Type checking: general notes

* We have only one type environment `$\Gamma$`
  (in contrast to _Typed Imp_, which had 3)

* We also have a kind environment `$\Delta$`

* We have no special-purpose rules
  for particular type constructors (unlike _Typed Imp_ and arrays)

---
## Type checking: expressions

* Now we'll present the type checking rules for expressions

---
## Type checking: literals

* Let's start with a nice, simple case: literals!

$$
\frac
{}
{\Delta, \Gamma \vdash Literal(IntL(n)) : Int}
$$

$$
\frac
{}
{\Delta, \Gamma \vdash Literal(BoolL(b)) : Bool}
$$

$$
\frac
{}
{\Delta, \Gamma \vdash Literal(UnitL) : Unit}
$$

---
## Type checking: literals

* We add an extra literal value for `nil`,
  which represents an empty list

* It has the polymorphic type<br/>`(forall ['a] (list 'a))`,<br/>
  or `$\forall\ \alpha\ . \alpha\ list$` in math-ese

$$
\frac
{}
{\Delta, \Gamma \vdash Literal(NilL) : \forall\ \alpha\ . \alpha\ list}
$$

$$
\label{}\tag{NilLiteral}
$$

---
## Type checking: variables

$$
\frac
{
x \in \text{dom}(\Gamma)
\hskip{1em}
\Gamma(x) = \tau
}
{
\Delta, \Gamma \vdash \text{VAR}(x) : \tau
}
$$

$$
\label{}\tag{Var}
$$

* If the variable `$x$` is in the type environment `$\Gamma$`
  and has type `$\tau$`,
  then the expression `VAR($x$)` also has type `$\tau$`.

---
## Type checking: `set`

$$
\frac
{
\Delta, \Gamma \vdash e : \tau
\hskip{1em}
x \in \text{dom}(\Gamma)
\hskip{1em}
\Gamma(x) = \tau
}
{
\Delta, \Gamma \vdash \text{SET}(x, e) : unit
}
$$

$$
\label{}\tag{Set}
$$

* If the variable `$x$` is in the type environment `$\Gamma$`
  and has type `$\tau$` (which means it's been previously defined)...

---
## Type checking: `set`

$$
\frac
{
\Delta, \Gamma \vdash e : \tau
\hskip{1em}
x \in \text{dom}(\Gamma)
\hskip{1em}
\Gamma(x) = \tau
}
{
\Delta, \Gamma \vdash \text{SET}(x, e) : unit
}
$$

$$
\label{}\tag{Set}
$$

* ...and if, given kind environment `$\Delta$`
  and type environment `$\Gamma$`,
  we can prove that expression `$e$` has type `$\tau$`...

---
## Type checking: `set`

$$
\frac
{
\Delta, \Gamma \vdash e : \tau
\hskip{1em}
x \in \text{dom}(\Gamma)
\hskip{1em}
\Gamma(x) = \tau
}
{
\Delta, \Gamma \vdash \text{SET}(x, e) : unit
}
$$

$$
\label{}\tag{Set}
$$

* ...then the expression $\text{SET}(x, e)$ has type `unit`

---
## Type checking: `set`

$$
\frac
{
\Delta, \Gamma \vdash e : \tau
\hskip{1em}
x \in \text{dom}(\Gamma)
\hskip{1em}
\Gamma(x) = \tau
}
{
\Delta, \Gamma \vdash \text{SET}(x, e) : unit
}
$$

$$
\label{}\tag{Set}
$$

* (Or type `$\tau$` if $\text{SET}$ returns the value set)

---
## Type checking: `while`

$$
\frac
{
\Delta, \Gamma \vdash e_1 : \text{bool}
\hskip{1em}
\Delta, \Gamma \vdash e_2 : \tau
}
{
\Delta, \Gamma \vdash \text{WHILE}(e_1, e_2) : \text{unit}
}
$$

$$
\label{}\tag{While}
$$

* Nothing unusual here...

---
## Type checking: `if`

$$
\frac
{
\Delta, \Gamma \vdash e_1 : \text{bool}
\hskip{1em}
\Delta, \Gamma \vdash e_2 : \tau
\hskip{1em}
\Delta, \Gamma \vdash e_3 : \tau
}
{
\Delta, \Gamma \vdash \text{IF}(e_1, e_2, e_3) : \tau
}
$$

$$
\label{}\tag{If}
$$

* Nothing unusual here either,
  except that we have to check
  that both `$e_2$` and `$e_3$` have the _same_ type `$\tau$`

* Deciding if two polymorphic types is tricky;
  we'll cover that next lecture

---
## Type checking: `begin`

$$
\frac
{
}
{
\Delta, \Gamma \vdash \text{BEGIN}() : \text{unit}
}
$$

$$
\label{}\tag{EmptyBegin}
$$

$$
\frac
{
\Delta, \Gamma \vdash
e_i : \tau_i,
\hskip{1em}
1 \leq i \leq n
}
{
\Delta, \Gamma \vdash
\text{BEGIN}(e_1, \ldots, e_n) : \tau_n
}
$$

$$
\label{}\tag{Begin}
$$

* Nothing unusual here either

---
## Type checking: `let`

$$
\frac
{
\Delta, \Gamma \vdash e_i : \tau_i, \\ 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma
\\{
x_1 \mapsto \tau_1, \ldots, x_n \mapsto \tau_n
\\} \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{LET}(\langle x_1, e_1, \ldots x_n, e_n \rangle, e) : \tau
}
$$

$$
\label{}\tag{Let}
$$

---
## Type checking: `let`

$$
\frac
{
\Delta, \Gamma \vdash e_i : \tau_i, \\ 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma
\\{
x_1 \mapsto \tau_1, \ldots, x_n \mapsto \tau_n
\\} \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{LET}(\langle x_1, e_1, \ldots x_n, e_n \rangle, e) : \tau
}
$$

$$
\label{}\tag{Let}
$$

* If all the $e_i$s have types $\tau_i$...

---
## Type checking: `let`

$$
\frac
{
\Delta, \Gamma \vdash e_i : \tau_i, \\ 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma
\\{
x_1 \mapsto \tau_1, \ldots, x_n \mapsto \tau_n
\\} \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{LET}(\langle x_1, e_1, \ldots x_n, e_n \rangle, e) : \tau
}
$$

$$
\label{}\tag{Let}
$$

* ...and if , when we extend the type environment $\Gamma$
  with bindings for all the $x_i$ with types $\tau_i$,
  we can typecheck the body expression $e$ to type $\tau$...

---
## Type checking: `let`

$$
\frac
{
\Delta, \Gamma \vdash e_i : \tau_i, \\ 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma
\\{
x_1 \mapsto \tau_1, \ldots, x_n \mapsto \tau_n
\\} \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{LET}(\langle x_1, e_1, \ldots x_n, e_n \rangle, e) : \tau
}
$$

$$
\label{}\tag{Let}
$$

* ...then the `let` expression as a whole has type $\tau$

---
## Type checking: `let*`

* We could write a special rule for `let*` too, but it would be pretty ugly
  * (it was one of the ugliest rules for regular _$\mu$Scheme_)

* Instead, we'll just write a rule for desugaring `let*` into nested `let`s

---
## Type checking: `let*`

$$
\frac
{
\Delta, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash \text{LETSTAR}(\langle \rangle, e) : \tau
}
$$

$$
\label{}\tag{EmptyLetStar}
$$

$$
\frac
{
\Delta, \Gamma \vdash
\text{LET}(\langle x_1, e_1 \rangle,
\text{LETSTAR}(\langle
x_2, e_2 \ldots x_n, e_n
\rangle, e))
: \tau,
\hskip{1em}
n > 0
}
{
\Delta, \Gamma \vdash
\text{LETSTAR}(\langle x_1, e_1, \ldots, x_n, e_n \rangle, e) : \tau
}
$$

$$
\label{}\tag{LetStar}
$$

* And there you go!

---
## Type checking: `lambda`

$$
\frac
{
\Delta \vdash \tau_i :: *, 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma \\{
x_1 \mapsto \tau_1,
\ldots,
x_n \mapsto \tau_n
\\} \vdash
e : \tau
}
{
\Delta, \Gamma \vdash
\text{LAMBDA}(\langle x_1 : \tau_1,\ldots,x_n : \tau_n
\rangle, e) : \tau_1 \times \cdots \times \tau_n \rightarrow \tau
}
$$

$$
\label{}\tag{Lambda}
$$

---
## Type checking: `lambda`

$$
\frac
{
\Delta \vdash \tau_i :: *, 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma \\{
x_1 \mapsto \tau_1,
\ldots,
x_n \mapsto \tau_n
\\} \vdash
e : \tau
}
{
\Delta, \Gamma \vdash
\text{LAMBDA}(\langle x_1 : \tau_1,\ldots,x_n : \tau_n
\rangle, e) : \tau_1 \times \cdots \times \tau_n \rightarrow \tau
}
$$

$$
\label{}\tag{Lambda}
$$

* All arguments of a `lambda`
  must be explicitly typed and the kinds of the types must all be `*`

---
## Type checking: `lambda`

$$
\frac
{
\Delta \vdash \tau_i :: *, 1 \leq i \leq n
\hskip{1em}
\Delta, \Gamma \\{
x_1 \mapsto \tau_1,
\ldots,
x_n \mapsto \tau_n
\\} \vdash
e : \tau
}
{
\Delta, \Gamma \vdash
\text{LAMBDA}(\langle x_1 : \tau_1,\ldots,x_n : \tau_n
\rangle, e) : \tau_1 \times \cdots \times \tau_n \rightarrow \tau
}
$$

$$
\label{}\tag{Lambda}
$$

* If adding those types to the type environment
  $\Gamma$ allows the body $e$ to type check with a type of<br/>$\tau$,
  the `lambda` itself has the type<br/>
  $\tau_1 \times \cdots \times \tau_n \rightarrow \tau$

---
## Type checking: `apply`

$$
\frac
{
\Delta, \Gamma \vdash
e : \tau_1 \times \cdots \times \tau_n \rightarrow \tau
\hskip{1em}
\Delta, \Gamma \vdash
e_i : \tau_i, \\ 1 \leq i \leq n
}
{
\Delta, \Gamma \vdash
\text{APPLY}(e, e_1, \ldots, e_n) : \tau
}
$$

$$
\label{}\tag{Apply}
$$

* Conversely, applying an expression $e$ to arguments $e_1, e_2,
  \ldots$ requires $e$ to have a function type
  $\tau_1 \times \cdots \times \tau_n \rightarrow \tau$

---
## Type checking: `apply`

$$
\frac
{
\Delta, \Gamma \vdash
e : \tau_1 \times \cdots \times \tau_n \rightarrow \tau
\hskip{1em}
\Delta, \Gamma \vdash
e_i : \tau_i, \\ 1 \leq i \leq n
}
{
\Delta, \Gamma \vdash
\text{APPLY}(e, e_1, \ldots, e_n) : \tau
}
$$

$$
\label{}\tag{Apply}
$$

* As long as the number of arguments $e_i$ is correct
  and they all have the correct types $\tau_i$,
  the application has type $\tau$

---
## Type checking: type application (`@`)

$$
\frac
{
\Delta, \Gamma \vdash e : \forall a_1, \ldots, a_n\, . \tau
\hskip{1em}
\Delta \vdash \tau_i :: *, \\ 1 \leq i \leq n
}
{
\Delta, \Gamma \vdash
\text{TYAPPLY}(e, \tau_1, \ldots, \tau_n) :
\tau[a_1 \mapsto \tau_1, \ldots a_n \mapsto \tau_n]
}
$$

$$
\label{}\tag{TyApply}
$$

* The type application operator `@`
  requires that all the type arguments have kind `*`
  and the expression $e$ has to have a polymorphic
  (universally quantified) type

---
## Type checking: type application (`@`)

$$
\frac
{
\Delta, \Gamma \vdash e : \forall a_1, \ldots, a_n\, . \tau
\hskip{1em}
\Delta \vdash \tau_i :: *, \\ 1 \leq i \leq n
}
{
\Delta, \Gamma \vdash
\text{TYAPPLY}(e, \tau_1, \ldots, \tau_n) :
\tau[a_1 \mapsto \tau_1, \ldots a_n \mapsto \tau_n]
}
$$

$$
\label{}\tag{TyApply}
$$

* The number of type arguments $\tau_i$
  must correspond to the number
  of universally quantified type variables $\alpha_i$

---
## Type checking: type application (`@`)

$$
\frac
{
\Delta, \Gamma \vdash e : \forall a_1, \ldots, a_n\, . \tau
\hskip{1em}
\Delta \vdash \tau_i :: *, \\ 1 \leq i \leq n
}
{
\Delta, \Gamma \vdash
\text{TYAPPLY}(e, \tau_1, \ldots, \tau_n) :
\tau[a_1 \mapsto \tau_1, \ldots a_n \mapsto \tau_n]
}
$$

$$
\label{}\tag{TyApply}
$$

* The result type is the type $\tau$
  with types $\tau_i$ substituted for the type variables $\alpha_i$
  * (This type also has kind `*`)

---
## _N.B._ type application(s)

* It's important to realize that in _Typed $\mu$Scheme_
  there are two distinct notions of "type application"

* The first is "type level type application";
  this is when a (non-nullary) type constructor (like `list`)
  is applied to another type (like `int`)
  to generate a new type (like `(list int)`)

---
## _N.B._ type application(s)

* It's important to realize that in _Typed $\mu$Scheme_
  there are two distinct notions of "type application"

* The second is "value level type application";
  this is when a type-polymorphic value
  (usually formed with `type-lambda` but sometimes built-in like `nil`)
  is applied to a type using the type application operator
  `@` to generate a value

---
## _N.B._ type application(s)

* It's important to realize that in _Typed $\mu$Scheme_
  there are two distinct notions of "type application"

* We will often be sloppy about this usage
  and call both of these "type application";
  which one we mean should be clear from the context

---
## Substitution

* The rule for type application
  is the first place we've had to deal with the notion of _substitution_

* This is intuitively clear but very tricky to do right in practice!

* Next lecture will discuss this in great detail;
  for now, we'll assume that it can be done correctly

---
## Type checking: `type-lambda`

* The type application rule
  shows us how to type an expression
  which _removes_ type variables from an expression

---
## Type checking: `type-lambda`

* The technical term for this is that it's an _elimination_ rule
* There must also be a rule to show us how to _introduce_ type variables
* (This is called, unsurprisingly, an _introduction_ rule)
* (Many rules come in introduction/elimination pairs in operational semantics)

---
## Type checking: `type-lambda`

* In _Typed $\mu$Scheme_,
  the introduction form for type variables is `type-lambda`

* Here is its type-checking rule:

$$
\frac
{
\alpha_i \notin \text{ftv}(\Gamma), \\
1 \leq i \leq n
\hskip{2em}
\Delta
\\{
\alpha_1 :: *, \ldots, \alpha_n :: *
\\}, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{TYLAMBDA}(
\alpha_1, \ldots, \alpha_n, e
) : \forall
\alpha_1, \ldots, \alpha_n\,
. \tau
}
$$

$$
\label{}\tag{TyLambda}
$$

* There's a lot going on here!

---
## Type checking: `type-lambda`

$$
\frac
{
\alpha_i \notin \text{ftv}(\Gamma), \\
1 \leq i \leq n
\hskip{2em}
\Delta
\\{
\alpha_1 :: *, \ldots, \alpha_n :: *
\\}, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{TYLAMBDA}(
\alpha_1, \ldots, \alpha_n, e
) : \forall
\alpha_1, \ldots, \alpha_n\,
. \tau
}
$$

$$
\label{}\tag{TyLambda}
$$

* First, we have to compute the set of _free type variables_
  ($\text{ftv}$) of the type environment $\Gamma$

---
## Type checking: `type-lambda`

$$
\frac
{
\alpha_i \notin \text{ftv}(\Gamma), \\
1 \leq i \leq n
\hskip{2em}
\Delta
\\{
\alpha_1 :: *, \ldots, \alpha_n :: *
\\}, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{TYLAMBDA}(
\alpha_1, \ldots, \alpha_n, e
) : \forall
\alpha_1, \ldots, \alpha_n\,
. \tau
}
$$

$$
\label{}\tag{TyLambda}
$$

* Then we have to pick $n$ "fresh" type variables
  (which means they are different
  from the free type variables already in $\Gamma$)

---
## Type checking: `type-lambda`

$$
\frac
{
\alpha_i \notin \text{ftv}(\Gamma), \\
1 \leq i \leq n
\hskip{2em}
\Delta
\\{
\alpha_1 :: *, \ldots, \alpha_n :: *
\\}, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{TYLAMBDA}(
\alpha_1, \ldots, \alpha_n, e
) : \forall
\alpha_1, \ldots, \alpha_n\,
. \tau
}
$$

$$
\label{}\tag{TyLambda}
$$

* We add them to the kind environment $\Delta$ with kinds $*$
  * (this language doesn't support higher-kinded type variables)

---
## Type checking: `type-lambda`

$$
\frac
{
\alpha_i \notin \text{ftv}(\Gamma), \\
1 \leq i \leq n
\hskip{2em}
\Delta
\\{
\alpha_1 :: *, \ldots, \alpha_n :: *
\\}, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{TYLAMBDA}(
\alpha_1, \ldots, \alpha_n, e
) : \forall
\alpha_1, \ldots, \alpha_n\,
. \tau
}
$$

$$
\label{}\tag{TyLambda}
$$

* If we can deduce that $e$
  has type $\tau$ with the extended kind environment...

* Then the entire `type-lambda` expression typechecks
  and has the polymorphic type
  $\forall \alpha_1, \ldots, \alpha_n\, . \tau$

---
## Type checking: `type-lambda`

$$
\frac
{
\alpha_i \notin \text{ftv}(\Gamma), \\
1 \leq i \leq n
\hskip{2em}
\Delta
\\{
\alpha_1 :: *, \ldots, \alpha_n :: *
\\}, \Gamma \vdash e : \tau
}
{
\Delta, \Gamma \vdash
\text{TYLAMBDA}(
\alpha_1, \ldots, \alpha_n, e
) : \forall
\alpha_1, \ldots, \alpha_n\,
. \tau
}
$$

$$
\label{}\tag{TyLambda}
$$

* The `$\alpha_i \in \text{ftv}(\Gamma)$` constraint
  exists to prevent inadvertent capture
  of a type variable name in the expression `$e$`

* This is a very subtle problem! (We will talk more about this next lecture)

---
## Type checking: `type-lambda`

* Here is a simple example of code
  that fails to type check because of the free type variable restriction:

<pre><code>(type-lambda ['a]
  (lambda ([x : 'a])
    (type-lambda ['a] x)))
</code></pre>

---
## Type checking: `type-lambda`

* This gives the error message:

<pre><code>Type error: type-lambda type variables are free
  in type environment
</code></pre>

* Problem: The inner `type-lambda` used the type variable `'a`
  which was already present ("free")
  in the outer type environment (being bound by the outer `type-lambda`)

---
## Type checking: `type-lambda`

* This gives the error message:

<pre><code>Type error: type-lambda type variables are free
  in type environment
</code></pre>

* Solution: Choose a new type variable for the inner `type-lambda`!

---
## Type checking: `type-lambda`

* Corrected version:

<pre><code>(type-lambda ['a]
  (lambda ([x : 'a])
    (type-lambda <em>['b]</em> x)))
</code></pre>

* (Not that this is useful or anything...)

---
## Type checking: definitions

* Now we'll present the type checking rules for definitions

* Fortunately, they are pretty straightforward

---
## Type checking: definitions

* Recall: evaluating a definition can produce a new value environment

* Similarly, type checking a definition can produce a new _type_ environment

---
## Type checking: definitions

* The type judgment has the form
  `$\langle d, \Delta, \Gamma \rangle \rightarrow \Gamma'$`

* This means: when definition `$d$` is evaluated
  in type environment `$\Gamma$`
  and kind environment `$\Delta$`,
  the result is an updated type environment `$\Gamma'$`

* The kind environment `$\Delta$` is unchanged

---
## Type checking: `val`

* A `val` definition updates the type environment `$\Gamma$`
  with a new binding

$$
\frac
{
\Delta, \Gamma \vdash e : \tau
}
{
\langle \text{VAL}(x, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{Val}
$$

* Since this isn't recursive,
  the expression `$e$` can't refer to the `$x$` being defined

---
## Type checking: `val`

* Unlike Typed Imp,
  we don't have a special rule
  that prevents us from "changing" the type
  of a previously-existing variable

* Instead, a `val` form _always_ creates a new name/type binding
  in the type environment `$\Gamma$`
  * So the old type isn't being _changed_,
    it's merely being replaced for all future definitions
  * (This is the same thing languages like OCaml do)

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

* `val-rec` is used for recursive bindings

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

* The type `$\tau$` must be specified and must have kind `*`

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

* The type environment `$\Gamma$` must be extended
  with the type of `$x$` (`$\tau$`)
  before type checking `$e$`, which must also have type `$\tau$`

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

* While we're at it,
  we should also check that all uses of the name `$x$`
  inside the expression `$e$` are "safe" _i.e._ `$x$`
  won't be evaluated until after it's bound to `$e$`

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

* Basically, this means that all uses of `$x$` in `$e$`
  should be inside a `lambda` expression

---
## Type checking: `val-rec`

* For recursive bindings, we use `val-rec`:

$$
\frac
{
\begin{gather*}
\Delta \vdash \tau :: * \\\\
\Delta, \Gamma\\{x \mapsto \tau \\} \vdash e : \tau
\end{gather*}
}
{
\langle \text{VALREC}(x, \tau, e), \Delta, \Gamma \rangle
\rightarrow
\Gamma\\{x \mapsto \tau\\}
}
$$

$$
\label{}\tag{ValRec}
$$

* This check could be left to a separate pass after type checking,
  but we will do it during type checking

---
## Type checking: `define`

* `define` is basically syntactic sugar for `val-rec`:

$$
\frac
{
\langle
\text{VALREC}(f, \tau,
\text{LAMBDA}(
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e
),
\Delta, \Gamma
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
{
\langle
\text{DEFINE}(\tau, f,
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e), \Delta, \Gamma
\rangle
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
$$

$$
\label{}\tag{Define}
$$

---
## Type checking: `define`

* `define` is basically syntactic sugar for `val-rec`:

$$
\frac
{
\langle
\text{VALREC}(f, \tau,
\text{LAMBDA}(
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e
),
\Delta, \Gamma
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
{
\langle
\text{DEFINE}(\tau, f,
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e), \Delta, \Gamma
\rangle
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
$$

$$
\label{}\tag{Define}
$$

* Note, though, that `val-rec` can do things that `define` can’t

---
## Type checking: `define`

* `define` is basically syntactic sugar for `val-rec`:

$$
\frac
{
\langle
\text{VALREC}(f, \tau,
\text{LAMBDA}(
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e
),
\Delta, \Gamma
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
{
\langle
\text{DEFINE}(\tau, f,
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e), \Delta, \Gamma
\rangle
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
$$

$$
\label{}\tag{Define}
$$

* `define` can’t be used to define polymorphic functions,
  because you need a `type-lambda` in the body of the `val-rec`
  which isn’t there in the `define`

---
## Type checking: `define`

* `define` is basically syntactic sugar for `val-rec`:

$$
\frac
{
\langle
\text{VALREC}(f, \tau,
\text{LAMBDA}(
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e
),
\Delta, \Gamma
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
{
\langle
\text{DEFINE}(\tau, f,
\langle
x_1 : \tau_1,
...
x_n : \tau_n
\rangle,
e), \Delta, \Gamma
\rangle
\rangle
\rightarrow
\Gamma\\{f \mapsto \tau\\}
}
$$

$$
\label{}\tag{Define}
$$

* (You could simply eliminate `define` from the language if you wanted)

---
## Type checking: top-level expressions

* Top-level expressions are simple:
  just evaluate the expression
  and bind it to the variable name `_` as usual:

$$
\frac
{
\langle
\text{VAL}(\_, e), \Delta, \Gamma
\rightarrow
\Gamma'
\rangle
}
{
\langle
\text{EXP}(e), \Delta, \Gamma
\rightarrow
\Gamma'
\rangle
}
$$

$$
\label{}\tag{Exp}
$$

---
## Next time

* We _almost_ know enough to write a type checker for the language

* We still need to cover a few more topics:
  * type equivalence
  * type renaming
  * free and bound type variables
  * capture-avoiding substitution

* We'll do that next lecture

            </textarea>
          </section>
      </div>
    </div>
    <script src="plugin/math/math.js"></script>
    <script src="dist/reveal.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <!-- Uncomment if you want syntax highlighting. -->
    <!--
    <link rel="stylesheet" href="plugin/highlight/arduino-light.css">
    -->
    <style>
/* MCV: My new reveal.js styles. */

.reveal {
  font-family: "Arial", sans-serif;
  font-size: 28pt;
  font-weight: normal;
  color: #000; 
}

.reveal .slide-number {
  background: white;
  /* border: 1px solid black; */
}

.reveal .slide-number-a {
  background: white;
  color: black;
  font-size: 24px;
}

.reveal .slides h1 {
  text-align: center;
  text-transform: none;
  padding: 150px 0 20px 0;
  font-size: 64pt;
  font-family: Gill Sans MT, Gill Sans, Calibri, sans-serif;
  font-weight: normal;
  color: #4f271c;
  background: #d0d0f0;
  margin-bottom: 0.5em;
}

.reveal h2 { 
  text-transform: none;
  font-family: Gill Sans MT, Gill Sans, Calibri, sans-serif !important;
  /* text-shadow: 2px 2px 3px #a0a0a0; */
  color: #4f271c !important;
  font-size: 60pt !important;
  font-weight: normal !important;
  /* background: #d0d0d0; */
  width: 80% !important;
  margin-left: 10%;
}

/* First level bullet color. */
.reveal .slides ul li::marker {
  color: #3891a7;
}

/* Second level bullet spacing. */
.reveal .slides ul li ul {
  margin-top: 0px;
}

.reveal .slides li {
  margin-top: 10px;
}

/* Second level bullet color. */
.reveal .slides ul li ul li::marker {
  color: #3891a7;
}

.reveal li {
  font-size: 36pt !important;
}

.reveal .smaller li {
  font-size: 32pt !important;
}

.reveal li ul li {
  font-size: 32pt !important;
}

.reveal li .smaller ul li {
  font-size: 28pt !important;
}

.reveal ul {
  width: 80% !important;
  text-align: left !important;
}

.reveal code em {
  color: #800000 !important;
  font-style: italic !important;
  font-weight: bold !important;
}

.reveal em code {
  color: #800000 !important;
  font-style: italic !important;
  font-weight: bold !important;
}

.reveal code .comment {
  color: #cc44cc !important;
  font-style: italic !important;
  font-weight: normal !important;
}

.katex-display > .katex {
  color: #0040b0 !important;
}

.katex-display > .katex > .katex-html > .tag {
  color: #808080 !important;
  margin-right: 100px !important;
}

.katex > .katex-html {
  color: #0040b0 !important;
  padding-left: 5px;
  padding-right: 5px;
}

.katex {
  font-size: 1.1em !important;
}

.reveal pre {
  margin-left: 200px !important;
  width: 75% !important;
  font-size: 24pt !important;
}

.reveal pre.smaller {
  font-size: 20pt !important;
}

.reveal code {
  color: #0040b0 !important;
  font-size: 90%;
}

.reveal pre code {
  /* max vertical size of code block */
  max-height: 700px !important;
}

.reveal li ul li code {
  font-size: 80%;
}

    </style>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        katex: {
          version: 'latest',
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
          macros: {
            "\\eqref": "\\href{###1}{(\\text{#1})}",
            "\\ref": "\\href{###1}{\\text{#1}}",
            "\\label": "\\htmlId{#1}{}",
          },
        },
        plugins: [ 
          RevealMarkdown,
          // RevealHighlight,
          RevealMath.KaTeX,
        ],
        center: false,
        controls: false,
        disableLayout: false,  // set to true to use custom CSS for layout
        showSlideNumber: 'all',
        slideNumber: true,
        transition: 'none',
        width: 1280,
        height: 800,
      });
    </script>
  </body>
</html>
