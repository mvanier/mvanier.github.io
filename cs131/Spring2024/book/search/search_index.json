{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 131 book: Winter 2024","text":"<p>This book is the official document repository for the Caltech CS 131 course  (Programming Languages) for the Spring 2024 term.</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p> <p>Please read this page for an overview of the course.</p>"},{"location":"lectures/","title":"Lectures","text":"<p>Links to lectures slides are posted below.</p> <ul> <li> <p>Lecture 1:   Introduction</p> </li> <li> <p>Lecture 2:   The Imp language</p> </li> <li> <p>Lecture 3:   The Imp language: the code</p> </li> <li> <p>Lecture 4:   The Imp language: the code, part 2</p> </li> <li> <p>Lecture 5:   The uScheme language</p> </li> <li> <p>Lecture 6:   The uScheme language: operational semantics</p> </li> <li> <p>Lecture 7:   The uScheme language: the code</p> </li> <li> <p>Lecture 8:   The uScheme+ language</p> </li> <li> <p>Lecture 9:   The uScheme+ language: operational semantics</p> </li> <li> <p>Lecture 10:   The uScheme+ language: the code, part 1</p> </li> <li> <p>Lecture 11:   The uScheme+ language: the code, part 2</p> </li> <li> <p>Lecture 12:   The Typed Imp language</p> </li> </ul>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 131 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare you or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>You are welcome to collaborate informally on your assignments with other individuals who are taking the course, but you must write all of your own code and you must not look at other students' code, except to help them as described below. Copying another student's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another student's file and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another student's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone dictate code while you type isn't acceptable either. Basically, you have to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine.</p> <p>All of the above also applies if you are getting tutored for the course, officially or unofficially.</p> <p>All of the above also applies to student work from previous years. We re-use some problems in assignments, and copying answers from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a student who is currently taking the course.</p>"},{"location":"admin/collab/#helping-others-and-the-50-foot-rule","title":"Helping others and the \"50-foot rule\"","text":"<p>It is common for students to want to help other students to write and debug their assignments. While we prefer that you go to one of the course teaching assistants when you need help on the assignments (it doesn't matter which one), we don't forbid you from seeking help from other students or offering your help to other students. However, we do insist on some guidelines to make the process fair for everyone.</p> <p>When you are helping another student with their homework, you are acting as an unofficial teaching assistant, and thus you must behave like one. A teaching assistant will not tell you the answer or dictate code to you; he/she will help you work through the problem so that you understand what you are doing wrong. If you don't have the time or the inclination to do this, do not assist other students. If you just give them your code, you are violating the Honor Code and both you and the people you are giving the code to may be in for some serious consequences.</p> <p>As a way of clarifying the way in which you can help other students (especially when it comes to debugging their code), we want you to obey the \"50 foot rule\". This rule states that if you help another student with their programming problems (including debugging), you must not consult your own code while doing so. Specifically, we ask that your own code be at least 50 feet away i.e. not visible to you or the person you are helping while you are helping them. (It doesn't have to be exactly 50 feet; the point is that you can't see your code while helping the other person and you shouldn't run back and forth between your computer with your code and the computer of the person you're helping.) The slogan of the 50-foot rule is: \"Help them with your brain, not with your code.\" Please do not try to find a loophole kind of way around this e.g. projecting your code on a building 50 feet away; that is clearly not what we mean. Posting your code on a pastebin-like internet site, emailing your code to other people, sharing your screen with your code on it, printing it out, or even referring to it on your laptop while helping someone else, are all clear violations of the collaboration policy for this course. Also, we don't want you to put your code up on a computer in a room 50 feet away from where you're helping someone and run back and forth, dictating a line at a time. If you can't help them without consulting your code, don't help them. Refer them to a teaching assistant.</p> <p>Note</p> <p>The 50-foot rule only applies when helping another student in person.</p> <p>Helping another student using teleconferencing software like Zoom, Skype, Discord etc. is covered below, but one aspect of it is that screen sharing is not permitted.</p> <p>We realize that it's more convenient to ask someone in your house for help than to walk all the way to the Annenberg building. A possible solution is to get to know a TA and meet with them in their dorm room (if they are willing). Another possibility is to meet with a TA on Zoom or Discord, or in a room that's closer than Annenberg (e.g. in a library).</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord), you may not share your screen with other students, whether to help them or to get help from them. This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software. This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs. If this happens you may lose the ability to use the discussion board for any purpose.</p> <p>This also applies to other programs with chat features that are not used in the course (like Slack, Discord, or Discourse), or even email for that matter.</p>"},{"location":"admin/collab/#use-of-public-websites","title":"Use of public websites","text":"<p>It is strictly forbidden to post any of the problems from the assignments onto websites (for instance, Stack Overflow), and anyone caught doing this will be charged with an Honor Code violation. This includes problems that are similar to assignment problems even if not identical. If you find a discussion of course-related material on internet websites, you may read it as long as the discussion is not about a problem that is identical to or very similar to a problem on one of the course assignments. However, do not transcribe code from the internet into your homework submissions.</p> <p>It is strictly forbidden to look at any solutions to any previous years' work posted on internet code repository sites (including but not limited to GitHub, GitLab, BitBucket, etc.). It is also strictly forbidden to put your own code on such a repository unless (a) it is a private repository, and (b) you do not allow anyone else access to this private repository. You may also not fork any such repositories that you might happen to find; we will consider this evidence of intent to plagiarize.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-github-copilot-or-chatgpt","title":"Use of code hinting software (Github Copilot or ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot, ChatGPT, or similar software for any part of this course. (This should be obvious.)</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments and exams.</p> Item Status Course book OK Course textbook OK Official OCaml documentation OK Other OCaml documentation OK Other OCaml books OK Your notes OK Notes of other students Not allowed Your graded assignments OK Other students' graded assignments Not allowed Other students' ungraded assignments Not allowed Other code written by anyone else that answers an assigned problem Not allowed Solutions to assignment/exam problems from a previous year Not allowed Material posted on internet forums that answers specific problems Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor. Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the course syllabus for CS 131 (Functional Programming) for the Spring 2024 term.</p>"},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor/lecturer for the course is Mike Vanier (mvanier@cms.caltech.edu). Mike's pronouns are he/him.</p>"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held in room 213 of the Annenberg building on Mondays, Wednesdays, and Fridays from 3 PM to 4 PM.</p>"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for the course. Contact information and office hours for teaching assistants will be posted on the course Piazza page.</p> <ul> <li>Rachael Kim</li> <li>Emeka Nkurumeh</li> <li>Vinny Thai  (head TA)</li> <li>Christopher Zhou</li> </ul>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>From the Caltech catalog:</p> <p>CS 131 is a course on programming languages and their implementation. It teaches students how to program in a number of simplified languages representing the major programming paradigms in use today (imperative, object-oriented, and functional). It will also teach students how to build and modify the implementations of these languages. Emphasis will not be on syntax or parsing but on the essential differences in these languages and their implementations. Both dynamically-typed and statically-typed languages will be implemented. Relevant theory will be covered as needed. Implementations will mostly be interpreters, but some features of compilers will be covered if time permits. </p>"},{"location":"admin/syllabus/#textbook","title":"Textbook","text":"<p>This course is based around the textbook Programming Languages: Build, Prove, and Compare, by Norman Ramsey. We will often abbreviate this book as PL:BPC.</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There will be a Piazza site, which you will be enrolled in if you are registered for this course.</p> <p>For homework submission and grading, we will use CodePost.</p>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Office hours will either be held in-person or on Zoom, at the discretion of the teaching assistant. Mike will hold his office hours on Zoom. Office hour times will be posted on Piazza.</p>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>CS 131 is on grades. There are no exams.</p> <p>There will be 5 or 6 assignments, worth 10 marks each. On CodePost, each assignment will be given 100 \"points\". The point grade will be divided by 10 to get the actual grade in marks.</p> <p>Letter grades are determined by taking the maximum grade (60 if there are 6 assignments, 50 if there are 5 assignments) and scaling it to a maximum of 100. Letter grades are assigned to these percentages as follows:</p> Numerical grade (out of 100%) Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 65-70% C+ 62-65% C 60-62% C- 58-60% D+ 55-58% D &lt; 55% F"},{"location":"admin/syllabus/#redoing-assignments","title":"Redoing assignments","text":"<p>After you receive your initial grade on an assignment, you have one week to submit a redo. Redos will be submitted as a separate CodePost assignment called <code>Assignment N (rework)</code> (for assignment <code>N</code>). Late redos (received after the 1-week redo window) will not be graded and your previous grade will stand. You may not submit more than one redo per assignment.</p>"},{"location":"admin/syllabus/#late-policy-for-assignments","title":"Late policy for assignments","text":"<p>If an assignment is late when first submitted, marks are deducted at the rate of 20 points/day. These marks can't be regained through rework. If a rework is late (i.e. is submitted more than one week after the original grade was submitted), it doesn't count, and the previous grade stands.</p> <p>Note</p> <p>If an assignment is submitted on time, but is missing one or more sections, those sections will be graded as a 0. The assignment can be reworked, of course, but assuming the sections that were missing on the initial submission are submitted with the rework, there is no additional rework for these sections. This means (for instance) if you don't submit a section on the initial submission but do submit it in the rework, the grade of that section in the rework is final \u2014 you don't get to rework it just because you hadn't submitted it before. So please don't leave out sections!</p> <p>Students may request extensions for assignments due to unusual circumstances. These extensions have to be approved by the course instructor (Mike).</p>"},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Friday at 2 AM unless otherwise indicated. Note that a due time of 2 AM means early that morning, so effectively it means very late the previous evening.</p>"},{"location":"admin/syllabus/#attendance-and-participation","title":"Attendance and participation","text":"<p>Attendance and participation currently do not count towards the final grade. However, we strive to make lectures interactive and do a lot of demos and discussion during lectures.  Missing out on this will deprive you of many of the benefits of the course (as well as a lot of the fun!). All lectures slides will be posted.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech's Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this page.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>The course collaboration policies are listed in the Collaboration policies page in this book.</p> <p>Note</p> <p>Please read the collaboration policies! You are responsible for knowing what is an isn't acceptable collaboration, and if you over-collaborate you may be sent to the Board of Control, which is never pleasant.</p>"},{"location":"admin/syllabus/#software","title":"Software","text":"<p>See the software page for information on installing the course software.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated by your classmates and the course staff with respect. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructors know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student Wellness","text":"<p>It is very important to us that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made. Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See the CASS website for more information.</p> <p>Undergraduate students should contact Dr. Lesley Nye, interim Dean of Undergraduate Students (administrative contact: Beth Larranaga) and graduate students should contact Darrell Peterson, Associate Dean of Graduate Studies (administrative contact: Georgine Okura).</p>"},{"location":"assignments/1/assignment1/","title":"Assignment 1: The Imp language","text":""},{"location":"assignments/1/assignment1/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, April 19th at 2 AM.</p>"},{"location":"assignments/1/assignment1/#prerequisites","title":"Prerequisites","text":"<p>The only prerequisite for the course is having taken and passed CS 4. We absolutely require you to know the OCaml programming language before taking this course, because all of your submissions will be in OCaml and we don't have time to teach that language here. We will not be using any major features of the language that weren't taught in CS 4, though one or two minor ones (like labelled arguments) will be in the code base in a few places.</p> <p>Note</p> <p>The CS 4 requirement doesn't apply if you're a graduate student. In that case, though, you are responsible for getting up to speed in OCaml by yourself.</p> <p>We will also assume that you have a rudimentary knowledge of Unix-style terminal commands (at roughly the level required for CS 4). If not, please read e.g. a Linux tutorial, because we will be using the terminal a lot in this course.</p> <p>Note</p> <p>You are not required to use Linux in this course. The terminal in MacOS works pretty much the same way (both Linux and MacOS are Unix systems), so the commands should work fine assuming the software is installed correctly. Windows terminal commands are completely different. If you have Windows, you should install Windows Subsystem for Linux (WSL), which gives you a full version of Linux running inside of Windows.  (Use that instead of trying to run Haskell natively on Windows.)</p>"},{"location":"assignments/1/assignment1/#syllabus","title":"Syllabus","text":"<p>Please make sure you have read the Syllabus page and the Collaboration policies page before submitting any assignments, so you know how the course is organized, what the grading policies are, what is and is not acceptable collaboration etc..</p>"},{"location":"assignments/1/assignment1/#software-installation","title":"Software installation","text":"<p>See the Software page for instructions on how to install the course software.</p>"},{"location":"assignments/1/assignment1/#external-websites","title":"External websites","text":"<p>In addition to this book, we will be using the following websites:</p> <ul> <li> <p>The course Canvas page, which is where we will post the source code for assignments.</p> </li> <li> <p>The course Piazza page, which is where most course-related announcements will be posted, as well as serving as a question-and-answer forum. Teaching assistant contact information and office hours will also be posted on the Piazza page.</p> </li> <li> <p>The course CodePost page, which is where assignments will be submitted and graded.</p> </li> </ul> <p>Students will be enrolled in Piazza and CodePost by the course instructor. If you added the course late, you may need to remind the instructor to add you.</p> <p>In addition, some TAs and the instructor may choose to host office hours online on Zoom.</p>"},{"location":"assignments/1/assignment1/#code-base","title":"Code base","text":"<p>All assignments will have a code base, which includes test code and sometimes template code for modules. These are posted on the course Canvas site in the Modules section as a single zip file.</p> <p>The code base for the Imp language contains two subdirectories: <code>imp</code> and <code>sexpr</code>. The <code>sexpr</code> subdirectory contains the code to parse S-expressions from strings and files. The <code>imp</code> subdirectory contains the base implementation of the <code>imp</code> language. You should unzip the file in a directory and do the following:</p> <ol> <li><code>cd</code> into the <code>sexpr</code> subdirectory and run <code>make</code>.</li> <li>Then <code>cd</code> into the <code>imp</code> subdirectory and run <code>make</code>.</li> </ol> <p>If all goes well, this should create the <code>imp</code> executable, which you can run as follows:</p> <pre><code>$ ./imp\n&gt;&gt;&gt;\n</code></pre> <p>Then you can type in Imp expressions at the prompt. Control-D will exit the interpreter.</p>"},{"location":"assignments/1/assignment1/#the-rlwrap-program","title":"The <code>rlwrap</code> program","text":"<p>If you can, try to install the <code>rlwrap</code> program, which will allow you to do line editing on your interpreters in the same way that you do using <code>utop</code> with OCaml. Most package managers will allow you to install <code>rlwrap</code>. On MacOS using Homebrew, the command is:</p> <pre><code>$ brew install rlwrap\n</code></pre> <p>On Ubuntu Linux, it's:</p> <pre><code>$ sudo apt install rlwrap\n</code></pre> <p>You can use it like this:</p> <pre><code>$ rlwrap ./imp\n</code></pre> <p>and then you can use line editing with your Imp interpreter. (The same applies to all of the interpreters in this course.)</p>"},{"location":"assignments/1/assignment1/#writing-and-testing-your-code","title":"Writing and testing your code","text":"<p>You will write two new files of Imp code:</p> <ul> <li> <p><code>lab1a.imp</code>, which is all the Imp code you will write for part A</p> </li> <li> <p><code>lab1c.imp</code>, which is all the (extended) Imp code you will write for part C</p> </li> </ul> <p>You will also edit the file <code>imp.ml</code> in accordance with the instructions given in part B.</p> <p>The <code>imp</code> subdirectory of the code base has a <code>tests</code> subdirectory. Copy your <code>lab1a.imp</code> and <code>lab1c.imp</code> files into that directory, go back to the <code>imp</code> directory and type:</p> <pre><code>$ make test\n</code></pre> <p>This will run some tests on your code, all of which should pass.  Of course, passing the tests doesn't mean that your code is perfect, but failing a test means that something is definitely wrong.</p>"},{"location":"assignments/1/assignment1/#what-to-hand-in","title":"What to hand in","text":"<p>For this assignment, you will submit three files to CodePost as <code>Assignment 1</code>:</p> <ol> <li><code>lab1a.imp</code></li> <li><code>imp.ml</code> (containing your additions as described in part B)</li> <li><code>lab1c.imp</code></li> </ol>"},{"location":"assignments/1/partA/","title":"Part A: Programming in Imp (15 points)","text":"<p>In this section you will write a few functions in the base Imp language (the version we provide to you, with no alterations) to familiarize yourself with how it works. This code will go into the file <code>lab1a.imp</code>.</p> <p>Note</p> <p>You are allowed to write helper functions in addition to the functions described.</p> <p>Since Imp doesn't (yet) have local variables other than function arguments (you'll implement this in part B), if you need them you can either</p> <ul> <li> <p>define a global variable instead</p> </li> <li> <p>write a helper function with extra arguments which you use as local variables</p> </li> </ul> <p>The second strategy should be familiar from CS 4. Note that you can change the values of function arguments using the <code>set</code> form.</p>"},{"location":"assignments/1/partA/#1-sigma","title":"1. <code>sigma</code>","text":"<p>[3 points]</p> <p>Define a function <code>sigma</code> satisfying <code>(sigma m n) = m + (m+1) + ... + n</code>. When <code>m &gt; n</code>, the behavior of <code>sigma</code> is unspecified; your implementation may do anything you like. Write two versions of this function. <code>sigma1</code> will work recursively while <code>sigma2</code> will work imperatively using a <code>while</code> loop.</p>"},{"location":"assignments/1/partA/#2-exp-and-log","title":"2. <code>exp</code> and <code>log</code>","text":"<p>[3 points]</p> <p>Define the functions <code>exp</code> and <code>log</code>. When base <code>b</code> and exponent <code>n</code> are nonnegative, <code>(exp b n) = b^n</code>, and when <code>b &gt; 1</code> and <code>m &gt; 0</code>, <code>(log b m)</code> is the smallest integer <code>n</code> such that <code>b^(n + 1) &gt; m</code>. (We're using the <code>^</code> symbol to mean \"to the power of\" here.) On inputs that don't satisfy the preconditions, your implementation may do anything you like \u2014\u2009even fail to terminate.</p>"},{"location":"assignments/1/partA/#3-fact","title":"3. <code>fact</code>","text":"<p>[3 points]</p> <p>Define a function <code>fact</code> such that <code>(fact n)</code> is the factorial of <code>n</code>. Define two versions of this function. The first (<code>fact1</code>) will be a simply-recursive function that is familiar from the definition of factorials. The second (<code>fact2</code>) will be an imperative function using a <code>while</code> loop.</p>"},{"location":"assignments/1/partA/#4-fib","title":"4. <code>fib</code>","text":"<p>[3 points]</p> <p>Define a function <code>fib</code> such that <code>(fib n)</code> is the <code>n</code>th Fibonacci number. The Fibonacci numbers are a sequence of numbers defined by these laws:</p> <pre><code>fib 0 = 0\nfib 1 = 1\nfib n = fib (n - 1) + fib (n - 2)  when n &gt; 1\n</code></pre> <p>Write two versions of this function. <code>fib1</code> will be the usual tree-recursive function that corresponds to the definition, but it will be extremely slow for large input values. <code>fib2</code> will be an imperative function using a <code>while</code> loop and will be fast.</p>"},{"location":"assignments/1/partA/#5-binary","title":"5. <code>binary</code>","text":"<p>[3 points]</p> <p>Define a function <code>binary</code> such that <code>(binary m)</code> is the number whose decimal representation looks like the binary representation of <code>m</code>. For example <code>(binary 12) = 1100</code>, since <code>1100</code><sub><code>2</code></sub> = <code>12</code><sub><code>10</code></sub>. You can assume that the input number <code>m</code> is non-negative.</p>"},{"location":"assignments/1/partB/","title":"Part B: Extending Imp (70 points)","text":"<p>All the changes you make in this section are to the file <code>imp.ml</code>.</p>"},{"location":"assignments/1/partB/#1-read","title":"1. <code>read</code>","text":"<p>[10 points]</p> <p>Add the primitive <code>read</code> to the Imp interpreter and the initial basis. Function <code>read</code> is executed for its side effect; it takes no arguments, reads a number from standard input, and returns the number. The <code>read</code> primitive reads an entire line before converting it to an integer. If the input is invalid, it should raise a <code>Runtime_err</code> exception with an appropriate error message.</p> <p>Note that OCaml provides the <code>read_line</code> function as a built-in function (in the <code>Stdlib</code> module). You can use it, or alternatively use <code>read_int</code> or <code>read_int_opt</code> to read the number.</p>"},{"location":"assignments/1/partB/#2-adding-syntactic-sugar","title":"2. Adding syntactic sugar","text":"<p>[20 points]</p> <p>One interesting way to extend a language is to add syntactic sugar to it. This means to add forms that are trivially convertible to existing forms. For this problem, we want you to add a few language forms without changing the abstract syntax tree (AST) representation of the language. Instead, extend the S-expression to AST conversion (the <code>parse_expr</code> function) so that it recognizes the following forms and emits the correct AST forms.</p> <p>Note</p> <p>This is not usually the best way to add syntactic sugar to a language. An alternative way, which we'll explore in other languages, is to convert the AST to a simpler AST (an intermediate representation). Working with bare S-expressions in OCaml is fairly tedious. On the other hand, Scheme and Racket macros are a very sophisticated user-programmable way to add syntactic sugar to the Scheme and Racket languages, and they work by converting S-expressions to other S-expressions (to a first approximation).</p> <p>In each case, if a syntax error arises, a <code>Syntax_err</code> exception must be raised with a meaningful error message.</p> <p>Note</p> <p>Don't forget to add any new keywords to the <code>keywords</code> list in the interpreter!</p>"},{"location":"assignments/1/partB/#a-do-while","title":"a. <code>do-while</code>","text":"<p>Add a C-like <code>do-while</code> form with this translation:</p> <pre><code>(do-while &lt;exp&gt; &lt;test-exp&gt;) ==&gt; (begin &lt;exp&gt; (while &lt;test-exp&gt; &lt;exp&gt;))\n</code></pre> <p>Example</p> <pre><code>&gt;&gt;&gt; (val x 5)\nvariable x = 5\n&gt;&gt;&gt; (do-while (println x) (set x (- x 1)))\n5\n4\n3\n2\n1\n0\n</code></pre>"},{"location":"assignments/1/partB/#b-while","title":"b. <code>while*</code>","text":"<p>Add a <code>while*</code> form with this translation:</p> <pre><code>(while* &lt;test-exp&gt; &lt;exp1&gt; &lt;exp2&gt; ... &lt;expN&gt;)\n  ==&gt; (while &lt;test-exp&gt; (begin &lt;exp1&gt; &lt;exp2&gt; ... &lt;expN&gt;))\n</code></pre> <p>This allows you to write <code>while</code> loops without having an explicit <code>begin</code>, which is very convenient. A <code>while*</code> expression with no non-test expressions is a syntax error, as is one with no expressions at all.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; (val x 5)\nvariable x = 5\n&gt;&gt;&gt; (while* (&gt; x 0) (println x) (set x (- x 1)))\n5\n4\n3\n2\n1\n0\n</code></pre>"},{"location":"assignments/1/partB/#c-for","title":"c. <code>for</code>","text":"<p>Add a C-like <code>for</code> loop with this translation:</p> <pre><code>(for &lt;begin-exp&gt; &lt;test-exp&gt; &lt;incr-exp&gt; (&lt;body-exp1&gt; &lt;body-exp2&gt; ... &lt;body-expN))\n==&gt;\n(begin &lt;begin-exp&gt;\n  (while &lt;test-exp&gt;\n    (begin &lt;body-exp1&gt; &lt;body-exp2&gt; ... &lt;body-expN&gt; &lt;incr-exp&gt;)))\n</code></pre> <p>Example</p> <pre><code>&gt;&gt;&gt; (val x 0)\nvariable x = 0\n&gt;&gt;&gt; (val n 0)\nvariable n = 0\n&gt;&gt;&gt; (for (set x 5) (&gt; x 0) (set x (- x 1)) ((println x) (set n (+ n 1))))\n5\n4\n3\n2\n1\n0\n&gt;&gt;&gt; n\n5\n</code></pre> <p>Note</p> <p>Don't forget the parentheses around the body expressions! Think of it as a <code>begin</code> expression without the <code>begin</code> keyword.</p> <p>Note that for all of these changes, you will have to decide what the location of the newly-created forms are. Here are some guidelines:</p> <ul> <li> <p>For <code>do-while</code>, use the <code>do-while</code> location for the generated <code>begin</code> and <code>while</code> forms.</p> </li> <li> <p>For <code>while*</code>, use the <code>while*</code> location for the generated <code>while</code> and <code>begin</code> forms.</p> </li> <li> <p>For <code>for</code>, use the <code>for</code> location for the outer generated <code>begin</code> form and the generated <code>while</code> form. For the inner generated <code>begin</code> form, use the location of the S-expression <code>List</code> constructor that contains the <code>begin</code> expressions.</p> </li> <li> <p>For expressions that pass through unchanged, keep the location the same.</p> </li> </ul>"},{"location":"assignments/1/partB/#3-and-and-or","title":"3. <code>and</code> and <code>or</code>","text":"<p>[10 points]</p> <p>The initial basis of the Imp language is split between primitive functions and user functions. The user functions are defined in the string <code>initial_basis</code> near the end of the file. Two of these definitions are quite unsatisfying:</p> <pre><code>(define and (b c) (if b c b))\n(define or (b c) (if b b c))\n</code></pre> <p>The reason these are bad is that <code>and</code> and <code>or</code> should have short-circuit semantics: if the first argument is <code>0</code> (for <code>and</code>) or <code>1</code> (for <code>or</code>) the second argument should never be evaluated. In this problem we will implement a correct version of <code>and</code> and <code>or</code> with the appropriate semantics.</p> <p>Before we begin, note that this could be done the same way we implemented <code>while*</code> and <code>do-while</code>: by making <code>and</code> and <code>or</code> syntactic sugar for <code>if</code> expressions. However, it's instructive to do it a different way. Here is what we want you to do:</p> <ol> <li> <p>Remove the definitions of <code>and</code> and <code>or</code> from the <code>initial_basis</code> string.</p> </li> <li> <p>Add <code>and</code> and <code>or</code> to the keywords list.</p> </li> <li> <p>Extend the AST <code>exp</code> type definition with two new constructors: <code>And (&lt;loc&gt;, &lt;exp&gt;, &lt;exp&gt;)</code> and <code>Or (&lt;loc&gt;, &lt;exp&gt;, &lt;exp&gt;)</code>.</p> </li> <li> <p>Extend <code>parse_expr</code> so that the S-expression corresponding to <code>(and &lt;exp&gt; &lt;exp&gt;)</code> gets converted to the corresponding AST form and similarly for <code>(or &lt;exp&gt; &lt;exp&gt;)</code>.</p> </li> <li> <p>Extend <code>eval_expr</code> with cases for <code>And</code> and <code>Or</code> AST forms. These should just dispatch to <code>If</code> AST forms according to the rules:</p> </li> </ol> <pre><code>And (l, e1, e2) ==&gt; If (l, e1, e2, e1)\nOr (l, e1, e2) ==&gt; If (l, e1, e1, e2)\n</code></pre> <p>with one caveat: make sure you do not compute the value of <code>e1</code> or <code>e2</code> more than once. (There are different ways to achieve this.)</p> <p>Again, make sure that the locations used in derived forms are reasonable ones.</p>"},{"location":"assignments/1/partB/#4-improving-while-and-begin","title":"4. Improving <code>while</code> and <code>begin</code>","text":"<p>[10 points]</p> <p>The way that <code>while</code> and <code>begin</code> expressions are evaluated in the <code>eval_expr</code> function is somewhat inefficient. In both cases, we sometimes have to create new <code>while</code>/<code>begin</code> expressions and evaluate them in order to evaluate the full expression (this was spelled out in the operational semantics). However, why should we dispatch the <code>while</code>/<code>begin</code> subexpression to <code>eval_expr</code> just so it can wind up in the exact same point in the code we are already in? The extra case analysis is completely unnecessary. Rewrite the code for these forms so that you never have to recurse on a newly-created <code>while</code> or <code>begin</code> subexpression.</p> <p>There are two ways to do this: imperatively and functionally. The imperative way would use an OCaml <code>while</code> loop and reference variables. We want you to do it the other way: using a tail-recursive helper function (for <code>while</code>) or using either a tail-recursive helper function or an equivalent higher-order function (for <code>begin</code>).</p>"},{"location":"assignments/1/partB/#5-adding-support-for-local-variables","title":"5. Adding support for local variables","text":"<p>[20 points]</p> <p>One glaring weakness of the Imp language is that it has no local variables, even though it has an environment for storing them. In this problem we will implement them.</p> <p>The syntax for function definitions will change to the following:</p> <pre><code>(define function-name (formals) {(locals &lt;locals&gt;)} expression)\n</code></pre> <p>The curly braces are not part of the concrete syntax; they mean that the <code>locals</code> declaration can be omitted, in which case the locals list is empty. In other words:</p> <pre><code>(define foo (x y z) &lt;exp&gt;)\n</code></pre> <p>is the same as:</p> <pre><code>(define foo (x y z) (locals) &lt;exp&gt;)  ; empty locals list\n</code></pre> <p>Here's an example of a function that uses locals:</p> <pre><code>(define dumb-add (x y z)\n  (locals sum)\n  (begin\n    (set sum x)\n    (set sum (+ sum y))\n    (set sum (+ sum z))\n    sum))\n</code></pre> <p>Here's the function being called:</p> <pre><code>&gt;&gt;&gt; (dumb-add 1 2 3)\n6\n</code></pre> <p>Here are the steps we want you to go through to implement locals:</p> <ol> <li> <p>Add <code>locals</code> to the keywords list.</p> </li> <li> <p>Extend the <code>Define</code> AST form in the <code>def</code> type to contain a list of identifiers corresponding to local variables. This list should be separate from the <code>id list</code> of function arguments.</p> </li> <li> <p>Extend <code>parse_def</code> so that it recognizes function definitions with locals and parses them to the new <code>Define</code> form. Function definitions without locals will also be parsed to the new <code>Define</code> form, but the locals list will be empty. Check that all the locals identifiers are valid and that they are unique (as is currently done for the function parameters). Note that it's OK to use the same name for a local variable and a function parameter; in such cases, the local variable takes precedence.</p> </li> <li> <p>Extend the <code>UserFunction</code> definition so it includes locals.</p> </li> <li> <p>When a function call with a <code>UserFunction</code> is evaluated, all locals are added to the local variable environment with an initial value of <code>0</code>. Then evaluation proceeds normally.</p> </li> </ol> <p>Try to do this without copying code unnecessarily.</p>"},{"location":"assignments/1/partC/","title":"Part C: Programming in extended Imp (15 points)","text":"<p>Rewrite your functions from part A as follows. Even if you used helper functions to implement your functions in part A (which is allowed), don't do that here; all functions should be self-contained. Also, none of these functions should use recursion. This code will go into the file <code>lab1c.imp</code>.</p> <p>Note</p> <p>Even if the previous implementation(s) of the functions you are writing used helper functions, do not use helper functions for any of the functions here. Having local variables will make helper functions unnecessary.</p>"},{"location":"assignments/1/partC/#1-sigma3","title":"1. <code>sigma3</code>","text":"<p>[4 points]</p> <p>Rewrite the <code>sigma2</code> function so it uses <code>while*</code> and local variable(s). Call the new function <code>sigma3</code>.</p>"},{"location":"assignments/1/partC/#2-exp2","title":"2. <code>exp2</code>","text":"<p>[4 points]</p> <p>Rewrite <code>exp</code> so it uses <code>while*</code> and local variable(s). Call the new version <code>exp2</code>.</p>"},{"location":"assignments/1/partC/#3-fact3","title":"3. <code>fact3</code>","text":"<p>[3 points]</p> <p>Define a version of <code>fact2</code> which uses local variable(s) and a <code>for</code> loop. Call it <code>fact3</code>.</p>"},{"location":"assignments/1/partC/#4-fib3","title":"4. <code>fib3</code>","text":"<p>[4 points]</p> <p>Define a version of <code>fib2</code> which uses local variable(s) and a <code>for</code> loop. Call it <code>fib3</code>.</p>"},{"location":"assignments/2/assignment2/","title":"Assignment 2: The uScheme language","text":""},{"location":"assignments/2/assignment2/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, May 3rd at 2 AM.</p>"},{"location":"assignments/2/assignment2/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 7.</p>"},{"location":"assignments/2/assignment2/#code-base","title":"Code base","text":"<p>We are supplying you with a zip file called <code>uscheme.zip</code>. It contains two subdirectories: <code>sexpr</code> and <code>uscheme</code>. The <code>sexpr</code> subdirectory contains the code to parse S-expressions from strings and files. The <code>uscheme</code> subdirectory contains the base implementation of the <code>uscheme</code> language, which (unlike Imp) is spread over a number of files. You should unzip the file in a directory and do the following:</p> <ul> <li><code>cd</code> into the <code>sexpr</code> subdirectory and run <code>make</code>.</li> <li>Then <code>cd</code> into the <code>uscheme</code> subdirectory and run <code>make</code>.</li> </ul> <p>If all goes well, this should create the <code>uscheme</code> executable, which you can run as follows:</p> <pre><code>$ ./uscheme\n</code></pre> <p>If you've installed <code>rlwrap</code> (see the last assignment), you should run it like this:</p> <pre><code>$ rlwrap ./uscheme\n</code></pre> <p>That way you will get nice line-editing features.</p> <p>Warning</p> <p>The version of <code>uscheme</code> we supply you with is unfinished. If you run it, it will start up but you won't be able to do much until you add a few missing features. The sections below describe what you have to do.</p>"},{"location":"assignments/2/assignment2/#what-to-hand-in","title":"What to hand in","text":"<p>You will hand in these files:</p> <ul> <li><code>ast.mli</code></li> <li><code>ast.ml</code></li> <li><code>ir.mli</code></li> <li><code>ir.ml</code></li> <li><code>env.mli</code></li> <li><code>env.ml</code></li> <li><code>error.mli</code></li> <li><code>error.ml</code></li> <li><code>quote.ml</code></li> <li><code>eval.ml</code></li> <li><code>basis.ml</code></li> <li><code>uscheme.ml</code></li> <li><code>lab2c.scm</code>  (from the <code>tests</code> subdirectory)</li> </ul>"},{"location":"assignments/2/debugging/","title":"Debugging","text":"<p>Debugging a multi-file OCaml project can be challenging. Here are some tips and tricks to make it less painful.</p>"},{"location":"assignments/2/debugging/#about-repls","title":"About REPLs","text":"<p>The term \"REPL\" is an acronym meaning \"Read-Eval-Print-Loop\". It's a fancy name for an interactive interpreter. Many languages have REPLs, such as Python, Ruby, almost all Scheme and Lisp dialects, OCaml, and Haskell. Other languages like C, C++ and Go do not. (Java didn't originally, but now has the <code>jshell</code> REPL.)</p> <p>The reason that REPLs are popular is that they are a big help for debugging, for writing quick throwaway code to explore an unfamiliar library, and as a way to interactively prototype a solution. Here, we're going to concentrate on using REPLs for debugging.</p> <p>Each project in CS 131 has two REPLs: the OCaml REPL and the REPL for the language being implemented. Each of them has different uses, which we'll describe below.</p>"},{"location":"assignments/2/debugging/#using-the-uscheme-repl","title":"Using the uScheme REPL","text":"<p>Running <code>make test</code> will work fine if all of the tests pass, but if a test fails, you have to dig deeper. Since each of the languages we will implement provides a REPL, it makes sense to use it to help understand when a test fails.</p> <p>The first thing to do when a test fails is to determine which test file contained the failing test. The output from <code>make test</code> will tell you this.</p> <p>The second thing is to isolate which test in the file failed. For most test failures (where the output of some code isn't what was expected), the output of <code>make test</code> will also tell you this. However, there are cases when <code>make test</code> doesn't give you enough information. An example would be when the code in a <code>check-expect</code> test loops forever. You will be told that a test in a particular file timed out, but not which test timed out. What do you do then?</p> <p>Fundamentally, all that <code>make test</code> is doing is running the uScheme interpreter on all of the test files, and collecting and displaying the output if a test fails. You can also manually run a test file.  For instance, if a test in <code>tests/lists.scm</code> fails, you can type:</p> <pre><code>$ ./uscheme tests/lists.scm\n</code></pre> <p>and look at the output. At this point, your main goal is to find the test that failed.</p> <p>The output from tests run interactively is more verbose than the output from just running <code>make test</code>. For instance, passing tests will also print the location of the test that passed.</p> <p>Let's define a simple test file called <code>foo.scm</code> and put it in the <code>tests</code> directory:</p> <pre><code>;; foo.scm\n(check-expect (+ 1 1) 2)\n(define loop () (loop))\n(check-expect (loop) 0)\n(check-expect (* 2 3) 6)\n</code></pre> <p>Looking at this, you can see that the <code>loop</code> function will loop indefinitely. If you run this file, here's what you see:</p> <pre><code>$ ./uscheme tests/foo.scm\ncheck-expect test passed (tests/foo.scm: 2:1-24)\n</code></pre> <p>and then it will hang (loop forever). The test output at least tells you that the last passing test was at line 2. So you should look for the test following the test on line 2, which is the one that calls <code>(loop)</code> and thus loops forever. (Of course, most examples will be more complicated than this.)</p> <p>Once you have located the test that fails, try running it interactively in the uScheme REPL:</p> <pre><code>$ ./uscheme\n&gt;&gt;&gt; (define loop () (loop))\n&gt;&gt;&gt; (loop)  ; runs forever\n</code></pre> <p>This allows you to confirm what the problem is. Now you've narrowed down the problem significantly.</p>"},{"location":"assignments/2/debugging/#using-the-ocaml-repl","title":"Using the OCaml REPL","text":"<p>Often a bug won't be in the code you write in uScheme but in the OCaml code you write to implement the interpreter. Finding these bugs can be tricky. For simple OCaml programs (like most of the ones in CS 4), you can simply load files into the OCaml REPL (<code>utop</code>) using the <code>#use</code> directive:</p> <pre><code># #use \"lab3.ml\";;\n</code></pre> <p>and then test the functions interactively to see if they are doing the right thing. But with a large multi-file program like the interpreters in this assignment (and in the rest of the course), it's not as easy.</p> <p>Starting with this assignment, we've added a <code>Makefile</code> target that will allow you to open an OCaml REPL (using <code>utop</code>) \"pre-loaded\" with the code from the assignment. The steps are:</p> <ol> <li> <p>Compile the code (type <code>make</code>).</p> </li> <li> <p>Type <code>make repl</code>. That will start up <code>utop</code> with the code for the assignment pre-loaded.</p> </li> <li> <p>Inside <code>utop</code>, experiment with the functions that you think aren't working correctly.</p> </li> </ol> <p>Here's an example to show how this works:</p> <pre><code>$ make\n$ make repl\n# open Env;;\n# string_of_value (IntVal 10);;\n- : string = \"10\"\n</code></pre> <p>Technically, we could have omitted the <code>open Env;;</code> line and typed <code>Env.string_of_value (IntVal 10);;</code>, but it's nice not to have to qualify all names from a module.</p> <p>Using the REPL is useful when you think a specific function is giving the wrong answer for a specific set of inputs. It's not always easy to use, though, since sometimes it's hard to create the necessary inputs. But it will make debugging easier in many cases.</p>"},{"location":"assignments/2/debugging/#the-ocaml-debugger","title":"The OCaml debugger","text":"<p>The most extreme approach is to use the OCaml debugger. This will allow you to step through your code with microscopic precision.</p> <p>To run the OCaml debugger on your code, compile it normally and then just call it with the <code>ocamldebug</code> program:</p> <pre><code>$ make\n$ ocamldebug ./uscheme\n        OCaml Debugger version 5.1.1\n\n(ocd)\n</code></pre> <p>The <code>(ocd)</code> is the OCamldebug prompt. To run the interpreter, type <code>run</code>:</p> <pre><code>(ocd) run\n&gt;&gt;&gt; (+ 1 2)\n3\n</code></pre> <p>Now, if there is code that crashes the interpreter, you can enter it and the debugger will halt on the crash. You can set breakpoints, move back in time (!) and do all the things you can usually do in debuggers.</p> <p>Warning</p> <p>Line-by-line debugging, which you're probably used to from imperative languages, doesn't really work in functional languages like OCaml. Instead, the debugger works on \"events\", which are \"interesting\" locations in the source code. This means that the learning curve for using the debugger is greater than that in an imperative language. This is one reason why few OCaml programmers use the debugger. (The others are the excellent OCaml REPL and the type checker, which catch most simple bugs.) Nevertheless, for really tricky bugs, it's good to have the debugger available.</p>"},{"location":"assignments/2/partA_extending1/","title":"Part A: Finishing and extending uScheme: parsing  (50 points)","text":"<p>In this section, you will be completing the parsing of forms to IR forms (described below) by implementing desugarings and adding features to the AST and IR.</p>"},{"location":"assignments/2/partA_extending1/#intermediate-representations","title":"Intermediate representations","text":"<p>The theme of this assignment is intermediate representations (called \"IR\" for short). Previously we've assumed that the interpreter converts the S-expression representation to an AST representation and then directly evaluates the AST representation. However, the main purpose of an AST is to serve as a faithful representation of the language syntax that is easy to manipulate inside a program. ASTs are generally not the optimal form for evaluators to work on. For one thing, there are almost always forms in the AST that aren't necessary, because they can be desugared into simpler forms.</p> <p>Note</p> <p>\"Desugaring\" a form means to convert it to an equivalent form which will give the exact same result when evaluated, but which is \"simpler\" in some sense. In our case, we want the desugared form to be converted to another form that already exists, so the evaluator has fewer forms that it needs to be able to handle. The fewer the forms an evaluator needs to handle, the easier it is to write.</p> <p>In assignment 1, we saw one way to desugar forms, which was by directly converting S-expressions into other S-expressions. However, there are two problems with this approach:</p> <ul> <li>Working with S-expressions directly is very tedious in OCaml.</li> <li>Most languages don't even use S-expressions.</li> </ul> <p>Some languages (notably most Lisp and Scheme dialects) contain powerful macro systems that operate at the level of S-expressions, and given a good enough macro system, desugaring at the level of S-expressions makes sense. (Probably the most powerful macro system ever implemented in a programming language is the one at the heart of the Racket family of languages. Check it out sometime.)</p> <p>However, we don't have a macro system in uScheme, so we will do something more conventional: we will not desugar S-expressions, but instead we will convert them to AST expressions as usual, and then convert AST expressions into a simpler intermediate representation (or IR for short). This IR form is like an AST form except that there is no redundancy; all AST expressions that can be converted to simpler expressions are converted. Furthermore, this conversion happens before the evaluator ever sees the code, so that there is no need to convert the same expression over and over, which may occur if the evaluator interprets the AST directly. The cost is that you have one more conversion step before you can evaluate the code, but this is usually a cost worth paying.</p> <p>Note that by converting AST forms into IR forms, we will write what in compiler terminology is called a simplification pass. Many forms will be nearly identical in both the AST and IR (so converting them will be tedious \"boilerplate\" code) but some forms will change and others will be eliminated altogether. We'll describe all the changes below.</p> <p>Note</p> <p>Yes, you are actually writing a compiler. It's a very simple compiler, and it doesn't output machine code or assembly language, but it's a compiler nonetheless, because it takes in one representation of a language (the AST) and outputs a different one (the IR).</p> <p>Note also that many (most?) languages have more than one intermediate representation. \"Real\" compilers, in particular, usually have a number of IRs, and the output of one IR transformation is the input to the next one. There are many things that can be done in IRs; simplification is only one of them. (Take CS 164 if you want to learn more about compilers and their IRs.)</p> <p>Before beginning, take a look at the <code>expr</code> and <code>def</code> type definitions in the <code>ast.mli</code> and <code>ir.mli</code> files. Notice which forms are present in the AST types but not in the IR types. This is where the desugaring will happen. (You will also be making some modifications to both the AST and IR types.)</p> <p>The files that you need to change for this section are:</p> <ul> <li><code>ast.mli</code></li> <li><code>ast.ml</code></li> <li><code>ir.mli</code></li> <li><code>ir.ml</code></li> </ul>"},{"location":"assignments/2/partA_extending1/#1-implementing-simple-desugarings","title":"1. Implementing simple desugarings","text":"<p>[10 points]</p> <p>The code base we have provided for you defines the IR in the files <code>ir.ml</code> and <code>ir.mli</code>. These files define the IR types <code>expr</code> and <code>def</code> and contain most of the code for converting between AST and IR forms. However, the conversion code for one expression form (corresponding to <code>let*</code> forms) and two definition forms (corresponding to <code>define</code> forms and top-level expressions) are not implemented. Since the basis functions defined in <code>basis.ml</code> use <code>define</code> in particular, you can't run this interpreter as is. Therefore, your first task is to finish implementing the code in <code>ir.ml</code> by replacing the <code>failwith \"TODO\"</code> expressions with code that implements the correct transformations.</p> <p>Note that the evaluator code in <code>eval.ml</code> acts on IR expressions, not AST expressions. You will need to modify that code in various ways, but not in this section.</p> <p>Here are the transformations we want you to implement:</p>"},{"location":"assignments/2/partA_extending1/#a-let","title":"a. <code>let*</code>","text":"<p>For <code>let*</code>, use the transformation:</p> <pre><code>(let* () e) --&gt; e\n(let* ([x1 e1] [x2 e2] ...) e) --&gt; (let ([x1 e1]) (let* ([x2 e2] ...) e))\n; repeat until there are no more \"let*\" expressions\n</code></pre> <p>Warning</p> <p>This is not a transformation at the level of S-expressions; we're only writing it in terms of S-expressions for the sake of brevity. In actual fact, you would be converting <code>LetStar (...)</code> expressions (in the AST) into nested <code>Let (...)</code> expressions (in the IR).</p> <p>If you implement this at the S-expression level you will get no credit (and you'll work much harder than you should!). This also applies to all the transformations we describe below.</p> <p>If you find this transformation tedious, reread the operational semantics for <code>let*</code> in lecture 6. Then feel better knowing that you don't have to implement this in the evaluator! One of the great things about desugaring is that it simplifies the evaluator, which also means that it makes it much easier to get the evaluator correct (and to prove it correct, if you're so inclined). Of course, you can specify the desugaring in the operational semantics as well.</p>"},{"location":"assignments/2/partA_extending1/#b-define","title":"b. <code>define</code>","text":"<p>For <code>define</code>, use the transformation:</p> <pre><code>(define f (x1 x2 ...) e) --&gt; (val f (lambda (x1 x2 ...) e))\n</code></pre> <p>Again, this is not a transformation at the level of S-expressions but at the level of the AST and IR forms. In fact, the IR doesn't even have a <code>Define</code> form, so this transformation is necessary.</p>"},{"location":"assignments/2/partA_extending1/#c-top-level-expressions","title":"c. Top-level expressions","text":"<p>For top-level expressions, use the transformation:</p> <pre><code>e --&gt; (val _ e)\n</code></pre>"},{"location":"assignments/2/partA_extending1/#2-extending-literals","title":"2. Extending literals","text":"<p>[5 points]</p> <p>In both the AST and the IR, the only kind of literals are integers. But in reality, we have several literal values:</p> <ul> <li>integers</li> <li>booleans (the special identifiers <code>#t</code> and <code>#f</code>,   representing \"true\" and \"false\" respectively)</li> <li>the unit value <code>#u</code> (used as a return value for functions   that don't really return anything, like <code>println</code>)</li> </ul> <p>In addition, <code>nil</code> (the empty list) and quoted S-expressions could also be considered literals. We won't do that, because quoted S-expressions have their own AST form and <code>nil</code> is just an identifier we bind to the empty list value.</p> <p>Note</p> <p>These decisions are quite arbitrary. Programming language designers use their own sense of aesthetics to determine what forms to include and how to categorize them. For instance, we could easily have made <code>nil</code> into a literal, but it seems cleaner to us not to do that. In fact, most real Scheme implementations don't even define <code>nil</code>, using <code>'()</code> instead (which we can also use).</p>"},{"location":"assignments/2/partA_extending1/#adding-literals-to-the-ast","title":"Adding literals to the AST","text":"<p>In the AST module (the files <code>ast.mli</code> and <code>ast.ml</code>) extend the set of literals by defining a separate <code>lit</code> type. This type will have constructors for integers, booleans, and unit literals. Then rewrite the <code>Literal</code> constructor of the <code>expr</code> type so that it takes a <code>lit</code> value instead of an <code>int</code> value.</p> <p>Extend the <code>parse_expr</code> function so that it parses S-expressions representing literals into the corresponding AST literals.</p> <p>Remove the names <code>#u</code>, <code>#t</code> and <code>#f</code> from the list of reserved identifiers.  (These names are not identifiers any more.) Keep <code>nil</code> as the only reserved identifier.</p> <p>Note</p> <p>The purpose of this transformation is so that the evaluator doesn't have to waste time looking up the identifiers <code>#t</code>, <code>#f</code> and <code>#u</code> at run-time, since they can only represent one thing.</p>"},{"location":"assignments/2/partA_extending1/#adding-literals-to-the-ir","title":"Adding literals to the IR","text":"<p>In the IR module (the files <code>ir.mli</code> and <code>ir.ml</code>), add this line to the type definitions:</p> <pre><code>type lit = Ast.lit\n</code></pre> <p>and then change the <code>Literal</code> constructor so that it takes a <code>lit</code> value instead of an <code>int</code> value as well.</p> <p>Note</p> <p>Do not define a new <code>lit</code> type in the IR. Just re-use the AST <code>lit</code> type, because it's the same in the AST and the IR. We only define the type alias for convenience, so we can type <code>lit</code> instead of <code>Ast.lit</code>.</p> <p>Rewrite the <code>Literal</code> constructor of the IR so it takes a <code>lit</code> value instead of an <code>int</code> value.</p>"},{"location":"assignments/2/partA_extending1/#3-extending-let-lambda-define-and-while-forms","title":"3. Extending <code>let</code>, <code>lambda</code>, <code>define</code> and <code>while</code> forms","text":"<p>[10 points]</p> <p>Writing a <code>begin</code> expression for the body of a <code>let</code>, <code>lambda</code>, <code>define</code> or <code>while</code> expression when the body consists of more than one expression is annoying; let's fix that!</p> <p>Extend the <code>let</code>/<code>let*</code>/<code>letrec</code>, <code>lambda</code>, <code>define</code> and <code>while</code> forms in the AST to allow multiple expressions in the body. To do this, you have to modify the AST in <code>ast.ml</code> and <code>ast.mli</code> for the affected forms, then change the way S-expressions are converted to AST expressions (adding support for the new ways of writing the forms), and finally change the way AST expressions are converted to IR expressions in <code>ir.ml</code>. Note that the IR versions of these forms only have a single expression in the body, and the IR doesn't have <code>let*</code> or <code>define</code> forms.</p> <p>Warning</p> <p>The IR types should not change.</p> <p>In each case, the multiple body expressions evaluate as if they were wrapped in a <code>begin</code> expression, and when you convert them to IR expressions, you should explicitly wrap the body expressions with a <code>begin</code> expression.</p> <p>To be specific, here are the desugarings you need to make when converting between the AST and the IR forms (again written schematically as S-expression transformations, though that's not what they are).</p> <pre><code>(let ([&lt;name1&gt; &lt;expr1] ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)\n--&gt;\n(let ([&lt;name1&gt; &lt;expr1] ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))\n\n(let* ([&lt;name1&gt; &lt;expr1] ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)\n--&gt;\n(let* ([&lt;name1&gt; &lt;expr1] ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))\n[then desugar let* to let as described above]\n\n(letrec ([&lt;name1&gt; &lt;expr1] ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)\n--&gt;\n(letrec ([&lt;name1&gt; &lt;expr1] ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))\n\n(lambda (&lt;name1&gt; ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)\n--&gt;\n(lambda (&lt;name1&gt; ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))\n\n(define &lt;name&gt; (&lt;arg1&gt; ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)\n--&gt;\n(define &lt;name&gt; (&lt;arg1&gt; ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))\n\n(while &lt;test-expr&gt; &lt;body-expr1&gt; &lt;body-expr2&gt; ...)\n--&gt;\n(while &lt;test-expr&gt; (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))\n</code></pre> <p>One other thing: we do not allow empty bodies for <code>let</code>, <code>let*</code>, <code>letrec</code>, <code>lambda</code> expressions, or for <code>define</code> forms. (In contrast, an empty body is OK in a <code>while</code> expression.) So all of these are syntax errors:</p> <pre><code>(let ())\n(let* ())\n(letrec ())\n(lambda (x))\n(lambda args)\n(define foo ())\n(define foo args)\n</code></pre> <p>The test scripts will check for this.</p> <p>Tip</p> <p>Instead of counting the number of body expressions and raising a syntax error exception when there aren't any, you can enforce this by a clever use of pattern matching. Instead of matching zero or more expressions using <code>exprs</code>, match one or more expressions using <code>expr :: exprs</code>. Anything that doesn't match is a malformed form, and will be considered to be a syntax error.</p>"},{"location":"assignments/2/partA_extending1/#4-adding-the-cond-form","title":"4. Adding the <code>cond</code> form","text":"<p>[5 points]</p> <p>Real Scheme has a conditional expression form called <code>cond</code> which is easier to use than <code>if</code> for most applications. It has the following syntax:</p> <pre><code>(cond [&lt;test-exprA&gt; &lt;expr1a&gt; &lt;expr2a&gt; ...]\n      [&lt;test-exprB&gt; &lt;expr1b&gt; &lt;expr2b&gt; ...]\n       ...)\n</code></pre> <p>In other words, <code>cond</code> is followed by zero or more clauses, where each clause has a test expression (an expression which evaluates to a boolean value) followed by zero or more body expressions. <code>cond</code> evaluates each clause in order; if a test expression returns a true value (which in Scheme is any value that isn't explicitly false), then the body expressions are evaluated in order and the value of the last one is the value of the <code>cond</code> expression. If the test expression evaluates to false, the next clause is evaluated. If there are no more clauses, the <code>cond</code> returns a unit (<code>#u</code>) value. Note that a <code>cond</code> expression doesn't have to have any clauses, in which case it again returns <code>#u</code>.</p> <p>Note</p> <p>The square brackets are just for readability; they could be replaced with parentheses as long as they are balanced. You don't have to worry about this, since the <code>sexpr</code> library handles parsing S-expressions.</p> <p>If you want the equivalent of an \"else\" clause in a <code>cond</code> expression, just use <code>#t</code> for the test expression. This is normally done only in the last clause. (You could easily add <code>else</code> as a keyword with a little extra work, but don't do that.)</p> <p>The <code>cond</code> form exists in the AST only; it is desugared in the IR to a series of nested <code>if</code> forms. You need to add a <code>Cond</code> constructor to the AST, convert S-expressions to AST <code>Cond</code> forms where appropriate, and write the code to convert AST <code>Cond</code> forms to nested IR <code>If</code> forms. Here is the desugaring of <code>cond</code> to <code>if</code>:</p> <pre><code>(cond [&lt;test-exprA&gt; &lt;expr1a&gt; &lt;expr2a&gt; ...]\n      [&lt;test-exprB&gt; &lt;expr1b&gt; &lt;expr2b&gt; ...]\n       ...)\n--&gt;\n(if &lt;test-exprA&gt; (begin &lt;expr1a&gt; &lt;expr2a&gt; ...)\n    (cond [&lt;test-exprB&gt; &lt;expr1b&gt; &lt;expr2b&gt; ...]\n          ...))\n[repeat until there are no more \"cond\" expressions]\n\n(cond) --&gt; #u\n</code></pre> <p>Finally, add <code>cond</code> to the list of keywords in <code>ast.ml</code>.</p>"},{"location":"assignments/2/partA_extending1/#5-adding-the-and-and-or-forms","title":"5. Adding the <code>and</code> and <code>or</code> forms","text":"<p>[5 points]</p> <p>Add <code>and</code> and <code>or</code> expression forms to the language. In the AST they will be represented as <code>And</code> and <code>Or</code> constructors. Write the code to convert from S-expressions to AST <code>And</code>/<code>Or</code> forms where appropriate. Note that both forms are variadic i.e. they can take any number of arguments, including zero. The IR does not have <code>And</code> or <code>Or</code> constructors; instead, convert them to <code>Let</code> and <code>If</code> forms, using this desugaring:</p> <pre><code>(and) --&gt; #t\n(and x) --&gt; x\n(and x y z ...) --&gt; (if x (and y z ...) #f)\n[repeat until there are no more \"and\" expressions]\n\n(or) --&gt; #f\n(or x) --&gt; x\n(or x y z ...) --&gt; (let (({or} x)) (if {or} {or} (or y z ...)))\n[repeat until there are no more \"or\" expressions]\n</code></pre> <p>Note that the <code>And</code> AST form gets converted to a series of nested <code>If</code> IR forms, whereas an <code>Or</code> AST form gets converted to a combination of <code>Let</code> and <code>If</code> forms. The <code>{or}</code> in the desugaring is the actual string <code>\"{or}\"</code>, which you should use as an identifier; this is safe because actual uScheme identifiers can't have curly braces, so this synthesized identifier can't be captured by any user code.</p> <p>Note</p> <p>The problem of variable capture when desugaring expressions into expressions that contain new identifiers is complex and subtle; this is a hack that will work in this specific case, but it's not a good general approach. To get a feel for the issues involved, think about what could happen if, instead of using <code>{or}</code> as an identifier, you just used <code>x</code>. Could this break under any circumstances?</p> <p>Finally, add <code>and</code> and <code>or</code> to the list of keywords in <code>ast.ml</code>.</p>"},{"location":"assignments/2/partA_extending1/#6-adding-the-valrec-form","title":"6. Adding the <code>valrec</code> form","text":"<p>[5 points]</p> <p>A <code>val</code> or <code>define</code> definition can be bound to a recursive function, but we can't do that with mutually recursive functions. (In language terminology, this is called a \"language wart\" i.e. a misfeature or missing feature.) We will fix this limitation in this problem.</p> <p>Define a <code>valrec</code> definition form that supports both recursion and mutual recursion. Use this syntax:</p> <pre><code>(valrec\n  [f ...]\n  [g ...]\n  ...)\n</code></pre> <p>The binding expressions (the <code>...</code> parts following the names <code>f</code> and <code>g</code> in this case) can be arbitrary uScheme expressions, but are normally <code>lambda</code> expressions. There can be any number of bindings, but there must be at least one. The semantics and its implementation will be discussed in part B.</p> <p>An empty <code>valrec</code> form (i.e. <code>(valrec)</code>) should be a syntax error. As with <code>let</code> expressions, all the names that are bound in a <code>valrec</code> expression must be unique.</p> <p>Implement the <code>valrec</code> syntax by extending the AST and IR type definitions to include <code>ValRec</code> constructors:</p> <pre><code>(* In ast.ml and ast.mli: *)\ntype def =\n  | ...\n  | ValRec of loc * (id * expr) list\n  | ...\n\n(* In ir.ml and ir.mli: *)\ntype def =\n  | ...\n  | ValRec of loc * (id * expr) list\n  | ...\n</code></pre> <p>Note that the form of the constructors is identical in the AST and the IR. Extend the code in <code>ast.ml</code> that converts from S-expressions to AST forms so that it correctly parses <code>valrec</code> forms (including error checking).</p> <p>Finally, add <code>valrec</code> to the list of keywords in <code>ast.ml</code>.</p>"},{"location":"assignments/2/partA_extending1/#7-functions-with-variable-numbers-of-arguments","title":"7. Functions with variable numbers of arguments","text":"<p>[10 points]</p> <p>Actual Scheme implementations allow us to define functions that can take a variable number of arguments. In fact, in real Scheme, many common functions, like <code>+</code>, <code>*</code>, <code>&lt;</code> etc. take arbitrary numbers of arguments (sometimes including zero). Some functions, like the <code>list</code> function which creates new lists, have to take arbitrary numbers of arguments because we don't know in advance how many values the list being created will contain. In this problem, we'll extend the <code>lambda</code> and <code>define</code> forms so that they can handle arbitrary numbers of arguments (including zero).</p> <p>Note</p> <p>Of course, not all functions will accept arbitrary numbers of arguments, but enforcing that is the responsibility of the function; it's not a syntax error.</p> <p>To do this, we will implement two new forms in the AST: <code>LambdaX</code> and <code>DefineX</code>, representing (respectively) <code>lambda</code> expressions and <code>define</code> expressions that can take arbitrary numbers of arguments. (The old <code>Lambda</code> and <code>Define</code> constructors are still present in the AST.) The new constructors are as follows:</p> <pre><code>(* in ast.ml: *)\n\ntype expr =\n  | ...\n  | LambdaX of loc * id list * id * expr list\n  | ...\n\ntype def =\n  | ...\n  | DefineX of loc * id * id list * id * expr list\n  | ...\n</code></pre> <p>The last <code>id</code> field in each new constructor represents the name of the argument which will be bound to a list of all non-required argument values (often referred to as the \"rest\" arguments because they contain the rest of the arguments after the required ones are bound).</p> <p>Warning</p> <p>When we say \"bound to a list of all non-required argument values\" we have to be very careful what we mean by a list.</p> <p>When a <code>lambda</code> expression with a rest argument is applied to its actual arguments, whichever ones are not matched by name (i.e. whichever \"extra\" arguments are present) are converted into a uScheme list (not an OCaml list!) and are bound to the name of the rest argument while evaluating the body of the <code>lambda</code>.</p> <p>Since the environment can only bind names to uScheme values, this list must be a single uScheme value i.e. a list that can be created out of other uScheme values. The way to build lists in any Scheme dialect is to create chains of pairs ending in <code>nil</code>, where the list elements are stored in the <code>car</code> (first element) of the pairs, and the <code>cdr</code> (second element) of each pair is the pair that contains the rest of the list, or <code>nil</code> if the list ends there. So a uScheme list is a chain of <code>PairVal</code> constructors ending in a <code>NilVal</code> constructor. The <code>NilVal</code> constructor represents the empty list when used by itself or the end of the list when used with pairs.</p> <p>The concrete syntax for these forms is as follows. For <code>lambda</code>, there are two cases:</p> <ul> <li> <p>a function which takes a single argument which represents all the arguments of the function looks like this: <code>(lambda args &lt;body&gt;)</code>. (Note that <code>args</code> is not surrounded by parentheses.)</p> </li> <li> <p>a function which takes one or more required arguments and then an argument representing all other (non-required) arguments looks like this: <code>(lambda (x y . rest) &lt;body&gt;)</code>.</p> </li> </ul> <p>In both cases, <code>&lt;body&gt;</code> represents the body of the <code>lambda</code> expression, which can be one or more expressions (but not zero expressions, as mentioned above).</p> <p>When the first form (<code>(lambda args &lt;body&gt;)</code>) is applied to its arguments, those arguments are bound to the <code>args</code> formal parameter as a (uScheme) list of values (of course, the name of the formal parameter doesn't have to be <code>args</code>). When the second form is applied to its arguments, all formal parameters before the <code>.</code> represent required arguments, so they are taken from the values at the front of the argument list; any arguments left over become bound to the <code>rest</code> formal parameter as a list of values (again, the argument doesn't have to be called <code>rest</code>). In the second form, the dot (<code>.</code>) is special syntax; it does not represent an identifier. Only a single argument can follow the dot in the argument list, or it's a syntax error. Similarly, the dot can't be the first or last thing in the argument list or it's a syntax error.</p> <p>The <code>define</code> form is extended similarly:</p> <ul> <li> <p>a function which takes a single argument which represents all the arguments of the function is defined like this: <code>(define &lt;name&gt; args &lt;body&gt;)</code>. (Again, <code>args</code> is not surrounded by parentheses.)</p> </li> <li> <p>a function which takes one or more required arguments and then an argument representing all other (non-required) arguments is defined like this: <code>(define foo (x y . rest) &lt;body&gt;)</code>.</p> </li> </ul> <p>If a <code>lambda</code> or <code>define</code> form doesn't use the new syntax, it should be converted into the <code>Lambda</code> or <code>Define</code> AST forms as before. If it does, it should be converted into <code>LambdaX</code> or <code>DefineX</code>, respectively.</p> <p>At the level of the IR, there are no <code>Define</code> or <code>DefineX</code> constructors in the <code>def</code> type. There is also no <code>LambdaX</code> constructor, but you will change the definition of <code>Lambda</code> to this:</p> <pre><code>(* In ir.ml: *)\n\ntype expr =\n  | ...\n  | Lambda of loc * id list * id option * expr\n  | ...\n</code></pre> <p>The only change is that the <code>id option</code> field has been added. When the <code>lambda</code>/<code>define</code> doesn't use arbitrary numbers of arguments, this field should be <code>None</code>; otherwise, it should be <code>Some &lt;name&gt;</code> where <code>&lt;name&gt;</code> is the name of the formal parameter which represents all non-required arguments. Having only a single <code>Lambda</code> form in the IR helps keep the evaluator simple (which is the whole reason we're using an IR in the first place!)</p> <p>Note that a <code>lambda</code> expression of the form <code>(lambda &lt;name&gt; ...)</code> (representing a function with one argument that gets all the actual arguments) will have an empty <code>id list</code> field but the <code>id option</code> field will be <code>Some &lt;name&gt;</code>.</p> <p>Wow, that took a while to explain! Now here is what you need to do:</p> <ol> <li> <p>Extend the AST as described above.</p> </li> <li> <p>Extend the functions which convert from S-expressions to AST expressions/definitions so that they can handle the new <code>lambda</code> and <code>define</code> forms.</p> <p>Warning</p> <p>Make sure you check for syntax errors involving improper use of the <code>.</code> syntax! All of these forms are errors:</p> <pre><code>; can't have \".\" as the first thing in the argument list...\n(lambda (. x) ...)\n\n; ... or as the last\n(lambda (x .) ...)\n\n; \".\" can't be followed by more than one argument name\n(lambda (x y . z w) ...)\n\n; can't have more than one \".\" in an argument list\n(lambda (x . y . z) ...)\n\n; same, but for \"define\"\n(define foo (. x) ...)\n(define foo (x .) ...)\n(define foo (x y . z w) ...)\n(define foo (x . y . z) ...)\n</code></pre> <p>In addition, using <code>\".\"</code> as a variable name in a <code>val</code> or <code>let</code>/<code>let*</code>/<code>letrec</code>/<code>valrec</code> expression is an error, and you have to check for this.</p> <p>Checking that the dot is used correctly in argument lists is quite tedious. Making sure it isn't used as a variable name is also tedious. You could make <code>.</code> a keyword (which would also prevent it from being used as a variable name), but we found it easier to make it a special case and write some helper functions instead. You can use your own coding judgment, but here are some test cases that should all cause syntax errors (and not e.g. name errors). Note that we can't use <code>check-error</code> with these forms (why?).</p> <pre><code>. ; not just a name error!\n\n(val . 10)\n\n(set . 10)  ; not just a name error!\n\n(valrec [. 10])\n\n(let ([. 10]) 10)\n(let ([. 10]) .)\n\n(let* ([. 10]) 10)\n(let* ([. 10]) .)\n\n(letrec ([. 10]) 10)\n(letrec ([. 10]) .)\n\n(lambda (. x) .)\n(lambda (. x) x)\n(lambda (x .) .)\n(lambda (x .) x)\n(lambda (x . y z) .)\n(lambda (x . y z) x)\n(lambda (x . y . z) x)\n\n(define foo (. x) .)\n(define foo (. x) x)\n(define foo (x .) .)\n(define foo (x .) x)\n(define foo (x . y z) .)\n(define foo (x . y z) x)\n(define foo (x . y . z) x)\n</code></pre> <p>To test for syntax errors, we have a shell script that runs uScheme on files containing syntax errors and checks for the phrase \"syntax error\" in the output. It's crude but it works.</p> </li> <li> <p>Extend the IR as described above. This will involve changes to the files <code>ir.ml</code> and <code>ir.mli</code>.</p> </li> <li> <p>Extend the functions that convert from AST expressions/definitions to IR expressions/definitions so that they can handle the new forms. This will involve additional changes to the file <code>ir.ml</code>.</p> </li> </ol> <p>There will be additional modifications needed (notably to the evaluator); we'll cover those in the next section.</p>"},{"location":"assignments/2/partB_extending2/","title":"Part B: Finishing and extending uScheme : evaluation (35 points)","text":"<p>Now that we've dealt with the parsing issues, we can concentrate on making the entire extended version of uScheme work.</p>"},{"location":"assignments/2/partB_extending2/#1-literals","title":"1. Literals","text":"<p>[5 points]</p> <p>Edit the literal-handling code in <code>eval.ml</code> to work with the new literal type.</p>"},{"location":"assignments/2/partB_extending2/#2-the-primitive-function","title":"2. The <code>=</code> primitive function","text":"<p>[5 points]</p> <p>Make the <code>=</code> primitive function (defined in <code>basis.ml</code>) work with unit values and symbols as well as all other atomic values. (It doesn't work for compound data types like pairs; the <code>equal</code> basis function takes care of that.) Note that the function <code>prim_eq</code> is the one that defines the <code>=</code> primitive.</p> <p>The only file you need to change for this problem is <code>basis.ml</code>.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; (= 0 0)\n#t\n&gt;&gt;&gt; (= 0 1)\n#f\n&gt;&gt;&gt; (= #u #u)\n#t\n&gt;&gt;&gt; (= #f #f)\n#t\n&gt;&gt;&gt; (= #f #t)\n#f\n&gt;&gt;&gt; (= 'foo 'foo)\n#t\n&gt;&gt;&gt; (= 'foo 'bar)\n#f\n</code></pre>"},{"location":"assignments/2/partB_extending2/#3-extending-pairs","title":"3. Extending pairs","text":"<p>[5 points]</p> <p>Change the representation of pairs in <code>env.ml</code>'s <code>value</code> type to be pairs of <code>value ref</code>s instead of pairs of <code>value</code>s. In other words, make pairs mutable. Once you have done this, change the definition of the pair primitives <code>cons</code>, <code>car</code>, and <code>cdr</code> (in <code>basis.ml</code>) to use the new representation. Add two new primitives to <code>basis.ml</code>: <code>set-car</code> and <code>set-cdr</code>. They both take two arguments: a <code>cons</code> pair and a value. <code>set-car</code> changes the <code>car</code> of the pair to the value, while <code>set-cdr</code> changes the <code>cdr</code>. Both primitives return unit (<code>#u</code>) values.</p> <p>Make whatever other changes may be necessary after making this change. The compiler will helpfully point out all places where the old pair definition is no longer valid. (Strongly statically-typed languages like OCaml are really good for refactorings of this sort.)</p> <p>The files you need to change for this problem are <code>env.ml</code>, <code>env.mli</code>, <code>quote.ml</code>, and <code>basis.ml</code>. Look at the way primitive functions are defined in <code>basis.ml</code> to understand how to define a new one.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; (val p (cons 1 2))\nval p = '(1 . 2)\n&gt;&gt;&gt; (car p)\n1\n&gt;&gt;&gt; (cdr p)\n2\n&gt;&gt;&gt; (set-car p 42)\n&gt;&gt;&gt; (car p)\n42\n&gt;&gt;&gt; p\n'(42 . 2)\n&gt;&gt;&gt; (set-cdr p 101)\n&gt;&gt;&gt; (cdr p)\n101\n&gt;&gt;&gt; p\n'(42 . 101)\n</code></pre>"},{"location":"assignments/2/partB_extending2/#4-the-equal-basis-function","title":"4. The <code>equal?</code> basis function","text":"<p>[2 points]</p> <p>There is a function called <code>equal?</code> in <code>basis.ml</code> which is commented out (indicated by a <code>TODO</code> comment). Remove the <code>TODO</code> comment and uncomment the function.</p>"},{"location":"assignments/2/partB_extending2/#5-the-valrec-definition-form","title":"5. The <code>valrec</code> definition form","text":"<p>[5 points]</p> <p>In part A you implemented the syntax for the <code>valrec</code> definition form. This form is used to define mutually-recursive functions at the top level. It looks like this:</p> <pre><code>(valrec\n  [f ...]\n  [g ...])\n</code></pre> <p>The <code>...</code> parts are normally <code>lambda</code> expressions. The semantics are similar to <code>letrec</code>:</p> <ul> <li> <p>Extend the environment with new bindings of all the names to be defined in the <code>valrec</code> (here, just <code>f</code> and <code>g</code>) to unspecified values.</p> </li> <li> <p>Evaluate the expressions (the <code>...</code> parts) in the context of the extended environment.</p> </li> <li> <p>Rebind the defined names to the values of the corresponding expressions.</p> </li> </ul> <p>Also, an empty <code>valrec</code> form (i.e. <code>(valrec)</code>) should be a syntax error.</p> <p>Note</p> <p>The main difference between <code>valrec</code> and <code>letrec</code> is that <code>valrec</code> has no body and the bindings are visible in the rest of the file.</p> <p>Implement the <code>valrec</code> semantics in the evaluator code in <code>eval.ml</code> (in the function <code>eval_def</code>).</p> <p>Once this is done, you'll be able to define mutually-recursive functions at the top level easily:</p> <pre><code>(valrec\n  [even? (lambda (n) (if (= n 0) #t (odd?  (- n 1))))]\n  [odd?  (lambda (n) (if (= n 0) #f (even? (- n 1))))])\n</code></pre> <p>When a <code>valrec</code> form is entered at the REPL, it needs to be evaluated, and then the names bound should be printed out along with their values, just like is done with a <code>val</code> expression. Extend the REPL printing code in <code>uscheme.ml</code> (specifically, the <code>repl_print</code> helper function) to achieve this.</p> <p>Note</p> <p><code>valrec</code> returns an environment and a uScheme value, like all definition forms. In this case, the uScheme value needs to be able to contain multiple values (for multiple mutually-recursive functions). To do this, create a uScheme value which is a uScheme list containing the values. (Recall that a uScheme list is made from pairs <code>cons</code>ed to each other and ending in a <code>nil</code> value.)</p> <p>The files you need to change for this problem are <code>eval.ml</code> and <code>uscheme.ml</code>.</p>"},{"location":"assignments/2/partB_extending2/#6-functions-with-variable-numbers-of-arguments","title":"6. Functions with variable numbers of arguments","text":"<p>[10 points]</p> <p>In part A, you implemented the syntax for functions with variable numbers of arguments. Here, you have to make them work.</p> <p>At the level of the IR, there is only one form we have to worry about, which is the (extended) <code>Lambda</code> form. (Hooray for desugaring!) Here is its definition:</p> <pre><code>(* In ir.ml: *)\n\ntype expr =\n  | ...\n  | Lambda of loc * id list * id option * expr\n  | ...\n</code></pre> <p>The <code>id list</code> represents the required arguments, the <code>id option</code> represents the \"rest\" argument for all the extra arguments after the required arguments (if a rest argument is used and if there are any more arguments), and the <code>expr</code> is the function body.</p> <p>Here is what you need to do:</p> <ol> <li> <p>You need to add an extra error constructor to the <code>uscheme_error_tag</code> type in <code>error.ml</code>:</p> <pre><code>...\n| CallErrorRest of int * int\n...\n</code></pre> <p>This represents invalid calls to functions with rest arguments (i.e. functions which can take arbitrary numbers of arguments). The first <code>int</code> is the number of required arguments expected, while the second is the number received. The number of received arguments must be at least as large as the number of required arguments, or it's an error. Define an OCaml function <code>call_err_rest</code> in analogy to <code>call_err</code> in <code>error.ml</code> and <code>error.mli</code> to make it easier to signal errors of this kind, and then use it where appropriate (i.e. in <code>eval.ml</code>).</p> </li> <li> <p>Modify the <code>value</code> type definition in <code>env.ml</code> and <code>env.mli</code>; specifically, change the <code>UserFuncVal</code> constructor to this:</p> <pre><code>type env = ...\nand value =\n  | ...\n  | UserFuncVal of Ast.id list * Ast.id option * Ir.expr * env\n  | ...\n</code></pre> <p>The <code>Ast.id option</code> field is <code>None</code> if the user function doesn't have a \"rest\" argument for non-required arguments, and it's <code>Some &lt;name&gt;</code> if it does.</p> </li> <li> <p>Extend the evaluator code in <code>eval.ml</code> to handle function calls involving the extended <code>Lambda</code> form. Here are the semantics:</p> <ul> <li> <p>If there is a \"rest\" argument:</p> <ul> <li> <p>If there are too few required arguments,   raise a <code>CallErrorRest</code> exception   using the <code>call_err_rest</code> function.</p> </li> <li> <p>Otherwise, bind the required arguments as usual,   collect all other arguments into a uScheme list,   and bind that list to the rest argument.</p> </li> </ul> </li> <li> <p>If there is no \"rest\" argument,   just call the function the usual way.</p> </li> </ul> </li> </ol> <p>You need to modify several different files in this problem: <code>env.ml</code>, <code>env.mli</code>, <code>error.ml</code>, <code>error.mli</code>, and <code>eval.ml</code>.</p>"},{"location":"assignments/2/partB_extending2/#7-other-modifications","title":"7. Other modifications","text":"<p>[3 points]</p> <p>You need to make a trivial modification in <code>uscheme.ml</code> on line 52:</p> <pre><code>let scheme_basis = \"\"\n</code></pre> <p>Change this to:</p> <pre><code>let scheme_basis = Basis.scheme_basis\n</code></pre> <p>This will make the interpreter load the uScheme \"basis\" (the built-in uScheme functions) when it starts. The reason this change wasn't already in the code is because, if it were there, the uScheme interpreter compiled from the unmodified code would crash as soon as it started. As is, it doesn't, so you can run e.g. syntax tests even if you haven't made any changes to the code.</p>"},{"location":"assignments/2/partC_programming/","title":"Part C: Programming in extended uScheme  (15 points)","text":"<p>Whew! If you got through parts A and B, relax. This part will be a breeze. </p> <p>In this section you will write a number of uScheme functions to test your implementation and also to get some practice writing idiomatic Scheme functions. You should use the file <code>uscheme/tests/lab2c.scm</code> as a template file. Just delete the lines that say</p> <pre><code>; TODO\n</code></pre> <p>and replace them with your code. The unit tests are already in the file, so once you've compiled uScheme, if you type <code>make test</code> at the terminal prompt, it will run these tests (as well as all the other ones). Alternatively, to run only the tests in this file, type:</p> <pre><code>$ ./uscheme tests/lab2c.scm\n</code></pre> <p>The template file also has the type of each function in a comment before the function, as documentation.</p> <p>All of these functions should be written in a functional style, without <code>set</code>, <code>begin</code> or <code>while</code> expressions (this is a requirement).</p> <p>Tip</p> <p>Look at the primitive uScheme functions defined in <code>basis.ml</code> and make sure you understand what each one does. That will make this section much easier.</p> <p>Here are the functions you have to write:</p>"},{"location":"assignments/2/partC_programming/#1-map","title":"1. <code>map</code>","text":"<p>[1 point]</p> <p>This function takes these arguments:</p> <ul> <li>a function of one argument <code>f</code></li> <li>a list <code>lst</code></li> </ul> <p>It returns a list obtained by applying the function <code>f</code> to each element of <code>lst</code> (like the OCaml <code>List.map</code> function).</p>"},{"location":"assignments/2/partC_programming/#2-filter","title":"2. <code>filter</code>","text":"<p>[1 point]</p> <p>This function takes these arguments:</p> <ul> <li>a function of one argument <code>f</code> that returns a boolean</li> <li>a list <code>lst</code></li> </ul> <p>It returns a list which consists of all the elements of <code>lst</code> for which the function <code>f</code> returns <code>#t</code> (in their original order). (This is like the OCaml <code>List.filter</code> function.) Use a <code>cond</code> expression to write the only conditional in the function (this is a requirement). Note that an \"else\" case in a <code>cond</code> can be simulated by having the test expression be simply <code>#t</code>.</p>"},{"location":"assignments/2/partC_programming/#3-exists","title":"3. <code>exists?</code>","text":"<p>[1 point]</p> <p>This function takes these arguments:</p> <ul> <li>a function of one argument <code>f</code> that returns a boolean</li> <li>a list <code>lst</code></li> </ul> <p>It returns <code>#t</code> if there is at least one element in <code>lst</code> for which the function <code>f</code> returns <code>#t</code>. Again, use a <code>cond</code> to write the conditional.</p>"},{"location":"assignments/2/partC_programming/#4-all","title":"4. <code>all?</code>","text":"<p>[1 point]</p> <p>This function is the same as <code>exists?</code> except that it only returns <code>#t</code> if the function <code>f</code> returns <code>#t</code> for all of the elements of <code>lst</code>. Again, use <code>cond</code>.</p>"},{"location":"assignments/2/partC_programming/#5-takewhile","title":"5. <code>takewhile</code>","text":"<p>[1 point]</p> <p>This function takes these arguments:</p> <ul> <li>a function of one argument <code>f</code> that returns a boolean</li> <li>a list <code>lst</code></li> </ul> <p>It returns all of the elements of <code>lst</code> up to but not including the first one for which the function <code>f</code> does not return <code>#t</code>. In other words, you \"take\" elements from the list \"while\" <code>f</code> returns <code>#t</code>, and then stop once it doesn't. This is not the same as <code>filter</code>!</p> <p>Using <code>cond</code> is not required (here or in the rest of the functions in this section), though it can certainly be done that way.</p>"},{"location":"assignments/2/partC_programming/#6-dropwhile","title":"6. <code>dropwhile</code>","text":"<p>[1 point]</p> <p>This is like <code>takewhile</code> except that it drops elements from the list argument until it finds one for which the function <code>f</code> returns <code>#f</code> (i.e. it \"drops\" elements \"while\" <code>f</code> returns <code>#t</code>), and then it returns the entire list starting from that element.</p>"},{"location":"assignments/2/partC_programming/#7-foldl","title":"7. <code>foldl</code>","text":"<p>[1 point]</p> <p>This function takes these arguments:</p> <ul> <li>a function of two arguments <code>f</code></li> <li>an initial value <code>init</code></li> <li>a list <code>lst</code></li> </ul> <p>It computes the result of applying the function <code>f</code> to <code>init</code> and the first element of <code>lst</code>, then applying <code>f</code> to that value and the next element of <code>lst</code>, and so on until all elements of <code>lst</code> have been processed. If <code>lst</code> is empty, <code>foldl</code> returns <code>init</code>. In other words, it's like the OCaml function <code>List.fold_left</code>.</p>"},{"location":"assignments/2/partC_programming/#8-foldr","title":"8. <code>foldr</code>","text":"<p>[1 point]</p> <p>This function takes the same arguments as <code>foldl</code> but \"folds from the right\". If <code>lst</code> is empty, again return <code>init</code>. Otherwise, apply the function <code>f</code> to the last element of <code>lst</code> and <code>init</code>, then apply <code>f</code> to the second-last element of <code>lst</code> and the result of the first application of <code>f</code>, etc.  until you get to the front of the list. In other words, it's like the OCaml function <code>List.fold_right</code>.</p>"},{"location":"assignments/2/partC_programming/#9-curry","title":"9. <code>curry</code>","text":"<p>[1 point]</p> <p>This function takes one argument: a function of two arguments <code>f</code>. It returns a curried version of this function, i.e. a function that takes a single argument which has the same type as the first argument of <code>f</code>, and returns a function of one argument which has the same type as the second argument of <code>f</code>. Applying either the original function or the curried function to the same two arguments gives the same result, though you need more parentheses if you're using the curried version.</p>"},{"location":"assignments/2/partC_programming/#10-uncurry","title":"10. <code>uncurry</code>","text":"<p>[1 point]</p> <p>This function takes a curried version of a function of two arguments and returns the uncurried version.</p>"},{"location":"assignments/2/partC_programming/#11-list","title":"11. <code>list</code>","text":"<p>[1 point]</p> <p>This function takes an arbitrary number of arguments and returns a list of the arguments. Use the special syntax for variadic functions you implemented in part A of this assignment. (This function's definition is therefore completely trivial.)</p> <p>Since this function is used in the test script <code>tests/lists</code>, once it is working, also add it to the basis functions in <code>basis.ml</code>.</p>"},{"location":"assignments/2/partC_programming/#12-extremum","title":"12. <code>extremum</code>","text":"<p>[2 points]</p> <p>We want to implement variadic <code>min</code> and <code>max</code>, that is <code>min</code> and <code>max</code> that can take an arbitrary number of arguments. Since the code for those two functions is so similar, we can factor it out by defining a function called <code>extremum</code> which takes two arguments: an operator <code>op</code> and a list of numbers <code>lst</code>. From this, <code>min</code> and <code>max</code> have the following definitions:</p> <pre><code>;; min : x1 x2 ... -&gt; min(x1, x2, ...)\n(define min lst (extremum &lt; lst))\n\n;; max : x1 x2 ... -&gt; max(x1, x2, ...)\n(define max lst (extremum &gt; lst))\n</code></pre> <p>Define <code>extremum</code>. Note that if <code>min</code> or <code>max</code> are applied to zero arguments, call the <code>error</code> function with the argument <code>'not-enough-arguments</code>. If they are applied to a single argument, return that argument. Otherwise, compute the minimum/maximum of the arguments.</p>"},{"location":"assignments/2/partC_programming/#13-o","title":"13. <code>o</code>","text":"<p>[2 points]</p> <p>This function takes a list of one-argument functions and composes all of them together. Specifically:</p> <ul> <li><code>(o)</code> is just the identity function</li> <li><code>(o f)</code> is the same as <code>f</code> for any function <code>f</code></li> <li><code>(o f g)</code> is the composition of the functions <code>f</code> and <code>g</code> i.e.   the function that given an argument <code>x</code> computes <code>(f (g x))</code></li> <li><code>(o f g h ...)</code> composes functions <code>f</code>, <code>g</code>, <code>h</code> \u2026\u200b in the   same way</li> </ul> <p>Tip</p> <p>Define a two-argument function <code>compose</code> that composes exactly two functions, and use it and <code>foldr</code> to define <code>o</code>. The solution is quite short.</p> <p>By the way, we use the name <code>o</code> because it looks like the small circle usually used in math books to represent function composition.</p>"},{"location":"assignments/3/assignment3/","title":"Assignment 3: The uScheme+ language","text":""},{"location":"assignments/3/assignment3/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, May 10th at 2 AM.</p>"},{"location":"assignments/3/assignment3/#coverage","title":"Coverage","text":"<p>This assignment covers the material up to lecture 11.</p>"},{"location":"assignments/3/assignment3/#code-base","title":"Code base","text":"<p>We are supplying you with a zip file called <code>lab3_code.zip</code>. It contains two subdirectories: <code>sexpr</code> and <code>uscheme_plus</code>. The <code>sexpr</code> subdirectory contains the code to parse S-expressions from strings and files. The <code>uscheme_plus</code> subdirectory contains the base implementation of the uScheme+ language, which (like uScheme) is spread over a number of files. You should unzip the file in a directory and do the following:</p> <ul> <li><code>cd</code> into the <code>sexpr</code> subdirectory and run <code>make</code>.</li> <li>Then <code>cd</code> into the <code>uscheme_plus</code> subdirectory and run <code>make</code>.</li> </ul> <p>If all goes well, this should create the <code>uscheme_plus</code> executable, which you can run as follows:</p> <pre><code>$ ./uscheme_plus\n</code></pre> <p>Note</p> <p>This version of <code>uscheme_plus</code> (compiled from the code we supply you with) is unfinished, but it will still run. However, it will not pass all the tests. The following sections describe what you have to do to complete it.</p>"},{"location":"assignments/3/assignment3/#topic-control-operators","title":"Topic: control operators","text":"<p>The theme of this assignment is \"control operators\". In part A, you will be implementing the control operators that we have described in class, specifically:</p> <ul> <li><code>break</code></li> <li><code>continue</code></li> <li><code>return</code></li> <li><code>throw</code></li> <li><code>try-catch</code></li> </ul> <p>In part B, you will implement tail call optimization, which is a fundamental technique in functional programming languages (it's what allows us to use recursion for loops).</p> <p>What we won't do in this assignment is make you write code in uScheme+. The reason for this is that control operators don't lend themselves to writing new and exciting kinds of code, unlike (say) the addition of first-class functions in uScheme. Mostly, control operators are useful for specific tasks, and you know when you need one. Instead, we are providing you with test scripts that exercise all the features we want you to implement.</p>"},{"location":"assignments/3/assignment3/#what-to-hand-in","title":"What to hand in","text":"<p>For this assignment, you will only need to modify the following files from the supplied code:</p> <ul> <li><code>ast.ml</code></li> <li><code>ast.mli</code></li> <li><code>error.ml</code></li> <li><code>error.mli</code></li> <li><code>eval.ml</code></li> </ul> <p>Submit these files as the CodePost assignment named <code>Assignment 3</code>.</p>"},{"location":"assignments/3/partA_control_operators/","title":"Part A: Implementing control operators","text":"<p>In the file <code>eval.ml</code>, there are a number of places marked <code>failwith \"TODO\"</code> where you need to finish the implementation of various features. In this section we will ignore one of those places (inside the <code>push_env_frame</code> function); that will be the topic of the next section. All the other <code>TODO</code>s are in two functions:</p> <ul> <li><code>eval_val_in_frame</code></li> <li><code>reduce_expr</code></li> </ul> <p>In addition, all of the <code>TODO</code>s relate to the implementation of the following control operators:</p> <ul> <li><code>break</code></li> <li><code>continue</code></li> <li><code>return</code></li> <li><code>throw</code></li> <li><code>try-catch</code></li> </ul> <p>Your job in this section is to implement these control operators, using the small-step operational semantics from lecture 9 as your guide. When editing <code>eval.ml</code>, always write your code in one of the locations marked <code>TODO</code> unless the instructions below specifically say not to. (Of course, replace the <code>failwith \"TODO\"</code> code with your code.) Some features require you to edit code in other files as well; this will be described below, but there are no <code>TODO</code> indicators for this code.</p> <p>Pay attention to the functional stack operations in the helper functions section in <code>eval.ml</code>. Use these to do all stack operations. Note that there is an <code>Fstack</code> module in the code base which implements functional stacks; the stack helper functions in <code>eval.ml</code> are just wrappers around these functions. (The name <code>Fstack</code> means \"functional stack\"; it's called that mainly to distinguish itself from the <code>Stack</code> module, which is imperative and is part of the OCaml standard library.) Notably, the <code>stack_push</code> function converts an <code>Fstack</code> <code>Overflow</code> exception to a uScheme+ exception.</p> <p>Note</p> <p>You will lose marks if you use <code>Fstack</code> functions directly.</p> <p>Here are some notes about each form:</p>"},{"location":"assignments/3/partA_control_operators/#1-break","title":"1. <code>break</code>","text":"<p>File to edit:</p> <ul> <li><code>eval.ml</code> (<code>reduce_expr</code> only)</li> </ul> <p>There are two ways to implement <code>break</code>. One is a direct implementation in the code of the small-step operational semantics. The other is an optimized form, which optimizes <code>break</code> expressions much like we optimized <code>while</code> expressions in assignment 1 for the Imp language. Either way is acceptable. The optimized form will require you to define a helper function.</p> <p>Make sure you don't allow <code>break</code> to cross function call boundaries! Also, if <code>break</code> ends up with an empty context stack, it's an error. Use the <code>Error.break_outside_while</code> function to signal <code>break</code>-related errors.</p>"},{"location":"assignments/3/partA_control_operators/#2-continue","title":"2. <code>continue</code>","text":"<p>Files to edit:</p> <ul> <li><code>ast.ml</code></li> <li><code>ast.mli</code></li> <li><code>error.ml</code></li> <li><code>error.mli</code></li> <li><code>eval.ml</code> (<code>reduce_expr</code> only)</li> </ul> <p>To implement <code>continue</code>, first you have to implement syntactic support for it. In the files <code>ast.ml</code> and <code>ast.mli</code>, add a <code>Continue</code> constructor to the <code>expr</code> datatype with a single <code>loc</code> argument (like the <code>Break</code> constructor). Update the <code>loc_of_expr</code> function to cover the new case, then extend <code>parse_expr</code> to parse <code>continue</code> expressions. Don't forget to update <code>ast.mli</code> with whatever changes are needed.</p> <p>Since <code>continue</code> is a keyword, make sure to add it to the list of keywords in <code>ast.ml</code>.</p> <p>Then you should add an extra error constructor called <code>ContinueOutsideWhile</code> to the <code>uscheme_error_tag</code> type in <code>error.ml</code>. This constructor takes no arguments. Update the <code>print_err</code> function to handle the additional constructor. Add a <code>continue_outside_while</code> error function in analogy to <code>break_outside_while</code> to <code>error.ml</code> and put its signature in <code>error.mli</code>.</p> <p>Everything else you need to do for <code>continue</code> is in the file <code>eval.ml</code>, in the function <code>reduce_expr</code>. (Note that there is no <code>TODO</code> location for this; you should figure out an appropriate place to put the code.) Once again, you can implement this in a basic or an optimized way, analogous to what you did with <code>break</code>. And again, make sure that <code>continue</code> doesn't cross function call boundaries. Use the <code>Error.continue_outside_while</code> function to signal <code>continue</code>-related errors. As with <code>break</code>, if the context stack becomes empty during a <code>continue</code>, it's an error.</p>"},{"location":"assignments/3/partA_control_operators/#3-return","title":"3. <code>return</code>","text":"<p>File to edit:</p> <ul> <li><code>eval.ml</code> (both the <code>reduce_expr</code> and <code>eval_val_in_frame</code> functions)</li> </ul> <p>Again, there is a basic and an optimized way to implement <code>return</code>. If you choose to do this the basic way,' you will have to change <code>eval_val_in_frame</code> to a <code>let rec</code> definition, which we will allow. If you do this the optimized way, you can leave it as a plain <code>let</code>.</p> <p>Use the <code>Error.return_outside_func</code> function to signal <code>return</code>-related errors. As with <code>break</code> and <code>continue</code>, it's an error if the context stack becomes empty during a <code>return</code>.</p> <p>Note that <code>(return)</code> is illegal in uScheme+. If you want the effect of returning \"nothing\", you can write <code>(return #u)</code>. <code>return</code> must always have a single expression whose corresponding value is the returned value.</p>"},{"location":"assignments/3/partA_control_operators/#4-throw-and-try-catch","title":"4. <code>throw</code> and <code>try-catch</code>","text":"<p>File to edit:</p> <ul> <li><code>eval.ml</code> (both the <code>reduce_expr</code> and <code>eval_val_in_frame</code> functions)</li> </ul> <p>Implementing <code>throw</code> is pretty straightforward; it's just a direct implementation of the operational semantics. Unwinding the stack is done in <code>eval_val_in_frame</code>, not in <code>reduce_expr</code>, since you need to evaluate the expression to throw before you unwind the stack. The unwinding can again be done in a basic or an optimized way, and again either is acceptable. You have to unwind the stack until you hit a <code>TryCatchFrame</code>, and you can cross function call boundaries (because that's kind of the whole point of exception handling).</p> <p><code>try-catch</code> is a bit subtle; you first have to evaluate the catch expression to a value, which should be a function (that's the exception handler). In <code>reduce_expr</code>, you have to push a <code>TryCatchEvalHandlerFrame</code> onto the stack before evaluating the exception handler. (This corresponds to the <code>Try-Catch</code> operational semantics rule in lecture 9.) Once the exception handler has been evaluated to a value, then (in <code>eval_val_in_frame</code>) you need to push a different frame (<code>TryCatchFrame</code>) onto the stack. (This is called \"installing the exception handler\".) Before you do this, you need to check that the exception handler is in fact a function (either a user function or a primitive is acceptable). We've included that code for you. Once this is done, you need to first push a <code>LetEnvFrame</code> frame onto the context stack, followed by the <code>TryCatchFrame</code>. (This corresponds to the <code>Try-Catch-Handler</code> operational semantics rule in lecture 9.) The case where no exception is thrown inside a <code>try-catch</code> form corresponds to the <code>Try-Catch-Finish</code> operational semantics rule; this rule is implemented for you.</p> <p>Note that <code>throw</code> unwinds the stack like <code>break</code>, <code>continue</code> and <code>return</code> do, but unlike them it unwinds through function call boundaries. The only thing that can stop <code>throw</code> from unwinding is hitting a <code>TryCatchFrame</code> (at which point the exception handler is invoked) or emptying out the stack completely without hitting a <code>TryCatchFrame</code> (which is an error; use the <code>Error.uncaught_throw</code> function to signal this). Invoking the exception handler should be done by calling the <code>eval_call</code> function.</p>"},{"location":"assignments/3/partA_control_operators/#5-question-about-letenvframe","title":"5. Question about <code>LetEnvFrame</code>","text":"<p>In lecture 9, it says that the reason for installing the <code>LetEnvFrame</code> first and then installing the <code>TryCatchFrame</code> is in case there are more forms to evaluate after the <code>try-catch</code> expression completes. But what about the exception handler itself? Why don't we have to install the environment in the <code>LetEnvFrame</code> before executing the exception handler? We certainly don't want the exception handler to execute in the context of an environment from a different function. But does it? Think about this, and write the answer in a comment in the <code>eval.ml</code> file (near the top).</p> <p>Once all of these features have been implemented, all of the test scripts except for <code>recurse_n.scm</code> and <code>tail.scm</code> should work. These scripts require tail call optimization, which is the topic of part B.</p>"},{"location":"assignments/3/partB_tail_calls/","title":"Part B: Implementing tail call optimization","text":"<p>Tail call optimization is a way of making sure that the context stack doesn't grow unnecessarily. For instance, consider the following functions:</p> <pre><code>(define fact-iter (n r)\n  (if (= n 0)\n      r\n      (fact-iter (- n 1) (* r n))))\n(define fact (n) (fact-iter n 1))\n</code></pre> <p>The <code>fact</code> function computes factorials of non-negative integers. It does this by dispatching to the tail-recursive function <code>fact-iter</code>. With tail call optimization (often abbreviated as TCO, and often inaccurately referred to as \"tail recursion optimization\")<sup>1</sup>, the recursive calls to <code>fact-iter</code> will not have to return to the call site and the entire function can execute in a constant context stack size (i.e. not dependent on the value of <code>n</code>). Without TCO, every recursive call will put down a <code>CallEnvFrame</code> onto the context stack, even if the top of the context stack was another <code>CallEnvFrame</code>. This is unnecessary; the previous <code>CallEnvFrame</code> is sufficient because the subsequent <code>CallEnvFrame</code> will change the environment when removed from the stack and then the previous one will immediately change it again. It's also undesirable because it grows the context stack; in a very deep recursion, the context stack might grow to a point where the implementation runs out of stack space (the dreaded \"stack overflow\"). Having TCO is what allows us to use recursion in place of explicit <code>while</code> loops in functional languages. This is necessary to enable the functional style of programming you learned about in CS 4.</p> <p>To see how <code>CallEnvFrame</code>s can build up without TCO, consider the function call <code>(fact-iter 5 1)</code>. This will push an <code>ApplyFrame</code> frame onto the context stack. Once all the argument values are evaluated, it will be replaced by a <code>CallEnvFrame</code>. Then the body of <code>fact-iter</code> will be evaluated, which will push an <code>IfFrame</code> onto the context stack while <code>(= n 0)</code> is evaluated. Once that happens, the <code>IfFrame</code> is popped off, to be replaced (in the false case) with the recursive call to <code>fact-iter</code>. This gives rise to another <code>ApplyFrame</code>, and once the arguments to the recursive call are evaluated, the <code>ApplyFrame</code> will be popped off the context stack and another <code>CallEnvFrame</code> will be pushed onto the stack so that the body of <code>fact-iter</code> can be evaluated again. From this we can see that we will eventually have a sequence of consecutive <code>CallEnvFrame</code>s on the context stack, even though the only one that matters is the lowest one. TCO will get rid of this problem.</p> <p>The good news is that implementing TCO is quite easy! There are two changes you need to make.</p>"},{"location":"assignments/3/partB_tail_calls/#1-push_env_frame","title":"1. <code>push_env_frame</code>","text":"<p>First, you need to edit the <code>push_env_frame</code> function in <code>eval.ml</code>. This function is only used to push either <code>LetEnvFrame</code> or <code>CallEnvFrame</code> frames, each of which just wraps an environment which needs to be restored. If <code>push_env_frame</code> determines that pushing the environment is unnecessary, it doesn't push the frame; otherwise, it does. The rules that you should use to decide if the environment push is unnecessary are the following:</p> <ol> <li> <p>Pushing a <code>CallEnvFrame</code> onto another <code>CallEnvFrame</code> is unnecessary. This is the \"classic\" tail-call optimization.</p> </li> <li> <p>Pushing a <code>LetEnvFrame</code> onto a <code>CallEnvFrame</code> is also unnecessary.</p> </li> <li> <p>Pushing a <code>LetEnvFrame</code> onto another <code>LetEnvFrame</code> is also unnecessary.</p> </li> <li> <p>Pushing a <code>CallEnvFrame</code> onto a <code>LetEnvFrame</code>... here's where things get weird. On the one hand, you might think that you don't need to do this because the <code>CallEnvFrame</code> environment will be immediately replaced by a <code>LetEnvFrame</code> environment. On the other hand, a <code>CallEnvFrame</code> is used to indicate where to unwind a <code>return</code> to, and to signal an error if a <code>break</code> unwinds to this point, so you can't just get rid of it. On the other other hand, just doing nothing isn't optimal either. Think about this and figure out the best approach. (Ask a TA or the instructor if you need a hint. The test scripts will definitely be checking this.) The good news is that the correct approach is very simple and doesn't require much code.</p> </li> </ol> <p>There is some debugging/tracing code in <code>push_env_frame</code> which you shouldn't alter. The part you should edit consists of this line:</p> <pre><code>stack_push l frame context  (* TODO FIXME: This is incorrect. *)\n</code></pre> <p>Of course, this line will need to be replaced by more than one line.</p>"},{"location":"assignments/3/partB_tail_calls/#2-taking-account-of-begin","title":"2. Taking account of <code>begin</code>","text":"<p>The last expression in a <code>begin</code> expression is considered to be \"in tail position\" if the <code>begin</code> expression itself is. What this means, basically, is that when you are evaluating the last subexpression of a non-empty <code>begin</code> expression, you shouldn't push an empty <code>BeginFrame</code> onto the stack, because if you do, you will break tail call optimization. Fortunately, this is very easy to implement, and the tests will check that you did it right.</p>"},{"location":"assignments/3/partB_tail_calls/#testing-tail-call-optimization","title":"Testing tail-call optimization","text":"<p>We've added some instrumentation to the supplied code to make it easy to check if your implementation of tail-call optimization is, well, optimal. The built-in function <code>trace-fs</code> (which stands for \"trace frame stack\") takes a single integer, normally <code>0</code>, <code>1</code>, or <code>2</code>. Any integer larger than <code>2</code> is equivalent to <code>2</code>, and any integer less than <code>0</code> is an error. Here's what these settings mean:</p> <ul> <li> <p><code>(trace-fs 0)</code></p> <p>Turn stack tracing off. Return the maximum depth of the stack since the last time stack tracing was turned on. (If it was never turned on, return 0.)</p> </li> <li> <p><code>(trace-fs 1)</code></p> <p>Turn stack tracing on. Return <code>0</code>. Every time <code>push_env_frame</code> is called, print the current stack frame depth.</p> </li> <li> <p><code>(trace-fs 2)</code></p> <p>Turn stack tracing on. Return <code>0</code>. Every time <code>push_env_frame</code> is called, print a representation of the state of the stack frame as well as the stack frame depth.</p> </li> </ul> <p>Let's see how this works through two example functions:</p> <pre><code>;; not tail-recursive:\n(define fact (n)\n  (if (= n 0)\n      1\n      (* n (fact (- n 1)))))\n\n;; tail-recursive:\n(define fact-iter (n r)\n  (if (= n 0)\n      r\n      (fact-iter (- n 1) (* r n))))\n</code></pre> <p>If we set stack tracing to <code>0</code>, no tracing happens:</p> <pre><code>&gt;&gt;&gt; (trace-fs 0)\n0\n&gt;&gt;&gt; (fact 10)\n3628800\n&gt;&gt;&gt; (fact-iter 10 1)\n3628800\n&gt;&gt;&gt; (trace-fs 0)\n0\n</code></pre> <p>If we turn on stack tracing, look what happens:</p> <pre><code>&gt;&gt;&gt; (trace-fs 1)\n0\n&gt;&gt;&gt; (fact 10)\nStack frame depth: 0\nStack frame depth: 2\nStack frame depth: 4\nStack frame depth: 6\nStack frame depth: 8\nStack frame depth: 10\nStack frame depth: 12\nStack frame depth: 14\nStack frame depth: 16\nStack frame depth: 18\nStack frame depth: 20\n3628800\n&gt;&gt;&gt; (trace-fs 0)\n20\n</code></pre> <p>The non-tail-recursive <code>fact</code> function grew the context stack to 20 frames when executing <code>(fact 10)</code>. If we try this with <code>(fact-iter 10 1)</code>, and if we have properly implemented tail call optimization, we see something very different:</p> <pre><code>&gt;&gt;&gt; (trace-fs 1)\n0\n&gt;&gt;&gt; (fact-iter 10 1)\nStack frame depth: 0\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\nStack frame depth: 1\n3628800\n&gt;&gt;&gt; (trace-fs 0)\n1\n</code></pre> <p>Note that the stack depth doesn't grow beyond <code>1</code>.</p> <p>On the other hand, if tail call optimization is not implemented, (or implemented incorrectly), we see this:</p> <pre><code>&gt;&gt;&gt; (trace-fs 1)\n0\n&gt;&gt;&gt; (fact-iter 10 1)\nStack frame depth: 0\nStack frame depth: 1\nStack frame depth: 2\nStack frame depth: 3\nStack frame depth: 4\nStack frame depth: 5\nStack frame depth: 6\nStack frame depth: 7\nStack frame depth: 8\nStack frame depth: 9\nStack frame depth: 10\n3628800\n&gt;&gt;&gt; (trace-fs 0)\n10\n</code></pre> <p>Now the stack is growing proportional to the size of the <code>n</code> argument.</p> <p>If we really want to see exactly what's happening on the context stack, we should use tracing level 2, which prints out the state of the entire stack instead of just the depth. Let's see it in both the non-tail-recursive and tail-recursive cases.</p> <pre><code>&gt;&gt;&gt; (trace-fs 2)\n0\n&gt;&gt;&gt; (fact 3)\nStack frame depth: 0\n\n== Frame stack ==\n\n  &lt;empty&gt;\n\nStack frame depth: 2\n\n== Frame stack ==\n\n  ApplyFrame\n  CallEnvFrame\n\nStack frame depth: 4\n\n== Frame stack ==\n\n  ApplyFrame\n  CallEnvFrame\n  ApplyFrame\n  CallEnvFrame\n\nStack frame depth: 6\n\n== Frame stack ==\n\n  ApplyFrame\n  CallEnvFrame\n  ApplyFrame\n  CallEnvFrame\n  ApplyFrame\n  CallEnvFrame\n\n6\n</code></pre> <p>Note the alternating <code>ApplyFrame</code>s and <code>CallEnvFrame</code>s on the stack. Compare this to the corresponding call to <code>fact-iter</code>:</p> <pre><code>&gt;&gt;&gt; (trace-fs 2)\n0\n&gt;&gt;&gt; (fact-iter 3 1)\nStack frame depth: 0\n\n== Frame stack ==\n\n  &lt;empty&gt;\n\nStack frame depth: 1\n\n== Frame stack ==\n\n  CallEnvFrame\n\nStack frame depth: 1\n\n== Frame stack ==\n\n  CallEnvFrame\n\nStack frame depth: 1\n\n== Frame stack ==\n\n  CallEnvFrame\n\n6\n</code></pre> <p>On the other hand, if tail call optimization is not implemented, we see this:</p> <pre><code>&gt;&gt;&gt; (trace-fs 2)\n0\n&gt;&gt;&gt; (fact-iter 3 1)\nStack frame depth: 0\n\n== Frame stack ==\n\n  &lt;empty&gt;\n\nStack frame depth: 1\n\n== Frame stack ==\n\n  CallEnvFrame\n\nStack frame depth: 2\n\n== Frame stack ==\n\n  CallEnvFrame\n  CallEnvFrame\n\nStack frame depth: 3\n\n== Frame stack ==\n\n  CallEnvFrame\n  CallEnvFrame\n  CallEnvFrame\n\n6\n</code></pre> <p>Note how the <code>CallEnvFrame</code>s pile up on the context stack.</p> <p>Using stack tracing will be very helpful in debugging tail call optimization. It's also used by the test scripts.</p> <ol> <li> <p>A tail call does not have to be recursive.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/software/","title":"Installing the course software","text":"<p>Here are the steps you should go through to install OCaml on your computer. If you have already installed OCaml (e.g. because you took CS 4), you can skip most of these instructions. Please make sure that you are running a current version of OCaml (version 5.1.1 or later). If not, use <code>opam</code> to upgrade your OCaml version as described below.</p>"},{"location":"intro/software/#installing-ocaml-and-opam","title":"Installing OCaml and <code>opam</code>","text":"<p>See the instructions on the OCaml website.</p> <p>Note</p> <p><code>opam</code> is the OCaml package manager. It should be installed along with OCaml.</p> <p>Be aware that the version numbers may have changed since that document was written. Be sure to install the correct version! For this term, we are using OCaml version 5.1.1.</p>"},{"location":"intro/software/#macos","title":"MacOS","text":"<p>The instructions for MacOS refer to the Homebrew package manager, which needs to be installed first.</p> <p>Note</p> <p>Homebrew does not come pre-installed on Macs, but it is easy to install and is incredibly useful. Almost any open-source command-line software you can imagine can be installed using Homebrew with a single command. (This includes most programming languages, including OCaml).</p> <p>Ignore the warnings about using Homebrew on Mac M1 processors, which are obsolete. It works fine now.</p> <p>We strongly recommend that you do not use the MacPorts package manager (incorrectly referred to as \"MacPort\" in the OCaml website). Use Homebrew instead.</p>"},{"location":"intro/software/#linux","title":"Linux","text":"<p>If you are using Linux, you can install OCaml using your system's package manager. If your Linux is an Ubuntu variant (the most common kind), you should install OCaml using the Ubuntu package manager <code>apt</code> (also known as <code>apt-get</code>). Installation instructions for Ubuntu and other Linux distributions are available on this page. For Ubuntu the commands are:</p> <pre><code>$ sudo apt update\n$ sudo apt install opam\n</code></pre> <p>The <code>sudo</code> is so you don't have to install the software as the root user. You may be asked to enter your password, which you should do.</p> <p>Note</p> <p>The instructions on the website also tell you to do this first:</p> <pre><code>$ sudo add-apt-repository ppa:avsm/ppa\n</code></pre> <p>This is unnecessary, since we will show you how to upgrade OCaml below.</p>"},{"location":"intro/software/#windows","title":"Windows","text":"<p>If you are using Windows, your should install a Linux system inside of Windows using the Windows Subsystem for Linux (WSL) Then you can use <code>apt</code> like on any Ubuntu Linux system. Don't try to install OCaml natively on Windows; although this may be possible, you are very likely to run into problems beyond the capability of the instructors to solve. Please use WSL!</p>"},{"location":"intro/software/#initialization","title":"Initialization","text":"<p>Once you have a version of OCaml and <code>opam</code> installed, you need to set it up, and, if necessary, upgrade the versions. Go through the following steps.</p> <ul> <li> <p>Start a terminal. If you are running MacOS, you can use the Terminal program. If you're using Windows/WSL, you can either use Windows Terminal or use Visual Studio Code and start a terminal inside the editor. If you're using Windows, make sure you are running Ubuntu/WSL inside the terminal and not Powershell! Both Windows Terminal and VS Code allow you to select either one, once WSL has been installed.</p> </li> <li> <p>Initialize <code>opam</code> by typing <code>opam init</code> in a terminal and following the instructions.</p> <p>Note</p> <p>There is an issue with initializing <code>opam</code> inside of WSL (Windows Subsystem for Linux). Basically, due to the way WSL works, you have to initialize <code>opam</code> differently by disabling sandboxing. This theoretically can cause some problems if a package does something really stupid, but it probably won't. The fix is to use this command instead of just <code>opam init</code>:</p> <pre><code>$ opam init --disable-sandboxing\n</code></pre> </li> <li> <p>At the end of the <code>opam init</code> command, it will ask you to run <code>eval ${opam env}</code><sup>1</sup> to set up the <code>PATH</code> variable of your shell to point to the <code>opam</code> directories. This is important, because if you don't do this, adding new packages (and new OCaml versions) will not work. Opam will also ask you if it can change your shell initialization file (e.g. <code>~/.bashrc</code> for <code>bash</code> or <code>~/.zshrc</code> for <code>zsh</code>) by adding some commands. You should say yes, because if you don't, every time you start up a new terminal you will have to type <code>eval ${opam env}</code> to get <code>opam</code> to work correctly.</p> </li> <li> <p>In your terminal, type:</p> <pre><code>$ opam update\n$ opam upgrade\n</code></pre> <p>to make sure the package repository is up to date and all OCaml packages have been upgraded to the most recent versions.</p> </li> <li> <p>Check the OCaml version by typing <code>ocaml --version</code>. If it's the desired version (which is 5.1.1 this term), you are done with this part. Otherwise do</p> <pre><code>$ opam switch create 5.1.1\n</code></pre> <p>and wait for the new version to be installed. (This will take a while.)</p> </li> <li> <p>Install some libraries and programs:</p> <pre><code>$ opam install utop dune ocamlformat\n</code></pre> <p>This will install the <code>utop</code>, <code>dune</code>, and <code>ocamlformat</code> programs, as well as a number of OCaml libraries you don't have to worry about.</p> <p><code>utop</code> is the OCaml interactive interpreter. We will be working with this a lot!</p> <p>Note</p> <p>There is a more primitive interactive interpreter just called <code>ocaml</code> that comes with the OCaml distribution. We won't use this, because <code>utop</code> is vastly more featureful and nicer to use.</p> <p><code>dune</code> is the OCaml compilation manager. We will introduce this when we need it.</p> <p><code>ocamlformat</code> is an auto-formatter for OCaml code. You don't actually need this, but it gets handy when you are working with longer files of code and you want to make sure everything is formatted neatly.</p> </li> </ul>"},{"location":"intro/software/#using-ocaml","title":"Using OCaml","text":"<p>There are only a few things you need to know in order to use OCaml effectively.</p>"},{"location":"intro/software/#starting-ocaml","title":"Starting OCaml","text":"<p>Open a terminal and type:</p> <pre><code>$ utop\n</code></pre> <p>at the terminal prompt. (The <code>$</code> is the terminal prompt; don't type that.) This will bring up the OCaml interactive interpreter, which is a good environment for experimenting with the language and for testing code you've written. (This is similar to the Python interactive interpreter.)</p> <p><code>utop</code> makes it possible to easily recall and edit previously-input lines of text by using the up and down arrow keys. To see what it can do, start up <code>utop</code>:</p> <pre><code>$ utop\n</code></pre> <p>and type the following commands (one per line, hitting the return key at the end of each line):</p> <pre><code># Printf.printf \"hello\\n\" ;;\n# Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>Note that the OCaml interpreter prompt is the hash sign (<code>#</code>); don't type that! These lines should, when evaluated, print the words <code>\"hello\"</code> and <code>\"goodbye\"</code> respectively. Once you've done this, you should be able to recall either line by using the up arrow key. For instance, you can hit the up arrow key once to get the line:</p> <pre><code>Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>and edit it so that it says:</p> <pre><code>Printf.printf \"hasta la vista\\n\" ;;\n</code></pre> <p>When you hit return, it should print out <code>\"hasta la vista\"</code> on a separate line. This feature makes line editing much easier. You can also use control-a (hold the control key down and type <code>a</code>) to get to the beginning of a line you are editing and control-e to get to the end. control-l (lower-case L) clears the terminal and puts the cursor at the top of the terminal window.</p> <p>Exit the interpreter by typing control-d (this is just like Python). You can also type <code>#quit;;</code> at the prompt:</p> <pre><code># #quit;;\n</code></pre> <p>and that will also work.</p>"},{"location":"intro/software/#configuring-utop","title":"Configuring <code>utop</code>","text":"<p>One annoying thing about <code>utop</code> is that it tends to go overboard on command completion.  You can disable this by typing this inside <code>utop</code>:</p> <pre><code># #utop_prompt_dummy;;\n# UTop.set_show_box false;;\n</code></pre> <p>It's annoying to type this every time you start <code>utop</code>, so what I do is make a <code>utop</code> initialization file called <code>init.ml</code> and put it in the directory <code>~/.config/utop</code> (creating that directory if necessary). Then these commands will be run every time <code>utop</code> starts.</p> <p>Note</p> <p>Unfortunately, this will not work properly if used in a directory that has a <code>.ocamlinit</code> file in it (usually your home directory). There are workarounds, but most of the time it will work properly.</p>"},{"location":"intro/software/#using-visual-studio-code","title":"Using Visual Studio Code","text":"<p>You can use any plain text editor you like to write OCaml code, but we recommend you try Visual Studio Code (also known as VS Code), which has excellent OCaml support. In order to use it, you need to do the following steps:</p> <ul> <li> <p>Install the OCaml Language Server Protocol by typing this into a terminal:</p> <pre><code>$ opam install ocaml-lsp-server\n</code></pre> <p>A language server protocol provides a way for editors to query languages so that things like command completion and type information can be displayed in the editor while you're editing code.</p> </li> <li> <p>Install Visual Studio Code from the VS Code website.</p> </li> <li> <p>When inside VS Code, look at the Extensions pane (select View/Extensions from the menu). Type \"OCaml\" into the search bar at the top, and select and install \"OCaml Platform\".</p> </li> </ul> <p>Now you will get nice syntax highlighting and code completion when you edit OCaml source code. You can also start a terminal while inside VS Code to test your code by running the OCaml interpreter.</p> <ol> <li> <p>Or possibly <code>eval ${opam config env}</code> or something similar. It all does the same thing.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/welcome/","title":"Welcome to CS 131!","text":"<p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about the material. In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus   (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>links to lecture slides</li> <li>assignments</li> <li>coding notes and tips</li> </ul> <p>and anything else we consider useful. Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>code supplied to students for assignments</li> <li>some administrative information e.g. contact information</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"intro/welcome/#instructor-and-course-staff","title":"Instructor and course staff","text":"<p>The course instructor is Mike Vanier (mvanier@cms.caltech.edu).</p> <p>The TAs are listed in the syllabus.  Their contact information will be posted on the course Canvas page.</p>"},{"location":"intro/welcome/#what-this-course-is-about","title":"What this course is about","text":"<p>CS 131 is a course on implementing programming languages. We will be implementing interpreters for several programming languages. Some will be imperative, and some will be functional. Some will be untyped, some dynamically typed, and some statically typed. We will learn how programming languages differ \"from the inside\" i.e. how different features of programming languages affect the implementations of these languages.</p> <p>This is an extremely interesting and fun topic, and it's one of my personal favorite subjects. Implementing programming languages can be very addicting, but it is also a lot of work. We will be using the OCaml language exclusively in this course.</p> <p>We hope you enjoy the course!</p>"}]}