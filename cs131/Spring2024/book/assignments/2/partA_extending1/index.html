
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://mvanier.github.io/cs131/Spring2024/book/assignments/2/partA_extending1/">
      
      
        <link rel="prev" href="../debugging/">
      
      
        <link rel="next" href="../partB_extending2/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.3">
    
    
      
        <title>Part A: Finishing and extending uScheme: parsing - The CS 131 book (Spring 2024)</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.50c56a3b.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../css/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#part-a-finishing-and-extending-uscheme-parsing-50-points" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="The CS 131 book (Spring 2024)" class="md-header__button md-logo" aria-label="The CS 131 book (Spring 2024)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            The CS 131 book (Spring 2024)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Part A: Finishing and extending uScheme: parsing
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to medium mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to medium mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="medium" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18V6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-2.69L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="The CS 131 book (Spring 2024)" class="md-nav__button md-logo" aria-label="The CS 131 book (Spring 2024)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    The CS 131 book (Spring 2024)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Introduction
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Introduction
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../intro/welcome/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Welcome to CS 131!
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../intro/software/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installing the course software
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../lectures/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lecture slides
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Administrative
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Administrative
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../admin/syllabus/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Syllabus
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../admin/collab/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Collaboration policies
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Assignment 1: The Imp language
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Assignment 1: The Imp language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../1/assignment1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../1/partA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part A: Programming in Imp
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../1/partB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part B: Extending Imp
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../1/partC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part C: Programming in extended Imp
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" checked>
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Assignment 2: The uScheme language
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Assignment 2: The uScheme language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../assignment2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../debugging/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debugging
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Part A: Finishing and extending uScheme: parsing
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Part A: Finishing and extending uScheme: parsing
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#intermediate-representations" class="md-nav__link">
    <span class="md-ellipsis">
      Intermediate representations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-implementing-simple-desugarings" class="md-nav__link">
    <span class="md-ellipsis">
      1. Implementing simple desugarings
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. Implementing simple desugarings">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-let" class="md-nav__link">
    <span class="md-ellipsis">
      a. let*
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-define" class="md-nav__link">
    <span class="md-ellipsis">
      b. define
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-top-level-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      c. Top-level expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-extending-literals" class="md-nav__link">
    <span class="md-ellipsis">
      2. Extending literals
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Extending literals">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#adding-literals-to-the-ast" class="md-nav__link">
    <span class="md-ellipsis">
      Adding literals to the AST
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adding-literals-to-the-ir" class="md-nav__link">
    <span class="md-ellipsis">
      Adding literals to the IR
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-extending-let-lambda-define-and-while-forms" class="md-nav__link">
    <span class="md-ellipsis">
      3. Extending let, lambda, define and while forms
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-adding-the-cond-form" class="md-nav__link">
    <span class="md-ellipsis">
      4. Adding the cond form
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-adding-the-and-and-or-forms" class="md-nav__link">
    <span class="md-ellipsis">
      5. Adding the and and or forms
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-adding-the-valrec-form" class="md-nav__link">
    <span class="md-ellipsis">
      6. Adding the valrec form
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-functions-with-variable-numbers-of-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      7. Functions with variable numbers of arguments
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../partB_extending2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part B: Finishing and extending uScheme: evaluation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../partC_programming/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part C: Programming in extended uScheme
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Assignment 3: The uScheme+ language
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Assignment 3: The uScheme+ language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3/assignment3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3/partA_control_operators/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part A: Implementing control operators
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3/partB_tail_calls/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part B: Implementing tail call optimization
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Assignment 4: The Typed Imp language
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Assignment 4: The Typed Imp language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../4/assignment4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../4/partA_implementing_arrays/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part A: Implementing arrays
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../4/partB_implementing_local_variables/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part B: Implementing local variables
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../4/partC_functions_with_arrays_and_locals/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part C: Writing functions with arrays and locals
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Assignment 5: The Typed uScheme language
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            Assignment 5: The Typed uScheme language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../5/assignment5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../5/partA_substitution/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part A: Implementing capture-avoiding substitution
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../5/partB_type_checking/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part B: Implementing the type checker
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#intermediate-representations" class="md-nav__link">
    <span class="md-ellipsis">
      Intermediate representations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-implementing-simple-desugarings" class="md-nav__link">
    <span class="md-ellipsis">
      1. Implementing simple desugarings
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. Implementing simple desugarings">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-let" class="md-nav__link">
    <span class="md-ellipsis">
      a. let*
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-define" class="md-nav__link">
    <span class="md-ellipsis">
      b. define
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-top-level-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      c. Top-level expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-extending-literals" class="md-nav__link">
    <span class="md-ellipsis">
      2. Extending literals
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Extending literals">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#adding-literals-to-the-ast" class="md-nav__link">
    <span class="md-ellipsis">
      Adding literals to the AST
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adding-literals-to-the-ir" class="md-nav__link">
    <span class="md-ellipsis">
      Adding literals to the IR
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-extending-let-lambda-define-and-while-forms" class="md-nav__link">
    <span class="md-ellipsis">
      3. Extending let, lambda, define and while forms
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-adding-the-cond-form" class="md-nav__link">
    <span class="md-ellipsis">
      4. Adding the cond form
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-adding-the-and-and-or-forms" class="md-nav__link">
    <span class="md-ellipsis">
      5. Adding the and and or forms
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-adding-the-valrec-form" class="md-nav__link">
    <span class="md-ellipsis">
      6. Adding the valrec form
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-functions-with-variable-numbers-of-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      7. Functions with variable numbers of arguments
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="part-a-finishing-and-extending-uscheme-parsing-50-points">Part A: Finishing and extending <em>uScheme</em>: parsing  (50 points)</h1>
<p>In this section,
you will be completing the parsing of forms to IR forms
(described below)
by implementing desugarings
and adding features to the AST and IR.</p>
<h2 id="intermediate-representations">Intermediate representations</h2>
<p>The theme of this assignment is <em>intermediate representations</em>
(called "IR" for short).
Previously we've assumed that the interpreter
converts the S-expression representation to an AST representation
and then directly evaluates the AST representation.
However, the main purpose of an AST
is to serve as a faithful representation of the language syntax
that is easy to manipulate inside a program.
ASTs are generally <em>not</em> the optimal form for evaluators to work on.
For one thing, there are almost always forms in the AST that aren't necessary,
because they can be desugared into simpler forms.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>"Desugaring" a form means to convert it to an equivalent form
which will give the exact same result when evaluated,
but which is "simpler" in some sense.
In our case, we want the desugared form
to be converted to another form that already exists,
so the evaluator has fewer forms that it needs to be able to handle.
The fewer the forms an evaluator needs to handle,
the easier it is to write.</p>
</div>
<p>In assignment 1, we saw one way to desugar forms,
which was by directly converting S-expressions into other S-expressions.
However, there are two problems with this approach:</p>
<ul>
<li>Working with S-expressions directly is very tedious in OCaml.</li>
<li>Most languages don't even use S-expressions.</li>
</ul>
<p>Some languages (notably most Lisp and Scheme dialects)
contain powerful <em>macro systems</em> that operate at the level of S-expressions,
and given a good enough macro system,
desugaring at the level of S-expressions makes sense.
(Probably the most powerful macro system
ever implemented in a programming language
is the one at the heart of the
<a href="https://racket-lang.org/">Racket</a> family of languages.
Check it out sometime.)</p>
<p>However, we don't have a macro system in <em>uScheme</em>,
so we will do something more conventional:
we will <em>not</em> desugar S-expressions,
but instead we will convert them to AST expressions as usual,
and then convert AST expressions
into a simpler <em>intermediate representation</em> (or IR for short).
This IR form is like an AST form except that there is no redundancy;
all AST expressions that can be converted to simpler expressions
are converted.
Furthermore, this conversion happens
before the evaluator ever sees the code,
so that there is no need to convert the same expression over and over,
which may occur if the evaluator interprets the AST directly.
The cost is that you have one more conversion step
before you can evaluate the code,
but this is usually a cost worth paying.</p>
<p>Note that by converting AST forms into IR forms,
we will write what in compiler terminology is called a <em>simplification pass</em>.
Many forms will be nearly identical in both the AST and IR
(so converting them will be tedious "boilerplate" code)
but some forms will change and others will be eliminated altogether.
We'll describe all the changes below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Yes, you are actually writing a compiler.
It's a very simple compiler,
and it doesn't output machine code or assembly language,
but it's a compiler nonetheless,
because it takes in one representation of a language (the AST)
and outputs a different one (the IR).</p>
</div>
<p>Note also that many (most?) languages
have more than one intermediate representation.
"Real" compilers, in particular, usually have a number of IRs,
and the output of one IR transformation is the input to the next one.
There are many things that can be done in IRs;
simplification is only one of them.
(Take CS 164 if you want to learn more about compilers and their IRs.)</p>
<p>Before beginning, take a look at the <code>expr</code> and <code>def</code> type definitions
in the <code>ast.mli</code> and <code>ir.mli</code> files.
Notice which forms are present in the AST types but not in the IR types.
This is where the desugaring will happen.
(You will also be making some modifications to both the AST and IR types.)</p>
<p>The files that you need to change for this section are:</p>
<ul>
<li><code>ast.mli</code></li>
<li><code>ast.ml</code></li>
<li><code>ir.mli</code></li>
<li><code>ir.ml</code></li>
</ul>
<h2 id="1-implementing-simple-desugarings">1. Implementing simple desugarings</h2>
<p>[<strong>10 points</strong>]</p>
<p>The code base we have provided for you
defines the IR in the files <code>ir.ml</code> and <code>ir.mli</code>.
These files define the IR types <code>expr</code> and <code>def</code>
and contain most of the code for converting between AST and IR forms.
However, the conversion code for one expression form
(corresponding to <code>let*</code> forms)
and two definition forms
(corresponding to <code>define</code> forms and top-level expressions)
are not implemented.
Since the basis functions defined in <code>basis.ml</code>
use <code>define</code> in particular,
you can't run this interpreter as is.
Therefore, your first task
is to finish implementing the code in <code>ir.ml</code>
by replacing the <code>failwith "TODO"</code> expressions
with code that implements the correct transformations.</p>
<p>Note that the evaluator code in <code>eval.ml</code> acts on IR expressions,
not AST expressions.
You will need to modify that code in various ways, but not in this section.</p>
<p>Here are the transformations we want you to implement:</p>
<h3 id="a-let">a. <code>let*</code></h3>
<p>For <code>let*</code>, use the transformation:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>(let* () e) --&gt; e
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>(let* ([x1 e1] [x2 e2] ...) e) --&gt; (let ([x1 e1]) (let* ([x2 e2] ...) e))
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>; repeat until there are no more &quot;let*&quot; expressions
</span></code></pre></div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is <em>not</em> a transformation at the level of S-expressions;
we're only writing it in terms of S-expressions for the sake of brevity.
In actual fact,
you would be converting <code>LetStar (...)</code> expressions (in the AST)
into nested <code>Let (...)</code> expressions (in the IR).</p>
<p>If you implement this at the S-expression level you will get no credit
(and you'll work much harder than you should!).
This also applies to all the transformations we describe below.</p>
</div>
<p>If you find this transformation tedious,
reread the operational semantics for <code>let*</code> in lecture 6.
Then feel better knowing that
you don't have to implement this in the evaluator!
One of the great things about desugaring
is that it simplifies the evaluator,
which also means that it makes it much easier to get the evaluator correct
(and to prove it correct, if you're so inclined).
Of course, you can specify the desugaring
in the operational semantics as well.</p>
<h3 id="b-define">b. <code>define</code></h3>
<p>For <code>define</code>, use the transformation:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>(define f (x1 x2 ...) e) --&gt; (val f (lambda (x1 x2 ...) e))
</span></code></pre></div>
<p>Again, this is not a transformation
at the level of S-expressions but at the level of the AST and IR forms.
In fact, the IR doesn't even have a <code>Define</code> form,
so this transformation is necessary.</p>
<h3 id="c-top-level-expressions">c. Top-level expressions</h3>
<p>For top-level expressions, use the transformation:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>e --&gt; (val _ e)
</span></code></pre></div>
<h2 id="2-extending-literals">2. Extending literals</h2>
<p>[<strong>5 points</strong>]</p>
<p>In both the AST and the IR, the only kind of literals are integers.
But in reality, we have several literal values:</p>
<ul>
<li>integers</li>
<li>booleans (the special identifiers <code>#t</code> and <code>#f</code>,
  representing "true" and "false" respectively)</li>
<li>the unit value <code>#u</code> (used as a return value for functions
  that don't really return anything, like <code>println</code>)</li>
</ul>
<p>In addition, <code>nil</code> (the empty list) and quoted S-expressions
could also be considered literals.
We won't do that, because quoted S-expressions
have their own AST form
and <code>nil</code> is just an identifier we bind to the empty list value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These decisions are quite arbitrary.
Programming language designers use their own sense of aesthetics
to determine what forms to include and how to categorize them.
For instance, we could easily have made <code>nil</code> into a literal,
but it seems cleaner to us not to do that.
In fact, most real Scheme implementations
don't even define <code>nil</code>, using <code>'()</code> instead
(which we can also use).</p>
</div>
<h3 id="adding-literals-to-the-ast">Adding literals to the AST</h3>
<p>In the AST module (the files <code>ast.mli</code> and <code>ast.ml</code>)
extend the set of literals by defining a separate <code>lit</code> type.
This type will have constructors for integers, booleans, and unit literals.
Then rewrite the <code>Literal</code> constructor of the <code>expr</code> type so that it
takes a <code>lit</code> value instead of an <code>int</code> value.</p>
<p>Extend the <code>parse_expr</code> function so that it parses S-expressions
representing literals into the corresponding AST literals.</p>
<p>Remove the names <code>#u</code>, <code>#t</code> and <code>#f</code> from the list of reserved
identifiers.  (These names are not identifiers any more.)
Keep <code>nil</code> as the only reserved identifier.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The purpose of this transformation is so that
the evaluator doesn't have to waste time
looking up the identifiers <code>#t</code>, <code>#f</code> and <code>#u</code> at run-time,
since they can only represent one thing.</p>
</div>
<h3 id="adding-literals-to-the-ir">Adding literals to the IR</h3>
<p>In the IR module (the files <code>ir.mli</code> and <code>ir.ml</code>),
add this line to the type definitions:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>type lit = Ast.lit
</span></code></pre></div>
<p>and then change the <code>Literal</code> constructor
so that it takes a <code>lit</code> value instead of an <code>int</code> value as well.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do <em>not</em> define a new <code>lit</code> type in the IR.
Just re-use the AST <code>lit</code> type,
because it's the same in the AST and the IR.
We only define the type alias for convenience,
so we can type <code>lit</code> instead of <code>Ast.lit</code>.</p>
</div>
<p>Rewrite the <code>Literal</code> constructor of the IR
so it takes a <code>lit</code> value instead of an <code>int</code> value.</p>
<h2 id="3-extending-let-lambda-define-and-while-forms">3. Extending <code>let</code>, <code>lambda</code>, <code>define</code> and <code>while</code> forms</h2>
<p>[<strong>10 points</strong>]</p>
<p>Writing a <code>begin</code> expression for the body
of a <code>let</code>, <code>lambda</code>, <code>define</code> or <code>while</code> expression
when the body consists of more than one expression is annoying;
let's fix that!</p>
<p>Extend the <code>let</code>/<code>let*</code>/<code>letrec</code>, <code>lambda</code>, <code>define</code>
and <code>while</code> forms in the AST to allow multiple expressions in the body.
To do this,
you have to modify the AST in <code>ast.ml</code> and <code>ast.mli</code> for the affected forms,
then change the way S-expressions are converted to AST expressions
(adding support for the new ways of writing the forms),
and finally change the way AST expressions
are converted to IR expressions in <code>ir.ml</code>.
Note that the IR versions of these forms
only have a single expression in the body,
and the IR doesn't have <code>let*</code> or <code>define</code> forms.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The IR types should not change.</p>
</div>
<p>In each case,
the multiple body expressions evaluate
as if they were wrapped in a <code>begin</code> expression,
and when you convert them to IR expressions,
you should explicitly wrap the body expressions with a <code>begin</code> expression.</p>
<p>To be specific, here are the desugarings you need to make when
converting between the AST and the IR forms
(again written schematically as S-expression transformations,
though that's not what they are).</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>(let ([&lt;name1&gt; &lt;expr1] ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>--&gt;
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>(let ([&lt;name1&gt; &lt;expr1] ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>(let* ([&lt;name1&gt; &lt;expr1] ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>--&gt;
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a>(let* ([&lt;name1&gt; &lt;expr1] ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))
</span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a>[then desugar let* to let as described above]
</span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a>
</span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a>(letrec ([&lt;name1&gt; &lt;expr1] ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)
</span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a>--&gt;
</span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a>(letrec ([&lt;name1&gt; &lt;expr1] ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))
</span><span id="__span-4-13"><a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a>
</span><span id="__span-4-14"><a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a>(lambda (&lt;name1&gt; ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)
</span><span id="__span-4-15"><a id="__codelineno-4-15" name="__codelineno-4-15" href="#__codelineno-4-15"></a>--&gt;
</span><span id="__span-4-16"><a id="__codelineno-4-16" name="__codelineno-4-16" href="#__codelineno-4-16"></a>(lambda (&lt;name1&gt; ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))
</span><span id="__span-4-17"><a id="__codelineno-4-17" name="__codelineno-4-17" href="#__codelineno-4-17"></a>
</span><span id="__span-4-18"><a id="__codelineno-4-18" name="__codelineno-4-18" href="#__codelineno-4-18"></a>(define &lt;name&gt; (&lt;arg1&gt; ...) &lt;body-expr1&gt; &lt;body-expr2&gt; ...)
</span><span id="__span-4-19"><a id="__codelineno-4-19" name="__codelineno-4-19" href="#__codelineno-4-19"></a>--&gt;
</span><span id="__span-4-20"><a id="__codelineno-4-20" name="__codelineno-4-20" href="#__codelineno-4-20"></a>(define &lt;name&gt; (&lt;arg1&gt; ...) (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))
</span><span id="__span-4-21"><a id="__codelineno-4-21" name="__codelineno-4-21" href="#__codelineno-4-21"></a>
</span><span id="__span-4-22"><a id="__codelineno-4-22" name="__codelineno-4-22" href="#__codelineno-4-22"></a>(while &lt;test-expr&gt; &lt;body-expr1&gt; &lt;body-expr2&gt; ...)
</span><span id="__span-4-23"><a id="__codelineno-4-23" name="__codelineno-4-23" href="#__codelineno-4-23"></a>--&gt;
</span><span id="__span-4-24"><a id="__codelineno-4-24" name="__codelineno-4-24" href="#__codelineno-4-24"></a>(while &lt;test-expr&gt; (begin &lt;body-expr1&gt; &lt;body-expr2&gt; ...))
</span></code></pre></div>
<p>One other thing:
we do not allow empty bodies
for <code>let</code>, <code>let*</code>, <code>letrec</code>, <code>lambda</code> expressions, or for <code>define</code> forms.
(In contrast, an empty body is OK in a <code>while</code> expression.)
So all of these are syntax errors:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>(let ())
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>(let* ())
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>(letrec ())
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>(lambda (x))
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>(lambda args)
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a>(define foo ())
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a>(define foo args)
</span></code></pre></div>
<p>The test scripts will check for this.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Instead of counting the number of body expressions
and raising a syntax error exception when there aren't any,
you can enforce this by a clever use of pattern matching.
Instead of matching zero or more expressions using <code>exprs</code>,
match one or more expressions using <code>expr :: exprs</code>.
Anything that doesn't match is a malformed form,
and will be considered to be a syntax error.</p>
</div>
<h2 id="4-adding-the-cond-form">4. Adding the <code>cond</code> form</h2>
<p>[<strong>5 points</strong>]</p>
<p>Real Scheme has a conditional expression form called <code>cond</code>
which is easier to use than <code>if</code> for most applications.
It has the following syntax:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>(cond [&lt;test-exprA&gt; &lt;expr1a&gt; &lt;expr2a&gt; ...]
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>      [&lt;test-exprB&gt; &lt;expr1b&gt; &lt;expr2b&gt; ...]
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>       ...)
</span></code></pre></div>
<p>In other words, <code>cond</code> is followed by zero or more <em>clauses</em>,
where each clause has a test expression
(an expression which evaluates to a boolean value)
followed by zero or more body expressions.
<code>cond</code> evaluates each clause in order;
if a test expression returns a true value
(which in Scheme is any value that isn't explicitly false),
then the body expressions are evaluated in order
and the value of the last one is the value of the <code>cond</code> expression.
If the test expression evaluates to false, the next clause is evaluated.
If there are no more clauses, the <code>cond</code> returns a unit (<code>#u</code>) value.
Note that a <code>cond</code> expression doesn't have to have any clauses,
in which case it again returns <code>#u</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The square brackets are just for readability;
they could be replaced with parentheses as long as they are balanced.
You don't have to worry about this,
since the <code>sexpr</code> library handles parsing S-expressions.</p>
</div>
<p>If you want the equivalent of an "else" clause in a <code>cond</code> expression,
just use <code>#t</code> for the test expression.
This is normally done only in the last clause.
(You could easily add <code>else</code> as a keyword with a little extra work,
but don't do that.)</p>
<p>The <code>cond</code> form exists in the AST only;
it is desugared in the IR to a series of nested <code>if</code> forms.
You need to add a <code>Cond</code> constructor to the AST,
convert S-expressions to AST <code>Cond</code> forms where appropriate,
and write the code to convert AST <code>Cond</code> forms to nested IR <code>If</code> forms.
Here is the desugaring of <code>cond</code> to <code>if</code>:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>(cond [&lt;test-exprA&gt; &lt;expr1a&gt; &lt;expr2a&gt; ...]
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>      [&lt;test-exprB&gt; &lt;expr1b&gt; &lt;expr2b&gt; ...]
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>       ...)
</span><span id="__span-7-4"><a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a>--&gt;
</span><span id="__span-7-5"><a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a>(if &lt;test-exprA&gt; (begin &lt;expr1a&gt; &lt;expr2a&gt; ...)
</span><span id="__span-7-6"><a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a>    (cond [&lt;test-exprB&gt; &lt;expr1b&gt; &lt;expr2b&gt; ...]
</span><span id="__span-7-7"><a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a>          ...))
</span><span id="__span-7-8"><a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a>[repeat until there are no more &quot;cond&quot; expressions]
</span><span id="__span-7-9"><a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a>
</span><span id="__span-7-10"><a id="__codelineno-7-10" name="__codelineno-7-10" href="#__codelineno-7-10"></a>(cond) --&gt; #u
</span></code></pre></div>
<p>Finally, add <code>cond</code> to the list of keywords in <code>ast.ml</code>.</p>
<h2 id="5-adding-the-and-and-or-forms">5. Adding the <code>and</code> and <code>or</code> forms</h2>
<p>[<strong>5 points</strong>]</p>
<p>Add <code>and</code> and <code>or</code> expression forms to the language.
In the AST they will be represented as <code>And</code> and <code>Or</code> constructors.
Write the code to convert from S-expressions
to AST <code>And</code>/<code>Or</code> forms where appropriate.
Note that both forms are <em>variadic</em>
<em>i.e.</em> they can take any number of arguments, including zero.
The IR does not have <code>And</code> or <code>Or</code> constructors;
instead, convert them to <code>Let</code> and <code>If</code> forms,
using this desugaring:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>(and) --&gt; #t
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a>(and x) --&gt; x
</span><span id="__span-8-3"><a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a>(and x y z ...) --&gt; (if x (and y z ...) #f)
</span><span id="__span-8-4"><a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a>[repeat until there are no more &quot;and&quot; expressions]
</span><span id="__span-8-5"><a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a>
</span><span id="__span-8-6"><a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a>(or) --&gt; #f
</span><span id="__span-8-7"><a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a>(or x) --&gt; x
</span><span id="__span-8-8"><a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a>(or x y z ...) --&gt; (let (({or} x)) (if {or} {or} (or y z ...)))
</span><span id="__span-8-9"><a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a>[repeat until there are no more &quot;or&quot; expressions]
</span></code></pre></div>
<p>Note that the <code>And</code> AST form gets converted
to a series of nested <code>If</code> IR forms,
whereas an <code>Or</code> AST form gets converted
to a combination of <code>Let</code> and <code>If</code> forms.
The <code>{or}</code> in the desugaring is the actual string <code>"{or}"</code>,
which you should use as an identifier;
this is safe because actual <em>uScheme</em> identifiers
can't have curly braces,
so this synthesized identifier can't be captured by any user code.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The problem of <em>variable capture</em>
when desugaring expressions into expressions that contain new identifiers
is complex and subtle;
this is a hack that will work in this specific case,
but it's not a good general approach.
To get a feel for the issues involved,
think about what could happen if,
instead of using <code>{or}</code> as an identifier,
you just used <code>x</code>.
Could this break under any circumstances?</p>
</div>
<p>Finally, add <code>and</code> and <code>or</code> to the list of keywords in <code>ast.ml</code>.</p>
<h2 id="6-adding-the-valrec-form">6. Adding the <code>valrec</code> form</h2>
<p>[<strong>5 points</strong>]</p>
<p>A <code>val</code> or <code>define</code> definition can be bound to a recursive function,
but we can't do that with mutually recursive functions.
(In language terminology, this is called a "language wart"
<em>i.e.</em> a misfeature or missing feature.)
We will fix this limitation in this problem.</p>
<p>Define a <code>valrec</code> definition form
that supports both recursion and mutual recursion.
Use this syntax:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>(valrec
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>  [f ...]
</span><span id="__span-9-3"><a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>  [g ...]
</span><span id="__span-9-4"><a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a>  ...)
</span></code></pre></div>
<p>The binding expressions
(the <code>...</code> parts following the names <code>f</code> and <code>g</code> in this case)
can be arbitrary <em>uScheme</em> expressions,
but are normally <code>lambda</code> expressions.
There can be any number of bindings, but there must be at least one.
The semantics and its implementation will be discussed in part B.</p>
<p>An empty <code>valrec</code> form (<em>i.e.</em> <code>(valrec)</code>) should be a syntax error.
As with <code>let</code> expressions,
all the names that are bound in a <code>valrec</code> expression must be unique.</p>
<p>Implement the <code>valrec</code> syntax
by extending the AST and IR type definitions
to include <code>ValRec</code> constructors:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>(* In ast.ml and ast.mli: *)
</span><span id="__span-10-2"><a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a>type def =
</span><span id="__span-10-3"><a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a>  | ...
</span><span id="__span-10-4"><a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a>  | ValRec of loc * (id * expr) list
</span><span id="__span-10-5"><a id="__codelineno-10-5" name="__codelineno-10-5" href="#__codelineno-10-5"></a>  | ...
</span><span id="__span-10-6"><a id="__codelineno-10-6" name="__codelineno-10-6" href="#__codelineno-10-6"></a>
</span><span id="__span-10-7"><a id="__codelineno-10-7" name="__codelineno-10-7" href="#__codelineno-10-7"></a>(* In ir.ml and ir.mli: *)
</span><span id="__span-10-8"><a id="__codelineno-10-8" name="__codelineno-10-8" href="#__codelineno-10-8"></a>type def =
</span><span id="__span-10-9"><a id="__codelineno-10-9" name="__codelineno-10-9" href="#__codelineno-10-9"></a>  | ...
</span><span id="__span-10-10"><a id="__codelineno-10-10" name="__codelineno-10-10" href="#__codelineno-10-10"></a>  | ValRec of loc * (id * expr) list
</span><span id="__span-10-11"><a id="__codelineno-10-11" name="__codelineno-10-11" href="#__codelineno-10-11"></a>  | ...
</span></code></pre></div>
<p>Note that the form of the constructors
is identical in the AST and the IR.
Extend the code in <code>ast.ml</code>
that converts from S-expressions to AST forms
so that it correctly parses <code>valrec</code> forms
(including error checking).</p>
<p>Finally, add <code>valrec</code> to the list of keywords in <code>ast.ml</code>.</p>
<h2 id="7-functions-with-variable-numbers-of-arguments">7. Functions with variable numbers of arguments</h2>
<p>[<strong>10 points</strong>]</p>
<p>Actual Scheme implementations
allow us to define functions that can take a variable number of arguments.
In fact, in real Scheme, many common functions,
like <code>+</code>, <code>*</code>, <code>&lt;</code> <em>etc.</em> take arbitrary numbers of arguments
(sometimes including zero).
Some functions, like the <code>list</code> function which creates new lists,
<em>have</em> to take arbitrary numbers of arguments
because we don't know in advance how many values the list being created
will contain.
In this problem, we'll extend the <code>lambda</code> and <code>define</code> forms
so that they can handle arbitrary numbers of arguments (including zero).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Of course,
not all functions will accept arbitrary numbers of arguments,
but enforcing that is the responsibility of the function;
it's not a syntax error.</p>
</div>
<p>To do this, we will implement two new forms in the AST:
<code>LambdaX</code> and <code>DefineX</code>, representing (respectively)
<code>lambda</code> expressions and <code>define</code> expressions
that can take arbitrary numbers of arguments.
(The old <code>Lambda</code> and <code>Define</code> constructors are still present in the AST.)
The new constructors are as follows:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>(* in ast.ml: *)
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a>
</span><span id="__span-11-3"><a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a>type expr =
</span><span id="__span-11-4"><a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a>  | ...
</span><span id="__span-11-5"><a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a>  | LambdaX of loc * id list * id * expr list
</span><span id="__span-11-6"><a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a>  | ...
</span><span id="__span-11-7"><a id="__codelineno-11-7" name="__codelineno-11-7" href="#__codelineno-11-7"></a>
</span><span id="__span-11-8"><a id="__codelineno-11-8" name="__codelineno-11-8" href="#__codelineno-11-8"></a>type def =
</span><span id="__span-11-9"><a id="__codelineno-11-9" name="__codelineno-11-9" href="#__codelineno-11-9"></a>  | ...
</span><span id="__span-11-10"><a id="__codelineno-11-10" name="__codelineno-11-10" href="#__codelineno-11-10"></a>  | DefineX of loc * id * id list * id * expr list
</span><span id="__span-11-11"><a id="__codelineno-11-11" name="__codelineno-11-11" href="#__codelineno-11-11"></a>  | ...
</span></code></pre></div>
<p>The last <code>id</code> field in each new constructor
represents the name of the argument
which will be bound to a list of all non-required argument values
(often referred to as the "rest" arguments
because they contain the rest of the arguments
after the required ones are bound).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When we say "bound to a list of all non-required argument values"
we have to be very careful what we mean by a <em>list</em>.</p>
<p>When a <code>lambda</code> expression with a rest argument
is applied to its actual arguments,
whichever ones are not matched by name
(<em>i.e.</em> whichever "extra" arguments are present)
are converted into a <em>uScheme</em> list (not an OCaml list!)
and are bound to the name of the rest argument
while evaluating the body of the <code>lambda</code>.</p>
<p>Since the environment can only bind names to <em>uScheme</em> values,
this list must be a single <em>uScheme</em> value <em>i.e.</em>
a list that can be created out of other <em>uScheme</em> values.
The way to build lists in any Scheme dialect is to
create chains of pairs ending in <code>nil</code>,
where the list elements are stored
in the <code>car</code> (first element) of the pairs,
and the <code>cdr</code> (second element) of each pair is the pair that
contains the rest of the list, or <code>nil</code> if the list ends there.
So a <em>uScheme</em> list is a chain of <code>PairVal</code> constructors
ending in a <code>NilVal</code> constructor.
The <code>NilVal</code> constructor represents the empty list
when used by itself or the end of the list when used with pairs.</p>
</div>
<p>The concrete syntax for these forms is as follows.
For <code>lambda</code>, there are two cases:</p>
<ul>
<li>
<p>a function which takes a single argument
which represents all the arguments of the function looks like this:
<code>(lambda args &lt;body&gt;)</code>.
(Note that <code>args</code> is <em>not</em> surrounded by parentheses.)</p>
</li>
<li>
<p>a function which takes one or more required arguments
and then an argument representing all other (non-required) arguments
looks like this: <code>(lambda (x y . rest) &lt;body&gt;)</code>.</p>
</li>
</ul>
<p>In both cases,
<code>&lt;body&gt;</code> represents the body of the <code>lambda</code> expression,
which can be one or more expressions
(but not zero expressions, as mentioned above).</p>
<p>When the first form (<code>(lambda args &lt;body&gt;)</code>) is applied to its arguments,
those arguments are bound to the <code>args</code> formal parameter
as a (<em>uScheme</em>) list of values
(of course, the name of the formal parameter doesn't have to be <code>args</code>).
When the second form is applied to its arguments,
all formal parameters before the <code>.</code> represent required arguments,
so they are taken from the values at the front of the argument list;
any arguments left over
become bound to the <code>rest</code> formal parameter as a list of values
(again, the argument doesn't have to be called <code>rest</code>).
In the second form, the dot (<code>.</code>) is special syntax;
it does not represent an identifier.
Only a single argument can follow the dot in the argument list,
or it's a syntax error.
Similarly, the dot can't be the first or last thing in the argument list
or it's a syntax error.</p>
<p>The <code>define</code> form is extended similarly:</p>
<ul>
<li>
<p>a function which takes a single argument
which represents all the arguments of the function is defined like this:
<code>(define &lt;name&gt; args &lt;body&gt;)</code>.
(Again, <code>args</code> is <em>not</em> surrounded by parentheses.)</p>
</li>
<li>
<p>a function which takes one or more required arguments
and then an argument representing all other (non-required) arguments
is defined like this:
<code>(define foo (x y . rest) &lt;body&gt;)</code>.</p>
</li>
</ul>
<p>If a <code>lambda</code> or <code>define</code> form doesn't use the new syntax,
it should be converted into the <code>Lambda</code> or <code>Define</code> AST forms as before.
If it does, it should be converted into <code>LambdaX</code> or <code>DefineX</code>,
respectively.</p>
<p>At the level of the IR, there are no <code>Define</code> or <code>DefineX</code> constructors
in the <code>def</code> type.
There is also no <code>LambdaX</code> constructor,
but you will change the definition of <code>Lambda</code> to this:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>(* In ir.ml: *)
</span><span id="__span-12-2"><a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a>
</span><span id="__span-12-3"><a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a>type expr =
</span><span id="__span-12-4"><a id="__codelineno-12-4" name="__codelineno-12-4" href="#__codelineno-12-4"></a>  | ...
</span><span id="__span-12-5"><a id="__codelineno-12-5" name="__codelineno-12-5" href="#__codelineno-12-5"></a>  | Lambda of loc * id list * id option * expr
</span><span id="__span-12-6"><a id="__codelineno-12-6" name="__codelineno-12-6" href="#__codelineno-12-6"></a>  | ...
</span></code></pre></div>
<p>The only change is that the <code>id option</code> field has been added.
When the <code>lambda</code>/<code>define</code> doesn't use arbitrary numbers of arguments,
this field should be <code>None</code>;
otherwise, it should be <code>Some &lt;name&gt;</code>
where <code>&lt;name&gt;</code> is the name of the formal parameter
which represents all non-required arguments.
Having only a single <code>Lambda</code> form in the IR
helps keep the evaluator simple
(which is the whole reason we're using an IR in the first place!)</p>
<p>Note that a <code>lambda</code> expression of the form <code>(lambda &lt;name&gt; ...)</code>
(representing a function with one argument
that gets all the actual arguments)
will have an empty <code>id list</code> field
but the <code>id option</code> field will be <code>Some &lt;name&gt;</code>.</p>
<p>Wow, that took a while to explain!
Now here is what you need to do:</p>
<ol>
<li>
<p>Extend the AST as described above.</p>
</li>
<li>
<p>Extend the functions which convert from S-expressions
to AST expressions/definitions
so that they can handle the new <code>lambda</code> and <code>define</code> forms.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Make sure you check for syntax errors
involving improper use of the <code>.</code> syntax!
All of these forms are errors:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>; can&#39;t have &quot;.&quot; as the first thing in the argument list...
</span><span id="__span-13-2"><a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a>(lambda (. x) ...)
</span><span id="__span-13-3"><a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a>
</span><span id="__span-13-4"><a id="__codelineno-13-4" name="__codelineno-13-4" href="#__codelineno-13-4"></a>; ... or as the last
</span><span id="__span-13-5"><a id="__codelineno-13-5" name="__codelineno-13-5" href="#__codelineno-13-5"></a>(lambda (x .) ...)
</span><span id="__span-13-6"><a id="__codelineno-13-6" name="__codelineno-13-6" href="#__codelineno-13-6"></a>
</span><span id="__span-13-7"><a id="__codelineno-13-7" name="__codelineno-13-7" href="#__codelineno-13-7"></a>; &quot;.&quot; can&#39;t be followed by more than one argument name
</span><span id="__span-13-8"><a id="__codelineno-13-8" name="__codelineno-13-8" href="#__codelineno-13-8"></a>(lambda (x y . z w) ...)
</span><span id="__span-13-9"><a id="__codelineno-13-9" name="__codelineno-13-9" href="#__codelineno-13-9"></a>
</span><span id="__span-13-10"><a id="__codelineno-13-10" name="__codelineno-13-10" href="#__codelineno-13-10"></a>; can&#39;t have more than one &quot;.&quot; in an argument list
</span><span id="__span-13-11"><a id="__codelineno-13-11" name="__codelineno-13-11" href="#__codelineno-13-11"></a>(lambda (x . y . z) ...)
</span><span id="__span-13-12"><a id="__codelineno-13-12" name="__codelineno-13-12" href="#__codelineno-13-12"></a>
</span><span id="__span-13-13"><a id="__codelineno-13-13" name="__codelineno-13-13" href="#__codelineno-13-13"></a>; same, but for &quot;define&quot;
</span><span id="__span-13-14"><a id="__codelineno-13-14" name="__codelineno-13-14" href="#__codelineno-13-14"></a>(define foo (. x) ...)
</span><span id="__span-13-15"><a id="__codelineno-13-15" name="__codelineno-13-15" href="#__codelineno-13-15"></a>(define foo (x .) ...)
</span><span id="__span-13-16"><a id="__codelineno-13-16" name="__codelineno-13-16" href="#__codelineno-13-16"></a>(define foo (x y . z w) ...)
</span><span id="__span-13-17"><a id="__codelineno-13-17" name="__codelineno-13-17" href="#__codelineno-13-17"></a>(define foo (x . y . z) ...)
</span></code></pre></div>
<p>In addition, using <code>"."</code> as a variable name
in a <code>val</code> or <code>let</code>/<code>let*</code>/<code>letrec</code>/<code>valrec</code> expression is an error,
and you have to check for this.</p>
</div>
<p>Checking that the dot is used correctly in argument lists
is quite tedious.
Making sure it isn't used as a variable name is also tedious.
You could make <code>.</code> a keyword
(which would also prevent it from being used as a variable name),
but we found it easier to make it a special case
and write some helper functions instead.
You can use your own coding judgment,
but here are some test cases
that should all cause syntax errors (and not <em>e.g.</em> name errors).
Note that we can't use <code>check-error</code> with these forms (why?).</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a>. ; not just a name error!
</span><span id="__span-14-2"><a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a>
</span><span id="__span-14-3"><a id="__codelineno-14-3" name="__codelineno-14-3" href="#__codelineno-14-3"></a>(val . 10)
</span><span id="__span-14-4"><a id="__codelineno-14-4" name="__codelineno-14-4" href="#__codelineno-14-4"></a>
</span><span id="__span-14-5"><a id="__codelineno-14-5" name="__codelineno-14-5" href="#__codelineno-14-5"></a>(set . 10)  ; not just a name error!
</span><span id="__span-14-6"><a id="__codelineno-14-6" name="__codelineno-14-6" href="#__codelineno-14-6"></a>
</span><span id="__span-14-7"><a id="__codelineno-14-7" name="__codelineno-14-7" href="#__codelineno-14-7"></a>(valrec [. 10])
</span><span id="__span-14-8"><a id="__codelineno-14-8" name="__codelineno-14-8" href="#__codelineno-14-8"></a>
</span><span id="__span-14-9"><a id="__codelineno-14-9" name="__codelineno-14-9" href="#__codelineno-14-9"></a>(let ([. 10]) 10)
</span><span id="__span-14-10"><a id="__codelineno-14-10" name="__codelineno-14-10" href="#__codelineno-14-10"></a>(let ([. 10]) .)
</span><span id="__span-14-11"><a id="__codelineno-14-11" name="__codelineno-14-11" href="#__codelineno-14-11"></a>
</span><span id="__span-14-12"><a id="__codelineno-14-12" name="__codelineno-14-12" href="#__codelineno-14-12"></a>(let* ([. 10]) 10)
</span><span id="__span-14-13"><a id="__codelineno-14-13" name="__codelineno-14-13" href="#__codelineno-14-13"></a>(let* ([. 10]) .)
</span><span id="__span-14-14"><a id="__codelineno-14-14" name="__codelineno-14-14" href="#__codelineno-14-14"></a>
</span><span id="__span-14-15"><a id="__codelineno-14-15" name="__codelineno-14-15" href="#__codelineno-14-15"></a>(letrec ([. 10]) 10)
</span><span id="__span-14-16"><a id="__codelineno-14-16" name="__codelineno-14-16" href="#__codelineno-14-16"></a>(letrec ([. 10]) .)
</span><span id="__span-14-17"><a id="__codelineno-14-17" name="__codelineno-14-17" href="#__codelineno-14-17"></a>
</span><span id="__span-14-18"><a id="__codelineno-14-18" name="__codelineno-14-18" href="#__codelineno-14-18"></a>(lambda (. x) .)
</span><span id="__span-14-19"><a id="__codelineno-14-19" name="__codelineno-14-19" href="#__codelineno-14-19"></a>(lambda (. x) x)
</span><span id="__span-14-20"><a id="__codelineno-14-20" name="__codelineno-14-20" href="#__codelineno-14-20"></a>(lambda (x .) .)
</span><span id="__span-14-21"><a id="__codelineno-14-21" name="__codelineno-14-21" href="#__codelineno-14-21"></a>(lambda (x .) x)
</span><span id="__span-14-22"><a id="__codelineno-14-22" name="__codelineno-14-22" href="#__codelineno-14-22"></a>(lambda (x . y z) .)
</span><span id="__span-14-23"><a id="__codelineno-14-23" name="__codelineno-14-23" href="#__codelineno-14-23"></a>(lambda (x . y z) x)
</span><span id="__span-14-24"><a id="__codelineno-14-24" name="__codelineno-14-24" href="#__codelineno-14-24"></a>(lambda (x . y . z) x)
</span><span id="__span-14-25"><a id="__codelineno-14-25" name="__codelineno-14-25" href="#__codelineno-14-25"></a>
</span><span id="__span-14-26"><a id="__codelineno-14-26" name="__codelineno-14-26" href="#__codelineno-14-26"></a>(define foo (. x) .)
</span><span id="__span-14-27"><a id="__codelineno-14-27" name="__codelineno-14-27" href="#__codelineno-14-27"></a>(define foo (. x) x)
</span><span id="__span-14-28"><a id="__codelineno-14-28" name="__codelineno-14-28" href="#__codelineno-14-28"></a>(define foo (x .) .)
</span><span id="__span-14-29"><a id="__codelineno-14-29" name="__codelineno-14-29" href="#__codelineno-14-29"></a>(define foo (x .) x)
</span><span id="__span-14-30"><a id="__codelineno-14-30" name="__codelineno-14-30" href="#__codelineno-14-30"></a>(define foo (x . y z) .)
</span><span id="__span-14-31"><a id="__codelineno-14-31" name="__codelineno-14-31" href="#__codelineno-14-31"></a>(define foo (x . y z) x)
</span><span id="__span-14-32"><a id="__codelineno-14-32" name="__codelineno-14-32" href="#__codelineno-14-32"></a>(define foo (x . y . z) x)
</span></code></pre></div>
<p>To test for syntax errors,
we have a shell script that runs <em>uScheme</em>
on files containing syntax errors
and checks for the phrase "syntax error" in the output.
It's crude but it works.</p>
</li>
<li>
<p>Extend the IR as described above.
This will involve changes to the files <code>ir.ml</code> and <code>ir.mli</code>.</p>
</li>
<li>
<p>Extend the functions that convert from AST expressions/definitions
to IR expressions/definitions
so that they can handle the new forms.
This will involve additional changes to the file <code>ir.ml</code>.</p>
</li>
</ol>
<p>There will be additional modifications needed
(notably to the evaluator);
we'll cover those in the next section.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../debugging/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Debugging">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Debugging
              </div>
            </div>
          </a>
        
        
          
          <a href="../partB_extending2/" class="md-footer__link md-footer__link--next" aria-label="Next: Part B: Finishing and extending uScheme: evaluation">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                Part B: Finishing and extending uScheme: evaluation
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "navigation.footer", "navigation.top"], "search": "../../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.d7c377c4.min.js"></script>
      
        <script src="../../../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>