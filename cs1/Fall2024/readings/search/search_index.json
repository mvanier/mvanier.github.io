{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 1 book: Fall 2024","text":"<p>This book is location of the readings for the Caltech CS 1 course  (Introduction to Computer Programming) for the Fall 2024 term.</p> <p>The course instructors are Adam Blank and Mike Vanier. The readings were mostly authored by Mike, with many ideas and suggestions coming from Adam.</p> <p>Please direct all comments about these readings to Mike. In particular, he is very interested in hearing about</p> <ol> <li>Typos and errors.</li> <li>Anything that isn't clear.</li> <li>Suggestions for topics that aren't covered but should be.</li> </ol> <p>Dark mode and grey mode</p> <p>Since reading a website with a bright white background can be hard on the eyes, this site can be switched to \"dark mode\" (dark background, light text) or \"grey mode\" (grey background, dark text) by clicking on the icon at the top of the page to the immediate left of the search bar.</p>"},{"location":"#feedback-is-welcome","title":"Feedback is welcome!","text":"<p>We like getting feedback! It will help make these readings better for future CS 1 classes, so don't be shy about emailing us if you think something can be explained better.</p>"},{"location":"1/reading1/","title":"Reading 1: Introduction to Python, part 1","text":"<p>I do not fear computers.  I fear the lack of them. - Isaac Asimov</p>"},{"location":"1/reading1/#introduction","title":"Introduction","text":"<p>Welcome to CS 1! We're delighted that you're taking our course. We hope you have a lot of fun and learn a lot in the process.</p> <p>This is the first \"reading\" of the course. The idea behind readings is to serve as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through code examples, answer questions, and get you thinking about the programming process. We will try to post the reading(s) corresponding to a lecture at least a day before the lecture. You should ideally have read it (them) before coming to lecture, so you can use class time to ask questions about the material and refine your understanding. We will use the questions you ask in the lecture to improve the readings.</p> <p>Note</p> <p>The readings will roughly correspond to the lecture topics, but it's not an exact equivalence; some topics may be covered more deeply in the readings than in lectures or vice-versa.</p>"},{"location":"1/reading1/#topics","title":"Topics","text":"<p>This reading is a general introduction to programming and Python, followed by a short crash course on the most basic aspects of Python, which will be continued in the next reading.</p>"},{"location":"1/reading1/#your-programming-background","title":"Your programming background","text":"<p>We are very well aware that students in CS 1 come from a very wide variety of backgrounds in terms of knowledge of computer programming. Some of you have never programmed a computer before. That's fine; you're in the right place! Others have done some or perhaps even extensive programming. We will try to make these notes accessible to everyone, and if there is a topic that you are very familiar with, we encourage you to skim (but not to skip) the notes on that topic.</p>"},{"location":"1/reading1/#programming-as-a-thought-process","title":"Programming as a thought process","text":"<p>[This section is for new programmers; experienced programmers can skip to the next section.]</p> <p>The hardest subjects to learn are usually those that force you to think in a different way than you're used to. For instance, when you learn algebra, you have to generalize the arithmetic you've learned (\"ten apples times three equals thirty apples\") to allow for unknown quantities (variables) (\"<code>x</code> apples times <code>y</code> equals <code>xy</code> apples\"). That's a mental leap. When you learn calculus you have to generalize what you know about functions to allow for operations like derivatives that take functions as arguments. And when you learn programming for the first time, you have to learn to \"think like a machine\". This is what we mean when we speak of programming as a thought process. \"Thinking like a machine\" means understanding enough about how the computer works to be able to predict what the result of executing your code is going to be.</p> <p>Thinking like a machine isn't necessarily hard, but it is different. The machine (the computer) works by iron-clad rules of logic, doing many very simple operations at blinding speed. We write programs to tell computers what to do, and the computer will do exactly what we tell it to, no more and no less, whether it makes sense or not. There is no room for error; if you get a single character wrong in your program, it will either do the wrong thing or not run at all. The computer doesn't know or care what you \"meant\" it to do, only what you specifically asked it to do. It is completely literal and completely unforgiving. You should expect to spend a lot of time fixing mistakes in your programs (which are called \"bugs\") to finally get it to do the right thing.</p>  The first bug ever found (1947): a moth trapped in the Mark II computer in Harvard University.  <p>Fortunately, the computer has a number of safeguards which prevent you from doing anything really horrible (so running a program is unlikely to physically destroy the computer itself, for instance); usually, if you make a mistake, it will just complain that something went wrong and halt, or else it'll just not do what you wanted it to.</p> <p>Learning to understand the very logical, very exact, very literal and incredibly picky way a computer works is going to take time. We're not going to lie to you: programming can be incredibly frustrating. But once you finally get it to do what you want, it's incredibly satisfying, and with experience, the less frustrating it gets and the more satisfying it is. (But the frustration never goes away entirely!) We will be trying to help you learn to \"think like a machine\" all through this course. Often, we will not give you the whole story about what is happening when we first introduce a topic, because to do that would take too long and be tedious. But as we visit and revisit topics, we will fill in more and more of the gaps so that eventually you'll have a very good idea of what happens when your programs execute. (To get a really deep understanding of all this, though, you'll have to take more courses than just CS 1!) Don't worry; it's going to be fun!</p>"},{"location":"1/reading1/#program-design-as-a-thought-process","title":"Program design as a thought process","text":"<p>[This section is for beginning and experienced programmers alike.]</p> <p>Even after you internalize the first thought process (thinking like a machine) you have to learn another thought process: how to design programs. You will have to write many functions and programs in this course. You'll be given a pretty precise description of what the function or program is supposed to do, and then you will have to write the code to do it. This is a creative act! There is always going to be more than one way to solve all but the simplest problems, and there is never going to be an objectively \"perfect\" answer. But for many programmers, even ones who understand the workings of a programming language quite well, it can be challenging to put together the elements of the programming language in the right way to solve a problem. We call this activity program design. As a creative act, we can't give exact rules on how to do it, but we can give guidelines, rules of thumb, and general wisdom we've accumulated over our years of programming. Knowing these guidelines and rules of thumb should help you when you have to write a function (or class, or module) but don't know where to start.</p> <p>The details of the programming languages we'll be teaching you (first Python, and then Java) will be in these readings. The thought process behind program design will mainly be covered in lectures, often by simply showing you a problem and walking through the steps needed to solve it. That way, you'll see how experienced programmers think about a problem, and you can apply what you learn to your own programs.</p>"},{"location":"1/reading1/#programming-jargon","title":"Programming jargon","text":"<p>Another challenge for beginning programmers is that programming uses a lot of common words with very specific meanings that aren't the usual meanings. Words like list, dictionary, string, file, function, interpreter and so on mean very different things when used in a programming context than they would mean in everyday conversation. We will try hard to be incredibly clear on what a particular programming term means, especially if that meaning is different from the common meaning. If you find a term we are using confusing, let us know so we can improve these readings!</p>"},{"location":"1/reading1/#the-choice-of-programming-languages","title":"The choice of programming language(s)","text":"<p>We will be using two programming languages in this course: Python and Java. We will use Python for about the first two-thirds of the course, and then switch to Java for the remainder of the course.</p> <p>Note</p> <p>Java is the only language used in CS 2, so it's important that you learn it before taking that course. Java is also well worth knowing in its own right.</p> <p>Python is an excellent first programming language. It's very useful for teaching the basic concepts of programming, and it's also an incredibly useful real-world language. Perhaps most relevant to you, Python has in recent years emerged as one of the most important programming languages in science and data analysis, as well as one of the most-used languages in machine learning and artificial intelligence. Python is easy to learn, incredibly versatile, very readable, and very consistent. You may know some (or a lot!) of Python already, but even in that case we're pretty sure we're going to be teaching you some new things about it.</p> <p></p> <p>We love Python both as a teaching language and as a language we use ourselves, but don't kid yourself: it's not the only good or useful programming language. As we mentioned, near the end of this course (and in CS 2) you will learn Java. if you take CS 3 and/or CS 11, you will learn C, and if you take CS 4 you will learn OCaml. Serious programmers need to know more than one language, so think of this as the start of your programming journey. Programming is a lot of fun, and we hope to show you why we love it so much and why it's so exciting to learn computer science.</p>"},{"location":"1/reading1/#a-brief-history-of-python","title":"A brief history of Python","text":"<p>Computer languages have weird names. Some, like <code>C</code>, are completely arbitrary and meaningless.<sup>1</sup> Others, like <code>Java</code> or <code>Ruby</code>, are named after something (coffee and the gem stone, respectively). <code>Python</code> is named after the British comedy group Monty Python's Flying Circus. It was invented in the late 1980s by Guido van Rossum, a Dutch programmer who wanted a language that was easier to use than C for everyday tasks. Guido was also a fan of the comedy group, so he named his language after them as an homage.</p> <p>Python has been under continual development ever since it was created, and the latest version of Python available as of this writing is Python 3.12.4. Python is now one of the most popular programming languages in use today.</p> <p>The Python home page is at https://www.python.org. (You should bookmark it, because the online Python documentation is hosted there, and you will definitely need that for this course.)</p>"},{"location":"1/reading1/#code-examples","title":"Code examples","text":"<p>In the supporting documents we will be going through all the details you need to know in order to get Python working on your computer, which IDE/editor to use<sup>2</sup>, etc. We won't do that in the readings, but instead we'll assume you can run Python code.</p> <p>Note</p> <p>If you can't do that yet, don't worry; you should still be able to understand the code examples. You simply won't be able to run them yourselves yet.</p> <p>However, we strongly recommend that you do get Python set up as soon as possible and follow along with the readings by typing in the examples and playing around with them; you'll learn a lot more that way and it'll be more fun too.</p> <p>Here is a snippet of Python code:</p> <pre><code>print('Hello, world!')\n</code></pre> <p>Believe it or not, this is a complete Python program! When run from a terminal window, it will print the words <code>Hello, world!</code> to the terminal.<sup>3</sup></p> <p>Terminals</p> <p>A terminal (more jargon!) is a program which allows you to directly type commands to your computer and receive textual output back from the computer. Some of you may never have used a terminal, because non-programmers typically have little use for one. Programmers use them all the time, and some of us spend most of our time on the computer working inside a terminal. Terminal programs include Terminal.app and Iterm.app (MacOS), Windows Terminal (Windows), and many different programs for Linux. You can run Python programs directly from a terminal, and we'll show you lots of examples of this.</p> <p>We will get into the details of Python below, but just so you aren't confused: the words <code>'Hello, world!'</code> in single quotes are a Python string (which is the way textual data is represented inside Python). The word <code>print</code> stands for a built-in Python function which takes a single argument (in this case the string <code>'Hello, world!'</code>) and prints it out to the terminal.<sup>4</sup> We'll talk more about functions in the next reading, and we'll cover strings in detail after that.</p> <p>The colors in the Python code snippet have nothing to do with the Python language; they are what is called \"syntax coloring\". Its purpose is just to make the code a bit more readable by highlighting different parts of the code in different ways. (They don't affect the meaning of the code at all.)</p>"},{"location":"1/reading1/#source-code-files-vs-the-interactive-interpreter","title":"Source code files vs. the interactive interpreter","text":"<p>In this course, we will be working with Python in two distinct ways:</p> <ul> <li> <p>interactively, using the Python \"interactive interpreter\"</p> </li> <li> <p>running Python on text files containing Python code</p> </li> </ul> <p>When we are giving lectures, we'll be using Python in both ways, and you will do the same when writing your assignments. You will also be running \"test suites\" which will rigorously test your code, but if something doesn't work, you'll have to run the code yourself one of these ways to figure out why!</p> <p>Note</p> <p>Don't worry, we'll show you how to debug your code when the time comes.</p>"},{"location":"1/reading1/#source-code-files","title":"Source code files","text":"<p>Python code that you write (using an editor) is called source code. The \"source\" word implies that this is the first thing that is created in order to make a program. (Files are just data that is stored on a computer permanently i.e. it doesn't disappear when the computer is turned off). Python source code files are plain text files with a specific suffix, which is <code>.py</code>. Usually, the name of a source code file is in all lowercase letters; for instance, you might have one called <code>lab1.py</code> or <code>sudoku.py</code>.</p> <p>Let's say we've written a file of Python code called <code>hello.py</code> which contains the following code:</p> <pre><code>print('Hello, world!')\n</code></pre> <p>We can run this file by typing the following command at a terminal command line:</p> <pre><code>$ python hello.py\n</code></pre> <p>The <code>$</code> is called a prompt; you don't type it.</p> <p>Prompts</p> <p>Your prompt may look different from this. It doesn't matter. The purpose of the prompt is to highlight where on the terminal the commands you type are going to be displayed.</p> <p>Inside a terminal there is a program called a shell which is running. The shell is the program which interprets commands like this. (Most people think of the terminal and the shell as one combined entity, but they are actually separate; a shell runs inside of a terminal.)</p> <p>The shell prompt (the <code>$</code> above) is printed automatically when the shell is waiting for more input. Then you type in the words <code>python hello.py</code> and hit the return key<sup>5</sup>. What this does is run the <code>python</code> program (which is the program that runs Python language files) on the file called <code>hello.py</code>.</p> <p>If all goes well, the terminal should print out:</p> <pre><code>Hello, world!\n</code></pre> <p>and return you to the prompt.</p> <p>Note</p> <p>This assumes your computer is running either Linux or Mac OS X as its operating system. If it's running Windows, you can get to a terminal prompt like this by installing the Windows Subsystem for Linux, but don't worry about this now; there are other ways to run Python programs. The important thing to understand is that you can run all the Python code in a single file with a single command.</p> <p>Python programs can be split between multiple files; such files are usually called \"modules\". We will talk more about modules in a future reading.</p>"},{"location":"1/reading1/#the-python-interpreter","title":"The Python interpreter","text":"<p>It's also possible to enter all the code for a program on-the-fly by starting up the Python interpreter. An interpreter or interactive interpreter is a program which reads lines of code you type and immediately runs them.<sup>6</sup> Python can work as an interpreter if you type the word <code>python</code> into a terminal, followed by typing the return key:</p> <p></p> <p>This will cause the interactive Python interpreter to start up. First, a banner message is printed, which identifies the Python version as well as some other information. Then the Python prompt is displayed. It looks like this:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> <p>The three <code>&gt;</code>s are the Python prompt. It's how Python tells you it's waiting for you to type a line of code for it to execute. (Don't confuse the Python prompt with the shell prompt! the Python prompt is only used to enter Python language statements, not to invoke arbitrary programs.)</p> <p>Now you can enter expressions at the prompt:</p> <pre><code>&gt;&gt;&gt; 1 + 1\n</code></pre> <p>Hit the return key, and Python will helpfully print out</p> <pre><code>2\n</code></pre> <p>and print out the prompt again. If you want to exit the interpreter, type \"control d\" i.e. hold down the \"control\" key on your keyboard while typing the letter <code>d</code> (lowercase). This will exit the interpreter and return you to the shell prompt. Typing <code>exit()</code> or <code>quit()</code> at the prompt followed by the return key  will also exit the interpreter.</p> <p>It's important to understand that the <code>&gt;&gt;&gt;</code> prompt is not part of the Python language; it's just the way that the interactive Python interpreter lets you know that it is waiting for you to enter some code.</p> <p>There is more to say about the interactive interpreter; we will cover it as we get to it.</p>"},{"location":"1/reading1/#python-as-a-calculator","title":"Python as a calculator","text":""},{"location":"1/reading1/#arithmetic-expressions","title":"Arithmetic expressions","text":"<p>One thing that is easy to do with Python is to use it as a kind of terminal-based calculator program. You do this by starting the interactive interpreter and entering arithmetic expressions:</p> <pre><code>&gt;&gt;&gt; 2 + 2\n4\n&gt;&gt;&gt; 1.2 * 3.4\n4.08\n&gt;&gt;&gt; 2 ** 16\n65536\n&gt;&gt;&gt; (4 - 2) * (3 + 3)\n12\n&gt;&gt;&gt; 1/6\n0.16666666666666666\n</code></pre> <p>and so on. Note that some common operations use different operators than is customary in math:</p> Operator symbol Meaning in Python <code>*</code> multiplication <code>/</code> division <code>**</code> to the power of <p>This is done because common symbols like the \"times\" symbol (\\(\\times\\)) and the \"divide\" symbol (\\(\\div\\)) can't be typed on a standard keyboard. (Most programming languages use <code>*</code> and <code>/</code> for multiplication and division.) Traditional math notation uses superscripts for powers, which is also not easily typeable, so Python uses <code>**</code>. For instance, <code>2 ** 16</code> means \\(2^{16}\\).</p>"},{"location":"1/reading1/#numbers","title":"Numbers","text":"<p>Numbers in Python can be \"integers\" (no fractional part) or \"floating point\" (approximate real numbers). Floating point numbers are a computer approximation to real numbers. Some real numbers (like \\(\\pi\\) or \\(e\\)) need an infinite number of decimal places to represent them exactly. Computers don't have infinite storage, so the number is cut off after a certain number of decimal places, and we call this kind of number a \"floating point\" number (or \"float\" for short).</p> <pre><code>&gt;&gt;&gt; 42\n42\n&gt;&gt;&gt; 1.23\n1.23\n&gt;&gt;&gt; 6.022e23\n6.022e+23\n</code></pre> <p><code>42</code> is an integer, and <code>1.23</code> and <code>6.022e23</code> are floating point numbers. The <code>e</code> means \"exponent\", so <code>6.022e23</code> means \\(6.022 \\times 10^{23}\\). You can combine integers and floating-point numbers in arithmetic expressions:</p> <pre><code>&gt;&gt;&gt; 42 + 1.23\n43.23\n</code></pre> <p>Python even lets you enter complex numbers:</p> <pre><code>&gt;&gt;&gt; (1.0+2.3j) * (3.4+4.5j)\n(-6.949999999999999+12.32j)\n</code></pre> <p>(Don't worry if you don't yet know what complex numbers are.)</p> <p>Note</p> <p>The long list of consecutive <code>9</code>s in <code>(-6.949999999999999+12.32j)</code> are due to roundoff error. It's not something you need to be worried about now.</p>"},{"location":"1/reading1/#operator-precedence","title":"Operator precedence","text":"<p>When writing arithmetic expressions with different operators, sometimes there will be two reasonable ways to interpret the expression. For instance:</p> <pre><code>1 + 2 * 3\n</code></pre> <p>could mean either</p> <pre><code>1 + (2 * 3)\n</code></pre> <p>or</p> <pre><code>(1 + 2) * 3\n</code></pre> <p>The usual rule in math is to do multiplications (and divisions) before additions (and subtractions), so in fact Python evaluates this expression the first way:</p> <pre><code>&gt;&gt;&gt; 1 + 2 * 3\n7\n</code></pre> <p>If you really want to evaluate it the second way, add the parentheses yourself:</p> <pre><code>&gt;&gt;&gt; (1 + 2) * 3\n9\n</code></pre> <p>In computer-language-speak, we say that the <code>*</code> operator has a higher precedence than the <code>+</code> operator. There are a lot of precedence rules in Python (and in most programming languages), but you don't generally have to think about them; Python usually does what you expect. Most of the time, all you need to remember is that:</p> <ul> <li><code>*</code> and <code>/</code> have a higher precedence than <code>+</code> or <code>-</code>,</li> <li><code>**</code> has a higher precedence than <code>*</code> or <code>/</code>,</li> <li><code>=</code> (assignment, next section) has a lower precedence than any of them,</li> <li>and use parentheses if you need to force a different order of evaluation.</li> </ul> <p>If you positively have to know what the relative precedences of different operators are, you should look at the Python language operator precedence table. (This might be worth bookmarking.)</p> <ol> <li> <p>It's actually called <code>C</code> because it's the successor to a language called <code>B</code>. We hope that clears that up.\u00a0\u21a9</p> </li> <li> <p>Did you catch that? We just dropped two programming jargon terms on you: \"IDE\" and \"editor\". An \"editor\" is a program that allows you to write text files, which is what programs are, and \"IDE\" stands for Integrated Development Environment, which is a kind of super-editor that allows you to run and debug code as well as edit it.\u00a0\u21a9</p> </li> <li> <p>It's a tradition for the first program you write in a new language to be one that prints out the phrase <code>\"Hello, world!\"</code>. This started with the C programming language in the 1970s and persists to this day.\u00a0\u21a9</p> </li> <li> <p>The <code>print</code> function can do much more than this, but this is the simplest way to use it.\u00a0\u21a9</p> </li> <li> <p>Some keyboards have the \"return\" key labelled as \"Enter\" instead of \"return\". It does the same thing.\u00a0\u21a9</p> </li> <li> <p>If you eventually take Mike's CS 131 course, you'll learn how to write your own interpreters!\u00a0\u21a9</p> </li> </ol>"},{"location":"10/reading10/","title":"Reading 10: Conditionals","text":"<p>If it's a penny for your thoughts and you put in your two cents worth, then someone, somewhere is making a penny. - Steven Wright</p>"},{"location":"10/reading10/#overview","title":"Overview","text":"<p>In this reading we are going to learn how to use Python's conditional statements, which allow your programs to change their behaviors based on various conditions that occur as the program runs.</p>"},{"location":"10/reading10/#topics","title":"Topics","text":"<ul> <li> <p>Relational operators</p> </li> <li> <p>The <code>if</code> statement</p> </li> <li> <p>The <code>if</code>/<code>else</code> statement</p> </li> <li> <p>Multi-way tests and <code>elif</code></p> </li> </ul>"},{"location":"10/reading10/#what-a-conditional-is","title":"What a conditional is","text":"<p>One fundamental thing a computer program needs to be able to do is to make decisions about what to do given the data available. If certain conditions are met, the program does one thing, and if different conditions exist, it does another thing. Programming languages do this by means of conditionals, which in most languages (including Python) are called <code>if</code> statements.</p>"},{"location":"10/reading10/#a-simple-example","title":"A simple example","text":"<p>We'll return to a problem we've discussed before: analyzing temperatures collected at noon on every day of the week. How do we figure out how many of the temperatures are above 72 degrees? We can't solve this with what we know so far.</p> <p>This problem naturally divides into two subproblems:</p> <ul> <li> <p>How do we test to see whether or not a particular temperature   is greater than 72 degrees?</p> </li> <li> <p>How do we use that information to control our program?</p> </li> </ul>"},{"location":"10/reading10/#relational-operators","title":"Relational operators","text":"<p>To compare a number with another number, we need a relational operator. The standard relational operators in Python are:</p> Operator What it means <code>==</code> equal to <code>!=</code> not equal to <code>&lt;</code> less than <code>&lt;=</code> less than or equal <code>&gt;</code> greater than <code>&gt;=</code> greater than or equal <p>These operators should be familiar from math, although in math we often use nicer operator symbols like \u2264, \u2265, and \u2260 instead of <code>&lt;=</code>, <code>&gt;=</code>, and <code>!=</code>. (When we write programs, we're limited by what we can type on our keyboards.) We also use <code>==</code> instead of <code>=</code> for equality comparison.</p> <p>Relational operators take two numbers as arguments and return either <code>True</code> or <code>False</code>.</p> <pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 20\n&gt;&gt;&gt; a &gt; b\nFalse\n&gt;&gt;&gt; a &lt; b\nTrue\n&gt;&gt;&gt; a == a\nTrue\n&gt;&gt;&gt; a == b\nFalse\n&gt;&gt;&gt; a != b\nTrue\n&gt;&gt;&gt; a &lt;= a\nTrue\n&gt;&gt;&gt; b &gt;= a\nTrue\n&gt;&gt;&gt; 42 &gt;= 42\nTrue\n</code></pre> <p>These are pretty intuitive, but be careful with the <code>==</code> operator. Remember that the <code>=</code> operator is used for assignment and only for assignment. What this means is that you can't write (say) <code>x = y</code> when you mean <code>x == y</code>, because only the latter expression will return a boolean (<code>True</code>/<code>False</code>) value.<sup>1</sup></p> <p>For this problem, we want to check to see if a temperature is greater than 72 degrees.</p> <pre><code>&gt;&gt;&gt; temp = 85\n&gt;&gt;&gt; temp &gt; 72\nTrue\n</code></pre> <p>OK, this solves our first problem: how to test whether the temperature is greater than 72 degrees. What about the second problem?</p>"},{"location":"10/reading10/#the-if-statement","title":"The <code>if</code> statement","text":"<p>The second problem is: how do we use that information to control our program? In Python, we use the <code>if</code> statement:</p> <pre><code>temp = 85\nif temp &gt; 72:\n    print('Hot!')\n</code></pre> <p>which will of course print out:</p> <pre><code>Hot!\n</code></pre> <p>The general structure of an <code>if</code> statement is:</p> <pre><code>if &lt;boolean expression&gt;:\n    &lt;block of code&gt;\n</code></pre> <p>Let's explore what this means and how it works.</p>"},{"location":"10/reading10/#truthiness-and-falsiness","title":"\"Truthiness\" and \"falsiness\"","text":"<p>The word \"boolean\" in <code>&lt;boolean expression&gt;</code> just means \"true or false\". Python does have the boolean values called <code>True</code> and <code>False</code>. However, Python is pretty lenient about what it considers to be \"true\" or \"false\" in an <code>if</code> statement's boolean expression; it doesn't have to evaluate to the <code>True</code> or <code>False</code> value. As far as Python is concerned, \"false\" can be any one of the following things:</p> <ul> <li>the <code>False</code> value</li> <li>the integer <code>0</code></li> <li>the empty string <code>''</code></li> <li>the empty list <code>[]</code></li> </ul> <p>and a few other things we haven't seen yet. We say that these values are \"falsy\". Anything else is considered to be \"true\" (\"truthy\") in a boolean expression.<sup>2</sup> From now on, when we say that a boolean expression is \"false\", we mean that it evaluates to a \"falsy\" value, and when we say it's \"true\", we mean that it evaluates to a \"truthy\" value.</p> <p>If you want to test if a particular value is \"truthy\" or \"falsy\", you can pass it as the argument of the <code>bool</code> function. If it's \"truthy\", then <code>bool</code> will return <code>True</code>, and if it's \"falsy\", <code>bool</code> will return <code>False</code>.</p> <pre><code>&gt;&gt;&gt; bool(True)\nTrue\n&gt;&gt;&gt; bool(False)\nFalse\n&gt;&gt;&gt; bool(0)\nFalse\n&gt;&gt;&gt; bool([])\nFalse\n&gt;&gt;&gt; bool('')\nFalse\n&gt;&gt;&gt; bool(1)\nTrue\n&gt;&gt;&gt; bool(abs)  # Even a function is truthy!\nTrue\n</code></pre>"},{"location":"10/reading10/#evaluating-an-if-statement","title":"Evaluating an <code>if</code> statement","text":"<p>The way an <code>if</code> statement evaluates is simple: if the <code>&lt;boolean expression&gt;</code> evaluates to a true value, evaluate the <code>&lt;block of code&gt;</code>. Otherwise, don't. Then continue with the code following the <code>if</code> statement. (We'll extend this below when we talk about the <code>if</code>/<code>else</code> statement.)</p>"},{"location":"10/reading10/#syntax-notes","title":"Syntax notes","text":"<ul> <li> <p>Don't forget to put the colon character (<code>:</code>) after the <code>&lt;boolean expression&gt;</code>, or it'll be a syntax error! Python requires the colon for all of its statements with blocks, so at least it's consistent.</p> </li> <li> <p>The <code>&lt;block of code&gt;</code> in an <code>if</code> statement is like the body of a <code>for</code> loop: all the lines should be indented to the same extent.</p> </li> </ul>"},{"location":"10/reading10/#back-to-the-example","title":"Back to the example","text":"<p>We have a list of temperatures, one for each day this week.</p> <pre><code>temps = [67, 75, 59, 73, 81, 80, 71]\n</code></pre> <p>We want to compute how many of these are above 72. How do we do this in our program?</p> <p>We already know how to compare a particular temperature with 72 using a relational operator. We will also need an <code>if</code> statement to do something only if the temperature is above 72. But we have a whole list of temperatures, not just one. Therefore, it makes sense that we will also need a <code>for</code> loop to iterate over the list.</p> <p>We can write a \"skeleton\" of the code we need like this:</p> <pre><code>temps = [67, 75, 59, 73, 81, 80, 71]\nfor temp in temps:\n    if temp &gt; 72:\n        &lt;do something&gt;\n</code></pre> <p>We just have to fill in the <code>&lt;do something&gt;</code> part.</p> <p>A couple of notes about this code:</p> <ul> <li> <p>An <code>if</code> statement inside of a <code>for</code> loop is a very common \"code pattern\". As you write more programs, you will start to see more code patterns, and knowing these patterns will make it much easier for you to solve programming problems.<sup>3</sup></p> </li> <li> <p>Writing a \"skeleton\" of code with pieces left out is sometimes called pseudocode. Sometimes (like in this case) pseudocode is very close to real code. Other times it's just an English description of how to solve a problem. Either way, writing pseudocode can help you get started writing a program even if you don't know exactly how to write everything yet.</p> </li> </ul> <p>For this problem, we need to figure out how many values in the list are above 72. That suggests that we need to have a variable that contains the count of these values. We'll call this variable <code>temps_above_72</code>. Before the loop, this variable should start off at <code>0</code>. Then, every time we encounter a temperature above 72, we add 1 to the variable.</p> <pre><code>temps = [67, 75, 59, 73, 81, 80, 71]\ntemps_above_72 = 0\nfor temp in temps:\n    if temp &gt; 72:\n        temps_above_72 += 1\n</code></pre> <p>At the end of the loop, the value of the <code>temps_above_72</code> variable is the count of all the temperatures in the list which are above 72.</p> <p>Notice that we used the <code>+=</code> operator. We could have written <code>temps_above_72 = temps_above_72 + 1</code>, but using the <code>+=</code> operator is much more concise.<sup>4</sup></p> <p>To complete this example, let's add a <code>print</code> statement after the loop:</p> <pre><code>temps = [67, 75, 59, 73, 81, 80, 71]\ntemps_above_72 = 0\nfor temp in temps:\n    if temp &gt; 72:\n        temps_above_72 += 1\nprint('{} days above 72'.format(temps_above_72))\n</code></pre> <p>When this is run it prints out:</p> <pre><code>4 days above 72\n</code></pre> <p>This is a trivial example; you could easily have done it in your head. However, it becomes much less trivial if you have one million temperatures, or one billion, or even more. It's important to realize that computers aren't only useful for doing difficult computations; they are also useful for doing large numbers of simple computations.</p>"},{"location":"10/reading10/#the-ifelse-statement","title":"The <code>if</code>/<code>else</code> statement","text":"<p>An <code>if</code> statement allows you to either</p> <ul> <li>do something (execute a block of code) if a condition is true, or</li> <li>do nothing if it isn't true</li> </ul> <p>More generally, we might want to</p> <ul> <li> <p>do something (execute a block of code) if a condition is true, or</p> </li> <li> <p>do something different (execute a different block of code) if the condition isn't true</p> </li> </ul> <p>To deal with the second case, an <code>if</code> statement can optionally include a second part called the \"<code>else</code> clause\". The structure of such a statement is:</p> <pre><code>if &lt;boolean expression&gt;:\n    &lt;block of code&gt;\nelse:\n    &lt;different block of code&gt;\n</code></pre> <p>The word <code>else</code> is a keyword, of course. The <code>if</code> and <code>else</code> keywords have to be indented the same amount. There has to be a colon (<code>:</code>) after the <code>else</code> keyword. If the <code>&lt;boolean expression&gt;</code> is true then only the <code>if</code> block is evaluated; if it's false then only the <code>else</code> block is evaluated.</p> <p>Terminology</p> <p>In an <code>if</code>/<code>else</code> statement, the <code>if</code> part (including the block) is referred to as the \"<code>if</code> clause\" and the <code>else</code> part (including the block) is referred to as the \"<code>else</code> clause\".</p> <p>Here's an example:</p> <pre><code>temp = 69\nif temp &gt; 72:\n    print('greater than 72!')\nelse:\n    print('less than or equal to 72!')\n</code></pre> <p>Predictably, this will print:</p> <pre><code>less than or equal to 72!\n</code></pre>"},{"location":"10/reading10/#multi-way-tests","title":"Multi-way tests","text":"<p>In the previous example we had two situations: when the temperature was less than 72 and when it wasn't. More generally, there may be many different mutually-exclusive situations, and you might want to do something different for each of them. We call this a multi-way test.</p> <p>Let's imagine a very simple generalization of our previous example. We will go though a list of temperatures and keep records of</p> <ul> <li>the number of temperatures that are less than 72 degrees</li> <li>the number of temperatures that are exactly 72 degrees</li> <li>the number of temperatures that are greater than 72 degrees</li> </ul> <p>We'll assume (as we have been doing) that all the temperatures are integers. How do we write this code?</p> <p>It turns out that there are several different ways to write it, but only one \"nice\" way. Whichever way we choose, we are going to need some variables:</p> <pre><code>temps_below_72 = 0\ntemps_at_72 = 0\ntemps_above_72 = 0\n</code></pre>"},{"location":"10/reading10/#the-bad-way","title":"The bad way","text":"<p>One way to write this code is as follows:</p> <pre><code>if t &lt; 72:\n    temps_below_72 += 1\nif t == 72:\n    temps_at_72 += 1\nif t &gt; 72:\n    temps_above_72 += 1\n</code></pre> <p>This will work, but it's bad code. Why? Think about this for a minute and then click on \"Answer\" for the answer.</p> Answer <p>The problem with this approach is that you may do unnecessary tests. It's clear that the three cases (temperature less than 72, equal to 72, or greater than 72) are mutually exclusive, but the way the code is written, you could end up checking all three conditions even if you don't have to.</p> <p>For example, let's say that the temperature is less than 72. Let's follow the execution of the code. First, we execute the first <code>if</code> statement, which causes <code>temps_below_72</code> to be incremented by 1.</p> <pre><code>if t &lt; 72:\n    temps_below_72 += 1\nif t == 72:\n    temps_at_72 += 1\nif t &gt; 72:\n    temps_above_72 += 1\n</code></pre> <p>Then, we execute the second <code>if</code> statement. Nothing happens, because <code>t</code> isn't equal to <code>72</code>.</p> <pre><code>if t &lt; 72:\n    temps_below_72 += 1\nif t == 72:\n    temps_at_72 += 1\nif t &gt; 72:\n    temps_above_72 += 1\n</code></pre> <p>Finally, we execute the third <code>if</code> statement. Again nothing happens, because <code>t</code> isn't greater than <code>72</code>.</p> <pre><code>if t &lt; 72:\n    temps_below_72 += 1\nif t == 72:\n    temps_at_72 += 1\nif t &gt; 72:\n    temps_above_72 += 1\n</code></pre> <p>It should be clear that the last two tests are completely unnecessary. Once we know that <code>t</code> is less than <code>72</code>, we shouldn't have to test if it's equal to <code>72</code> or greater than <code>72</code>.</p> <p>Of course, in this case the tests are not computationally expensive: you are just comparing two integers. But what if the tests involved calls to functions that were computationally expensive? That would slow the code down a lot, especially since in many cases you wouldn't even need the answer!</p> <p>This kind of bad code pattern is often called an antipattern, which just means that it's a common bad way of doing something.</p>"},{"location":"10/reading10/#a-better-way","title":"A better way","text":"<p>To avoid doing unnecessary tests, we can rewrite the code using <code>else</code> statements.</p> <pre><code>if t &lt; 72:\n    temps_below_72 += 1\nelse:\n    if t == 72:\n        temps_at_72 += 1\n    else:  # t &gt; 72\n        temps_above_72 += 1\n</code></pre> <p>This code is correct and doesn't do any unnecessary tests. One curious thing is that we don't have to explicitly test for <code>t &gt; 72</code>, because if we get to the second <code>else</code> clause, we know that <code>t</code> must be greater than <code>72</code>. We write this fact in a comment to alert anyone reading the code that this will be the case.</p> <p>Even though this code works and doesn't do unnecessary tests, it's still ugly. Nested <code>if</code>/<code>else</code> statements such as this are hard to read (and even more so if the comment was left out). Also, what if you had 5, 10, or more mutually-exclusive cases to test for? Then you would have a great number of nested <code>if</code>/<code>else</code> statements, and the code would be really hard to read.</p> <pre><code>temps_below_60 = 0\ntemps_between_60_and_65 = 0\ntemps_between_65_and_70 = 0\ntemps_between_70_and_75 = 0\nif t &lt; 60:\n    temps_below_60 += 1\nelse:\n    if t &lt; 65:\n        temps_between_60_and_65 += 1\n    else:\n        if t &lt; 70:\n            temps_between_65_and_70 += 1\n        else:\n            if t &lt; 75:\n                temps_between_70_and_75 += 1\n            else:\n                ...\n</code></pre> <p>You get the idea. This kind of situation is surprisingly common in code, and Python has the tools to deal with it.</p>"},{"location":"10/reading10/#the-best-way-the-ifelifelse-statement","title":"The best way: the <code>if</code>/<code>elif</code>/<code>else</code> statement","text":"<p>Let's think about how we would say this in pseudo-English. \"If the temperature is less than 72 degress, do (one thing), else if it's exactly 72, do (another thing), else do (a third thing).\"</p> <p>To write this code in Python, we introduce the <code>elif</code> keyword. <code>elif</code> is short for <code>else if</code>.<sup>5</sup> An <code>elif</code> clause contains a test (like the <code>if</code> line) and also has a block of code (like both the <code>if</code> and <code>else</code> clauses).</p> <p>Here's what the code above looks like when using <code>elif</code>:</p> <pre><code>if t &lt; 72:\n    temps_below_72 += 1\nelif t == 72:\n    temps_at_72 += 1\nelse:  # t &gt; 72\n    temps_above_72 += 1\n</code></pre> <p>This is both efficient and readable, and it will also scale to as many cases as we like. Therefore, when doing multi-way tests, use the <code>if</code>/<code>elif</code>/<code>else</code> form.</p>"},{"location":"10/reading10/#syntax-notes_1","title":"Syntax notes","text":"<ul> <li> <p>All conditional forms start with the <code>if</code> keyword; you can't have an <code>else</code> clause or an <code>elif</code> clause without an <code>if</code> clause.</p> </li> <li> <p>There can be any number of <code>elif</code> clauses, including zero. Each one has to have its own test.</p> </li> <li> <p>The <code>else</code> clause is always optional, even after an <code>elif</code> clause. If the <code>else</code> clause is omitted, that means to do nothing if the other cases don't apply.</p> </li> <li> <p>Don't forget the colon character (<code>:</code>) after the boolean expression on the <code>if</code> and <code>elif</code> lines, and directly after the <code>else</code> keyword.</p> </li> </ul>"},{"location":"10/reading10/#a-pitfall","title":"A pitfall","text":"<p>Even though in many cases of multi-way tests, using an <code>if</code>/<code>elif</code>/<code>else</code> statement with one or more <code>elif</code>s is the right approach, it's dangerous to rely on this too much. Sometimes you can write the code to avoid conditionals altogether, and in these cases, you usually shouldn't use conditionals.</p> <p>Here's an example. Try to figure out what is wrong with this code, and how you would rewrite it. (Assume that the function will only receive valid inputs.)</p> <pre><code>def scale_value(lst, scale, index):\n    \"\"\"\n    Return a list value multiplied by a scale value\n    which depends on the position in the list.\n\n    Arguments:\n      lst, scale: lists of integers of length 4\n      index: an integer between 0 and 3\n\n    Return value: an integer\n    \"\"\"\n\n    if index == 0:\n        result =  lst[0] * scale[0]\n    elif index == 1:\n        result =  lst[1] * scale[1]\n    elif index == 2:\n        result =  lst[2] * scale[2]\n    elif index == 3:\n        result =  lst[3] * scale[3]\n    # no `else` clause\n    return result\n</code></pre> Answer <p>This function can be simplified almost to the point of non-existence. Here's the corrected version:</p> <pre><code>def scale_value(lst, scale, index):\n    \"\"\"\n    Return a list value multiplied by a scale value\n    which depends on the position in the list.\n\n    Arguments:\n      lst, scale: lists of integers of length 4\n      index: an integer between 0 and 3\n\n    Return value: an integer\n    \"\"\"\n\n    return lst[index] * scale[index]\n</code></pre> <p>In fact, though, the function is so simple that we probably wouldn't even define it. Instead, everywhere we would want to use it we'd just write <code>lst[index] * scale[index]</code> (with variable names changed as needed).</p> <p>Even though the original function was correct, using an <code>if</code>/<code>elif</code>/<code>else</code> statement is clearly wrong because it's unnecessary. When you can rewrite the code to be much more concise, as in this case, you generally should.</p> <ol> <li> <p>Fortunately, if you make a mistake with this, Python will usually catch it right away and label it as a syntax error.\u00a0\u21a9</p> </li> <li> <p>This may seem sloppy to you, and it is. But being sloppy about what is \"false\" allows you to write some kinds of code in a more natural way, as we'll see. There are trade-offs for everything.\u00a0\u21a9</p> </li> <li> <p>It's similar to the way knowing idioms or expressions in a human language helps you speak the language more fluently.\u00a0\u21a9</p> </li> <li> <p>If you've programmed in C or Java, you might wonder if you could write this line as <code>temps_above_72++</code>. The answer is: no, you can't. Python doesn't have the <code>++</code> or <code>--</code> operators.  Sorry.\u00a0\u21a9</p> </li> <li> <p>You might be wondering why Python chose an unintuitive keyword like <code>elif</code> instead of just using <code>else if</code> (like C and Java do). It turns out that using <code>elif</code> instead of <code>else if</code> made it easier to write the Python parser (the part of the Python interpreter that converts the Python source code to something the interpreter can interpret).\u00a0\u21a9</p> </li> </ol>"},{"location":"11/reading11/","title":"Reading 11: Loops (part 2)","text":"<p>I discovered that the most interesting music of all was made by simply lining the loops in unison, and letting them slowly shift out of phase with each other. - Steve Reich</p>"},{"location":"11/reading11/#overview","title":"Overview","text":"<p>In this reading we are going to continue the discussion of loops begun in reading 9, and introduce a new loop type and some new keywords.</p>"},{"location":"11/reading11/#topics","title":"Topics","text":"<ul> <li><code>while</code> loops</li> <li>infinite loops</li> <li>the <code>break</code> statement</li> <li>the D.R.Y. principle</li> </ul>"},{"location":"11/reading11/#loops-beyond-for","title":"Loops: beyond <code>for</code>","text":"<p>Previously in reading 9 we introduced loops with the <code>for</code> loop. <code>for</code> loops are the most common kind of loop in Python, but they are not the best choice for every situation. For instance:</p> <ul> <li>sometimes we're not working with lists (or even sequences)</li> <li>sometimes we don't have a fixed number of things to loop over</li> <li>sometimes we don't know in advance   how many times we will have to go through the loop</li> </ul> <p>For these, we will need a different kind of loop.</p>"},{"location":"11/reading11/#while-loops","title":"<code>while</code> loops","text":"<p>Python has a more primitive kind of looping statement called a <code>while</code> loop. It has the following structure:</p> <pre><code>while &lt;boolean expression&gt;:\n    &lt;block of code&gt;\n</code></pre> <p>This is syntactically very similar to an <code>if</code> statement: there is a keyword (<code>while</code>) followed by a boolean expression, and a colon character (<code>:</code>) at the end of the line. The rest is a block of code, with each line indented to the same extent. In fact, the only difference between a <code>while</code> loop and an <code>if</code> statement is the use of the keyword <code>while</code> instead of <code>if</code>! The meaning is quite different, though.</p> <p><code>while</code> loops evaluate as follows:</p> <ol> <li>The boolean expression is evaluated.</li> <li>If the boolean expression gives a true (truthy) value,    execute the block of code and go back to step 1.</li> <li>Otherwise, exit the loop.</li> </ol>"},{"location":"11/reading11/#a-simple-example","title":"A simple example","text":"<p>Starting at the number 10, print all the numbers from 10 down to 1:</p> <pre><code>num = 10\nwhile num &gt; 0:\n    print(num)\n    num -= 1\nprint('Done!')\n</code></pre> <p>When evaluated, this code prints out:</p> <pre><code>10\n9\n8\n7\n6\n5\n4\n3\n2\n1\nDone!\n</code></pre> <p>Notice that when <code>num = 0</code>, the <code>while</code> loop exits and Python continues executing with the line after the <code>while</code> loop (line 5).</p>"},{"location":"11/reading11/#a-bad-example","title":"A bad example?","text":"<p>This example is unrealistic; you could easily write it with a <code>for</code> loop:</p> <pre><code>for num in [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]:\n    print(num)\n</code></pre> <p>When we learn about the <code>range</code> function, we'll be able to write this even more concisely. To spare you the suspense, here it is:</p> <pre><code>for num in range(10, 0, -1):\n    print(num)\n</code></pre> <p>Since it's so easy to write this code using a <code>for</code> loop, there's no point is using the more primitive <code>while</code> loop. (In fact, doing so would be bad style.)</p>"},{"location":"11/reading11/#a-better-example","title":"A better example","text":"<p>Problem: use the <code>input</code> function to read numbers from the user and print them, stopping when a negative number is read.</p> <p>In this case, we cannot know how many times we will have to go through the loop (because we can't control what the user does). This is a much more natural situation in which to use a <code>while</code> loop. (Loops where you don't know how many iterations will occur are often referred to as indefinite loops.)</p> <p>Here's our first attempt:</p> <pre><code>num = int(input('Enter a number: '))\nwhile num &gt; 0:\n    print('Your number was: {}'.format(num))\n    num = int(input('Enter a number: '))\nprint('Done!')\n</code></pre> <p>Obviously, this will print out different things every time the code is run. Here's one sample run:</p> <pre><code>Enter a number: 1729\nYour number was: 1729\nEnter a number: 2716057\nYour number was: 2716057\nEnter a number: -91\nDone!\n</code></pre> <p>Fun facts?</p> <p>The numbers I chose to enter are not at all random. For fun, do a web search on them. </p>"},{"location":"11/reading11/#ugly-code","title":"Ugly code","text":"<p>Let's look at that code again, with line numbers:</p> <pre><code>num = int(input('Enter a number: '))\nwhile num &gt; 0:\n    print('Your number was: {}'.format(num))\n    num = int(input('Enter a number: '))\nprint('Done!')\n</code></pre> <p>This code works, but it's ugly. Why?</p> <p>It's because of the repetition. Two of the lines (lines 1 and 4) are exactly the same except for indentation. Writing the same line more than once is very bad style.<sup>1</sup> The problem with repeated code is</p> <ul> <li>it's annoying to read</li> <li>there is almost always a way to write it without repetition</li> <li>if you want to change something in the code,   you have to change every repeat or else it probably won't work</li> </ul> <p>As you get more experience programming, you should develop a personal sense of code aesthetics, and one thing we want you to internalize is that repeated code should make you feel uneasy. It's ugly, it could be written better, and it will probably cause problems later on.</p>"},{"location":"11/reading11/#the-dry-principle","title":"The D.R.Y. principle","text":"<p>There is a programming principle that summarizes this kind of judgment: the D.R.Y. principle. The acronym D.R.Y. just means Don't Repeat Yourself. If you find yourself writing the same line, or even almost the same line, more than once, you are violating the D.R.Y. principle and you should consider rewriting your code to making it \"DRYer\".</p> <p>However, in order to fix this code, we have to introduce a couple of things in Python we haven't seen before.</p>"},{"location":"11/reading11/#infinite-loops","title":"Infinite loops","text":"<p>You almost always want a loop to end. But there is no reason why you can't have an infinite loop, which is a loop that never ends. In Python, it's as simple as this:</p> <pre><code>while True:\n    print('This never ends!')\n</code></pre> <p>which when run prints out:</p> <pre><code>This never ends!\nThis never ends!\nThis never ends!\nThis never ends!\nThis never ends!\nThis never ends!\nThis never ends!\nThis never ends!\n...\n</code></pre> <p>on and on until you halt it by typing Control-C (the Control key and the <code>c</code> key pressed at the same time).<sup>2</sup></p> <p>Infinite loops are not useless, but we do need some way of exiting the loop when some condition is met. Let's build up to that.</p> <p>If we re-wrote our loop example using an infinite loop, it might look like this:</p> <pre><code>while num &gt; 0:\n    num = int(input('Enter a number: '))\n    print('Your number was: {}'.format(num))\n</code></pre> <p>This is both good and bad. On the good side, we've gotten rid of the repetition. On the bad side, it never halts! We need to find a way to make it stop.</p>"},{"location":"11/reading11/#the-break-statement","title":"The <code>break</code> statement","text":"<p>When you want to manually break out of a loop at a particular point, you do this with a <code>break</code> statement. A <code>break</code> statement is just the keyword <code>break</code>, and it means \"get out of this loop now!\" It's often used inside an infinite (<code>while True:</code>) loop. So the phrase \"infinite loop\" is actually a misnomer; almost always what we really want isn't an infinite loop, but a loop which exits somewhere in the middle of the loop body when some condition is met. This is extremely flexible, though you rarely need it.</p> <p>Let's look at how we could use this to fix our example:</p> <pre><code>while True:\n    num = int(input('Enter a number: '))\n    if num &lt; 0:\n        break\n    else:\n        print('Your number was: {}'.format(num))\n</code></pre> <p>Notice that we can't decide whether to exit the loop until we have the number, since the exit condition is that the number is <code>&lt; 0</code>. But in order to get the number, we have to use the <code>input</code> function. If we don't want to repeat the <code>input</code> line, it has to be inside the loop. This means that we can only choose whether to exit the loop when we are part way through executing the loop body. This is a typical reason to use a <code>break</code> statement.</p> <p>Notice that this also removed the repetition from our code, so we have \"DRYed\" up the code. This is objectively better code; for instance, if we wanted to change the prompt, we would only have to do it in one place. Repeated code is almost always bad code.</p> <p>Actually, we can simplify the code a bit more:</p> <pre><code>while True:\n    num = int(input('Enter a number: '))\n    if num &lt; 0:\n        break\n    print('Your number was: {}'.format(num))\n</code></pre> <p>There is no need for the <code>else</code>, because if the <code>break</code> ever executes, the loop terminates, so if you get past the <code>break</code> you are already in the \"else\" case.<sup>3</sup></p>"},{"location":"11/reading11/#when-to-use-break-rules-of-thumb","title":"When to use <code>break</code> (rules of thumb)","text":"<ul> <li> <p>A regular <code>while</code> loop (without <code>break</code>) works well when we can test for the loop exit condition before we start executing the loop body.</p> </li> <li> <p>If you need to check for the exit condition in the middle or end of the loop body you probably want to have an infinite loop (<code>while True:</code>) with a <code>break</code> statement in the loop body.<sup>4</sup></p> </li> </ul> <p>If you don't mind repeating code, you can always rewrite a loop so it doesn't need a <code>break</code>, but it's usually much easier to understand code that uses a <code>break</code> than code with repetition. So, when necessary: give yourself a <code>break</code>!<sup>5</sup></p> <p>It's also important to realize that the D.R.Y. principle is a rule of thumb; it's a guideline that will generally steer you towards better code. Like every rule of thumb, though, there may be exceptions. Sometimes, a little repetition may be better than trying to write the D.R.Y.-est possible code. As you gain experience with programming, you will develop an intuition about what good code is and what it isn't.</p>"},{"location":"11/reading11/#returning-from-inside-a-loop","title":"<code>return</code>ing from inside a loop","text":"<p>Sometimes you can get away with using a <code>return</code> statement instead of a <code>break</code> statement. This happens when you are in a function and you are looking for a particular value; when you find it, you return from the entire function (which implies that you also exit the loop). Here's a function which is somewhat similar to our previous example but which uses <code>return</code> instead of <code>break</code> to exit a <code>while</code> loop:</p> <pre><code>def get_number():\n    \"\"\"Get a positive integer from the terminal.\"\"\"\n    while True:\n        num = int(input('Enter a number: '))\n        if num &gt; 0:\n            return num\n</code></pre> <p>An interaction with <code>get_number</code> might look like this:</p> <pre><code>&gt;&gt;&gt; get_number()\nEnter a number: -10\nEnter a number: -42\nEnter a number: 55\n55\n</code></pre> <p>In this case, the <code>while</code> loop will continue until the user inputs a positive integer.<sup>6</sup> Once that happens, the <code>return</code> will exit the function, so you don't need a <code>break</code>. You could use a <code>break</code>, like this:</p> <pre><code>def get_number():\n    \"\"\"Get a non-negative integer from the terminal.\"\"\"\n    while True:\n        num = int(input('Enter a number: '))\n        if num &gt; 0:\n            break\n    return num\n</code></pre> <p>This will do the same thing, but it's more code.</p>"},{"location":"11/reading11/#more-about-break","title":"More about <code>break</code>","text":"<p>For completeness, we should mention a couple of other things about <code>break</code>:</p> <ul> <li> <p>You aren't required to use <code>while True:</code> in order to use <code>break</code>. You can use <code>break</code> inside any <code>while</code> loop.</p> </li> <li> <p>You can also use <code>break</code> from inside a <code>for</code> loop as well as a <code>while</code> loop.</p> </li> <li> <p>A <code>break</code> statement only exits the nearest enclosing loop. If you have a nested loop (say, a <code>for</code> loop inside another <code>for</code> loop), the <code>break</code> will only exit the innermost loop that contains it. If you want to break out of more than one loop, you have to do it a different way.<sup>7</sup></p> </li> </ul>"},{"location":"11/reading11/#looking-forward","title":"Looking forward","text":"<p>There is another loop-related keyword called <code>continue</code> which we will discuss in a few readings. It's rarely needed but (again) can be used to make code DRYer in some cases.</p> <ol> <li> <p>Some authors call it a \"code smell\" because it's \"stinky\".\u00a0\u21a9</p> </li> <li> <p>Control-C is a common way to halt runaway processes, at least on Unix-based systems like Linux and MacOS.\u00a0\u21a9</p> </li> <li> <p>A similar thing happens when you use <code>return</code> inside an <code>if</code> statement.\u00a0\u21a9</p> </li> <li> <p>Many languages like C and Java have a <code>do</code>/<code>while</code> loop which is used when the test comes at the end of the loop. Python doesn't have this kind of loop.\u00a0\u21a9</p> </li> <li> <p>If you think this will be the last bad joke in the readings, think again.\u00a0\u21a9</p> </li> <li> <p>Or until the user inputs a non-integer, which will result in an error.\u00a0\u21a9</p> </li> <li> <p>The usual way of doing this involves raising an exception and then catching it outside of all the loops you want to exit. We will learn about exceptions in later readings.\u00a0\u21a9</p> </li> </ol>"},{"location":"12/reading12/","title":"Reading 12: Files","text":"<p>I bought a donut and they gave me a receipt for the donut. I don't need a receipt for a donut! I'll just give you the money, and you give me the donut. End of transaction! We don't need to bring ink and paper into this! I can't imagine a scenario where I'd have to prove that I bought a donut. Some skeptical friend... \"Don't even act like I didn't get that donut! I've got the documentation right here! Oh, wait, it's back home, in the file. Under D...for donut.\" - Mitch Hedberg</p>"},{"location":"12/reading12/#overview","title":"Overview","text":"<p>In this reading we'll talk about files, which are the most basic way to store data permanently.</p>"},{"location":"12/reading12/#topics","title":"Topics","text":"<ul> <li>Files</li> <li>Binary and text files</li> <li>Opening and closing files</li> <li>Reading from text files</li> </ul>"},{"location":"12/reading12/#why-files","title":"Why files?","text":"<p>Data that computer programs act on can be either temporary or permanent. Values of program variables are temporary (they disappear when a program exits). But we often want to work with more permanent data. For example, if we are analyzing some data, we probably want the raw data to be available in some permanent form so that we can analyze it in multiple ways, or so that we can add more data as it comes in. The most basic way to store data in a permanent way on a computer is to use a file.<sup>1</sup></p> <p>The word \"file\" is borrowed from its more traditional use as a folder in a \"file cabinet\", where paper records have been stored since at least the mid-1800s. In the context of computers, a \"file\" is a data structure that is stored on some permanent medium (such as a hard disk, a solid state disk, flash memory, or even magnetic tape). The important things about a file are that</p> <ul> <li> <p>it contains data</p> </li> <li> <p>the data it contains does not go away when a program exits or when the computer it is stored on is switched off</p> </li> </ul> <p>We say that data stored in files is \"persistent\" for this reason; it \"persists\" even when you turn your computer off.</p> <p>We've already been working with files, of course. Every time you write a program (say, a CS 1 assignment), you are creating a file. Program source code is traditionally stored in files, but files are used for much more than this:</p> <ul> <li>scientific data</li> <li>media of all types (books, PDFs, audio files, video files)</li> <li>executable (binary) versions of computer programs</li> <li>configuration information</li> <li>personal information</li> </ul> <p>and much more. Without files, most of what we do with computers would not be possible.</p>"},{"location":"12/reading12/#binary-and-text-files","title":"Binary and text files","text":"<p>We can distinguish two primary types of files based on the way the data is formatted: binary files and text files. The word binary just means that it is made up of raw <code>0</code>s and <code>1</code>s (binary numbers) stored on a computer disk.<sup>2</sup> Of course, computer disks don't store actual <code>0</code>s and <code>1</code>s (whatever that might mean); they store a physical representation of them in terms of some physical property that can have one of two states (for instance, the magnetization state of a tiny area of a metal disk, or the electric charge stored in a flash memory cell).</p>  Data: it's all just bits!  <p>Aside: Ternary computers</p> <p>There is no fundamental reason why data has to be stored as bits (base 2 numbers). From an engineering standpoint, though, it makes sense: it's a lot easier to store data on a computer if you only have to distinguish between two physical states than if you have to distinguish between more than two states. But other ways of encoding data have been tried. For instance, some computers made in the Soviet Union in the late 1950s to the early 1970s used base-3 (ternary) numbers, which actually have some theoretical advantages; it's possible that base-3 computers may become popular again. For more information on these unusual computers see this Wikipedia article.</p> <p>When we speak of a binary file, we just mean a \"raw\" file that can be anything. In fact, all files on a computer are binary files.  But some files store their bits in particular ways that make sense for a particular kind of data. We refer to these \"ways of storing bits in a file\" as a file's encoding.  One very common kind of file encoding is as a text file.</p> <p>A text file is a file where each consecutive sequence of 8 bits (called a byte) represents a single character.<sup>3</sup> These files are easy to read because a program can read a single byte and immediately convert it into the appropriate character; they are easy to write for similar reasons. In this course, when we say \"file\" we will usually mean \"text file\". Nevertheless, non-text files are very important; if your program reads or writes images, or audio, or video, it will need to use non-text file encodings.</p>"},{"location":"12/reading12/#an-example","title":"An example","text":"<p>Let's assume there is a text file called <code>temps.txt</code> containing temperature data taken once per day at noon. This file could be large (more than 1000 entries). We will assume that the text file has exactly one temperature number per line. We want to read numbers from this file and compute values from them.</p> <p>Since <code>temps.txt</code> is a text file, it contains a sequence of characters. These characters can be interpreted as numbers. For instance, the file might look like this:</p> <pre><code>78.2\n68.3\n59.0\n88.1\n49.5\n99.0\n</code></pre> <p>Of course, a real file of temperature data would probably be much larger. We'll work with this file for the rest of this reading.</p>"},{"location":"12/reading12/#opening-a-file","title":"Opening a file","text":"<p>Files in Python are represented as file objects i.e. objects which represent a file on a hard drive (or some other storage medium e.g. a solid-state drive). These are not the same thing as the file itself; instead, they provide a convenient way to interact with the file from Python.</p> <p>Before we work with a file, we have to create a file object in Python that is linked to the real file. After that, doing an operation on a file operations just means calling a method on the file object. File objects are created using the <code>open</code> function.</p> <pre><code>&gt;&gt;&gt; temps = open('temps.txt', 'r')\n&gt;&gt;&gt; temps\n&lt;_io.TextIOWrapper name='temps.txt' mode='r' encoding='UTF-8'&gt;\n</code></pre> <p>You don't need to understand everything that is printed out when you enter <code>temps</code>, but it's Python's way of telling you that <code>temps</code> is an object of the class <code>_io.TextIOWrapper</code> with the name <code>temps.txt</code>, the mode <code>r</code> and the encoding <code>UTF-8</code>. (We haven't learned about classes yet, but we will.) You might expect it to say <code>file</code> somewhere; actually, <code>_io.TextIOWrapper</code> is (in Python) a more general version of a file. The <code>UTF-8</code> encoding is one of the standard encodings for text files.<sup>4</sup></p> <p>What's important here is that the <code>temps</code> object is a Python object that is able to do operations on the actual file <code>temps.txt</code> by calling its methods. Before we get to that, let's look at the <code>open</code> function in more detail.</p> <p>The <code>open</code> function is used to create file objects given a file name. A call to <code>open</code> looks schematically like this:</p> <pre><code>open(&lt;name of file&gt;, &lt;mode&gt;)\n</code></pre> <p>This function returns a Python file object. The <code>&lt;name of file&gt;</code> argument is the file's name as a string. The <code>&lt;mode&gt;</code> argument is one or more characters that describe how the file can be used. We won't go through all the possible mode values; a full list is here if you're interested. For our purposes, you should know these three modes:</p> <ul> <li> <p><code>'r'</code> \u2014 the file is opened read-only;</p> </li> <li> <p><code>'w'</code> \u2014 the file is opened write-only; if the file already existed before the <code>open</code> call, it will be wiped out and overwritten;</p> </li> <li> <p><code>'a'</code> \u2014 the file is opened write-only; if the file already existed before the <code>open</code> call, writing to the file will append the new text to the end of the file.</p> </li> </ul> <p>For the <code>'r'</code> and <code>'a'</code> modes, if the file doesn't exist, a <code>FileNotFoundError</code> exception is raised.</p> <p>In this case, we are reading from an existing file called <code>temps.txt</code> and we are not going to write back into that file, so the <code>'r'</code> mode is appropriate.</p> <p>If you leave off the <code>&lt;mode&gt;</code> argument, then <code>'r'</code> is assumed (this is called a default argument, and we'll learn more about it in later readings). For instance:</p> <pre><code>&gt;&gt;&gt; open('foo.txt')\n</code></pre> <p>is the same as:</p> <pre><code>&gt;&gt;&gt; open('foo.txt', 'r')\n</code></pre>"},{"location":"12/reading12/#file-paths-and-the-file-system","title":"File paths and the file system","text":"<p>When you open a file, you have to specify the name of the file, but it's more involved than that. The string you provide is called a file path and it represents a file's \"location\" in the file system. You don't need to understand the file system other than to understand that it's a series of nested directories which are places where files can be located.</p> <p>The topmost directory in the file system is called the root directory; on many computers (notably MacOS and Linux) the root directory is identified by a single forward slash (<code>/</code>); on Windows it's a backwards slash (<code>\\</code>) (usually called a \"backslash\"). The topmost directory where you can store your files is called your home directory. You can create subdirectories whenever you want, and it's a good idea to do so in order to organize your files.</p> <p>Directories</p> <p>Creating and navigating through directories is outside the scope of these readings. Most of the time, this is done outside of Python, either in a graphical program called a file manager, or in the terminal using special commands. For instance, on Linux and MacOS, relevant terminal commands include:</p> <ul> <li><code>cd</code> \u2014 change directories</li> <li><code>mkdir</code> \u2014 make a new directory</li> <li><code>ls</code> \u2014 list the files in a directory</li> </ul> <p>Windows terminals use different commands to achieve the same thing.</p> <p>Many programs that run on your computer (for instance, terminal programs and text editors) keep track of a current directory which they are able to access directly. The Python interpreter also keeps track of the current directory. Unless you do something unusual, this will be the directory in which you started Python. You can access this from the Python interpreter by importing the <code>os</code> module and calling the <code>getcwd</code> (get current working directory) function:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.getcwd()\n'/Users/student'\n</code></pre> <p>[Of course, on your computer it will probably return a different result.]</p> <p>A file path always ends with the name of the file. If that's all there is, then the file is assumed to be in the current directory. If you want to open a file that isn't in the current directory, you have these choices:</p> <ul> <li> <p>You can specify an absolute path. This is a list of all the directories starting from the root directory and ending in the current directory, plus the file name, separated by slashes (forward slashes for MacOS/Linux, backslashes for Windows). For instance:</p> <pre><code>&gt;&gt;&gt; open('/Users/student/cs1/assignments/1/lab1.data', 'r')\n</code></pre> <p>(This assumes that a file named <code>lab1.data</code> exists in the directory <code>/Users/student/cs1/assignments/1</code>.)<sup>5</sup></p> </li> <li> <p>You can specify a relative path. This is like an absolute path, but it starts from the current directory instead of the root directory. This is indicated by dropping the initial slash character. For instance, if you are in the <code>'/Users/student/cs1'</code> directory, you might type:</p> <pre><code>&gt;&gt;&gt; open('assignments/1/lab1.data', 'r')\n</code></pre> <p>to open the same file as before.</p> </li> </ul> <p>There are two more things you may find in a file path:</p> <ol> <li> <p>The <code>.</code> character by itself means the current directory.</p> </li> <li> <p>The <code>..</code> characters means the parent of the current directory, which is \"one up\" in the directory tree.</p> </li> </ol> <p>You can use these to create arbitrarily complicated paths. For example, if the current directory is <code>/Users/student/cs2/assignments/2</code> and you wanted to open <code>/Users/student/cs1/assignments/1/lab1.data</code> you could type:</p> <pre><code>&gt;&gt;&gt; open('../1/lab1.data', 'r')\n</code></pre> <p>instead of the much longer</p> <pre><code>&gt;&gt;&gt; open('/Users/student/cs1/assignments/1/lab1.data', 'r')\n</code></pre> <p>That's enough about file paths for now.  You'll soon get used to them.</p>"},{"location":"12/reading12/#closing-a-file","title":"Closing a file","text":"<p>Before we get to the interesting stuff (which is how to read information from a file), we need to talk briefly about closing files. Once we are done working with a file, we should close it, which means to make it so that no further actions (reads or writes) can be done to the file. We do this by calling the file object's <code>close</code> method. For instance:</p> <pre><code>file = open('temps.txt', 'r')\n# ... read data from the file object ...\nfile.close()  # close the file\n</code></pre> <p>After closing a file, any attempt to read from (or write to) the file will result in an error.</p> <p>If a file isn't closed, it will eventually be closed anyway once the program exits. However, it is bad practice to have large numbers of open files in a program which are no longer being used. Most operating systems have a limit on the number of files that can be open at the same time, and if you are collecting data from a lot of files, you might exceed that limit. It's better to close a file as soon as you no longer need it.</p>"},{"location":"12/reading12/#reading-from-text-files","title":"Reading from text files","text":"<p>Probably the most common thing to do with text files is to read lines from them. Of course, text files are actually just linear sequences of characters (like strings stored on a disk drive). We can think of them as sequences of lines, where a \"line\" is a sequence of characters ending in a newline character (the <code>'\\n'</code> character).</p> <p>Note</p> <p>Files are not true Python sequences in the sense that a string or a list is a Python sequence. For instance, you can't use the square bracket syntax on file objects to get a particular line.</p> <p>Python has two basic methods for reading lines from text files, which we now describe.</p>"},{"location":"12/reading12/#the-readlines-method-on-files","title":"The <code>readlines</code> method on files","text":"<p>We'll start with the <code>readlines</code> method, because it's conceptually simpler. What this method does is to return all the lines in a file as a list of strings. This method is very easy to use. Typically, you have some code like this:</p> <pre><code>file = open('temps.txt', 'r')\nlines = file.readlines()\nfile.close()\n</code></pre> <p>and then you can use the <code>lines</code> list however you want. If you look at the <code>lines</code> list you'll see that it's a list of strings, where each string ends in a newline character:<sup>6</sup></p> <pre><code>&gt;&gt;&gt; lines\n['78.2\\n', '68.3\\n', '59.0\\n', '88.1\\n', '49.5\\n', '99.0\\n']\n</code></pre> <p>Note that this is not a list of <code>float</code>s, even though that's really what we want. We would have to convert each string to a float in order to get the list we want. Here's one (bad) way to do it:</p> <pre><code>file = open('temps.txt', 'r')\nlines = file.readlines()\nfile.close()\nfor line in lines:\n    line = float(line)\n</code></pre> <p>At the end of this, <code>lines</code> will now be a list of <code>float</code>s, each representing a temperature. Although this works, it's bad because the name <code>line</code> suggests a string, and what we want are numbers.<sup>7</sup> In this case, you would be better off creating a new list of numbers. That code might look like this:</p> <pre><code>file = open('temps.txt', 'r')\nlines = file.readlines()\nfile.close()\nnums = []\nfor line in lines:\n    nums.append(float(line))\n</code></pre> <p>Then we could use the <code>nums</code> list for whatever we wanted. On the other hand, this second version has a problem too: if the file is very long, you are creating two big lists in memory, where previously you were creating only one. It would be better if we could go through the file line by line, convert each line to a <code>float</code>, and append it to the <code>nums</code> list without ever having to save the <code>lines</code> list. But since we used the <code>readlines</code> method, we've already created the <code>lines</code> list, so this won't work. We have to try a different approach.</p>"},{"location":"12/reading12/#a-pitfall","title":"A pitfall","text":"<p>We'll get back to the example shortly, but we want to alert you to something that can be confusing for new programmers. Once you have read one or more lines of text from a text file into a list, the strings in the list are completely independent of the lines in the file they came from. So if you change any of the lines in the list, the file will not change as a result. Files are not lists and can't be altered like lists. (There are ways to change the contents of files, and we will see one of them below, but it's not this simple.)</p> <p>For instance, this code:</p> <pre><code>file = open('temps.txt', 'r')\nlines = file.readlines()\nfile.close()\nlines[0] = '0.0\\n'\n</code></pre> <p>will not change the first number in the file to <code>0.0</code>. In fact, the file can't be changed at all, since you opened it in read-only mode.</p>"},{"location":"12/reading12/#the-readline-method-on-files","title":"The <code>readline</code> method on files","text":"<p>Getting back to our problem, what we have seen is that there are many situations where you would like to be able to read the lines in a file one at a time without storing the lines in a list. In fact, this is the usual situation. Once you read a line, you may convert it into some other kind of data, you may save that data in some way or use it to compute something else, and once you've done this, you no longer need the original line.</p> <p>For this kind of case, Python provides the <code>readline</code> method. It reads a single line from a file and returns it (including the newline character at the end of the line). The file object also keeps track of where in the file the line was read from, so that the next time the method is called, it will read the next line in the file, and so on. If there are no more lines in the file, the <code>readline</code> method returns the empty string.<sup>8</sup></p> <p>Question</p> <p>What is the difference between what happens when</p> <ul> <li> <p>you use the <code>readline</code> method to read a blank line from a file, or</p> </li> <li> <p>you use it to try to read a line from a file when all the lines in the file have already been read?</p> </li> </ul> <p>Think about this before clicking to reveal the answer.</p> Answer <p>This is one reason Python keeps the newline character in the string that is returned from the <code>readline</code> method. Reading a blank line from a file using the <code>readline</code> method will not return an empty string; it will return a string containing a single newline character i.e. <code>'\\n'</code>. Trying to read a line from a file when all lines have been read returns the empty string i.e. <code>''</code>. So if <code>readline</code> ever returns the empty string, you know that there are no more lines in the file to read.</p> <p>Let's say we wanted to compute the average of all the temperatures in our <code>temps.txt</code> file. We could read our file using a series of calls to the <code>readline</code> method:<sup>9</sup></p> <pre><code>file = open('temps.txt', 'r')\nsum_nums = 0.0\nn = 0  # number of lines\n\nline = file.readline()\nsum_nums += float(line)\nn += 1\n\nline = file.readline()\nsum_nums += float(line)\nn += 1\n\nline = file.readline()\nsum_nums += float(line)\nn += 1\n\nline = file.readline()\nsum_nums += float(line)\nn += 1\n\n# ... etc. until there are no more lines ...\n\nfile.close()\navg = sum_nums / n\n</code></pre> <p>This is not an effective strategy, though. We have no way of knowing exactly how many lines there are in the file, so we don't know how many times to call the <code>readline</code> method. Even worse, we are repeating the same code over and over, so this is an egregious violation of the D.R.Y. principle.</p> <p>We hope that at this point, your brain is screaming \"USE A LOOP!\" because that's exactly what we'll do. Since we don't know how many times we'll have to go through the loop, we'll use a <code>while</code> loop.</p> <p>We've mentioned before that pseudocode is an English-language description of code that can easily be converted into real code. Here's a pseudocode version of the code we'll write:</p> <pre><code>open the file\ninitialize sum_nums and n to zero\nread a line\nwhile the line is not empty (we're not at the end of the file):\n    convert the line to a float\n    add the float to sum_nums\n    add 1 to n\ndivide sum_nums by n to get the average\nprint the average\nclose the file\n</code></pre> <p>Translating this to Python is easy:</p> <pre><code>file = open('temps.txt', 'r')\nsum_nums = 0\nn = 0\nline = file.readline()\nwhile line != '':\n    num = float(line)\n    sum_nums += num\n    n += 1\n    line = file.readline()\navg = sum_nums / n\nprint('Average temperature: {}'.format(avg))\nfile.close()\n</code></pre> <p>This code will repeatedly call the <code>readline</code> method on the file object until it returns the empty string (i.e. until there are no more lines). Each time the <code>readline</code> method returns a line, the <code>float</code> function converts it into a floating-point number which is added to the <code>sum_nums</code> variable. We also keep track of the line count with the <code>n</code> variable. At the end, we divide the sum by the number of lines to get the average temperature, and we print it out to the terminal.</p> <p>What's nice about this code is that we never have to store a list of all the lines, or, for that matter, a list of all the numbers. We go through the file line-by-line, updating the <code>sum_nums</code> and the <code>n</code> variables, and then at the end of the loop we have the information we need to compute the average. No matter how big the file is, this code will still work, and we won't run out of memory storing big lists.</p> <p>However, this code is a bit clunky. (Clunky means inelegant, and possibly too repetitive or too verbose.) The <code>num</code> variable doesn't have to be there; we only use it to hold the temperature value before adding it to <code>sum_nums</code>. We can get rid of it and tighten up the code a bit:</p> <pre><code>file = open('temps.txt', 'r')\nsum_nums = 0\nn = 0\nline = file.readline()\nwhile line != '':\n    sum_nums += float(line)\n    n += 1\n    line = file.readline()\navg = sum_nums / n\nprint('Average temperature: {}'.format(avg))\nfile.close()\n</code></pre> <p>Unfortunately, that's not all that's wrong with this code. The line <code>line = file.readline()</code> is repeated twice, which violates the D.R.Y. principle. There should be a better way to write this.</p>"},{"location":"12/reading12/#the-dry-principle-again","title":"The D.R.Y. principle again","text":"<p>We've seen before that repeated code in a loop often means that the test for whether to get out of a loop shouldn't come at the beginning of the loop, but somewhere inside the loop. Would that trick work here too?  Let's try it:</p> <pre><code>file = open('temps.txt', 'r')\nsum_nums = 0\nn = 0\nwhile True:\n    line = file.readline()\n    if line == '':  # no more lines\n        break       # exit the loop\n    sum_nums += float(line)\n    n += 1\navg = sum_nums / n\nprint('Average temperature: {}'.format(avg))\nfile.close()\n</code></pre> <p>It works!  And the repetition is gone; the code is very D.R.Y.</p> <p>Notice that the <code>while True:</code> line just means \"repeat\". In pseudocode, what the loop means is:</p> <pre><code>repeat:\n   read a line from the file\n   if the line is empty (end of file), exit the loop\n   otherwise, convert the line to a float and add to sum_nums\n   add 1 to n\n</code></pre> <p>We can make one more readability improvement. Remember that when we talked about <code>if</code> we said that Python treats a few values as \"false\" even if they aren't the actual <code>False</code> value? We called these values \"falsy\" values. Falsy values include the integer <code>0</code>, the empty string, and the empty list. Since the empty string is considered to be \"falsy\", and the <code>readline</code> method returns the empty string if it can't read a line, we can rewrite this code like this:</p> <pre><code>file = open('temps.txt', 'r')\nsum_nums = 0\nn = 0\nwhile True:\n    line = file.readline()\n    if not line:\n        break\n    sum_nums += float(line)\n    n += 1\navg = sum_nums / n\nprint('Average temperature: {}'.format(avg))\nfile.close()\n</code></pre> <p>We've only changed the highlighted line: <code>if line == '':</code> became <code>if not line:</code>.  </p> <p>The <code>not</code> operator</p> <p><code>not</code> is an operator that flips boolean values: <code>not True</code> is <code>False</code> and <code>not False</code> is <code>True</code>.  It may look like a function,  but you don't need to put its argument in parentheses.  We say it's a prefix operator.</p> <p>So if <code>line</code> is the empty string <code>''</code>, then <code>line</code> is \"falsy\" and <code>not line</code> is \"truthy\". In fact, if we try this in Python:</p> <pre><code>&gt;&gt;&gt; not ''\nTrue\n</code></pre> <p>we see that <code>not line</code> will be <code>True</code> if there are no more lines to read. So <code>if not line:</code> reads like English, which is something that Python programmers appreciate.</p> <p>Now our code works, is D.R.Y., and reads well, so we are happy with it.</p>"},{"location":"12/reading12/#looking-forward","title":"Looking forward","text":"<p>We have more to say about files, but this reading is long enough! Here are some of the related topics we will discuss in future readings:</p> <ul> <li> <p>There is an even more concise way to write the averaging code that uses a <code>for</code> loop instead of a <code>while</code> loop.</p> </li> <li> <p>We will see how to write to text files.</p> </li> <li> <p>It's a pain to have to remember to call the <code>close</code> method on files. There is a keyword called <code>with</code> that can be used to automatically close files after they are no longer needed.</p> </li> </ul> <ol> <li> <p>It's not the only way, though. For instance, really large and highly-structured data sets are often stored in relational databases, and there is a significant amount of theory involved in how to do this well.\u00a0\u21a9</p> </li> <li> <p>If you don't know much about binary numbers, don't worry: we will be going over them in a few readings.\u00a0\u21a9</p> </li> <li> <p>We're oversimplifying here. Some kinds of text encodings are more complicated, especially if you need to encode Asian languages with large numbers of characters (e.g. Chinese). These require more than 8 bits per character.\u00a0\u21a9</p> </li> <li> <p>Another one you will hear about is the ASCII encoding, which is an older encoding that can only encode standard typewriter characters.\u00a0\u21a9</p> </li> <li> <p>The suffix <code>.data</code> implies that the file contains data, but there is no requirement that it be formatted in any particular way. The filesystem doesn't care.\u00a0\u21a9</p> </li> <li> <p>It is possible for a text file to end in a character which isn't a newline. That would make our example more complicated, so we'll assume that all our text files do end in newlines.\u00a0\u21a9</p> </li> <li> <p>When writing code, it's not enough that the code work; you also want it to make sense to someone reading it.\u00a0\u21a9</p> </li> <li> <p>If the last line doesn't end in a newline, and the <code>readline</code> method is reading that line, it returns a string containing all the characters up to the end of the file.\u00a0\u21a9</p> </li> <li> <p>We call our summation variable <code>sum_nums</code> instead of <code>sum</code> because <code>sum</code> is a built-in function in Python. We could have called it <code>sum</code>, but if we did we wouldn't be able to use the <code>sum</code> built-in function in that module after the <code>sum</code> variable was defined.\u00a0\u21a9</p> </li> </ol>"},{"location":"13/reading13/","title":"Reading 13: Odds and ends","text":"<p>I like to say, \"Chop suey's the biggest culinary joke that one culture has ever played on another\", because chop suey, if you translate into Chinese, means \"tsap sui\", which, if you translate back, means \"odds and ends\".</p> <p>Jennifer Lee</p>"},{"location":"13/reading13/#overview","title":"Overview","text":"<p>There are a lot of little topics that don't fit neatly into a reading because they don't introduce a new major language construct or cover some important aspect of program design. They are just \"odds and ends\" that you need to know about to be an effective Python programmer. This reading will cover these. (There are additional odds and ends besides these, but we'll leave them to later readings.)</p> <p>All of these are very specific to the Python language, but that doesn't mean they aren't important. They can make your programs more concise and easier to understand, and they are well worth learning. Don't feel bad if you can't absorb them all in a single sitting; just skim over this material, learn what seems interesting, and come back to it later as needed.</p>"},{"location":"13/reading13/#topics","title":"Topics","text":"<ul> <li>The <code>//</code> operator</li> <li>More on format strings</li> <li>More on booleans</li> <li>Looping over files with <code>for</code></li> <li>The <code>in</code> operator</li> <li>The <code>range</code> function</li> <li>Tuples</li> <li>The <code>enumerate</code> function</li> <li>Sequence slices</li> </ul>"},{"location":"13/reading13/#the-operator","title":"The <code>//</code> operator","text":"<p>Python's division operator (<code>/</code>) is a bit odd when you use it on integers; it always returns a float even if the numbers can be evenly divided. For instance:</p> <pre><code>&gt;&gt;&gt; 1 / 3\n0.3333333333333333\n&gt;&gt;&gt; 6 / 3\n2.0\n</code></pre> <p>The first division makes sense: you can't divide <code>3</code> evenly into <code>1</code>. But the second one could just as well have been <code>2</code>. Furthermore, sometimes you want an integer result when dividing two integers. For this case, Python provides the <code>//</code> operator:</p> <pre><code>&gt;&gt;&gt; 6 // 3\n2\n</code></pre> <p>This operator will always return an integer given integer inputs, and it will throw away the remainder after dividing the two integers (it doesn't try to round to the nearest integer, for instance):</p> <pre><code>&gt;&gt;&gt; 8 // 3\n2\n</code></pre> <p>You can even use it with floats, but it's not that useful:</p> <pre><code>&gt;&gt;&gt; 8.999 // 3\n2.0\n</code></pre> <p>Basically, it truncates the float or floats to ints, does the integer division, and converts the result back to a float.</p> <p>The bottom line is: if you really want integer division to result in an integer, use the <code>//</code> operator.</p>"},{"location":"13/reading13/#more-on-format-strings","title":"More on format strings","text":"<p>Python format strings are normally written like this:</p> <pre><code>'a = {}, b = {}'.format(a, b)\n</code></pre> <p>We can also add various specifiers to set e.g. numeric precision, field width, and various other things:</p> <pre><code>&gt;&gt;&gt;'num = {:.2f}'.format(3.14156)'\nnum = 3.14'\n</code></pre> <p>Typing <code>.format</code> in format strings is tedious. Fortunately, there is a fantastic shortcut!</p> <pre><code>f'a = {a}, b = {b}'\n</code></pre> <p>The <code>f'...'</code> syntax indicates that the string is a format string. It's exactly the same as writing</p> <pre><code>'a = {}, b = {}'.format(a, b)\n</code></pre> <p>except that it's shorter and easier to understand. Of course, in either case it would be an error if the variables <code>a</code> and <code>b</code> were not defined when the line of code is executed.</p> <p>If you need to add modifiers (format specifiers) with this syntax it's straightforward:</p> <pre><code>f'a = {a:10.4f}, b = {b:9.2g}'\n</code></pre> <p>The variable name comes before the colon, and the specifier comes after the colon.</p> <p>You can also use expressions in the square brackets:</p> <pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 20\n&gt;&gt;&gt; f'a = {a}, b = {b}, a + b = {a + b}'\n'a = 10, b = 20, a + b = 30'\n&gt;&gt;&gt; 'a = {}, b = {}, a + b = {}'.format(a, b, a + b)  # equivalent\n'a = 10, b = 20, a + b = 30'\n</code></pre> <p>You can use the <code>.format</code> method or the <code>f'...'</code> format string syntax as you like. Just make sure you don't put format specifiers into a string without doing one of these, or the variables in your format string won't get replaced with their actual values.</p>"},{"location":"13/reading13/#more-on-booleans","title":"More on booleans","text":"<p>We've seen previously that Python is kind of sloppy about what it considers to be \"true\" and \"false\". In addition to the actual <code>False</code> value, there are other values that are \"false\" in a boolean context (for instance, in the test part of an <code>if</code> statement). These other values include the number <code>0</code>, the empty string, the empty list, and others we haven't seen yet. We say that these values are \"falsy\". All other values are \"truthy\", though there is a specific <code>True</code> value as well.</p> <p>Also, at the end of reading 12, we introduced the <code>not</code> operator, which is like a function on booleans: it changes a \"truthy\" value to <code>False</code> and a \"falsy\" value to <code>True</code>.</p> <pre><code>&gt;&gt;&gt; not True\nFalse\n&gt;&gt;&gt; not False\nTrue\n&gt;&gt;&gt; not 0\nTrue\n&gt;&gt;&gt; not ''\nTrue\n&gt;&gt;&gt; not []\nTrue\n&gt;&gt;&gt; not 42\nFalse\n</code></pre> <p>Python has two more boolean operators you need to know about: <code>and</code> and <code>or</code>. These are used to combine two boolean values to make a third.</p> <ul> <li> <p><code>and</code> only returns <code>True</code> if both its arguments are true (truthy):</p> <pre><code>&gt;&gt;&gt; True and True\nTrue\n&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; False and True\nFalse\n&gt;&gt;&gt; False and False\nFalse\n</code></pre> </li> <li> <p><code>or</code> only returns <code>True</code> if either of its arguments are true (truthy):</p> <pre><code>&gt;&gt;&gt; True or True\nTrue\n&gt;&gt;&gt; True or False\nTrue\n&gt;&gt;&gt; False or True\nTrue\n&gt;&gt;&gt; False or False\nFalse\n</code></pre> </li> </ul> <p>Most of the time, though, we use <code>and</code> and <code>or</code> with expressions which evaluate to boolean values. Often, these are relational operators used in an <code>if</code> statement:</p> <pre><code>if a &gt; 0 and a &lt; 10:\n    print('in range')\nelse:\n    print('out of range')\n</code></pre>"},{"location":"13/reading13/#boolean-operator-short-circuiting","title":"Boolean operator \"short-circuiting\"","text":"<p>The <code>and</code> and <code>or</code> boolean operators have one other cool property: sometimes they don't have to evaluate both of their arguments! This is easiest to understand using examples.</p> <p>With <code>or</code>, it's easy to see that if its left-hand operand is <code>True</code> (or some other \"truthy\" value), then the result of the <code>or</code> expression has to be true too, since <code>True or &lt;anything&gt;</code> should be true. Because of this, when the left-hand operand of <code>or</code> evaluates to a true (truthy) value, the right-hand operand is never evaluated. This is called \"short circuiting\" and it's actually very useful. It allows you to take code like this:</p> <pre><code>if lst == []:\n    return True\nelif lst[0] == 42:\n    return True\nelse:\n    return False\n</code></pre> <p>and shrink it down to this:</p> <pre><code>return (lst == []) or (lst[0] == 42)\n</code></pre> <p>(Actually, we could leave off the parentheses too, since the <code>or</code> operator has very low precedence.)</p> <p>The interesting thing in this example is that the two operands of the <code>or</code> operator (<code>lst == []</code> and <code>lst[0] == 42</code>) are sometimes mutually exclusive. If <code>or</code> wasn't short-circuiting and both operands were evaluated, then the second operand would be an error if the list <code>lst</code> was empty. (Make sure you understand why this is.)</p> <p>The <code>and</code> operator also does short-circuiting, but it works differently. In the case of the <code>and</code> operator, if the first operand is false, there is no need to evaluate the second operand because the result of the entire expression will still be false. In other words, <code>False and &lt;anything&gt;</code> will be false. Because of this, in this case the second operand is not evaluated.</p> <p>To sum up:</p> <ul> <li> <p>If you have a boolean expression of the form <code>True or &lt;anything&gt;</code>, the <code>&lt;anything&gt;</code> part is not evaluated because the result will have to be <code>True</code> no matter what <code>&lt;anything&gt;</code> evaluates to.</p> </li> <li> <p>If you have a boolean expression of the form <code>False and &lt;anything&gt;</code> the <code>&lt;anything&gt;</code> part is not evaluated because the result will have to be <code>False</code> no matter what <code>&lt;anything&gt;</code> evaluates to.</p> </li> </ul>"},{"location":"13/reading13/#looping-over-files-with-for","title":"Looping over files with <code>for</code>","text":"<p>We saw previously that we could loop over files using a <code>while</code> loop. Our final version of the code we wrote looked like this:</p> <pre><code>temps = open('temps.txt', 'r')\nsum_nums = 0.0\nwhile True:\n    line = temps.readline()\n    if not line:\n        break\n    sum_nums += float(line)\ntemps.close()\n</code></pre> <p>This code is OK, but it seems a bit long winded. If we were to say what this code did in English, we would probably say something like \"loop over all the lines in the file, converting each line to a float and adding it to a sum variable.\" Notice that this description has no infinite loops, no <code>break</code>s, and is just generally shorter and easier to understand. Shouldn't Python allow us to express ourselves in a similar way?</p> <p>Fortunately, it does. You can use a <code>for</code> loop on files to write this amazingly concise code that does the same thing:</p> <pre><code>temps = open('temps.txt', 'r')\nsum_nums = 0.0\nfor line in temps:\n    sum_nums += float(line)\ntemps.close()\n</code></pre> <p>We've replaced the entire <code>while</code> loop with a two-line <code>for</code> loop! Cool, huh?   Because it's concise but also readable, this is the preferred way to write this.</p> <p>You probably have questions about this!</p> <p>Up until now, the Python value in a <code>for</code> loop following the <code>in</code> keyword was either a list or a string i.e. some kind of Python \"sequence\". Now we are putting a Python file object after the <code>in</code>. Does that mean that a file is a sequence? Actually, no \u2014 files are not sequences in Python. For instance, a sequence in Python should be able to use the square bracket indexing operator. If you try to do this with a file:</p> <pre><code>&gt;&gt;&gt; temps = open('temps.txt', 'r')\n&gt;&gt;&gt; line0 = temps[0]\n</code></pre> <p>you will get an error:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: '_io.TextIOWrapper' object is not subscriptable\n</code></pre> <p>This just means that the square bracket syntax doesn't work on files.</p> <p>OK, so files aren't \"sequences\" as such. So how can you use them in <code>for</code> loops?</p> <p>The full answer will have to wait for a future reading, but to give you a preview, the answer is that a Python object doesn't need to be a full-fledged sequence in order to be useable after the <code>in</code> in a <code>for</code> loop. It just has to be associated with a kind of Python object called an iterator, which basically means \"something that can be looped over in a <code>for</code> loop\". An iterator knows how to get the \"next\" value in an object (like a list, a string, a file, or other things), and it knows when there is no \"next\" value, which indicates that the <code>for</code> loop has finished executing. Python's lists, strings, and file objects are each associated with particular iterators over those objects, which is what allows them to be used in <code>for</code> loops.</p> <p>It's also possible to define your own iterators, which can be very useful. When we discuss iterators in more depth, we will see how to do that too.</p>"},{"location":"13/reading13/#the-in-operator","title":"The <code>in</code> operator","text":"<p>We have seen the Python keyword <code>in</code> in the context of a <code>for</code> expression:</p> <pre><code>&gt;&gt;&gt; for i in [1, 2, 3]:\n...     print(i)\n...\n1\n2\n3\n</code></pre> <p>(Note the <code>...</code> secondary prompt, by the way.)</p> <p>However, <code>in</code> has a completely different meaning when used as an operator all by itself (i.e. when it is put between Python expressions, but not in a line with <code>for</code>). In this case, it is a test to see if a Python value is found inside a data structure (like a list) that contains other Python values.</p> <p>For instance,</p> <pre><code>1 in [1, 2, 3]\n</code></pre> <p>means: \"does <code>1</code> occur in the list <code>[1, 2, 3]?</code>\", and</p> <pre><code>'t' in 'Caltech'\n</code></pre> <p>means: \"does the character <code>'t'</code> appear in the string <code>'Caltech'</code>?\" <code>in</code> used as an operator this way returns a <code>True</code>/<code>False</code> value:</p> <pre><code>&gt;&gt;&gt; 1 in [1, 2, 3]\nTrue\n&gt;&gt;&gt; 0 in [1, 2, 3]\nFalse\n&gt;&gt;&gt; 't' in 'Caltech'\nTrue\n&gt;&gt;&gt; 'z' in 'Caltech'\nFalse\n</code></pre> <p>With strings, you can do even more: you can test if a string is found anywhere inside another string:</p> <pre><code>&gt;&gt;&gt; 'alt' in 'Caltech'\nTrue\n&gt;&gt;&gt; 'Caltech' in 'Caltech'\nTrue\n&gt;&gt;&gt; 'MIT' in 'Caltech'\nFalse\n</code></pre> <p>This doesn't work for lists:</p> <pre><code>&gt;&gt;&gt; [1, 2] in [1, 2, 3]\nFalse\n</code></pre> <p>This is because a list could conceivably have another list as one of its elements, whereas a string can only be made up of individual characters.</p> <p>You can use the <code>in</code> operator with variables, too:</p> <pre><code>&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; x in [1, 2, 3]\nTrue\n&gt;&gt;&gt; y = [1, 2, 3]\n&gt;&gt;&gt; x in y\nTrue\n&gt;&gt;&gt; 1 in y\nTrue\n</code></pre> <p>Warning</p> <p>Be aware that <code>in</code> used as an operator like this has nothing to do with <code>in</code> used in a <code>for</code> loop! Python is overloading the meaning of the keyword <code>in</code> to do two completely different things. Most of the time, this is obvious, but since <code>in</code> used as an operator returns a <code>True</code>/<code>False</code> (boolean) value , you often see it used in an <code>if</code> statement e.g.</p> <pre><code>if x in [1, 2, 3]:\n    print('Found!')\n</code></pre> <p>This might be confusing, because you are seeing the <code>if</code> in a position where a <code>for</code> is more typical. You can even have both forms next to each other:</p> <pre><code>for line in lines:    # for loop\n    if 'Z' in line:   # in used as an operator\n        print('Found a Z!')\n</code></pre> <p>Make sure you keep the two distinct uses of <code>in</code> clear in your mind.</p>"},{"location":"13/reading13/#the-range-function","title":"The <code>range</code> function","text":"<p>The built-in function <code>range</code> is used to generate a sequence of consecutive integers. Very often, these are intended to be used inside a <code>for</code> loop.</p> <pre><code>&gt;&gt;&gt; for n in range(0, 5):\n...     print(n)\n...\n0\n1\n2\n3\n4\n</code></pre> <p>If you use the <code>range</code> function outside of a <code>for</code> loop, it will just return a <code>range</code> object.</p> <pre><code>&gt;&gt;&gt; range(0, 5)\nrange(0, 5)\n</code></pre> <p>Note</p> <p>The output here isn't a string! It's just the way that Python represents the <code>range</code> object as a string (like if you did <code>str(range(0, 5))</code>).</p> <p>A <code>range</code> object contains an iterator (like file objects do) that can produce (in this case) the numbers <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code> in order. If we want, we can convert a <code>range</code> object to a list:</p> <pre><code>&gt;&gt;&gt; list(range(0, 5))\n[0, 1, 2, 3, 4]\n</code></pre> <p>We will often use this trick to show exactly what values <code>range</code> is capable of returning. However, most of the time we use <code>range</code> without converting it to a list.</p> <p>Warning</p> <p>If you unnecessarily convert a <code>range</code> object to a list, it will probably work, but you will lose marks for writing unnecessary code. (It's also slower, and wastes space if the range is very large.)</p> <p><code>range</code> is a flexible function. Before we explain exactly how it works, here are a \"range\" of examples:</p> <pre><code>&gt;&gt;&gt; list(range(0, 5))\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; list(range(10, 20))\n[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n&gt;&gt;&gt; list(range(-10, -5))\n[-10, -9, -8, -7, -6]\n</code></pre>"},{"location":"13/reading13/#range-with-two-arguments","title":"<code>range</code> with two arguments","text":"<p><code>range</code>'s arguments are always integers. If there are two integer arguments, they represent the endpoints of the range. Specifically:</p> <pre><code>range(m, n)\n</code></pre> <p>means to create a range:</p> <ul> <li>starting with and including the integer <code>m</code></li> <li>ending with and excluding the integer <code>n</code></li> </ul> <p>Another way we say this is that <code>range(m, n)</code> creates a range of integers going \"from\" <code>m</code> and \"up to but not including\" <code>n</code>.</p> <p>So <code>list(range(0, 5))</code> results in <code>[0, 1, 2, 3, 4]</code>, and not <code>[0, 1, 2, 3, 4, 5]</code>. (Forgetting this is a common beginner's error.) This may seem unintuitive or even wrong, but as you'll see, it turns out to be the most natural choice.</p> <p><code>range</code>'s arguments must be integers, but they don't have to be positive integers. For instance:</p> <pre><code>&gt;&gt;&gt; list(range(-10, -5))\n[-10, -9, -8, -7, -6]\n</code></pre> <p>This creates a range that starts on the first argument (<code>-10</code>) and goes up to the second argument (<code>-5</code>) without including it. So the last element in the range is <code>-6</code>.</p>"},{"location":"13/reading13/#a-puzzle","title":"A puzzle","text":"<p>What does this <code>range</code> expression return? (Type this into the Python interpreter.)</p> <pre><code>list(range(10, 1))\n</code></pre> <p>Does this make sense given what we have already told you? What about <code>list(range(10, 10))</code>?</p>"},{"location":"13/reading13/#range-with-3-arguments","title":"<code>range</code> with 3 arguments","text":"<p>The <code>range</code> function is a bit unusual in that it can take 1, 2, or 3 arguments.<sup>1</sup> With 3 arguments, the first two mean the same thing as they do for <code>range</code> with 2 arguments. The last argument is the step size, which means how much to increase the range value at each step. Again, we'll convert ranges to lists for illustration only:</p> <pre><code>&gt;&gt;&gt; list(range(0, 10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; list(range(0, 10, 2))\n[0, 2, 4, 6, 8]\n&gt;&gt;&gt; list(range(0, 10, 3))\n[0, 3, 6, 9]\n</code></pre> <p>Notice that each pair of consecutive elements in <code>range</code> objects created from the 3-argument form of <code>range</code> differ by the step size. If the third argument is not provided, Python assumes you want a step size of <code>1</code>.</p> <p>When using the third argument, the rule for when to end the range is simple: if the next element in the range is equal to or greater than the second argument, don't include it. So it's still \"starting from the first argument, going up to but not including the second argument\".</p> <p>You can even have negative step sizes:</p> <pre><code>&gt;&gt;&gt; list(range(10, 0, -1))\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n</code></pre> <p>This doesn't include <code>0</code> at the end because we are going \"up to but not including\" <code>0</code>.</p>"},{"location":"13/reading13/#range-with-1-argument","title":"<code>range</code> with 1 argument","text":"<p><code>range</code> is most often used with a single argument only. We said above that <code>range</code> with two arguments assumes that the (missing) step size argument is <code>1</code>. Similarly, <code>range</code> called with only one argument assumes that the starting point is <code>0</code>.</p> <p>To recap: <code>range</code> \"really\" takes three arguments. If there are only two, the last one \"defaults\" to <code>1</code>. If there is only one argument, the (missing) first argument defaults to <code>0</code>, and the (missing) last argument defaults to <code>1</code>. The endpoint argument always has to be included.</p> <pre><code>&gt;&gt;&gt; list(range(0, 10, 1))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; list(range(0, 10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <p>All three forms of <code>range</code> shown here generate the same range. So if the starting point of your range is <code>0</code> and the step size is <code>1</code>, you should use the one-argument form of <code>range</code>.</p>"},{"location":"13/reading13/#range-in-for-loops","title":"<code>range</code> in <code>for</code> loops","text":"<p><code>range</code> has lots of uses, but it's most commonly used in a <code>for</code> loop to generate a sequence of consecutive integers. We saw this above:</p> <pre><code>&gt;&gt;&gt; for n in range(0, 5):\n...     print(n)\n...\n0\n1\n2\n3\n4\n</code></pre> <p>More usefully, we can use <code>range</code> to generate the indices of a list:</p> <pre><code>&gt;&gt;&gt; cheer = ['Caltech', 'is', 'great']\n&gt;&gt;&gt; for i in range(0, 3):\n...     print('{} -- YEAH!'.format(cheer[i]))\n...\nCaltech -- YEAH!\nis -- YEAH!\ngreat -- YEAH!\n</code></pre> <p>Notice that the choice to exclude the endpoint for the range works perfectly with the way that lists are indexed! The valid list indices for the <code>cheer</code> list are <code>0</code>, <code>1</code>, and <code>2</code> because it's a list of length 3 \u2014 and these are exactly the integers that <code>range(0, 3)</code> generates.</p> <p>This is OK, but notice that we had to put the length of the list (<code>3</code>) directly into the call to <code>range</code>. This is ugly! Fortunately, it's easy to fix.</p>"},{"location":"13/reading13/#the-rangelen-idiom","title":"The <code>range(len(...))</code> idiom","text":"<p>Since you can get the length of a list by using the <code>len</code> function, we can improve this code as follows:</p> <pre><code>&gt;&gt;&gt; cheer = ['Caltech', 'is', 'great']\n&gt;&gt;&gt; for i in range(0, len(cheer)):\n...     print('{} -- YEAH!'.format(cheer[i]))\n...\nCaltech -- YEAH!\nis -- YEAH!\ngreat -- YEAH!\n</code></pre> <p>Also, since the first argument to <code>range</code> is <code>0</code>, we can drop it:</p> <pre><code>&gt;&gt;&gt; cheer = ['Caltech', 'is', 'great']\n&gt;&gt;&gt; for i in range(len(cheer)):\n...     print('{} -- YEAH!'.format(cheer[i]))\n...\nCaltech -- YEAH!\nis -- YEAH!\ngreat -- YEAH!\n</code></pre> <p>This <code>range(len(...))</code> pattern is a common idiom in Python.<sup>2</sup> The nice thing about this is that even if <code>cheer</code> was changed, the <code>for</code> loop wouldn't have to change:</p> <pre><code>&gt;&gt;&gt; cheer = ['Caltech', 'is', 'really', 'really', 'great']\n&gt;&gt;&gt; for i in range(len(cheer)):\n...     print('{} -- YEAH!'.format(cheer[i]))\n...\nCaltech -- YEAH!\nis -- YEAH!\nreally -- YEAH!\nreally -- YEAH!\ngreat -- YEAH!\n</code></pre> <p>Notice, though, that in this case you don't actually need to use <code>range(len(...))</code>, because you don't need the indices of the list:</p> <pre><code>&gt;&gt;&gt; cheer = ['Caltech', 'is', 'really', 'really', 'great']\n&gt;&gt;&gt; for word in cheer:\n...     print('{} -- YEAH!'.format(word))\n...\nCaltech -- YEAH!\nis -- YEAH!\nreally -- YEAH!\nreally -- YEAH!\ngreat -- YEAH!\n</code></pre> <p>However, if you need to change an element in a list that you are looping over, you will need its index, and in that case, the <code>range(len(...))</code> idiom is useful. In fact, it used to be one of the standard ways to iterate through a Python list, but now we usually prefer to use the <code>enumerate</code> function (described below).</p> <p>Here's a simple example of changing the elements of a list:</p> <pre><code># We want to double each element in a list.\nnums = [23, 12, 45, 68, -101]\nfor i in range(len(nums)):\n    nums[i] = nums[i] * 2\n</code></pre> <p>This works, but we would normally shorten it using the <code>*=</code> operator:</p> <pre><code># We want to double each element in a list.\nnums = [23, 12, 45, 68, -101]\nfor i in range(len(nums)):\n    nums[i] *= 2\n</code></pre>"},{"location":"13/reading13/#tuples","title":"Tuples","text":"<p>We want to show you the <code>enumerate</code> function, but before we do that, we need to talk about tuples.<sup>3</sup> A tuple is a kind of Python sequence. In many ways, it's much like a list, except that it's written using parentheses instead of square brackets:</p> <pre><code># list\nlst = [1, 2, 3, 4, 5]\n# tuple\ntup = (1, 2, 3, 4, 5)\n</code></pre> <p>Since parentheses are used for grouping in Python, we have to write tuples of length 1 in a special way:</p> <pre><code># tuple of length 1; note the extra comma at the end\ntup1 = (1,)\n</code></pre> <p>This syntax is necessary because <code>(1)</code> is just a Python expression that happens to evaluate to the number <code>1</code>, whereas <code>(1,)</code> can only be a tuple.</p> <p>To write a zero-length tuple, just use empty parentheses:</p> <pre><code># zero-length tuple\ntup0 = ()\n</code></pre>"},{"location":"13/reading13/#similarities-between-tuples-and-lists","title":"Similarities between tuples and lists","text":"<p>Tuples are sequences, and most, but not all, of the common list operations work in a similar way with tuples.</p> <ul> <li> <p>You can use <code>for</code> loops with tuples:</p> <pre><code>&gt;&gt;&gt; for i in (1, 2, 3, 4, 5):\n...     print(i)\n...\n1\n2\n3\n4\n5\n</code></pre> </li> <li> <p><code>len</code> works with tuples and (of course) returns the length of the tuple:</p> <pre><code>&gt;&gt;&gt; len((1, 2, 3, 4, 5))\n5\n</code></pre> <p>(Note the doubled-up parentheses in this example. The tuple parentheses are the inner ones.)</p> </li> <li> <p>You can concatenate tuples with the <code>+</code> operator:</p> <pre><code>&gt;&gt;&gt; (1, 2, 3) + (4, 5, 6)\n(1, 2, 3, 4, 5, 6)\n</code></pre> <p>Don't try concatenating tuples to lists, or vice-versa; it won't work.</p> </li> <li> <p>You can index tuples the same way you index lists:</p> <pre><code>&gt;&gt;&gt; tup = ('foo', 'bar', 'baz')\n&gt;&gt;&gt; tup[0]\n'foo'\n&gt;&gt;&gt; tup[-1]\n'baz'\n</code></pre> </li> </ul> <p>In addition, you can convert tuples to lists, and lists to tuples:</p> <pre><code>&gt;&gt;&gt; tuple([1, 2, 3])\n(1, 2, 3)\n&gt;&gt;&gt; list((1, 2, 3))\n[1, 2, 3]\n</code></pre> <p><code>tuple</code> is a built-in function which converts sequences to tuples if possible. It even works on strings:</p> <pre><code>&gt;&gt;&gt; tuple('Caltech')\n('C', 'a', 'l', 't', 'e', 'c', 'h')\n</code></pre>"},{"location":"13/reading13/#differences-between-tuples-and-lists","title":"Differences between tuples and lists","text":"<p>The main difference between tuples and lists is that tuples are immutable. That means that you can't change the contents of a tuple once it is created.</p> <pre><code>&gt;&gt;&gt; tup = ('foo', 'bar', 'baz)\n&gt;&gt;&gt; tup[0] = 'hello'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code></pre> <p>Tuples are thus basically a restricted kind of list. So, you're probably thinking, what good are tuples, anyway?</p> <p>Tuples are rarely essential. However, there are definitely some cases where they are very convenient:</p> <ol> <li>returning multiple values from functions</li> <li>\"tuple unpacking\"</li> <li><code>for</code> loops with multiple bindings</li> <li>...and one more case that we will discuss in future readings.<sup>4</sup></li> </ol> <p>We'll discuss the first three cases below.</p>"},{"location":"13/reading13/#multiple-return-values","title":"Multiple return values","text":"<p>Functions in Python can only return a single value. Most of the time, this is fine. Sometimes, though, it would be very nice to be able to return more than one value from a function. The most natural way to do this in Python is to create a tuple from all the values you want to return, and then just return that tuple.</p> <p>Consider the built-in function <code>divmod</code>:</p> <pre><code>&gt;&gt;&gt; divmod(10, 3)\n(3, 1)\n&gt;&gt;&gt; divmod(42, 7)\n(6, 0)\n&gt;&gt;&gt; divmod(101, 5)\n(20, 1)\n</code></pre> <p><code>divmod</code> divides two integers. It returns the quotient and the remainder of its two arguments, as a tuple. We could define it ourselves using the <code>//</code> operator we showed you above and the <code>%</code> remainder operator:</p> <pre><code>def divmod(m, n):\n    return (m // n, m % n)\n</code></pre> <p>Note</p> <p>The actual definition is more complex because it has to work correctly for negative numbers too.</p> <p>Now we can write:</p> <pre><code>&gt;&gt;&gt; qr = divmod(101, 5)\n&gt;&gt;&gt; quotient = qr[0]\n&gt;&gt;&gt; remainder = qr[1]\n</code></pre> <p>This is a bit crude, though.  Let's improve it.</p>"},{"location":"13/reading13/#tuple-unpacking","title":"Tuple unpacking","text":"<p>One cool thing about tuples is that you can unpack them by writing a \"tuple of variables\" on the left-hand side of an assignment. So the previous example could have been written more concisely as follows:</p> <pre><code>&gt;&gt;&gt; qr = divmod(101, 5)\n&gt;&gt;&gt; (quotient, remainder) = qr\n</code></pre> <p>Since <code>qr</code> is a tuple of length 2, and <code>(quotient, remainder)</code> is a \"tuple of variables\" of length 2, Python lets us \"assign to the tuple\", which actualy means that the parts of the tuple (the variables <code>quotient</code> and <code>remainder</code>) will be assigned to. This is called \"tuple unpacking\" and it's basically a multiple assignment statement.</p> <p>Let's check that it works:</p> <pre><code>&gt;&gt;&gt; qr = divmod(101, 5)\n&gt;&gt;&gt; (quotient, remainder) = qr\n&gt;&gt;&gt; quotient\n20\n&gt;&gt;&gt; remainder\n1\n</code></pre> <p>Python allows you to write tuple unpacking without using parentheses:</p> <pre><code>&gt;&gt;&gt; qr = divmod(101, 5)\n&gt;&gt;&gt; quotient, remainder = qr\n&gt;&gt;&gt; quotient\n20\n&gt;&gt;&gt; remainder\n1\n</code></pre> <p>Although leaving off the tuple parentheses works in this particular case, we advise against leaving them off in general, since there are many situations where you have to use parentheses when writing a tuple. (It's easiest to remember if you always use them, and that will never be wrong.)</p> <p>Tuple unpacking works as follows. You have a tuple of variables on the left-hand side of an <code>=</code> assignment operator, and a tuple of the same length on the right-hand side (or a variable whose value is a tuple of that length). Then, the elements of the tuples on the right-hand side are copied into the variables on the left-hand side. If the lengths don't match, it's an error.</p> <pre><code>&gt;&gt;&gt; (a, b, c) = (1, 2, 3)\n&gt;&gt;&gt; a\n1\n&gt;&gt;&gt; b\n2\n&gt;&gt;&gt; c\n3\n&gt;&gt;&gt; v = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; (x, y) = v\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: too many values to unpack (expected 2)\n&gt;&gt;&gt; (a, b, c, d, e, f) = v\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: not enough values to unpack (expected 6, got 5)\n</code></pre>"},{"location":"13/reading13/#application-swapping-two-variables","title":"Application: swapping two variables","text":"<p>One spiffy application for tuples is to swap the values of two variables.<sup>5</sup> The usual textbook way to do this is to use a temporary variable:</p> <pre><code>a = 10\nb = 42\n# Swap a and b.\ntemp = a\na = b\nb = temp\n</code></pre> <p>This is kind of ugly, especially compared to what you can do with tuples:</p> <pre><code>a = 10\nb = 42\n# Swap a and b.\n(a, b) = (b, a)\n</code></pre> <p>The way this works is as follows. The right-hand side <code>(b, a)</code> is a tuple created from the variables <code>a</code> and <code>b</code>. Its value is <code>(42, 10)</code>. The left-hand side is a \"tuple of variables\" that use the same variable names. When tuple unpacking happens, the <code>42</code> gets unpacked into variable <code>a</code> and the <code>10</code> gets unpacked into variable <code>b</code>, which gives us the result we want.</p> <p>So in the very unlikely event that you need to swap the value of two variables, rest assured that Python has you covered! </p>"},{"location":"13/reading13/#application-for-loops-with-multiple-bindings","title":"Application: <code>for</code> loops with multiple bindings","text":"<p>We can use tuples and tuple unpacking with <code>for</code> loops to assign (\"bind\") values to multiple names in each iteration of a loop:</p> <pre><code>&gt;&gt;&gt; for (n, s) in [(1, 'a'), (2, 'b')]:\n...     print(f'num = {n}, char = {s}')\nnum = 1, char = a\nnum = 2, char = b\n</code></pre> <p>(Notice that we slipped in the new format string syntax too!)</p> <p>What's happening here is that in each iteration of the loop, a new tuple is unpacked into the variables <code>n</code> and <code>s</code> using tuple unpacking. This allows us to iterate over two variables simultaneously. One use of this is very common, which leads us into the next subject.</p>"},{"location":"13/reading13/#the-enumerate-function","title":"The <code>enumerate</code> function","text":"<p>Earlier, we saw this code:</p> <pre><code># We want to double each element in a list.\nnums = [23, 12, 45, 68, -101]\nfor i in range(len(nums)):\n    nums[i] *= 2\n</code></pre> <p>The purpose of <code>range(len(nums))</code> is to produce all the valid indices of the <code>nums</code> list (which we know are <code>0</code> to <code>4</code>). This seems like a lot of work for something so simple.</p> <p>A different (and more modern) way to write this code is as follows:</p> <pre><code>nums = [23, 12, 45, 68, -101]\nfor (i, e) in enumerate(nums):\n    nums[i] *= 2\n</code></pre> <p>What the built-in <code>enumerate</code> function does is to take a sequence and generate tuples of indices (<code>i</code>) and elements (<code>e</code>), one at a time. So the first time through the loop body, <code>i</code> will be <code>0</code> and <code>e</code> will be <code>23</code>; the second time <code>i</code> will be <code>1</code> and <code>e</code> will be 12, and so on.</p> <p>Since this is a tuple unpacking, we can leave off the parentheses around <code>(i, e)</code>, and some programmers think this looks better:</p> <pre><code>nums = [23, 12, 45, 68, -101]\nfor i, e in enumerate(nums):\n    nums[i] *= 2\n</code></pre> <p>We prefer to keep the parentheses.</p> <p>If you use <code>enumerate</code> directly, you will see that it returns an <code>enumerate</code> object:</p> <pre><code>&gt;&gt;&gt; enumerate(nums)\n&lt;enumerate object at 0x107cc3a80&gt;\n</code></pre> <p>Like a list or a <code>range</code> object, an <code>enumerate</code> object contains an iterator. This iterator generates the <code>(i, e)</code> tuples one at a time, and it can be used in a <code>for</code> loop like any other iterator. If you want to see what an <code>enumerate</code> object will generate, you can convert it to a list:</p> <pre><code>&gt;&gt;&gt; list(enumerate(nums))\n[(0, 23), (1, 12), (2, 45), (3, 68), (4, -101)]\n</code></pre> <p>However, don't do this when using an <code>enumerate</code> in a <code>for</code> loop, since it's totally unnecessary, and also slower.</p> <p>Getting back to our example:</p> <pre><code>nums = [23, 12, 45, 68, -101]\nfor (i, e) in enumerate(nums):\n    nums[i] *= 2\n</code></pre> <p>You might have noticed that we don't use the <code>e</code> variable anywhere. It's just there to make <code>enumerate</code> happy. What if we just left it off?</p> <pre><code>nums = [23, 12, 45, 68, -101]\nfor i in enumerate(nums):\n    nums[i] *= 2\n</code></pre> <p>This is not a syntax error, but it won't work either. In this case, the <code>i</code> variable will have the entire tuple assigned to it, so the first value of <code>i</code> would be <code>(0, 23)</code>. This obviously will make the line <code>nums[i] *= 2</code> fail.</p> <p>If you want to say \"I know there is supposed to be a variable here, but I don't need it\", the standard way to do that is to use the variable name <code>_</code>, which means \"I don't care about this variable\". Our example then becomes:</p> <pre><code>nums = [23, 12, 45, 68, -101]\nfor (i, _) in enumerate(nums):\n    nums[i] *= 2\n</code></pre> <p>This is really not much of an improvement over the <code>range(len(nums))</code> code, but it is the preferred way to write this. It would be nice if there was a variant of <code>enumerate</code> that only returned the indices.</p> <p>Note</p> <p>In fact, you could easily write one:</p> <pre><code>def enum(iterable):\n    return range(len(iterable))\n</code></pre> <p>and then you could re-write the example as:</p> <pre><code>nums = [23, 12, 45, 68, -101]\nfor i in enum(nums):\n    nums[i] *= 2\n</code></pre> <p>but there is no <code>enum</code>-like function in the Python standard libraries as far as we know.</p>"},{"location":"13/reading13/#sequence-slices","title":"Sequence slices","text":"<p>This is a long reading, but we've saved the best for last!</p> <p>It's very common, when working with sequences, to want to get more than one element from the sequence. For instance, you might have a DNA sequence like this:</p> <pre><code>seq = 'ATTGGCGCGTTA'\n</code></pre> <p>and you might want to get the subsequence starting from index <code>3</code> and going up to (but not including) index <code>9</code>. This would be the sequence <code>'GGCGCG'</code>. Python allows you to get this all at once using a sequence slice, which is a copy of part of the sequence:</p> <pre><code>&gt;&gt;&gt; seq = 'ATTGGCGCGTTA'\n&gt;&gt;&gt; seq[3:9]  # seq[3:9] is a sequence slice\n'GGCGCG'\n</code></pre> <p>This works for all kinds of sequences, not just strings:</p> <pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; lst[1:4]\n[2, 3, 4]\n</code></pre>"},{"location":"13/reading13/#slice-syntax","title":"Slice syntax","text":"<p>A sequence slice (which we'll just call a slice from now on), has this syntax:</p> <pre><code>seq[start:end]\n</code></pre> <p>where:</p> <ul> <li> <p><code>seq</code> is a sequence,</p> </li> <li> <p><code>start</code> is the integer index of the first location of the slice,</p> </li> <li> <p><code>end</code> is the integer index that is one location beyond the last location in the slice,</p> </li> <li> <p>and the colon character (<code>:</code>) separates the start and end parts.</p> </li> </ul> <p>Note that this is yet another special meaning for the poor colon character.<sup>6</sup></p> <p>The <code>start</code> and <code>end</code> indices are both optional. If <code>start</code> is not included, it defaults to <code>0</code>. If <code>end</code> is not included, it defaults to the length of the sequence.</p> <p>Some examples:</p> <pre><code>&gt;&gt;&gt; lst = [10, 20, 30, 40, 50, 60]\n&gt;&gt;&gt; lst[1:5]\n[20, 30, 40, 50]\n&gt;&gt;&gt; lst[0:6]  # the whole list\n[10, 20, 30, 40, 50, 60]\n&gt;&gt;&gt; lst[1:]   # all but the first element\n[20, 30, 40, 50, 60]\n&gt;&gt;&gt; lst[:5]  # all but the last element\n[10, 20, 30, 40, 50]\n&gt;&gt;&gt; lst[:]    # the entire list\n[10, 20, 30, 40, 50, 60]\n&gt;&gt;&gt; tup = (4, 8, 10, 25, 46)\n&gt;&gt;&gt; tup[1:3]\n(8, 10)\n&gt;&gt;&gt; tup[1:2]\n(8,)\n&gt;&gt;&gt; tup[1:1]\n()\n&gt;&gt;&gt; s = 'this is a test'\n&gt;&gt;&gt; s[4:8]\n&gt;&gt;&gt; ' is '\n&gt;&gt;&gt; s[4:]\n&gt;&gt;&gt; ' is a test'\n&gt;&gt;&gt; s[:4]\n&gt;&gt;&gt; 'this'\n</code></pre> <p>Remember that a slice is a copy of part of a sequence, so e.g. <code>lst[:]</code> is a very simple way to make a copy of a list.</p> <p>You can use negative indices too:</p> <pre><code>&gt;&gt;&gt; lst = [10, 20, 30, 40, 50, 60]\n&gt;&gt;&gt; lst[:-1]  # all but the last element\n[10, 20, 30, 40, 50]\n&gt;&gt;&gt; lst[-2:]  # last two elements\n[50, 60]\n&gt;&gt;&gt; lst[-5:-3]\n[20, 30]\n</code></pre> <p>One common application of this is to remove the newline character of a string which is read in from a file using the <code>readline</code> method:</p> <pre><code>file = open('nums.txt', 'r')\nline = file.readline()\nline = line[:-1]  # remove newline\n</code></pre> <p><code>start</code> and <code>end</code> don't have to be literal integers; they can be expressions that evaluate to integers.</p> <pre><code>&gt;&gt;&gt; lst = [10, 20, 30, 40, 50, 60]\n&gt;&gt;&gt; n = 2\n&gt;&gt;&gt; lst[n-1:n+2]\n[20, 30, 40]\n</code></pre> <p>In this case, the expressions on either side of the colon are evaluated before the slice is computed.</p> <p>If the slice's final index is greater than the index of the last element, the slice ends at the last element.</p> <pre><code>&gt;&gt;&gt; lst = [10, 20, 30, 40, 50, 60]\n&gt;&gt;&gt; lst[2:3000]\n[30, 40, 50, 60]\n</code></pre> <p>Note that this is not an error.</p>"},{"location":"13/reading13/#wrapping-up-and-looking-forward","title":"Wrapping up and looking forward","text":"<p>Even though this is a very long reading, there are still more \"odds and ends\" of Python that we haven't covered. We will see more of these in later readings.</p> <ol> <li> <p>Python allows you to define functions like this that can take varying numbers of arguments, although this is rarely needed. In later readings, we'll show you how to do this with your own functions.\u00a0\u21a9</p> </li> <li> <p>Idiom just means \"a standard way to write something\".\u00a0\u21a9</p> </li> <li> <p>By the way, there is a controversy in how to pronounce the word \"tuple\". Some people (evil, horrible people) pronounce it \"tupple\" (rhymes with \"supple\"). Other people (good, virtuous people) pronounce it \"toople\" (rhymes with \"hoople\"). We'll leave it to you to choose which side you're on.\u00a0\u21a9</p> </li> <li> <p>It has to do with dictionaries, if you must know. Stay tuned!\u00a0\u21a9</p> </li> <li> <p>I've been programming for decades, and I don't think I have ever needed to swap the values of two variables. Nevertheless, this seems to be a favorite example for people teaching new programmers, so who am I to disagree?\u00a0\u21a9</p> </li> <li> <p>When we talk about dictionaries, you'll see that colons have another special meaning there too.\u00a0\u21a9</p> </li> </ol>"},{"location":"2/reading2/","title":"Reading 2: Introduction to Python, part 2","text":"<p>Science is what we understand well enough to explain to a computer. Art is everything else we do. - Donald Knuth</p>"},{"location":"2/reading2/#topics","title":"Topics","text":"<p>This reading continues our crash course on the most basic aspects of Python started in the last reading.</p>"},{"location":"2/reading2/#variables-and-assignment","title":"Variables and assignment","text":"<p>Using Python as a calculator is useful but very limited. Often we want to give names to interesting values, especially when we want to use them more than once. Sometimes we also want to change those values. In Python (and in most programming languages) we do this using variables and assignment statements. A variable is a name that stands for a value (like a variable in algebra). An assignment statement is how we associate a value with a name. For instance:</p> <pre><code>&gt;&gt;&gt; width = 10\n&gt;&gt;&gt; width\n10\n</code></pre> <p>Here, <code>width</code> is a variable and <code>10</code> is the value that it stands for. When you type <code>width</code> in the interpreter, you get <code>10</code> back. The <code>=</code> sign is the assignment operator that does the actual assignment.</p> <p>Notice that when you type an assignment statement into the Python interpreter, nothing is printed. When you type a variable name (or any expression), it evaluates it (looks up its value), and prints it to the terminal.</p> <p>Assignment (<code>=</code>) vs. equality (<code>==</code>)</p> <p>The statement <code>width = 10</code> is an assignment, not an equality comparison! If you want to compare <code>width</code> with <code>10</code> to see if <code>width</code> currently equals <code>10</code>, you would have to type <code>width == 10</code>. You'd probably also want to use an <code>if</code> statement. We'll get to all of this in a few readings.</p> <p>If you assign to a variable again, it changes the value.</p> <pre><code>&gt;&gt;&gt; width = 10\n&gt;&gt;&gt; width\n10\n&gt;&gt;&gt; width = 42\n&gt;&gt;&gt; width\n42\n&gt;&gt;&gt; width = 'hi there!'\n&gt;&gt;&gt; width\n'hi there!'\n</code></pre> <p>Variable names don't have to be declared before assigning to them, and they don't have to only store data of a single type (unlike many other programming languages). Here, we see the variable <code>width</code> which contains the integer <code>10</code>, then <code>42</code>, then the string <code>'hi there!'</code>. (We'll learn more about strings in the next reading.) Of course, <code>'hi there!'</code> doesn't make sense as a width, but Python doesn't care if your names make sense. (In general, though, assigning a different kind of data to a variable is usually a bad idea.)</p> <p>Once you've defined a variable, you can use it in expressions:</p> <pre><code>&gt;&gt;&gt; pi = 3.1415926\n&gt;&gt;&gt; pi\n3.1415926\n&gt;&gt;&gt; 4 * pi\n12.5663704\n</code></pre>"},{"location":"2/reading2/#variable-name-rules","title":"Variable name rules","text":"<p>Not all names can be used as variable names:</p> <pre><code>a = 10\nb1 = 20\nthis_is_a_name = 30\n&amp;*%$2foo? = 40   # WRONG\n</code></pre> <p>The first three names are valid variable names, but the last isn't.</p> <p>Here are the rules for variable names (also known as identifiers):</p> <ul> <li> <p>Variable names can only consist of the letters <code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, the digits <code>0</code>-<code>9</code>, and the underscore (<code>_</code>).</p> </li> <li> <p>A variable name needs to have one or more characters.</p> </li> <li> <p>Variable names can't start with a digit (this avoids confusion with numbers).</p> </li> <li> <p>Variable names can't contain spaces. (Beginning programmers often find this an annoying restriction. Tip: if you want a space in a variable name, use the underscore (<code>_</code>) character instead.)</p> </li> <li> <p>The case of letters is significant: <code>Foo</code> is a different identifier than <code>foo</code>.</p> </li> </ul>"},{"location":"2/reading2/#assignments-and-expressions","title":"Assignments and expressions","text":"<p>The rule for evaluating an assignment statement is:</p> <ul> <li>Evaluate the expression on the right hand side of the <code>=</code> sign.</li> <li>Assign that result to the variable name on the left hand side of the <code>=</code> sign.</li> </ul> <p>Here, an expression can be a plain number, another variable, an arithmetic expression, or some combination of these. An expression can also be a function call (see below) and there are other kinds of expressions we'll meet later.</p> <p>Note</p> <p>Basically, some piece of Python code that has a value is an \"expression\". If it does something (like an assignment), it's usually not an expression but a statement. Don't worry if this seems fuzzy to you now; it will get clearer as we go along and you learn about different kinds of expressions and statements. There are also some ambiguous cases: a <code>print</code> function call is technically an expression, but it also does something (printing).</p> <p>So if you have an assignment statement with an arithmetic expression on the right-hand side, you evaluate the expression before doing the assignment:</p> <pre><code>&gt;&gt;&gt; a = 2 + 3\n# Evaluate 2 + 3 to get 5, then assign 5 to the variable \"a\".\n&gt;&gt;&gt; a\n5\n</code></pre> <p>You can use the results of previous assignments in subsequent ones:</p> <pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = a * 5\n&gt;&gt;&gt; c = a + b\n&gt;&gt;&gt; c\n60\n</code></pre> <p>You can even use the result of a previous assignment when reassigning the same variable:</p> <pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; a = a + 100\n&gt;&gt;&gt; a\n110\n</code></pre> <p>You might find statements like <code>a = a + 100</code> to be nonsensical, but remember that the <code>=</code> operator doesn't compare for equality, it assigns the result of evaluating the right-hand side to the variable on the left hand side. So <code>a = a + 100</code> means \"take the old value of <code>a</code>, add <code>100</code> to it and make that the new value of <code>a</code>\".</p>"},{"location":"2/reading2/#types","title":"Types","text":"<p>Data in programming languages is subdivided into different \"types\":</p> <ul> <li>integers: <code>0</code>, <code>-43</code>,<code>1001</code></li> <li>floating-point numbers:  <code>3.1415</code>, <code>2.718</code>, <code>1.234e-5</code></li> <li>boolean values: <code>True</code> <code>False</code></li> <li>strings:  <code>'foobar'</code> <code>'Hello, world!'</code></li> <li>and many others</li> </ul> <p>Roughly speaking, a type is a kind of data that is represented a particular way inside the computer. All integers are represented in pretty much the same way as other integers, and all strings are represented in the same way as other strings, but integers and strings are represented differently. (Don't worry if this seems vague to you now.)</p> <p>Types are important because many operations/functions can only work on specific types. For instance, you can multiply two numbers together but you can't multiply two strings.</p> <p>Python has these abbreviated names for types:</p> English name Python name integers <code>int</code> floating-point numbers <code>float</code> boolean values <code>bool</code> strings <code>str</code> <p>(as well as many others).</p> <p>Python variables can hold data of any type. Unlike many computer languages, you don't have to declare the type a variable can hold. As we saw above, the same variable can even hold values of different types at different times (though this is usually bad practice).</p> <pre><code>&gt;&gt;&gt; bird = 'parrot'\n&gt;&gt;&gt; weight = 10.3245\n&gt;&gt;&gt; income = 65000\n&gt;&gt;&gt; is_ready = True\n&gt;&gt;&gt; bird\n'parrot'\n&gt;&gt;&gt; bird = 42\n&gt;&gt;&gt; bird\n42\n</code></pre> <p>There is much more to say about types, and we will meet many more types as we go along.</p>"},{"location":"2/reading2/#functions","title":"Functions","text":"<p>Computer programs are primarily made up of functions. A function (like the math equivalent for which it's named) is something that takes in argument values and computes and returns a result. Unlike in math, a function in a programming language can also do other things: print to the terminal, send an email, create and display an image, and so on.</p> <p>Functions have to be defined and then called with appropriate arguments.</p>"},{"location":"2/reading2/#calling-functions","title":"Calling functions","text":"<p>Some functions are built-in to Python. For instance, <code>abs</code> is a function that computes absolute values of numbers, <code>min</code> computes the minimum of two numbers, <code>max</code> the maximum, and so on.</p> <p>You call a function using this syntax:</p> <pre><code>&gt;&gt;&gt; abs(-5)\n5\n&gt;&gt;&gt; min(5, 3)\n3\n&gt;&gt;&gt; max(5, 3)\n5\n</code></pre> <p>Syntax means the rules by which expressions and statements in the programming language are written. Every programming language has its own unique syntax, though there are lots of similarities between languages.</p> <p>In Python, the syntax for calling functions is the same as the usual math notation: the name of the function, followed by the argument list in parentheses. Multiple arguments in the argument list are separated by commas.</p> <p>Arguments can be either literal values (like numbers or strings), variables, or other expressions. For instance:</p> <pre><code>&gt;&gt;&gt; max(5 + 3, 8 \u2013 6)\n8\n</code></pre> <p>The way this works is that Python has the following evaluation rule for function calls:</p> <ul> <li> <p>First, evaluate all the arguments to the function.</p> <ul> <li>If the argument is a number, it's already evaluated.</li> <li>If the argument is a variable, look up the variable's value.</li> <li>If the argument is an expression, evaluate the expression to get its value.</li> </ul> </li> <li> <p>Then call the function with the argument values as the function's arguments.</p> </li> </ul> <p>Here, the function is the <code>max</code> (maximum) function. The first argument is the expression <code>5 + 3</code> which obviously evaluates to <code>8</code>. The second argument is the expression <code>8 - 6</code> which obviously evaluates to <code>2</code>. So the result is <code>max(8, 2)</code> or just <code>8</code>.</p> <p>You can use function calls in expressions:</p> <pre><code>&gt;&gt;&gt; 2 * max(5 + 3, 8 \u2013 6) - 4\n12\n</code></pre> <p>You can even have function calls inside other function calls:</p> <pre><code>&gt;&gt;&gt; max(max(5, 3), min(8, 6))\n6\n&gt;&gt;&gt; min(2 + max(5, 3), 10)\n7\n</code></pre> <p>In this case, remember that the inner function calls get evaluated before the outer one. (This is the same evaluation rule, since a function call is also an expression.)</p> <p>Note</p> <p>Don't think that you need to memorize these evaluation rules. For the most part, they should be intuitive; Python pretty much does what you would expect it to most of the time. We're being very explicit about these rules mainly for completeness.</p>"},{"location":"2/reading2/#defining-new-functions","title":"Defining new functions","text":"<p>A function call is done when you want to compute a particular value using that function. If the function doesn't exist yet, you have to define it. Unlike function calls, Python's syntax for function definitions is nothing like math notation. Instead, it uses a special keyword (reserved word) called <code>def</code> (short for \"define\"):</p> <pre><code>def double(x):\n    return x * 2\n</code></pre> <p>This code defines a function called <code>double</code> which takes one argument (called <code>x</code>), doubles it and returns it to where it was called. The argument <code>x</code> is called a formal argument or formal parameter of the function; it's a name that will acquire the value of whatever actual argument the <code>double</code> function is called with. The formal parameter(s) are enclosed in parentheses and separated by commas, just like arguments in function calls. At the end of the <code>def</code> line, you have to put a colon character (<code>:</code>) or it's a syntax error. (The placement of a colon here is just a peculiarity of Python's syntax.)</p> <p>Here's an example of calling this function:</p> <pre><code>&gt;&gt;&gt; double(42)\n84\n</code></pre> <p>In this case, the actual argument of the call to the <code>double</code> function is the number <code>42</code>. The definition states that the formal parameter <code>x</code> will be given the value <code>42</code> for this function call and then the \"body\" of the function will use that value for <code>x</code> when computing the return value.</p> <p>The body of the <code>double</code> function is just one line:</p> <pre><code>    return x * 2\n</code></pre> <p><code>return</code> is another Python keyword. What this line means is that the expression <code>x * 2</code> is computed and returned from the function. So, for instance, if some other code calls the <code>double</code> function:</p> <pre><code>n = double(42)\n</code></pre> <p>then the <code>double</code> function:</p> <ul> <li>will receive the number <code>42</code> as its only argument,</li> <li>will set its formal parameter <code>x</code> to <code>42</code>,</li> <li>will compute <code>x * 2</code> i.e. <code>84</code>,</li> <li>will return <code>84</code>,</li> </ul> <p>and then <code>n</code> will be assigned to the return value of <code>84</code>. After this, using the variable <code>n</code> will be like using the number <code>84</code> (at least until <code>n</code> is set to some other value).</p> <p>Keywords</p> <p>A keyword is a reserved word in Python's grammar. Even if it technically obeys the rules for variables, you can't use it as a variable name. Python, like most programming languages, has a number of keywords; the full list is here. You definitely should not bother memorizing these at this time.</p> <p>Note that you can enter function definitions interactively in the Python interpreter:</p> <pre><code>&gt;&gt;&gt; def double(x):\n...     return x * 2\n...\n&gt;&gt;&gt; double(42)\n84\n</code></pre> <p>When you do this, Python recognizes after the first line that you are inside a function definition and changes the prompt to its secondary prompt which is <code>...</code> (three periods). Once the function is done, Python returns to the primary prompt (<code>&gt;&gt;&gt;</code>).</p> <p>In general, though, you should be writing functions in files, loading them into Python, and then using/testing them interactively.<sup>1</sup> (We'll describe how to do this in a later reading and in the assignments.) Writing functions in the interpreter is a bad idea, because once the interpreter exits, the function definitions disappear (they aren't reloaded the next time you start Python).</p> <p>In Python, the body of a function can be one line or multiple lines long. Either way, you have to indent the body of the function relative to the <code>def</code> line. If there are multiple lines, you have to indent them all the same amount:</p> <pre><code>def sum_of_squares(x, y):\n    z = x * x\n    z = z + y * y\n    return z\n</code></pre> <p>In Python, it's conventional to indent the bodies of functions exactly four spaces, although this isn't a requirement.</p>"},{"location":"2/reading2/#local-variables","title":"Local variables","text":"<p>We sneakily introduced an important new feature of Python in the last example: local variables. Let's see that function again:</p> <pre><code>def sum_of_squares(x, y):\n    z = x * x\n    z = z + y * y\n    return z\n</code></pre> <p>(We've added line numbers to make it easier to talk about the code.)</p> <p>The body of the function consists of lines 2 to 4. They are evaluated in order. Line 2 defines a local variable called <code>z</code> which we set to be equal to <code>x * x</code> i.e. <code>x</code> squared. Then line 3 adds <code>y * y</code> to <code>z</code>, so that <code>z</code> contains the sum of squares of <code>x</code> and <code>y</code>. Then <code>z</code> is returned from the function in line 4. By default, Python executes code in this one-line-after-another manner. However, there are ways of changing the flow of the program which we will describe in later readings.</p> <p>A local variable is a variable which exists only while the function is executing. It springs into existence when the function is called and disappears when the function returns. The next time the <code>double</code> function is called, it won't \"remember\" its previous <code>z</code> value either; it starts from scratch. If you define this function and try to access the variable <code>z</code> after it returns, Python will tell you that <code>z</code> isn't defined.<sup>2</sup> Variables that aren't local are global variables.<sup>3</sup> Most variables in a Python program will be local variables.</p> <p>Let's say we call this function from the interpreter:</p> <pre><code>&gt;&gt;&gt; sum_of_squares(3, 4)\n25\n</code></pre> <p>So far, so good.  Now if we do:</p> <pre><code>&gt;&gt;&gt; z\n</code></pre> <p>we get this error:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'z' is not defined\n</code></pre> <p>Tracebacks</p> <p>A traceback is a representation of exactly where in the code Python was when an error occurred, along with an indication of what kind of error occurred. Tracebacks will be explained in detail in a later reading. For now, all you need to know is that it indicates that something went wrong, and there is usually an error message telling you what that was.</p> <p>Here, you can see that there is no value associated with the local variable <code>z</code> when <code>sum_of_squares(3, 4)</code> returns. Interestingly, this is also true of the formal parameters <code>x</code> and <code>y</code>; they behave like local variables as well.</p> <pre><code>&gt;&gt;&gt; sum_of_squares(3, 4)\n25\n&gt;&gt;&gt; x\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'x' is not defined\n&gt;&gt;&gt; y\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'y' is not defined\n</code></pre> <p>Note</p> <p>The fact that the names <code>x</code> and <code>y</code> are not defined after <code>sum_of_squares</code> returns is a good thing! You want your local variables to stay local, so they can't interfere with anything outside the function, and can't be interfered with by anything outside the function.</p>"},{"location":"2/reading2/#global-variables","title":"Global variables","text":"<p>Any variable defined at the top level of the program (which means not inside a function) is a global variable.<sup>4</sup></p> <pre><code># Global variable representing the current year.\nyear = 2024\n</code></pre> <p>A global variable can be used inside any function. In general, though, try not to use global variables if you can help it; local variables are just easier to reason about. Global variables are OK if you don't change them in the program; then they are effectively global constants.</p>"},{"location":"2/reading2/#comments","title":"Comments","text":"<p>One very important thing that all programming languages allow you to do is to write comments in the code. These are \"notes to yourself\" which explain things about the code to anyone reading it. They aren't executed; the computer simply ignores them.</p> <p>Python comment syntax is very simple: a comment starts with the <code>#</code> character and goes until the end of the line it's on.</p> <pre><code># This is a comment.\na = 10  # This is a comment that doesn't span an entire line.\n</code></pre> <p>Comments are one useful way to document your code. There are other ways which we'll see as we go along.</p> <ol> <li> <p>You may also be using a debugger, which is a tool that can run code inside of a code editor and help you walk through the code to find bugs. And you may also be running pre-written tests from the terminal command line.\u00a0\u21a9</p> </li> <li> <p>Unless a different non-local variable named <code>z</code> was defined previously, which we are assuming isn't the case here.\u00a0\u21a9</p> </li> <li> <p>We're oversimplifying here. There are other kinds of variables, and we'll get to them in due time.\u00a0\u21a9</p> </li> <li> <p>Names defined inside a class are also not global variables, but we're keeping things simple for now.\u00a0\u21a9</p> </li> </ol>"},{"location":"3/reading3/","title":"Reading 3: Strings, part 1","text":"<p>The good news about computers is that they do what you tell them to do. The bad news is that they do what you tell them to do. - Ted Nelson</p>"},{"location":"3/reading3/#topics","title":"Topics","text":"<p>In this reading and the next we'll be discussing \"strings\", which is the way text is represented inside computer programs. Strings are a fundamental data type, and are also an example of a Python \"object\". Python is what's called an \"object-oriented\" programming language, so objects are going to be a major topic for the entire course.<sup>1</sup> We will see objects again in a different language when we cover the Java language later in the course.</p> <p>Strings are important for another reason. Many beginning programmers are under the impression that the main thing programs do is work with numbers. While numbers are undoubtedly important, they are not the only kind of data. Strings are at least as important, and in many applications (for instance, web programming) probably more important.</p>"},{"location":"3/reading3/#terminology","title":"Terminology","text":"<p>As we've discussed previously, many terms in programming mean different things than they do in normal conversation. A string in programming doesn't mean something you use to tie things up or something your cat likes to play with. A string in programming is the way the computer represents textual data. Python has extremely good support for strings; using strings in Python is both powerful and easy. Also, there are a lot of useful operators and functions that are predefined in Python for working with strings.</p>  A string, but not a Python string  <p>We'll go over string syntax in detail below, but to cut to the chase, strings are usually represented as a sequence of characters in single quotes, like this:</p> <pre><code>'I am a string'\n</code></pre> <p>Strings are data, and as such can be assigned to variables:</p> <pre><code>s = 'I am a string'\n</code></pre> <p>And strings can be printed to the terminal using the built-in function <code>print</code>:</p> <pre><code>&gt;&gt;&gt; s = 'I am a string'\n&gt;&gt;&gt; print(s)\nI am a string\n</code></pre> <p>When this happens, the quotes are not printed.</p>"},{"location":"3/reading3/#applications","title":"Applications","text":"<p>Strings are one of the most commonly-used data types in computer programs. To give you some examples of things that can be represented as strings:</p> <ul> <li>DNA sequences e.g. <code>'ACCTGGAACT'</code></li> <li>Web pages</li> <li>Documents in text files</li> <li>Computer source code (like your Python programs)</li> </ul> <p>and many, many other kinds of data.</p>"},{"location":"3/reading3/#sequences","title":"Sequences","text":"<p>Strings are the first kind of data we've seen that is an example of a Python sequence. There are other kinds of sequence data types in Python (for instance, lists and tuples), which we will discuss in later readings. Sequences are nice because Python tends to use the same functions, operators and syntax for all sequences in similar ways. So once you've learned how to work with one kind of sequence (like strings), you can use that knowledge with other sequences (like lists), and things will usually do what you expect.</p>"},{"location":"3/reading3/#string-syntaxes","title":"String syntax(es)","text":"<p>Let's face it: syntax is boring. But much like learning your multiplication tables in elementary school, you just have to learn it. If syntax is boring, string syntax is even more boring. We'll give you the essentials here along with links to other documents with more details if you ever need them.</p>"},{"location":"3/reading3/#characters","title":"Characters","text":"<p>Strings are sequences of letters. In programming-speak, letters are referred to as characters. Characters include not only the alphabet letters (<code>a</code> to <code>z</code> and <code>A</code> to <code>Z</code>) but also digits (<code>0</code> through <code>9</code>), punctuation characters, etc. Basically, anything you can type on your keyboard is a character. Some characters are invisible, like newline characters and tab characters. However, they do something when printed; just because you don't see them doesn't mean they aren't real!<sup>2</sup></p> <p>Some programming languages (like Java) have a special data type for characters. Python doesn't; a character is represented by a string of length 1. For instance:</p> <pre><code>'a'  # the character a (letter)\n'1'  # the character 1 (digit)\n'_'  # the underscore character\n'?'  # question mark (symbol)\n</code></pre>"},{"location":"3/reading3/#quotation-marks","title":"Quotation marks","text":"<p>Most of the time, we write strings with single quote marks, not least because it's easy to type on the computer without using the shift key. But Python allows you to use either the single or double-quote character to delimit strings, as long as you use the same character for the start-string and end-string character:</p> <pre><code>'I am a string'\n\"So am I\"\n# \"This is not a valid string'\n# 'Neither is this\"\n</code></pre> <p>(We commented out the invalid strings.)</p> <p>The advantage of allowing both kinds of quote characters is that we can have one kind of quote within another:</p> <pre><code>\"This is a string with 'embedded single quotes'.\"\n'This is the \"same thing\" but with double quotes.'\n</code></pre> <p>This is useful when you want to e.g. print out a string with quotes in it.</p> <pre><code>&gt;&gt;&gt; print(\"Behold a 'quoted string'!\")\nBehold a 'quoted string'!\n</code></pre> <p>If you leave quotation marks off of a string entirely, Python doesn't consider it a string but will try to interpret it as regular Python code. For words, this means that Python will interpret the words as variable names, possibly resulting in an error:</p> <pre><code>&gt;&gt;&gt; foo\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'foo' is not defined\n&gt;&gt;&gt; 'foo'\n'foo'\n</code></pre> <p>If you try to embed a quote character inside a string that uses the same quote character as its delimiters, you get a syntax error:</p> <pre><code>&gt;&gt;&gt; s = 'this isn't going to work'\n</code></pre> <p>Python will respond:</p> <pre><code>  File \"&lt;stdin&gt;\", line 1\n    s = 'this isn't going to work'\n                  ^\nSyntaxError: invalid syntax\n</code></pre> <p>A syntax error means that you broke the syntax rules of Python. Here, Python thinks that the string ends with the <code>n</code> i.e.</p> <pre><code>s = 'this isn'\n</code></pre> <p>and then it can't make sense of <code>t going to work'</code>, so it aborts with an error. If the outer quotes were double quotes, it would work:</p> <pre><code>&gt;&gt;&gt; s = \"this isn't going to work\"\n&gt;&gt;&gt; s\n\"this isn't going to work\"\n</code></pre> <p>Of course, now the string <code>s</code> is telling you a lie about itself, but that's not our problem.</p>"},{"location":"3/reading3/#empty-string","title":"Empty string","text":"<p>If you need an empty string, you just write two quote characters one after another:</p> <pre><code>''  # empty string\n\"\"  # also empty string\n</code></pre> <p>You might think an empty string is completely useless, but it's not. Often you start with an empty string and add characters to it to create a longer string. (We'll see examples of this later.)</p> <p>Note that a string which contains only a space character is not an empty string:</p> <pre><code>' '  # a string containing a space character; not empty!\n</code></pre>"},{"location":"3/reading3/#whitespace-characters","title":"Whitespace characters","text":"<p>There are characters that don't actually print characters but make something else happen. The space character is one of them; it doesn't really \"print a space\", it simply moves the location where printing can happen over by one character width. (Nevertheless, we will still say that it \"prints a space\" because it's easier to write.) Characters like this are collectively called whitespace characters. There are three of these in common use: the space character, the newline character, and the tab character. The newline character makes the string skip to the beginning of the next line when printed. The tab character is like some number of spaces (the specific number depends on the terminal or editor settings). In Python, these characters are represented as follows:</p> character Python equivalent space <code>' '</code> or <code>\" \"</code> tab <code>'\\t'</code> or <code>\"\\t\"</code> newline <code>'\\n'</code> or <code>\"\\n\"</code> <p>Usually, these characters are inside of a string or at one or both ends of a string:</p> <pre><code>'    this is a string with spaces inside and on each end   '\n'this is a string with a newline at the end\\n'\n'this\\tis\\ta\\tstring\\twith\\twords\\tseparated\\tby\\ttabs'\n</code></pre> <p>It's important to understand that when you put e.g. a <code>\\n</code> inside a string, Python does not interpret this as the backslash character followed by the <code>n</code> character. Instead, it treats both of them as a single thing: a newline character.<sup>3</sup></p>"},{"location":"3/reading3/#escape-sequences","title":"Escape sequences","text":"<p>The notation <code>\\n</code> for a newline character or <code>\\t</code> for a tab character is a bit odd, because you are using two characters to stand for a single character. Python refers to such characters as escape sequences because you are \"escaping\" from the normal rules of how strings are constructed in order to put special characters into the string.</p> <p>There are a number of escape characters that Python recognizes; a full list is here, but you don't need to know it. For our purposes, the only ones we'll need are these:</p> escape sequence meaning <code>\\t</code> tab <code>\\n</code> newline <code>\\'</code> single quote character (even inside single-quoted string) <code>\\\"</code> double quote character (even inside double-quoted string) <code>\\\\</code> backslash character <p>You might wonder why we need the last three. You can use the escaped quote characters if you want to put a quote character inside a string which uses the same quote character as its delimiter.</p> <pre><code>'single quotes \\'inside\\' single quoted string'\n\"double quotes \\\"inside\\\" double quoted string\"\n</code></pre> <p>Usually, it's better to rewrite this by using a different quote character to create the string:</p> <pre><code>\"single quotes 'inside' a single quoted string\"\n'double quotes \"inside\" a double quoted string'\n</code></pre> <p>Sometimes we can't do this, like if we are already using both kinds of characters:</p> <pre><code>'this is a \"very messy \\'example\\' of\" nested quotes'\n</code></pre> <p>However, this is extremely rare.</p> <p>Since the backslash (<code>\\</code>) character is already used to mean the start of an escape sequence, what do we do if we want to put a literal backslash character inside a string? We use an escaped backslash, of course! This amounts to a double-backslash:</p> <pre><code>&gt;&gt;&gt; print('a string with a \\\\ backslash inside it')\na string with a \\ backslash inside it\n</code></pre> <p>When you enter a literal strings with escapes into the Python interpreter without using <code>print</code>, it shows you the escaped characters the way you would type them:</p> <pre><code>&gt;&gt;&gt; print('a string with a \\\\ backslash inside it')\na string with a \\ backslash inside it\n&gt;&gt;&gt; 'a string with a \\\\ backslash inside it'\n'a string with a \\\\ backslash inside it'\n</code></pre>"},{"location":"3/reading3/#strings-are-immutable","title":"Strings are immutable","text":"<p>A string is a fixed, or immutable object. Once you create a string, you can't change any of the letters inside the string. Instead, you would have to create a new string:</p> <pre><code>here = \"Caltexh\"  # oops!\nhere = \"Caltech\"  # fixed!\n</code></pre> <p>There are reasons for this that we will get to later, but for now, just be aware that you can't change the letters in a string after you create it.</p> <ol> <li> <p>Many programming languages are object-oriented: Java and C++ are two common examples. Some languages, like C, are not.\u00a0\u21a9</p> </li> <li> <p>You're science students, so you're used to this by now  \u21a9</p> </li> <li> <p>There is a way to make Python interpret it as a backslash followed by an <code>n</code>, which is <code>\\\\n</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"4/reading4/","title":"Reading 4: Strings, part 2","text":"<p>To err is human, but to really foul things up you need a computer. - Paul Erlich</p>"},{"location":"4/reading4/#topics","title":"Topics","text":"<p>This reading continues our discussion of strings. We'll go into more depth on strings and what you can do with them.</p>"},{"location":"4/reading4/#string-operations","title":"String operations","text":"<p>There are many useful string operations that are built in to Python. Some of them are operators (symbols) that work on strings; others are functions that work on strings. Still others are methods on string objects (methods will be covered in the next reading).</p>"},{"location":"4/reading4/#indexing","title":"Indexing","text":"<p>One basic thing we might want to do with a string is to extract a character from the string. We do this using Python's indexing operator, which is a pair of square brackets surrounding an integer index.</p> <pre><code>&gt;&gt;&gt; s = 'I am a string'\n&gt;&gt;&gt; s[0]\n'I'\n&gt;&gt;&gt; s[1]\n' '\n&gt;&gt;&gt; s[2]\n'a'\n</code></pre> <p>The first character of the string is <code>s[0]</code> which is the character <code>'I'</code> (actually a string of length 1). The second character is <code>s[1]</code>, which is a space character, the third is <code>s[2]</code>, which is <code>'a'</code>, and so on. Locations of characters in a string are called indices (plural of index), and they start at <code>0</code>, not <code>1</code>. The same kind of indexing is used for all Python sequence types (e.g. lists, tuples as well as strings) and we'll discuss it in more detail when we talk about lists.</p>"},{"location":"4/reading4/#length","title":"Length","text":"<p>To get the \"length\" of a string (i.e. the number of characters in the string) use the built-in <code>len</code> function:</p> <pre><code>&gt;&gt;&gt; len('')\n0\n&gt;&gt;&gt; len('Caltech')\n7\n&gt;&gt;&gt; len('MIT')\n3\n&gt;&gt;&gt; len('Caltech') &gt; len('MIT')\nTrue\n</code></pre> <p>Like the indexing operator, the <code>len</code> function can be used on any kind of sequence, not just on strings.</p>"},{"location":"4/reading4/#concatenation","title":"Concatenation","text":"<p>A common operation with strings is combining two strings to make a bigger string. In Python, this is done using the <code>+</code> operator, as if you were \"adding\" the two strings together:</p> <pre><code>&gt;&gt;&gt; 'foo' + 'bar'\n'foobar'\n&gt;&gt;&gt; s1 = 'Cal'\n&gt;&gt;&gt; s2 = 'tech'\n&gt;&gt;&gt; s3 = s1 + s2\n&gt;&gt;&gt; s3\n'Caltech'\n</code></pre> <p>The technical name for this is string concatenation. Of course, this isn't really addition, but for convenience we use the <code>+</code> operator anyway. This leads us into the next topic!</p>"},{"location":"4/reading4/#operator-overloading","title":"Operator overloading","text":"<p>Even though we like to use analogies between math and computer programming, there are lots of ways in which computer programs are different from math. One way is that operators like <code>+</code> are sometimes used for things that aren't arithmetic; string concatenation is a good example. We call this operator overloading; we are \"overloading\" the <code>+</code> operator to mean something that it wouldn't usually mean.</p> <p>Every programming language does operator overloading differently. Some don't allow it at all. Python overloads operators when it makes code easier to understand and more concise. We'll see other examples of this as we go along.</p>"},{"location":"4/reading4/#pitfalls","title":"Pitfalls","text":"<p>A pitfall is something that's easy to get wrong or easy to get confused about. We will talk a lot about pitfalls in this course.</p> <p>Here's a potential pitfall with string concatenation:</p> <pre><code>&gt;&gt;&gt; s1 = '12'\n&gt;&gt;&gt; s2 = '34'\n&gt;&gt;&gt; s1 + s2\n'1234'\n</code></pre> <p>Were you expecting <code>'46'</code>? When Python concatenates strings, it doesn't try to interpret the strings; it doesn't \"know\" that <code>'12'</code> is the string representation of a number.</p> <p>This doesn't work either:</p> <pre><code>&gt;&gt;&gt; s1 = 12\n&gt;&gt;&gt; s2 = '34'\n&gt;&gt;&gt; s1 + s2\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre> <p>Python won't auto-convert the string <code>s2</code> to an integer to make the addition work, nor will it auto-convert the integer <code>s1</code> to a string to make string concatenation work. In general, Python won't \"guess\" what you want; if it's not totally explicit, it will just fail. This may annoy you but it's actually a good thing.<sup>1</sup></p>"},{"location":"4/reading4/#string-multiplication","title":"String \"multiplication\"","text":"<p>Python also overloads the multiplication (<code>*</code>) operator when used with an integer \"multiplied\" by a string or vice-versa. In this case, it means string replication: the string is copied that number of times to make a new string.</p> <pre><code>&gt;&gt;&gt; s = 'foo'\n&gt;&gt;&gt; s\n'foo'\n&gt;&gt;&gt; s * 3\n'foofoofoo'\n&gt;&gt;&gt; 3 * s\n'foofoofoo'\n&gt;&gt;&gt; s * s   # oops! can't multiply strings!\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can't multiply sequence by non-int of type 'str'\n</code></pre> <p>The error message is telling us that we can only multiply a string by an integer, not by another string.</p> <pre><code>&gt;&gt;&gt; s = 'foo'\n&gt;&gt;&gt; s * 0    # multiply string x 0 = empty string\n''\n&gt;&gt;&gt; 0 * s\n''\n&gt;&gt;&gt; -1 * s   # this doesn't reverse strings, sorry!\n''\n&gt;&gt;&gt; 0.5 * s  # half-characters not supported, sorry!\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can't multiply sequence by non-int of type 'float'\n</code></pre>"},{"location":"4/reading4/#convert-to-string","title":"Convert to string","text":"<p>If you need to explicitly convert something to a string, use the built in function <code>str</code>:</p> <pre><code>&gt;&gt;&gt; str(12)\n'12'\n&gt;&gt;&gt; str(1.234)\n'1.234'\n&gt;&gt;&gt; str('foo')\n'foo'\n</code></pre> <p>Converting a string to a string doesn't change the string, as you might expect. But converting an integer or a float to a string creates a completely different kind of value.</p>"},{"location":"4/reading4/#printing-to-the-terminal","title":"Printing to the terminal","text":"<p>If you want to print a string to the terminal, you use the built-in <code>print</code> function, which we've seen already:</p> <pre><code>&gt;&gt;&gt; print(42)\n42\n&gt;&gt;&gt; print(3.1415926)\n3.1415926\n&gt;&gt;&gt; print('foobar')\nfoobar\n</code></pre> <p>A few things to notice here:</p> <ul> <li> <p><code>print</code> works on any Python value, not just strings. You don't have to use the <code>str</code> function to convert values to strings inside the <code>print</code> call; the <code>print</code> function takes care of that.</p> </li> <li> <p><code>print</code> advances to the next line after printing. Technically, what it does is print a newline character after printing the Python value. There is a way to suppress the newline character, which we'll see below.</p> </li> <li> <p>Printing to the terminal is not the same as returning a value from a function. This is an easy thing to get confused about (a pitfall!). Look at this:</p> </li> </ul> <pre><code>&gt;&gt;&gt; print(42)\n42\n&gt;&gt;&gt; 42\n42\n</code></pre> <p>It looks the same, right? But what's happening is totally different. Let's say you had this Python code in a file:</p> <pre><code>print(42)\n42\n</code></pre> <p>When you ran this file though Python, only the first line would print anything. The second line wouldn't do anything at all. But in the Python interactive interpreter, Python automatically prints any expression entered, which makes it look like these are the same thing, which isn't the case.</p> <p>The difference is more obvious with strings:</p> <pre><code>&gt;&gt;&gt; print('foobar')\nfoobar\n&gt;&gt;&gt; 'foobar'\n'foobar'\n</code></pre> <p>When the interactive interpreter prints the value of a string without using the <code>print</code> function, it adds the quotes so that you know the value is a string. Again, this won't happen if you wrote the Python code in a file; when you ran the file through Python you would just see:</p> <pre><code>foobar\n</code></pre>"},{"location":"4/reading4/#suppressing-the-newline-character","title":"Suppressing the newline character","text":"<p>As mentioned above, you can change the default behavior of printing a newline character after printing the value by adding an extra argument.</p> <p>Consider this code (we'll assume it's in a file):</p> <pre><code># Normal use of print:\nprint(10)\nprint(20)\nprint(30)\n</code></pre> <p>which results in this when run:</p> <pre><code>10\n20\n30\n</code></pre> <p>Notice that each number is printed on a separate line. Now look at this:</p> <pre><code># Print without printing a newline at the end:\nprint(10, end='')\nprint(20, end='')\nprint(30, end='')\n</code></pre> <p>which results in:</p> <pre><code>102030\n</code></pre> <p>The <code>end=''</code> argument is called a keyword argument. We'll talk more about keyword arguments later in the course, but just take it on faith that this is what you need to do if you don't want to print a newline character after printing a value using the <code>print</code> function.</p> <p>Conversely, if you just want to print a newline character, just do this:</p> <pre><code>print()\n</code></pre> <p>Writing e.g. <code>print('')</code> will also work, but it's bad style since it's more complicated than it needs to be.</p> <p>Coding style</p> <p>There are many ways of writing code that work, but that are still \"bad\" in various ways. Some of these ways are referred to as being \"bad coding style\". Writing a longer expression (like <code>print('')</code>) where a shorter expression (like <code>print()</code>) will do is an example of poor style, because the <code>''</code> in the argument to <code>print</code> is unnecessary. Don't worry too much about this now; the assignments will contain exercises to help you work on your coding style.</p>"},{"location":"4/reading4/#multiline-strings","title":"Multiline strings","text":""},{"location":"4/reading4/#single-line-strings-are-the-default","title":"Single-line strings are the default","text":"<p>By default, a string in Python spans a single line only. If you try to extend the string to the next line, you get a syntax error:</p> <pre><code>&gt;&gt;&gt; 'this is a string'\n'this is a string'\n&gt;&gt;&gt; 'I want to write a multiline string\n  File \"&lt;stdin&gt;\", line 1\n    'I want to write a multiline string\n                                       ^\nSyntaxError: EOL while scanning string literal\n</code></pre> <p>This error message says \"while trying to read a string literal, I encountered a newline (End Of Line or EOL) character, which is a syntax error\". So that doesn't work.</p>"},{"location":"4/reading4/#manually-creating-multiline-strings","title":"Manually creating multiline strings","text":""},{"location":"4/reading4/#putting-in-newlines","title":"Putting in newlines","text":"<p>You can create a multiline string manually by putting in newline characters:</p> <pre><code>&gt;&gt;&gt; s = 'I want to write a multiline string\\nlike this.'\n&gt;&gt;&gt; s\n'I want to write a multiline string\\nlike this.'\n&gt;&gt;&gt; print(s)\nI want to write a multiline string\nlike this.\n</code></pre> <p>However, in this case the string you type still has to be all on one physical line, which is often not what you want.</p>"},{"location":"4/reading4/#concatenating-strings-and-the-line-continuation-character","title":"Concatenating strings and the line continuation character","text":"<p>You could fix that by using string concatenation:</p> <pre><code>&gt;&gt;&gt; s = 'I want to write a multiline string\\n' + \\\n'like this.'\n&gt;&gt;&gt; print(s)\nI want to write a multiline string\nlike this.\n</code></pre> <p>Since Python executes code a line at a time, and the string concatenation spans multiple lines, you have to write the line continuation character at the end of the line, which you type with a backslash followed by the return key.<sup>2</sup> If you don't, then this happens:</p> <pre><code>&gt;&gt;&gt; s = 'I want to write a multiline string\\n' +\n  File \"&lt;stdin&gt;\", line 1\n    s = 'I want to write a multiline string\\n' +\n                                                ^\nSyntaxError: invalid syntax\n</code></pre> <p>This is not Python's finest error message, but it's telling you that the <code>+</code> expression isn't finished.</p> <p>The point of all this is that you can manually create multiline strings, but it's a pain. You have to remember to put in the newline characters and the line continuation characters. You also have to type <code>+</code> characters between the strings. There should be a better way.</p> <p>Line continuation character</p> <p>The line continuation character can be used for any long Python expression that won't fit on a single line, not just for concatenating strings. For instance:</p> <pre><code>first_20_ints = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + \\\n16 + 17 + 18 + 19 + 20\n</code></pre> <p>Try not to use it, though, because it's ugly and hard to read. On the other hand, very long lines are also hard to read, so use it when necessary to prevent lines from getting too long.</p>"},{"location":"4/reading4/#a-better-way-triple-quoted-strings","title":"A better way: triple-quoted strings","text":"<p>The better way is to use triple-quoted strings. To do this you use not one, not two, but three (3) quote characters to both begin and end a string. You can use either kind of quote character (single quote (<code>'</code>) or double quote (<code>\"</code>)) as long as all three of the quote characters are the same, and the same kind of quote characters are used at the beginning and end of the string.</p> <p>Triple-quoted strings can span multiple lines, though they don't have to.</p> <pre><code>&gt;&gt;&gt; '''I am a triple-quoted string!'''\n'I am a triple-quoted string!'\n&gt;&gt;&gt; '''As a triple-quoted string,\nI can span\nmultiple\nlines!\n'''\n'As a triple-quoted string,\\nI can span\\nmultiple\\nlines!\\n'\n</code></pre> <p>Notice that the Python interpreter converts triple-quoted strings to single-line strings before printing them back out. But if you use the <code>print</code> function:</p> <pre><code>&gt;&gt;&gt; print('''As a triple-quoted string,\nI can span\nmultiple\nlines!\n''')\nAs a triple-quoted string,\nI can span\nmultiple\nlines!\n</code></pre> <p>then you see the multiline-ness of the output string. Or we could bind a multiline string to a variable:</p> <pre><code>&gt;&gt;&gt; msg = '''\nThis is\na\nmultiline\nstring.'''\n&gt;&gt;&gt; print(msg)\n\nThis is\na\nmultiline\nstring.\n</code></pre> <p>Question</p> <p>Why is there a blank line before the <code>This is</code> when using the <code>print</code> function in this particular case? What would the call to <code>print</code> have to look like if you didn't want the blank line?</p> <p>Fun fact: inside a triple-quoted string, you can put any other kind of string:</p> <ol> <li>single-line strings surrounded by the <code>'</code> character</li> <li>single-line strings surrounded by the <code>\"</code> character</li> <li>the other kind of triple-quoted string (<code>\"\"\"</code> if your string uses <code>'''</code> or vice-versa).</li> </ol> <p>Also, escape sequences still work inside triple-quoted strings.</p>"},{"location":"4/reading4/#an-application","title":"An application","text":"<p>A web page can be written as a single multiline string:</p> <pre><code>'''&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;My home page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Welcome to my home page!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;'''\n</code></pre> <p>Don't worry if you don't understand the syntax. It's HTML (HyperText Markup Language), which is a formatting language used for writing web pages. Python doesn't understand HTML either; as far as Python is concerned, it's just a string.</p> <p>Compare this to how we would write it without multiline strings:</p> <pre><code>'&lt;html&gt;\\n' + \\\n'&lt;head&gt;\\n' + \\\n'&lt;title&gt;My home page&lt;/title&gt;\\n' + \\\n'&lt;/head&gt;\\n' + \\\n'&lt;body&gt;\\n' + \\\n'&lt;p&gt;Welcome to my home page!&lt;/p&gt;\\n' + \\\n'&lt;/body&gt;\\n' + \\\n'&lt;/html&gt;'\n</code></pre> <p>Ouch!  Now you see why multiline strings are useful!</p>"},{"location":"4/reading4/#string-formatting","title":"String formatting","text":"<p>It's often the case that we want to print out a string which contains Python values embedded inside it. For instance, you might want to print the value of a Python expression while debugging, or maybe you're writing a report and you need to print out some data that the report summarizes. You can always convert a Python value to a string using the <code>str</code> method and combine that with actual strings using string concatenation:</p> <pre><code>&gt;&gt;&gt; rainfall = 100\n&gt;&gt;&gt; print('The rainfall was ' + str(rainfall) + ' inches.'))\nThe rainfall was 100 inches.\n</code></pre> <p>However, this is not very pleasant to write.</p>"},{"location":"4/reading4/#the-format-method","title":"The <code>format</code> method","text":"<p>A much more flexible way to do this is to use string formatting. String formatting works by creating a template string, which contains everything you want to print except for some placeholders where Python values should go. You supply those values later, and they are converted into strings and put into the template string, returning a new string. (Note that this has nothing to do with printing, though we usually do it right before printing the string.)</p> <pre><code>&gt;&gt;&gt; rainfall = 100\n&gt;&gt;&gt; s = 'The rainfall was {} inches.'.format(rainfall)\n&gt;&gt;&gt; print(s)\nThe rainfall was 100 inches.\n</code></pre> <p>Here, the template string is <code>'The rainfall was {} inches.'</code>. Inside the template string, the placeholder characters are <code>{}</code>.</p> <p>The important part is the <code>.format(rainfall)</code> part of the second line. This is a method call on the string <code>'The rainfall was {} inches'</code>. We will talk more about method calls in the next reading (they're part of object-oriented programming), but for now just take it on faith that this works. What it does is to convert the Python value <code>rainfall</code> to a string and put it into the template string where the <code>{}</code> placeholder characters are. Then it returns the new string (the template string itself isn't changed).</p> <p>Note</p> <p>A template string is just a regular Python string; there's nothing special about it. However, the contents of the template string are processed by the <code>format</code> method call, which creates a new string with the placeholder characters replaced by whatever is supposed to go there.</p> <p>Normally we do everything inside a <code>print</code> call:</p> <pre><code>&gt;&gt;&gt; rainfall = 100\n&gt;&gt;&gt; print('The rainfall was {} inches.'.format(rainfall))\nThe rainfall was 100 inches.\n</code></pre> <p>There's also a shortcut way of writing this that is more concise:</p> <pre><code>&gt;&gt;&gt; rainfall = 100\n&gt;&gt;&gt; print(f'The rainfall was {rainfall} inches.')\nThe rainfall was 100 inches.\n</code></pre> <p>We will talk more about this syntax in later readings.</p>"},{"location":"4/reading4/#format-specifiers","title":"Format specifiers","text":"<p>Tip</p> <p>You may want to skip this section for now, and come back to it later. Most of the time you won't need to use format specifiers, but if you need to do very specific kinds of string formatting, the information in this section will be helpful.</p> <p>We will not give all the details here; instead, we'll present a simplified version of what you can do with format specifiers. If you do need the full details, the Python documentation on the string formatting \"mini-language\" is located here.</p> <p>There are many, many things you can do with string formatting. If you are formatting a floating-point number, you can specify the number of decimal places it has. You can specify a maximum width for the string which replaces the placeholder, or whether it's padded to the left or the right or centered. These specifiers go inside the <code>{}</code> placeholder characters. Most of the time, we just use <code>{}</code> because it's good enough for our needs. However, there are a few format specifiers that are generally useful, so we'll discuss those now.</p> <p>There are two parts to format specifiers:</p> <ol> <li>argument numbers</li> <li>formatting directives</li> </ol> <p>Both parts are optional. If you don't need either part, use <code>{}</code>.</p> <p>The first part is the argument number of the <code>format</code> method call, which is an integer (<code>0</code> or greater). So <code>{0}</code> means \"the first argument in the <code>format</code> call\", <code>{1}</code> means \"the second argument in the <code>format</code> call, etc.  If you don't specify this, it chooses the next argument that hasn't already been used, so the first <code>{}</code> would get the first argument of the <code>format</code> method call, the second <code>{}</code> would get the second, etc.</p> <p>The second part of the format specifier starts with the colon (<code>:</code>) character and contains formatting directives.<sup>3</sup> If you don't need the argument number, then the format specifier as a whole starts with the colon.</p> <p>Strings use the <code>'s'</code> directive. You can specify a string as having a particular field width, and it can be left-justified, centered, or right-justified within that width. If the string argument is smaller than the field width, spaces are used for padding.</p> <pre><code>&gt;&gt;&gt; '{:s}'.format('foo')\n'foo'\n&gt;&gt;&gt; '{:10s}'.format('foo')    # field width 10\n'foo       '\n&gt;&gt;&gt; '{:&lt;10s}'.format('foo')   # field width 10, left (&lt;) justified\n'foo       '\n&gt;&gt;&gt; '{:^10s}'.format('foo')   # field width 10, center (^) justified\n'   foo    '\n&gt;&gt;&gt; '{:&gt;10s}'.format('foo')   # field width 10, right (&gt;) justified\n'       foo'\n</code></pre> <p>Integers use the <code>'d'</code> directive. You can specify an integer has having a particular field width, and again it can be left-, center-, or right-justified.</p> <pre><code>&gt;&gt;&gt; '{:d}'.format(42)\n'42'\n&gt;&gt;&gt; '{:10d}'.format(42)\n'        42'\n&gt;&gt;&gt; '{:&lt;10d}'.format(42)\n'42        '\n&gt;&gt;&gt; '{:^10d}'.format(42)\n'    42    '\n&gt;&gt;&gt; '{:&gt;10d}'.format(42)\n'        42'\n</code></pre> <p>Floating-point numbers use either the <code>'f'</code> or the <code>'g'</code> directives.<sup>4</sup> In addition to the field width and left-, center-, or right-justification specifiers already described, you can specify the number of decimal places to print using a decimal point followed by an integer:</p> <pre><code>&gt;&gt;&gt; '{:f}'.format(3.14159265358979)\n'3.141593'\n&gt;&gt;&gt; '{:.2f}'.format(3.14159265358979)\n'3.14'\n&gt;&gt;&gt; '{:10.2f}'.format(3.14159265358979)\n'      3.14'\n&gt;&gt;&gt; '{:&lt;10.2f}'.format(3.14159265358979)\n'3.14      '\n&gt;&gt;&gt; '{:^10.2f}'.format(3.14159265358979)\n'   3.14   '\n&gt;&gt;&gt; '{:&gt;10.2f}'.format(3.14159265358979)\n'      3.14'\n&gt;&gt;&gt; '{:10.6f}'.format(3.14159265358979)\n'  3.141593'\n&gt;&gt;&gt; '{:10.6f}'.format(3.1)\n'  3.100000'\n</code></pre> <p>The <code>f</code> directive will always use the specified number of decimal places, even if it means adding extra (\"trailing\") zeros. To suppress trailing zeros, use the <code>g</code> directive instead.</p> <pre><code>&gt;&gt;&gt; '{:g}'.format(3.14159265358979)\n'3.14159'\n&gt;&gt;&gt; '{:.2g}'.format(3.14159265358979)\n'3.1'\n&gt;&gt;&gt; '{:10.2g}'.format(3.14159265358979)\n'       3.1'\n&gt;&gt;&gt; '{:&lt;10.2g}'.format(3.14159265358979)\n'3.1       '\n&gt;&gt;&gt; '{:^10.2g}'.format(3.14159265358979)\n'   3.1    '\n&gt;&gt;&gt; '{:&gt;10.2g}'.format(3.14159265358979)\n'       3.1'\n&gt;&gt;&gt; '{:10.6g}'.format(3.14159265358979)\n'   3.14159'\n&gt;&gt;&gt; '{:10.6g}'.format(3.1)\n'       3.1'\n</code></pre> <p>Notice also that the <code>g</code> directive uses the number after the decimal point to specify the total number of significant figures, not the number of decimal places.</p> <p>If you actually need to put curly braces inside format strings, you have to double them up:</p> <pre><code>&gt;&gt;&gt; '{{}}'.format()\n'{}'\n&gt;&gt;&gt; '{{'.format()\n'{'\n&gt;&gt;&gt; '}}'.format()\n'}'\n</code></pre> <p>There are a lot more things you can do with format strings, and we encourage you to consult the Python documentation if you need to do something more complicated than what we've described here.</p>"},{"location":"4/reading4/#the-application-revisited","title":"The application revisited","text":"<p>One problem with the multiline version of the web page given above is that it's totally static; it only represents a particular web page. Often you would like to create a template for a web page with things that can be added in later. A simple example would be to add the name of the user whose home page it is. Since the same code could be used for multiple users, it makes sense to write a template string with placeholders where the name should go. This leads to this kind of code:</p> <pre><code>template = '''&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;{}'s home page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Welcome to {}'s home page!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;'''\n\nprint(template.format('Mike', 'Mike'))\n</code></pre> <p>When run, this will print out:</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Mike's home page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Welcome to Mike's home page!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Things to notice:</p> <ul> <li> <p>You can use the <code>format</code> method on a literal string or on a string variable (here, the variable is called <code>template</code>).</p> </li> <li> <p>You can have more than one placeholder (<code>{}</code>); here there are two. They are filled in with arguments to the <code>format</code> method in order. Here, both of them are the string <code>'Mike'</code>.</p> </li> </ul> <p>Now the multiline string is much more useful; you can use it to generate a whole family of similar web pages. (There are much more sophisticated web templating systems available in Python, but the idea is basically the same.)</p> <p>If you don't want to repeat the name <code>Mike</code> in the arguments to <code>format</code>, there is a way to do it:</p> <pre><code>template = '''&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;{0}'s home page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Welcome to {0}'s home page!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;'''\n\nprint(template.format('Mike'))\n</code></pre> <p>The <code>{0}</code> formatting directive says to use \"argument 0\" which means the first argument of the <code>format</code> method.<sup>5</sup></p> <ol> <li> <p>The \"Zen of Python\" states that \"explicit is better than implicit\" and this is one example of that. To see the full Zen of Python, start up the Python interpreter and type <code>import this</code>.\u00a0\u21a9</p> </li> <li> <p>This is not a string escape because it's in source code, not inside a string, but if you do it inside a string then the newline will simply be ignored. There are some situations where you don't have to use a backslash-return to continue a line, but it's never wrong to use it if the statement doesn't all fit on one line.\u00a0\u21a9</p> </li> <li> <p>This is not standard terminology; the Python documentation also calls these format specifiers. I didn't want \"format specifier\" to mean two different things.\u00a0\u21a9</p> </li> <li> <p>There is also an <code>e</code> directive for exponent notation, but you probably don't need it.\u00a0\u21a9</p> </li> <li> <p>Programming languages almost always start counting from 0, not 1.\u00a0\u21a9</p> </li> </ol>"},{"location":"5/reading5/","title":"Reading 5: Objects and Methods","text":"<p>A graphic representation of data abstracted from banks of every computer in the human system. Unthinkable complexity. Lines of light ranged in the nonspace of the mind, clusters and constellations of data. Like city lights, receding. - William Gibson, Neuromancer</p>"},{"location":"5/reading5/#overview","title":"Overview","text":"<p>We've covered many of the essential aspects of Python programming, but we still have a way to go! In this reading we'll talk about what an \"object\" is, what \"methods\" do and how they are related to functions, and how Python is an \"object-oriented language\". We will use strings as a simple example of an object, but we will see many more kinds of objects later on.</p> <p>Info</p> <p>In fact, in Python all data are represented as objects. Even functions are objects.</p>"},{"location":"5/reading5/#topics","title":"Topics","text":"<ul> <li> <p>Terminal input using the <code>input</code> function</p> </li> <li> <p>Objects and methods</p> </li> </ul>"},{"location":"5/reading5/#terminal-input","title":"Terminal input","text":"<p>This is not really about objects and methods, but we have to put it somewhere, so we're putting it here .</p> <p>We'd like to be able to write interactive programs, where you (the user) and the program have a \"dialogue\". You do something, the program responds, you respond to the program, and so forth. There are many ways to do this, but the most basic way is to allow the program to read a line of input typed at the terminal. When the program wants a response from you, it asks you for a line of input. You type it in and hit the return key, then the program does something with that line of input, and so on. In Python, we do this using the <code>input</code> function:</p> <pre><code>&gt;&gt;&gt; input()\n*This is what you type.*\n'This is what you type.'\n</code></pre> <p>Note</p> <p>We've put asterisks around the text that you would type into the terminal for the <code>input()</code> function call. You wouldn't actually type the asterisks.</p> <p>The line under the <code>input()</code> call is what you type literally at the keyboard (try it!). When you're done, hit the return key and Python prints the string it received.</p> <p>This isn't how you actually use <code>input</code>, of course. You almost always store the line read into a variable:</p> <pre><code>&gt;&gt;&gt; answer = input()\n*This is my answer.*\n&gt;&gt;&gt; answer\n'This is my answer.'\n</code></pre> <p>Now you can use the value of <code>answer</code> to do something in your program. One other thing that would be nice is if <code>input</code> could print a prompt, which is a string that indicates what it is expecting of you. To use a prompt, add a string argument to <code>input</code>:</p> <pre><code>&gt;&gt;&gt; answer = input('Please answer \"yes\" or \"no\": ')\nPlease answer \"yes\" or \"no\": *yes*\n&gt;&gt;&gt; answer\n'yes'\n</code></pre> <p>The only thing that the user entered in this example was the word <code>yes</code>, which becomes the value of the <code>answer</code> variable.</p> <p>Question</p> <ol> <li> <p>Why are the words <code>\"yes\"</code> and <code>\"no\"</code> in the prompt string written with double quotes?</p> </li> <li> <p>Why is there a blank space at the end of the prompt string?</p> </li> </ol> <p>Type this example into Python yourself, and play around with it to get familiar with how the <code>input</code> function works.</p>"},{"location":"5/reading5/#using-input-to-input-integers-and-other-non-strings","title":"Using <code>input</code> to input integers and other non-strings","text":"<p>One thing to be careful about is that <code>input</code> always returns a string, even if you intended it to return e.g. an integer. For instance, look at this code:</p> <pre><code>i = input('Enter an integer: ')\nj = input('Enter another integer: ')\nprint('The sum of the two integers is {}'.format(i + j))\n</code></pre> <p>Here's a sample run:</p> <pre><code>Enter an integer: *42*\nEnter another integer: *101*\nThe sum of the two integers is 42101\n</code></pre> <p>What went wrong?</p> <p>Remember, computer languages are dumb and they don't know what you want them to do unless you spell it out exactly. Here, the <code>input</code> function always returns a string, so the variables <code>i</code> and <code>j</code> contain the strings <code>'42'</code> and <code>'101'</code>, respectively. When you \"add\" two strings, you actually concatenate them, so you get the result <code>'42101'</code>. To avoid this, you have to tell Python to convert the result of the <code>input</code> call to an integer using the <code>int</code> conversion function. Here's the right way to do this:</p> <pre><code>i = int(input('Enter an integer: '))\nj = int(input('Enter another integer: '))\nprint('The sum of the two integers is {}'.format(i + j))\n</code></pre> <p>Now look at what happens when we run it:</p> <pre><code>Enter an integer: *42*\nEnter another integer: *101*\nThe sum of the two integers is 143\n</code></pre> <p>This time it works, because of the calls to the <code>int</code> function which converts the string output from <code>input</code> to integers. Again, please play around with this in the interpreter so you understand exactly how it works.</p> <p>You can convert strings to more than just integers. You can also convert strings to floating-point numbers with the <code>float</code> function:</p> <pre><code>&gt;&gt;&gt; pi = float('3.1415926')\n&gt;&gt;&gt; pi\n3.1415926\n&gt;&gt;&gt; 4.0 * pi\n12.5663704\n</code></pre> <p>Exceptions</p> <p>You might wonder what happens if you try to convert a string to a float (or an integer) which is not the string representation of a valid float (or integer). For example:</p> <pre><code>&gt;&gt;&gt; pi = float('foobar')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: could not convert string to float: 'foobar'\n</code></pre> <p>In this case, Python handles the error by raising an exception and printing a traceback. We will talk a lot more about exceptions and traceback in future readings.</p> <p>OK, that's enough about <code>input</code>.  On to objects!</p>"},{"location":"5/reading5/#objects-and-methods","title":"Objects and methods","text":"<p>You've probably heard the term \"object-oriented\" as in \"Python (or Java, or C++) is an object-oriented programming language\". What does that mean?</p> <p>The exact meaning of \"object-oriented\" differs between languages, but for Python, it means that all data values are represented as objects. OK, great, so what is an object?</p> <p>An object is some kind of Python data along with some associated functions that act on the data. (You can think of the data and the functions as begin \"bound together\" to create an object.) The functions that act on the object are called methods to distinguish them from regular functions. Unlike a function, a method \"belongs\" to a particular object and has access to the object's internal components.<sup>1</sup></p> <p>Let's look at the syntax of method calls.</p>"},{"location":"5/reading5/#method-call-syntax-dot-syntax","title":"Method call syntax (\"dot syntax\")","text":"<p>We know that function calls have a very specific syntax: the name of the function, followed by a list of arguments in parentheses. Multiple arguments to a function are separated by commas. So function calls looks like this:</p> <pre><code>func1()        # no arguments\nfunc2(x)       # one argument\nfunc3(x, y, z) # three arguments\n</code></pre> <p>and so on. Method calls are almost exactly the same, except that instead of the name of the function, we have the name of the object, a dot (<code>.</code>) and the name of the method. Here are some hypothetical method calls on a hypothetical object called <code>obj</code>:</p> <pre><code>obj.method1()\nobj.method2(x)\nobj.method3(x, y, z)\n</code></pre> <p>Method calls are like function calls on an object. If you like, you can think of the object as an extra argument to the method that happens to be placed in a weird location (before the dot).</p> <p>I call the <code>obj.method</code> kind of syntax for method calls the \"dot syntax\". As we'll see in later readings, this syntax is used for more than just method calls, though the other uses are similar.</p>"},{"location":"5/reading5/#strings-are-objects","title":"Strings are objects","text":"<p>We've actually been working with Python objects already. Since all Python values are objects, even things like integers are objects (but we don't usually use methods on integers). Strings are also objects, and there are a number of useful methods defined for strings. For instance:</p> <pre><code>&gt;&gt;&gt; 'spam'.upper()\n'SPAM'\n&gt;&gt;&gt; s = 'spam'\n&gt;&gt;&gt; s.upper()\n'SPAM'\n</code></pre> <p>The <code>upper</code> method on strings converts a string to its uppercase version. (Note that it doesn't change the string, because strings are immutable; it simply creates a new string with the same characters but uppercased).</p> <p>Notice that you can call a method on a literal value (like <code>'spam'</code>) or on a variable that stands for that value (like <code>s</code>). Most of the time, we use methods on variables, but in this reading we'll often use methods on literal strings for convenience.</p> <p>Since methods are like functions, they have an argument list. In this case, the argument list is empty, so we have to put the open/close parentheses <code>()</code> after the name of the method. It's pretty common to have methods that take no arguments; what that means is that the method only needs the name of the object to do what it's doing. In this case, all the <code>upper</code> method needs to know about is the string object itself.</p> <p>You might think that it's dumb that you have to include an empty pair of open/close parentheses to call a method with no arguments. But if you leave them off, the method never gets called:</p> <pre><code>&gt;&gt;&gt; 'spam'.upper\n&lt;built-in method upper of str object at 0x109d3ee30&gt;\n</code></pre> <p>Python is basically saying here \"yup, that's a method all right\". If you want it to do something, you need the parentheses.<sup>2</sup></p> <p>Here are some other methods on strings:</p> <pre><code>&gt;&gt;&gt; 'SPAM'.lower()\n'spam'\n&gt;&gt;&gt; 'spam'.islower()\nTrue\n&gt;&gt;&gt; '   string with spaces on each end    '.strip()\n'string with spaces on each end'\n&gt;&gt;&gt; 'Caltech'.endswith('tech')\nTrue\n</code></pre> <p>Info</p> <p>Python uses the special names <code>True</code> and <code>False</code> to stand for boolean (true/false) values.</p> <p>Notice in particular the call to the <code>endswith</code> method. This is the first method call we've seen that has an argument in its argument list.</p> <p>A full list of Python's string methods can be found here. You're not expected to memorize them! Some of the more useful ones include:</p> <ul> <li><code>capitalize</code></li> <li><code>startswith</code> and <code>endswith</code></li> <li><code>find</code></li> <li><code>format</code> (we've seen this already)</li> <li><code>index</code></li> <li><code>join</code></li> <li><code>lower</code> and <code>upper</code></li> <li><code>strip</code></li> </ul> <p>Exercise</p> <p>Pick three methods from the above list and look up their definitions. Don't memorize them; just remember enough so that when you come across a situation where they might be useful, you'll know where to look.</p>"},{"location":"5/reading5/#methods-vs-functions","title":"Methods vs. functions","text":"<p>Let's take a closer look at the <code>endswith</code> method:</p> <pre><code>&gt;&gt;&gt; 'Caltech'.endswith('tech')\nTrue\n</code></pre> <p>You might wonder why this wasn't written as a regular function, e.g. something like this:</p> <pre><code>&gt;&gt;&gt; endswith('Caltech', 'tech') # Doesn't work!\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'endswith' is not defined\n</code></pre> <p>Python is telling you that there is no <code>endswith</code> function.</p> <p>In fact, <code>endswith</code> could have been written that way. Or you could define it that way if you really wanted to:</p> <pre><code>&gt;&gt;&gt; def endswith(s, suffix):\n...     return s.endswith(suffix)\n...\n&gt;&gt;&gt; endswith('Caltech', 'tech')\nTrue\n</code></pre> <p>There's no reason to do this, though. One benefit of using methods instead of functions is that you can use the same method name on different objects and have it mean different things for each object. Usually, though, it's better if the meaning is similar (even if it's not identical), because otherwise it's likely to be confusing. Not having to define new names for similar (but not identical) functionality means that code reads better and is more intuitive.</p>"},{"location":"5/reading5/#defining-methods","title":"Defining methods","text":"<p>We will not go into the syntax for defining methods at this time. In fact, it's almost identical to function definition syntax. For now, and for most of this course, we will use pre-written methods. Python's extensive code libraries (called modules) and many built-in data structures mean that there are a lot of pre-written methods we can use right away.</p>"},{"location":"5/reading5/#the-len-function","title":"The <code>len</code> function","text":"<p>As we mentioned above, there are many function-like things that can be written either as methods or as functions, at least in principle. Python is not always totally consistent in this regard.<sup>3</sup> Some things are written as functions, and others as methods, and sometimes you find the same functionality is provided by both a function and a method. Usually, though, a particular behavior is implemented as one or the other.</p> <p>As if this wasn't confusing enough, consider the very useful built-in <code>len</code> function. (Notice that I said function, not method.) <code>len</code> takes a single argument and returns its \"length\", whatever \"length\" means for that kind of data. We can use <code>len</code> on a lot of different kinds of Python objects. For instance, strings have a length:</p> <pre><code>&gt;&gt;&gt; len('foobar')\n6\n</code></pre> <p>For a string, its <code>len</code> is the number of characters in the string.</p> <p>On the other hand, integers and boolean values don't have a <code>len</code>:</p> <pre><code>&gt;&gt;&gt; len(1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: object of type 'int' has no len()\n&gt;&gt;&gt; len(True)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: object of type 'bool' has no len()\n</code></pre> <p>Lists (which are another data type that we'll meet shortly) also have a length:</p> <pre><code>&gt;&gt;&gt; len([1, 2, 3])\n3\n</code></pre> <p>(Here, <code>[1, 2, 3]</code> is Python's syntax for a list of three integers: <code>1</code>, <code>2</code>, and <code>3</code>.) So <code>len</code> works on both strings and lists, but it should be clear that finding the length of a string is a different kind of operation than finding the length of a list. You might think, therefore, that Python should have made <code>len</code> a method on strings and lists, not a function. Why didn't it?</p> <p>Well, actually, it did but it pretends that it didn't. When you say <code>len(x)</code> in Python, it internally calls a method called <code>__len__</code> on the object. Observe:</p> <pre><code>&gt;&gt;&gt; len('foobar')\n6\n&gt;&gt;&gt; 'foobar'.__len__()\n6\n&gt;&gt;&gt; len([1, 2, 3])\n3\n&gt;&gt;&gt; [1, 2, 3].__len__()\n3\n</code></pre> <p>The only reason <code>len</code> is a function is that it's used so often that the Python designer (Guido van Rossum) figured that it would be more pleasant to write it like a function than like a method. You can agree with this or not, but that's how it is.<sup>4</sup></p> <p>What's more interesting is that this is a good example of a method (<code>__len__</code>) which has the same name for two different kinds of objects (strings and lists) but which does different things in each case. Both things are conceptually \"lengths\" but the details are different. This is common with methods: each object can use the same method names as other objects, but the meaning of these methods is specific to the object.</p> <p>Special methods</p> <p>One last thing: the <code>__len__</code> method uses a naming convention that we'll see again. Names of methods that are used internally by Python for some important purpose are, by convention, written with two leading and two trailing underscores. There are a bunch of \"special methods\" like this that do a number of things, and we'll meet some more of them very soon. Be aware, though, that this is only a convention. You could write your own methods with names like this, and Python would still accept it. However, please don't do that! If you redefined a method like <code>__len__</code>, your program will probably fail, and it might be very hard for you to figure out why.</p> <ol> <li> <p>That is, assuming the object has any internals. Some very simple objects, like integers, don't have any internal components.\u00a0\u21a9</p> </li> <li> <p>Some object-oriented languages, like Ruby, don't require you to use parentheses for methods with no arguments. You can waste an incredible amount of time arguing over whether this is a good or a bad thing.\u00a0\u21a9</p> </li> <li> <p>Some languages, like Java or Ruby, try hard to be \"pure\" object-oriented languages. Python is more pragmatic; Python programmers use whatever seems best for the application at hand.\u00a0\u21a9</p> </li> <li> <p>Every programming language has some features in it that some people don't like. Most have features that almost everyone doesn't like. Python is very good, but it isn't perfect. Features in a programming languages that most programmers dislike are commonly referred to as warts. Compared to most languages, Python has very few warts.\u00a0\u21a9</p> </li> </ol>"},{"location":"6/reading6/","title":"Reading 6: Modules","text":"<p>It would appear that we have reached the limits of what it is possible to achieve with computer technology, although one should be careful with such statements, as they tend to sound pretty silly in 5 years. - John von Neumann</p>"},{"location":"6/reading6/#overview","title":"Overview","text":"<p>In this reading we'll introduce Python modules. A module is a term we use for a reusable chunk of Python code, which means code that is intended to be used in multiple programs.</p>"},{"location":"6/reading6/#topics","title":"Topics","text":"<ul> <li>Modules</li> <li>The <code>import</code> keyword</li> <li>Writing your own modules</li> <li>Some useful modules</li> </ul>"},{"location":"6/reading6/#modules","title":"Modules","text":"<p>Some programs are meant to be stand-alone i.e. the code in the program is intended to be used only for that program. But it's not uncommon to write Python functions (and, as we'll see later, Python classes) that are more generally useful and can be used in multiple programs. In order to make it easy to use the same code in multiple programs, programming languages have developed the idea of a \"module\". A module is like a code \"library\" that you can \"check out\" and use in any program that needs it. (Modules are often informally called \"libraries\".)</p> <p>Modules are important because the best code is code you don't have to write! If someone has already written the code that you need, tested it, debugged it, and put it into a module, it's usually better to use the module than rewrite the code yourself.</p>"},{"location":"6/reading6/#module-contents","title":"Module contents","text":"<p>A module can contain any kind of Python code whatsoever. Most of the time, though, a module will contain</p> <ul> <li>functions</li> <li>values (generally intended to be constants)</li> <li>classes</li> </ul> <p>We'll talk about classes later in the course. For now, we're mainly interested in modules that contain functions we might want to use.</p>"},{"location":"6/reading6/#using-modules","title":"Using modules","text":"<p>When you think of code that is likely to be re-used in multiple programs, one thing you might think of is common math functions, like square root, sine, cosine, etc. In this section, let's assume that we want to use these functions. If there is a module that contains these functions, we have to import the module, which means to load the module into the computer's memory so that we can use its functions. In Python, there is a predefined module called <code>math</code> which contains all the standard mathematical functions; that's the module we'll be importing.</p>"},{"location":"6/reading6/#the-import-keyword-and-qualified-names","title":"The <code>import</code> keyword and qualified names","text":"<p>The standard way to import a module is to use the <code>import</code> keyword:</p> <pre><code>import math\n</code></pre> <p>Once you've done this, you get access to all the functions in the <code>math</code> module. One of these is the square root function, called <code>sqrt</code> in Python. However, in order to use this function we have to include the name of the module in the function call:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(4)\n2.0\n&gt;&gt;&gt; math.sqrt(2)\n1.4142135623730951\n</code></pre> <p>The <code>sqrt</code> function always returns a floating-point (approximate real number) value, which is why <code>math.sqrt(4)</code> returns <code>2.0</code> and not <code>2</code>.<sup>1</sup></p> <p>One thing to be aware of is that if you use <code>import</code> this way, you have to put the name of the module before the name of the function, separated by a dot. (This is exactly the \"dot syntax\" already described for objects, but here instead of <code>&lt;object&gt;.&lt;method&gt;</code> it means <code>&lt;module&gt;.&lt;function&gt;</code>.) If you try to leave it out, you get an error:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; sqrt(2)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'sqrt' is not defined\n</code></pre> <p>What the error message is really telling you is that you need to write <code>math.sqrt</code>, not just <code>sqrt</code>.</p> <p>Note</p> <p>If you write <code>math.sqrt</code> but forget the <code>import</code> line it also fails:</p> <pre><code>&gt;&gt;&gt; math.sqrt(2)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'math' is not defined\n</code></pre> <p>The error message lets us know that Python doesn't recognize the name <code>math</code> until it's been imported.</p> <p>Names like <code>math.sqrt</code> are called qualified names; here, it means \"the <code>sqrt</code> function that is defined in the <code>math</code> module\". The reason Python's <code>import</code> statement works this way is that it's nice to have imported names \"compartmentalized\" inside their modules. This matters because other modules may define different <code>sqrt</code> functions. For instance, there is a module called <code>cmath</code> which provides math functions that work on complex numbers.</p> <p>Note</p> <p>A complex number is a kind of number that contains a real and an imaginary part. The real part is just a real number. The imaginary part is a real number multiplied by the square root of -1, which is usually called <code>i</code> or <code>j</code> (Python calls it <code>j</code>). Python allows you to write literal complex numbers:<sup>2</sup></p> <pre><code>&gt;&gt;&gt; c = 1.0+2.0j\n&gt;&gt;&gt; c * c\n(-3+4j)\n</code></pre> <p>We can <code>import</code> both modules at the same time and use both <code>sqrt</code> functions, because we have to qualify the names:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(-1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: math domain error\n&gt;&gt;&gt; import cmath\n&gt;&gt;&gt; cmath.sqrt(-1)\n1j\n</code></pre> <p>The <code>math.sqrt</code> function doesn't work on negative inputs (hence the error message) but the <code>cmath.sqrt</code> function works fine on negative inputs.</p> <p>We can even import both modules on the same line:</p> <pre><code>import math, cmath\n</code></pre> <p>More generally, you can import as many modules as you like on one line by separating them with commas. On the other hand, if you have a lot of modules to import, it's more readable to have each <code>import</code> on a separate line:</p> <pre><code>import math\nimport cmath\n</code></pre> <p>In fact, importing multiple modules on one line is considered poor Python style.<sup>3</sup></p>"},{"location":"6/reading6/#the-from-x-import-y-syntax","title":"The <code>from X import Y</code> syntax","text":"<p>Sometimes it's annoying to have to qualify names. Maybe you are going to be using the <code>sqrt</code> function over and over again, and having to write <code>math.sqrt</code> each time seems too verbose (and maybe also too hard to read). There is a way to import a function that doesn't require that the function's name be qualified: you use the <code>from X import Y</code> syntax.</p> <pre><code>&gt;&gt;&gt; from math import sqrt\n&gt;&gt;&gt; sqrt(2.0)\n1.4142135623730951\n</code></pre> <p>You can even import multiple names:</p> <pre><code>&gt;&gt;&gt; from math import sin, cos, pi\n&gt;&gt;&gt; sin(pi/2) + cos(pi/2)\n1.0\n</code></pre> <p>Or you can go nuts and import every name in a module:</p> <pre><code>&gt;&gt;&gt; from math import *\n&gt;&gt;&gt; sqrt(sin(pi/3))\n0.9306048591020996\n</code></pre> <p>The asterisk character (<code>*</code>) is called \"star\" in this context (it's not multiplication) and means \"everything\", so this will import every name in the module, which you can then use without having to write the module name as a qualifier (so <code>sqrt</code> and not <code>math.sqrt</code>).</p> <p>Beginning Python programmers love this form, because it's very convenient to use. However, most of the time it's also bad programming practice. The problem is that different modules will sometimes define the same name to mean different things:</p> <pre><code>&gt;&gt;&gt; from math import sin\n&gt;&gt;&gt; sin(1.0)\n0.8414709848078965\n&gt;&gt;&gt; from evil import sin\n&gt;&gt;&gt; sin('bear false witness')\n'The check is in the mail!'\n</code></pre> <p>(The second example is made-up, of course.) If we use the <code>from X import *</code> syntax routinely, we can get name clashes, where you import the same name multiple times. In this case, Python will only allow you to use the last name that was imported.</p> <pre><code>&gt;&gt;&gt; from math import *\n&gt;&gt;&gt; from evil import *\n</code></pre> <p>Now <code>sin</code> means <code>evil.sin</code>, and <code>math.sin</code> can't be used.</p> <p>Name clashes can lead to difficult-to-find bugs. Our advice is therefore:</p> <p>Tip</p> <p>Don't use the <code>from X import *</code> syntax unless there is a really good reason to.</p> <p>If you think you want to use this form, try using <code>from X import Y</code> i.e. specify exactly which name(s) you want to import. That's much less likely to cause problems, and if a name clash happens, it will probably be easier to spot.</p>"},{"location":"6/reading6/#the-import-x-as-y-syntax","title":"The <code>import X as Y</code> syntax","text":"<p>OK, so hopefully you're convinced that indiscriminate use of the <code>from X import *</code> syntax is a bad idea. Still, if a module has a long name it's really annoying to have to write it over and over as the first part of qualified names. Fortunately, Python provides another way to do this: you can rename a module when you import it using the <code>import X as Y</code> syntax. Most of the time, you rename a module to a much shorter name:</p> <pre><code>&gt;&gt;&gt; import math as m\n&gt;&gt;&gt; m.sqrt(2.0)\n1.4142135623730951\n</code></pre> <p>The benefit of this is that you're protected from name clashes as long as you choose module names that are different. The downside of this is that <code>m.sqrt</code> is perhaps less readable than either <code>math.sqrt</code> or <code>sqrt</code>. Nevertheless, we think that it's a good compromise.</p> <p>Note</p> <p>Many popular Python libraries, such as NumPy and Pandas (for multidimensional data analysis), and matplotlib (for plotting and visualization) are normally used with the <code>import X as Y</code> syntax:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"6/reading6/#modules-are-first-class","title":"Modules are first-class","text":"<p>It might surprise you to know that modules are actually also Python objects! The technical way of saying this is that modules are \"first-class\" objects, but all that means is that they are objects like any other object.<sup>4</sup> Because of this, you can store modules in variables, you can pass them as arguments to functions, etc.</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; m = math\n&gt;&gt;&gt; m.sqrt(2.0)\n1.4142135623730951\n</code></pre> <p>So the <code>import math as m</code> syntax is exactly equivalent to <code>import math</code> followed by <code>m = math</code>.</p>"},{"location":"6/reading6/#module-documentation-and-the-help-function","title":"Module documentation and the <code>help</code> function","text":"<p>Modules can contain a lot of different functions, values, etc. How do we learn about what's in a module?</p> <p>One way is to go to the Python web site and look in the library documentation. The place to go is https://docs.python.org/library. This is the preferred approach if the module is part of Python's standard libraries, which will be the case for most of the modules we'll use in this course.</p> <p>Another way is to use the <code>help</code> function built in to Python. The help function can take a module, a function, or a class as its argument and will print out the documentation associated with that thing.</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; help(math.sqrt)\nHelp on built-in function sqrt in module math:\n\nsqrt(x, /)\n    Return the square root of x.\n</code></pre> <p>Note</p> <p>Don't worry about the <code>/</code> in the <code>sqrt(x, /)</code> line. It means that the argument <code>x</code> is \"positional only\". This will mean more to you when we talk about \"keyword arguments\" in later readings.</p> <p>You can get documentation for entire modules, too:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; help(math)\nHelp on module math:\n\nNAME\n    math\n\nMODULE REFERENCE\n    https://docs.python.org/3.12/library/math.html\n...\n</code></pre> <p>(This goes on for many pages.)</p> <p>One thing that's interesting is that the <code>help</code> function is not \"magical\" in any way; it's just a regular Python function. The reason it can take a function or a module as its argument follows from the fact that functions and modules are themselves Python objects. On the other hand, if you wanted help on (say) the <code>def</code> keyword in Python, this won't work:</p> <pre><code>&gt;&gt;&gt; help(def)\n  File \"&lt;stdin&gt;\", line 1\n    help(def)\n         ^\nSyntaxError: invalid syntax\n</code></pre> <p>Since <code>def</code> is a keyword and not a Python object, this doesn't work. You have to go to the online documentation to learn everything about how <code>def</code> works.</p> <p>The <code>help</code> function only works if the function or module argument is known to Python:</p> <pre><code>&gt;&gt;&gt; help(math.sqrt)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'math' is not defined\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; help(math.sqrt)\nHelp on built-in function sqrt in module math:\n\nsqrt(x, /)\n    Return the square root of x.\n</code></pre> <p>You can also write documentation for your own functions so that the <code>help</code> function will work on them. We'll see how to do that in the next reading.</p> <p>Note</p> <p>The <code>help</code> function can also be called with no arguments:</p> <pre><code>&gt;&gt;&gt; help()\n... [long welcome message] ...\nhelp&gt;\n</code></pre> <p>When invoked this way, <code>help</code> puts you into an interpreted environment which runs on top of the interactive Python interpreter (as is suggested by the <code>help&gt;</code> prompt, which is distinct from the usual Python <code>&gt;&gt;&gt;</code> prompt). Inside this prompt, you can enter anything you want help on: a module, a function, a value, etc. This even works if you haven't loaded a module. Imagine you start the Python interpreter and don't import any modules. This still works:</p> <pre><code>&gt;&gt;&gt; help()\n... [long welcome message] ...\nhelp&gt; math.sqrt\nHelp on built-in function sqrt in math:\n\nmath.sqrt = sqrt(x, /)\n    Return the square root of x.\n</code></pre> <p>If you need help on multiple topics, calling <code>help</code> this way is often useful. To get out of the <code>help</code> system, type <code>quit</code> at the prompt.</p>"},{"location":"6/reading6/#writing-your-own-modules","title":"Writing your own modules","text":"<p>Writing a Python module is very easy. You just need to do two things:</p> <ol> <li>Write your code in a file.  (Make sure it's a plain text file.)</li> <li>Make sure that the name of the file ends in <code>.py</code>.</li> </ol> <p>Also, by convention, module names should be short and consist of all lowercase letters and (if necessary) underscores.<sup>5</sup></p> <p>Let's write a simple module called <code>greetings</code> which provides functions to print out greeting messages. The module's file will be named <code>greetings.py</code>. Here's our first attempt:</p> <pre><code># Module: greetings\n# Filename: greetings.py\n\ndef greet(name):\n    print('Hi there, {}!'.format(name))\n\ndef insult(name):\n    print('Get lost, {}!'.format(name))\n</code></pre> <p>Once this code is saved into the file <code>greetings.py</code>, you can import it like any other module.</p> <pre><code>&gt;&gt;&gt; import greetings\n&gt;&gt;&gt; greetings.greet('Adam')\nHi there, Adam!\n&gt;&gt;&gt; greetings.insult('Mike')\nGet lost, Mike!\n</code></pre> <p>Or, if you like, you can import it the other way:</p> <pre><code>&gt;&gt;&gt; from greetings import *\n&gt;&gt;&gt; greet('Adam')\nHi there, Adam!\n</code></pre> <p>Or even:</p> <pre><code>&gt;&gt;&gt; import greetings as g\n&gt;&gt;&gt; g.greet('Adam')\nHi there, Adam!\n</code></pre> <p>The point of all this is that writing normal Python code in a file is exactly the same as writing a Python module. So Python modules are incredibly easy to create and use.</p> <p>Note</p> <p>In the next reading, we will see how to add documentation to our modules so that the <code>help</code> function can print it out when requested.</p>"},{"location":"6/reading6/#some-useful-modules","title":"Some useful modules","text":"<p>There are lots of useful modules included with Python. Some commonly-used ones include:</p> <ul> <li><code>math</code>   (math functions)</li> <li><code>cmath</code>  (complex number math functions)</li> <li><code>string</code> (functions on strings)</li> <li><code>random</code> (random number functions)</li> <li><code>sys</code>    (system functions)</li> <li><code>os</code>     (operating system specific functions)</li> <li><code>re</code>     (regular expressions)</li> </ul> <p>There are many, many more useful modules besides these. Go to the Python module documentation for a full list. There are also many important and useful modules that aren't included with Python. Some of these include:</p> <ul> <li><code>numpy</code>   (numerical programming with multidimensional arrays)</li> <li><code>scipy</code>  (scientific functions)</li> <li><code>pandas</code> (data frames and data analysis)</li> <li><code>matplotlib</code>   (plotting and visualization tools)</li> </ul> <p>These modules are used extensively by data scientists and are one of the main reasons that Python is so popular.<sup>6</sup></p> <ol> <li> <p>In programming languages, the integer <code>2</code> and the floating-point number <code>2.0</code> are different, because the way they are represented internally is different.\u00a0\u21a9</p> </li> <li> <p>To be completely accurate, Python allows you to write literal imaginary numbers, which means a regular number with the suffix <code>j</code>. When you write <code>1.0+2.0j</code>, it's actually a Python addition expression: the real number <code>1.0</code> added to the imaginary number <code>2.0j</code>.\u00a0\u21a9</p> </li> <li> <p>According to PEP8, which is a set of standard coding style conventions for Python.\u00a0\u21a9</p> </li> <li> <p>Functions are also first-class Python objects, and you can pass functions as arguments to other functions. This turns out to be very powerful and leads to a style of programming called \"functional programming\". Functional programming is the topic of CS 4 and CS 115.\u00a0\u21a9</p> </li> <li> <p>This is also part of the PEP8 style guidelines. We will see PEP8 again.\u00a0\u21a9</p> </li> <li> <p>They are also very easy to install using the <code>pip</code> tool. For instance, to install <code>numpy</code> all you need to do is type <code>pip install numpy</code> at a terminal prompt.\u00a0\u21a9</p> </li> </ol>"},{"location":"7/reading7/","title":"Reading 7: Documenting your code","text":"<p>The protean nature of the computer is such that it can act like a machine or like a language to be shaped and exploited. - Alan Kay</p>"},{"location":"7/reading7/#overview","title":"Overview","text":"<p>Documenting your code means writing comments and explanations to make your code easier for other programmers to understand. Documentation doesn't affect the way your code runs, but it's still extremely important. Many beginning programmers comment sparsely or not at all, but when you write programs as part of a team (which is what most professional programmers do), good documentation is essential and can't be neglected. Remember: programs are not just written to make the computer understand what to do; they also must be able to communicate to other programmers what you intended. Those other programmers may be in charge of maintaining or extending your code, and you need to make sure that they understand the code they're working on.</p> <p>There are two ways to document code. The first way is using plain old comments. The second way uses Python docstrings, which is the preferred way to add documentation to your Python functions and modules.</p>"},{"location":"7/reading7/#topics","title":"Topics","text":"<ul> <li> <p>Commenting and comment style</p> </li> <li> <p>Docstrings</p> </li> </ul>"},{"location":"7/reading7/#comments","title":"Comments","text":""},{"location":"7/reading7/#syntax-and-style","title":"Syntax and style","text":"<p>We've already seen that in Python, comments begin with a pound sign (<code>#</code>)<sup>1</sup> and go to the end of the line.</p> <pre><code># This is a comment.\n# So is this.\n</code></pre> <p>When you write a comment, please include at least one space after the <code>#</code> character. This is good:</p> <pre><code># A nice comment.\n</code></pre> <p>and this is bad:</p> <pre><code>#A bad comment.\n</code></pre> <p>This last comment is perfectly legal in Python, but it's hard to read.</p> <p>Note</p> <p>There are a lot of \"style guidelines\" like this that will help you write more readable code. The definitive set of style guidelines for Python is \"PEP8\", which you can read here. However, PEP8 is a bit overwhelming for new programmers, so we'll try to point out the most important style guidelines as we come to them.<sup>2</sup> If you're ever confused about how to format your code, you can consult PEP8.</p> <p>You can put comments after a line of code on the same line:</p> <pre><code>a = 42  # this is a comment\n</code></pre> <p>This is OK as long as the line doesn't get too long. Lines shouldn't be longer than about 80 characters, because otherwise they are hard to read.<sup>3</sup> If a comment can't easily fit on the end of a line, put it on the line before the line being commented on, not after. So this is good:<sup>4</sup></p> <pre><code># Set the variable `a` to an interesting value.\na = 42\n</code></pre> <p>and this is bad:</p> <pre><code>a = 42\n# Set the variable `a` to an interesting value.\n</code></pre>"},{"location":"7/reading7/#multiline-comments","title":"Multiline comments?","text":"<p>Many computer languages (like Java and C++) also have special symbols for multiline comments (comments that span multiple lines), but Python does not. The closest Python comes to multiline comments are docstrings, which we discuss in the next section, but technically docstrings are not comments.</p> <p>If you do want a multiline comment, what you need to do is to make a bunch of single-line comments one after the other, like this:</p> <pre><code># This is what Python\n# considers to be a\n# \"multi-line\"\n# comment.\n</code></pre> <p>Most text editors with Python support have some way of selecting multiple lines and commenting them all out.</p>"},{"location":"7/reading7/#when-to-use-comments","title":"When to use comments","text":"<p>Comments are mainly used inside of functions to explain what some code does if its meaning isn't obvious. Don't use a comment to restate something obvious about the code. However, if you are doing something clever or tricky, or even something you think that someone reading the code might not understand, adding a comment is a good idea.</p> <p>Here's an example of bad and good comments stolen from PEP8. This is bad:</p> <pre><code>x = x + 1   # Increment x.\n</code></pre> <p>Here, you are restating something obvious about the code, so the comment is completely unnecessary.</p> <p>This is good:</p> <pre><code>x = x + 1   # Compensate for border.\n</code></pre> <p>Not knowing what the context of the program is, I don't know what \"Compensate for border\" might mean, but at least it isn't something that is obvious from the code.</p> <p>An example of tricky code that might deserve a comment is this:</p> <pre><code>n += n * (n % 2) * 4   # Multiply `n` by 5 only if `n` is odd.\n</code></pre> <p>Hopefully you won't be writing much code like this.</p> <p>Note that if you never comment your code, or if you comment poorly, we will take marks off of your assignments.</p>"},{"location":"7/reading7/#docstrings","title":"Docstrings","text":"<p>Traditionally, one of the most common places to put a comment is right before a function, so you can tell the reader what the function does:</p> <pre><code># Print out a hearty greeting.\ndef greet(name):\n    print('Hi there, {}!'.format(name))\n</code></pre> <p>The only problem with this kind of comment is that Python's <code>help</code> function can't use them. Once Python reads the comment, it discards it and it's gone. It would be great if there were a way to write a \"comment\" that would somehow be usable by Python's <code>help</code> function. And there is such a way! It's called a docstring, which is short for \"documentation string\".</p>"},{"location":"7/reading7/#docstring-syntax","title":"Docstring syntax","text":"<p>A docsting is just a regular Python string which happens to be the first thing inside:</p> <ul> <li>a function body</li> <li>a module</li> <li>a class (covered later in the course)</li> </ul> <p>When you execute a docstring, the docstring itself doesn't do anything. However, Python \"knows\" about docstrings, so when it sees a string in one of those places it stores it as part of the function (or module, or class). Then it can use it later, as we'll see.</p> <p>Docstrings are normally written as triple-quoted strings, because very often the information you want to write spans more than one string. Python does not require docstrings to be triple-quoted, but the PEP8 style guidelines do.</p>"},{"location":"7/reading7/#function-docstrings","title":"Function docstrings","text":"<p>Here's our previous example with a docstring instead of a comment:</p> <pre><code>def greet(name):\n    \"\"\"Print out a hearty greeting.\"\"\"\n    print('Hi there, {}!'.format(name))\n</code></pre> <p>Notice that even though this is a one-line docstring, we wrote it with triple quotes. That way, if we ever want to add more information and it needs to span more lines we don't have to change the quotes. We strongly recommend that you use triple-quoted strings for all docstrings. We also recommend that you use three double-quote characters (<code>\"\"\"</code>) not three single-quote characters (<code>'''</code>), since this is the PEP8 convention.</p> <p>Let's assume we wrote the <code>greet</code> function in a file called <code>greetings.py</code>. That makes it a Python module, so inside the Python interpreter, we can <code>import</code> it and run it:</p> <pre><code>&gt;&gt;&gt; import greetings\n&gt;&gt;&gt; greetings.greet('Mike')\nHi there, Mike!\n</code></pre> <p>as expected. Here's the good part: we can also get <code>help</code> on the function:</p> <pre><code>&gt;&gt;&gt; help(greetings.greet)\nHelp on function greet in module greetings:\n\ngreet(name)\n    Print out a hearty greeting.\n</code></pre> <p>Note</p> <p>Python actually uses what's called a \"pager\" to print out the help message. This allows you to read very long help messages a page at a time. Hit the space bar to advance to the next page if there is one, and type <code>q</code> to dismiss the help message.</p> <p>Notice that the help message for the <code>greet</code> function is exactly the docstring that you wrote. Whatever you write in the docstring immediately becomes available to the <code>help</code> function.</p>"},{"location":"7/reading7/#module-docstrings","title":"Module docstrings","text":"<p>Let's look at the entire module (in the file <code>greetings.py</code>), with docstrings for each function:</p> <pre><code># Module: greetings\n# Filename: greetings.py\n\n\ndef greet(name):\n    \"\"\"Print out a hearty greeting.\"\"\"\n    print('Hi there, {}!'.format(name))\n\n\ndef insult(name):\n    \"\"\"Print out a nasty insult.\"\"\"\n    print('Get lost, {}!'.format(name))\n</code></pre> <p>It looks good, but the comments at the beginning of the module seem out of place. In addition, they are completely unnecessary, so we'll start by fixing that:</p> <pre><code># This module contains functions to print out various kinds of\n# greeting messages.\n\n\ndef greet(name):\n    \"\"\"Print out a hearty greeting.\"\"\"\n    print('Hi there, {}!'.format(name))\n\n\ndef insult(name):\n    \"\"\"Print out a nasty insult.\"\"\"\n    print('Get lost, {}!'.format(name))\n</code></pre> <p>That's a better comment, but the <code>help</code> function can't use it. So now we'll turn the comment into a module docstring:</p> <pre><code>\"\"\"\nThis module contains functions to print out various kinds of\ngreeting messages.\n\"\"\"\n\n\ndef greet(name):\n    \"\"\"Print out a hearty greeting.\"\"\"\n    print('Hi there, {}!'.format(name))\n\n\ndef insult(name):\n    \"\"\"Print out a nasty insult.\"\"\"\n    print('Get lost, {}!'.format(name))\n</code></pre> <p>Now it's looking professional. Let's fire up the interpreter:</p> <pre><code>&gt;&gt;&gt; import greetings\n&gt;&gt;&gt; help(greetings)\nHelp on module greetings:\n\nNAME\n    greetings\n\nDESCRIPTION\n    This module contains functions to print out various kinds of\n    greeting messages.\n\nFUNCTIONS\n    greet(name)\n        Print out a hearty greeting.\n\n    insult(name)\n        Print out a nasty insult.\n\nFILE\n    /home/mvanier/cs1/greetings.py\n</code></pre> <p>This gives us all the information about the module we might want (assuming we've written good docstrings).</p>"},{"location":"7/reading7/#what-to-put-in-docstrings","title":"What to put in docstrings","text":"<p>OK, that's the \"how\" of docstrings. More interesting is the \"what\" of docstrings i.e. \"what should I write in a docstring?\"</p> <p>The first rule is write docstrings for every function and every module you create. Don't skip writing a docstring because you think the function is obvious; that may be true, but docstrings can also be used to generate external documentation for a module (like a web page), and in that case, you want somebody reading the documentation to know about all the functions in the module.<sup>5</sup></p> <p>Docstrings are good documentation</p> <ul> <li>for you</li> <li>for you in the future (when you've forgotten what your code does)</li> <li>for anyone else reading or using your code</li> </ul> <p>The most important thing that needs to be in docstrings is information that will let people understand how to correctly use the code.</p> <p>In a function docstring, you should describe:</p> <ul> <li>what the function does (not how it does it)</li> <li>what the function arguments mean (ideally one line per argument)</li> <li>what the function returns</li> <li>any other effect that the function has when run (e.g. printing to the terminal, writing to a file, etc.)</li> </ul> <p>What you shouldn't put in the docstring is a description of how the function works. That should go inside the function body in comments, and may be omitted entirely if the code is simple or \"obvious\". I generally want to write comments in a function when the code is tricky or is doing something unintuitive. Of course, that's a judgment call.</p> <p>Warning</p> <p>Another thing you should never do is copy the problem description verbatim into a docstring. This is sometimes done by students who are told to write docstrings but are too lazy or rushed to write a real one. If you do this, expect to get no credit for the docstring.</p> <p>If we use these guidelines ultra-strictly, our docstrings for our functions might look like this:</p> <pre><code>\"\"\"\nThis module contains functions to print out various kinds of\ngreeting messages.\n\"\"\"\n\n\ndef greet(name):\n    \"\"\"Print out a hearty greeting.\n\n    Arguments:\n      name : the name to print with the greeting\n\n    Return value: none\n\n    Side effects: the greeting gets printed to the terminal.\n    \"\"\"\n    print('Hi there, {}!'.format(name))\n\n\ndef insult(name):\n    \"\"\"Print out a nasty insult.\n\n    Arguments:\n      name : the name to print with the insult\n\n    Return value: none\n\n    Side effects: the insult gets printed to the terminal.\n    \"\"\"\n    print('Get lost, {}!'.format(name))\n</code></pre> <p>However, not every function needs this level of detail. Very simple functions (like these) can get by with simpler docstrings, as long as they explain what the function does.</p> <p>Note</p> <p>In fact, for functions this simple, docstrings that are this detailed are overkill. It's possible to get obsessive about documentation; try to resist this tendency. Too much documentation is better than too little, but try to find the right level of detail.</p> <p>In a module docstring, you should describe:</p> <ul> <li>the purpose of the module</li> <li>a general description of the kinds of functions in the module</li> </ul> <p>What you shouldn't put in the docstring is a detailed description of any of the functions. That should go into the function docstrings, and there is no need to repeat that information.</p>"},{"location":"7/reading7/#the-__main__-module","title":"The <code>__main__</code> module","text":"<p>Let's try a dumb experiment: writing a function with a docstring in the Python interpreter. (It's dumb because functions written directly in the interpreter are throwaway functions because they disappear when you quit the interpreter.)</p> <pre><code>&gt;&gt;&gt; def double(x):\n...     \"\"\"This function returns twice the value of the argument `x`.\"\"\"\n...     return 2 * x\n</code></pre> <p>Now let's get some <code>help</code> on it:</p> <pre><code>&gt;&gt;&gt; help(double)\nHelp on function double in module __main__:\n\ndouble(x)\n    This function returns twice the value of the argument `x`.\n</code></pre> <p>What does this <code>module __main__</code> thing referred to mean?</p> <p><code>module __main__</code> is the name that Python gives to a module which is either</p> <ul> <li>the interactive interpreter</li> <li>the module that was directly invoked by Python   (if you're running Python on a file)</li> </ul> <p>All other modules are referred to by their own names.</p> <p>Here, <code>module __main__</code> refers to the interactive interpreter. But if we ran Python on a file of code, it would refer to the file's module. Consider a file <code>test.py</code> containing this code:</p> <pre><code>\"\"\"\nTest module.\n\"\"\"\n\n\ndef double(x):\n    \"\"\"This function returns twice the value of the argument `x`.\"\"\"\n    return 2 * x\n\n\nhelp(double)\n</code></pre> <p>When you run this from the terminal, you get this output:</p> <pre><code>$ python test.py\nHelp on function double in module __main__:\n\ndouble(x)\n    This function returns twice the value of the argument `x`.\n</code></pre> <p>Notice that it says <code>module __main__</code>, not <code>module test</code>.</p>"},{"location":"7/reading7/#the-__name__-special-variable","title":"The <code>__name__</code> special variable","text":"<p>Python stores the name of the currently-executing module in a special variable called <code>__name__</code>. Let's change the file <code>test.py</code> just a bit:</p> <pre><code>\"\"\"\nTest module.\n\"\"\"\n\n\ndef double(x):\n    \"\"\"This function returns twice the value of the argument `x`.\"\"\"\n    return 2 * x\n\n\nprint('My name is: {}'.format(__name__))\n</code></pre> <p>Let's run it as a standalone file from the terminal:</p> <pre><code>$ python test.py\nMy name is: __main__\n</code></pre> <p>Now let's <code>import</code> it from the interactive interpreter:</p> <pre><code>&gt;&gt;&gt; import test\nMy name is: test\n</code></pre> <p>We'll see a good use for the <code>__name__</code> variable in a future reading.</p> <p>Note</p> <p>We haven't mentioned this before, but Python can run arbitrary code when you import a module. Most of the time, the only code in a module are function definitions (or maybe class or variable definitions) which don't produce any output when run. But if there is e.g. a <code>print</code> statement in the module at the top level, it gets run when the module is imported and you will see the result. (But if you try to import it a second time, Python doesn't reload it and you don't see the result. Importing is not the same as reloading.<sup>6</sup>)</p>"},{"location":"7/reading7/#improving-our-docstrings","title":"Improving our docstrings","text":"<p>The docstrings we've written above are pretty uninspiring. We should take our own advice! So let's improve the <code>test.py</code> file by writing better docstrings.</p> <pre><code>\"\"\"\nThis module is a test of Python's docstring functionality.\n\"\"\"\n\n\ndef double(x):\n    \"\"\"\n    This function returns twice the value of the argument `x`.\n\n    Arguments:\n      x : an integer\n    Return value: an integer\n    \"\"\"\n    return 2 * x\n</code></pre> <p>Here, we've split up the function docstring into multiple lines and given a general statement about what the function does, followed by a description of the argument and the return value.</p> <p>We aren't going to insist on this format for every single function you write, but it's definitely appropriate for longer functions (say, more than ten lines).</p> <ol> <li> <p><code>#</code> is also sometimes called a \"hash sign\".\u00a0\u21a9</p> </li> <li> <p>The \"PEP\" in \"PEP8\" means \"Python Enhancement Proposal\" and is mainly used for proposing and discussing possible improvements to the language.\u00a0\u21a9</p> </li> <li> <p>PEP8 says they should be no more than 79 characters.\u00a0\u21a9</p> </li> <li> <p>When referring to a Python variable name in a comment, we surround it with backticks, so we write <code>`a`</code> and not just <code>a</code>. You don't have to do this, but it helps to make it clear that this is a Python name and not a regular word. This convention comes from Markdown, which is a syntax used for writing documents that get converted into web pages.\u00a0\u21a9</p> </li> <li> <p>The only exception might be for a function which is never intended to be used outside of the module. But for this course, write docstrings for all functions.\u00a0\u21a9</p> </li> <li> <p>There is a way to reload a module, but you don't need to know about it yet, or probably ever.\u00a0\u21a9</p> </li> </ol>"},{"location":"8/reading8/","title":"Reading 8: Lists","text":"<p>Once you have a computer that can do a few things - strictly speaking, one that has a certain 'sufficient set' of basic procedures - it can do basically anything any other computer can do. This, loosely, is the basis of the great principle of 'Universality'. - Richard Feynman</p>"},{"location":"8/reading8/#overview","title":"Overview","text":"<p>In this reading, we're going to talk about Python's lists. As is typical for programming jargon, the word \"list\" means something very different in programming than it does in everyday life. In everyday life, a \"list\" is something we use to write down an ordered sequence of entries. (For instance, on a \"to-do list\" we might write down all the things we have to do this week.) So you might write down this to-do list:</p> <ol> <li>Work on CS 1 homework.</li> <li>Work on Math homework.</li> <li>Work on Phys homework.</li> <li>Work on Chem homework.</li> <li>Binge watch Netflix for 10 hours.</li> </ol> <p>In a programming language, a list is a kind of data object that can store a group of other data objects in a sequence. The data objects that are stored inside the list are called the elements of the list, or alternatively the list items. Here's an example of a Python list:</p> <pre><code>courses = ['CS 1', 'Ma 1', 'Ph 1', 'Chem 1']\n</code></pre> <p>The list is the collection of items inside the square brackets, separated by commas.</p> <p>The items in the list can be retrieved if you know their position in the list, and you can change the item at a particular position. You can also make a list bigger by adding more items to the end.</p> <p>Many programming languages restrict lists so that any particular list can only hold one kind of data object (for instance, a \"list of integers\"). Python is more flexible: you can have a list containing many different kinds of data (including other lists). Nevertheless, most of the time, Python lists only contain a single kind of data.</p> <p>Often we will be using a list as a single Python object. Python objects that contain other Python objects, like lists, are referred to as data structures. There are a number of other data structures that we'll meet soon, including tuples, dictionaries, and sets. One nice thing about Python is that working with these data structures is much more convenient than in many other languages, which makes programming easier.</p>"},{"location":"8/reading8/#a-simple-example","title":"A simple example","text":"<p>It's very common when programming to have many related values that you'd like to store in a single object. For instance, you might be doing weather research and need to store the average temperature for each day of the week. You could define variables for each day...</p> <pre><code>temp_sunday    = 59.6\ntemp_monday    = 72.4\ntemp_tuesday   = 68.5\ntemp_wednesday = 79.0\ntemp_thursday  = 66.4\ntemp_friday    = 77.1\ntemp_saturday  = -126.0  # Whoa, what happened here?\n</code></pre> <p>...but this would quickly become tedious. Even something as simple as finding the average temperature for these days would be difficult:</p> <pre><code>avg_temp = (temp_sunday + temp_monday + temp_tuesday + temp_wednesday + \\\n            temp_thursday + temp_friday + temp_saturday) / 7\n</code></pre> <p>A better way would be to collect all the temperatures in a single data structure (a list):</p> <pre><code>temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n</code></pre> <p>Now, finding the average is easy:</p> <pre><code>avg_temp = sum(temps) / 7\n</code></pre> <p>(We cheated a bit by using the built-in <code>sum</code> function. Once we learn about loops we'll be able to write <code>sum</code> ourselves.)</p> <p>The point of lists is to make it as easy to work with groups of values as it is to work with single values. Lists are used everywhere in Python code, and there are lots of predefined functions and methods for working with them, some of which we'll learn about below.<sup>1</sup></p>"},{"location":"8/reading8/#creating-lists","title":"Creating lists","text":"<p>A literal list is a list that you write directly by giving the values of all the elements. The <code>temps</code> list we defined above is an example of a literal list. A literal list is surrounded by square brackets, and the list elements are separated by commas.</p> <p>You don't have to have literal values in a list, however. You can make a list of any kind of Python expressions, which will be evaluated when the list is created. Examples:</p> <pre><code>temp_sunday    = 59.6\ntemp_monday    = 72.4\ntemp_tuesday   = 68.5\ntemp_wednesday = 79.0\ntemp_thursday  = 66.4\ntemp_friday    = 77.1\ntemp_saturday  = -126.0\n\n# Make a list from variables.\ntemps = [temp_sunday, temp_monday, temp_tuesday, temp_wednesday, \\\n         temp_thursday, temp_friday, temp_saturday]\n\n# Make a list of powers of a number.\nx = 42.8\nx_list = [x, x * x, x * x * x, x * x * x * x, x ** 5]\n\n# Make a list of trigonometric functions applied to pi.\nfrom math import sin, cos, tan, pi\nvals = [sin(pi), cos(pi), tan(pi)]\n\n# Make a list from other lists.\nlol = [[1, 2], [3, 4], [5, 6]]\nnested_lists = [[1], [[2, 3], [[4, 5, 6], [7, 8, 9, 10]]]]\n\n# Make a list with different types of data.\nhlist = [1, 2.5, True, 'foobar', [3, 4, 5]]\n</code></pre> <p>There are other ways to create lists, which we'll see below.</p>"},{"location":"8/reading8/#empty-list","title":"Empty list","text":"<p>An empty list is written as open/close square brackets:</p> <pre><code>empty = []\n</code></pre> <p>We'll see uses for this shortly.</p>"},{"location":"8/reading8/#accessing-list-elements","title":"Accessing list elements","text":"<p>Once you've created a list, you need to be able to extract (access) the elements of the list. Python also uses square brackets with a particular syntax to get the list elements:</p> <pre><code>temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\nt0 = temps[0]   # 59.6\n</code></pre> <p>The syntax to access a list element is:</p> <ul> <li>the name of the list (here, <code>temps</code>)</li> <li>the location (or index) of the element,   as an integer in square brackets (here, <code>[0]</code>)</li> </ul> <p>One peculiarity of list indexing is that the first element is \"element 0\". In computer programming, unlike in math, we almost always start counting from 0, not 1.<sup>2</sup></p> <p>The index doesn't have to be a literal integer; it can also be a Python expression which evaluates to an integer.</p> <pre><code>temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\nt3 = temps[3]  # 79.0\nt3a = temps[2 + 1]  # same\nt3b = temps[2 ** 8 - 253]  # same\n</code></pre> <p>In this case, Python evaluates the index expression to an integer before doing the list access.</p>"},{"location":"8/reading8/#index-errors","title":"Index errors","text":"<p>If a list index is too large, Python signals an error:</p> <pre><code>&gt;&gt;&gt; temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; temps[6]\n-126.0\n&gt;&gt;&gt; temps[7]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: list index out of range\n</code></pre> <p>Note</p> <p>Most errors in Python give rise to exceptions. We will discuss exceptions and exception handling in detail later in the course. When an error situation arises which leads to an exception, we say that Python \"raises an exception\". We'll use that terminology from now on. The <code>IndexError</code> in the error message is an example of a Python exception that is raised when you try to access a value off the end of a list. The <code>Traceback</code> stuff is also related to exception handling; for now, you can ignore it.</p> <p>Note, though, that not all exceptions represent errors. We'll see examples of this in later readings too. And, of course, not all errors end up raising exceptions.<sup>3</sup></p>"},{"location":"8/reading8/#negative-indices","title":"Negative indices","text":"<p>Python has a neat feature not found in most programming languages: you can use negative numbers as list indices. If you do, Python will access elements starting from the end of the list. So an index of <code>-1</code> means the last element of the list, an index of <code>-2</code> means the second-last, etc.</p> <pre><code>temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\ntlast = temps[-1]   # -126.0\nt2last = temps[-2]  # 77.1\n</code></pre> <p>Note, though, that you can't go too far back, or Python raises an <code>IndexError</code> exception:</p> <pre><code>&gt;&gt;&gt; temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; temps[0]\n59.6\n&gt;&gt;&gt; temps[-7]\n59.6\n&gt;&gt;&gt; temps[-8]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: list index out of range\n</code></pre> <p>Python will not \"wrap around\" negative list indices if they go past the first element.</p>"},{"location":"8/reading8/#modifying-list-elements","title":"Modifying list elements","text":"<p>When we talked about strings, we pointed out that in Python strings are immutable: you can't change the characters inside a string once it's been created. In contrast, lists are always mutable: you can change (modify) a list element at any time. To modify a list element, just put the list element on the left-hand side of an assignment:</p> <pre><code>&gt;&gt;&gt; temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; temps[0]\n59.6\n&gt;&gt;&gt; temps[0] = 75.0\n&gt;&gt;&gt; temps[0]\n75.0\n</code></pre> <p>You can even change a list element to an element of a different type:</p> <pre><code>&gt;&gt;&gt; temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; temps[6] = 'really cold'\n&gt;&gt;&gt; temps\n[59.6, 72.4, 68.5, 79.0, 66.4, 77.1, 'really cold']\n</code></pre> <p>This is very rarely a good idea. When it happens, it's usually because of a bug in your code.</p>"},{"location":"8/reading8/#list-operators-and","title":"List operators: <code>+</code> and <code>*</code>","text":"<p>Much like strings, lists have operators that you can use on them. Many of these operators behave like their string counterparts. For instance, you can concatenate lists using the <code>+</code> operator:</p> <pre><code>&gt;&gt;&gt; temps1 = [59.6, 72.4, 68.5]\n&gt;&gt;&gt; temps2 = [79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; temps = temps1 + temps2\n&gt;&gt;&gt; temps\n[59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; temps + []\n[59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n&gt;&gt;&gt; [] + temps\n[59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\n</code></pre> <p>You can use the <code>*</code> operator with an integer on either side to create multiples of a list, all concatenated together:</p> <pre><code>&gt;&gt;&gt; [0] * 10\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n&gt;&gt;&gt; 5 * [42]\n[42, 42, 42, 42, 42]\n&gt;&gt;&gt; 0 * [100]\n[]\n&gt;&gt;&gt; 100 * []\n[]\n&gt;&gt;&gt; [1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n</code></pre> <p>Notice that both the <code>+</code> and <code>*</code> operators do the same kind of thing for both strings and lists. That's because strings and lists are both Python sequences, and Python tries hard to make sequences behave in similar ways as much as possible.</p> <p>There is another important list operator called <code>in</code> that we will meet in a later reading.</p>"},{"location":"8/reading8/#list-functions","title":"List functions","text":""},{"location":"8/reading8/#len","title":"<code>len</code>","text":"<p>The <code>len</code> function applied to a list argument returns the length of the list:</p> <pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; len(lst)\n5\n&gt;&gt;&gt; len([])\n0\n</code></pre>"},{"location":"8/reading8/#list","title":"<code>list</code>","text":"<p>The <code>list</code> function converts other kinds of sequences to lists. The only other sequence type we know about is strings; let's see what <code>list</code> does to a string:</p> <pre><code>&gt;&gt;&gt; s = 'Monty Python'\n&gt;&gt;&gt; list(s)\n['M', 'o', 'n', 't', 'y', ' ', 'P', 'y', 't', 'h', 'o', 'n']\n</code></pre> <p>This is the easiest way to split a string into letters. It's also useful for something else: a string is immutable but a list is mutable. So if you really want to change a letter in a string, you can convert it to a list, change the list, and then convert the list back to a string using the <code>join</code> method on strings.<sup>4</sup> That might look like this:</p> <pre><code>&gt;&gt;&gt; s = 'Monty Python'\n&gt;&gt;&gt; lst = list(s)\n['M', 'o', 'n', 't', 'y', ' ', 'P', 'y', 't', 'h', 'o', 'n']\n&gt;&gt;&gt; lst[6] = 'B'\n&gt;&gt;&gt; lst\n['M', 'o', 'n', 't', 'y', ' ', 'B', 'y', 't', 'h', 'o', 'n']\n&gt;&gt;&gt; ''.join(lst)  # trust us, this works\n'Monty Bython'\n</code></pre>"},{"location":"8/reading8/#list-methods","title":"List methods","text":"<p>Lists are Python objects, so they can have methods like any other object. There are a lot of list methods; some of the most useful ones are briefly described here. (We won't describe every aspect of these methods; see the official Python documentation for that.)</p>"},{"location":"8/reading8/#append","title":"<code>append</code>","text":"<p>To add an element to the end of a list, use the <code>append</code> method:</p> <pre><code>&gt;&gt;&gt; lst = []\n&gt;&gt;&gt; lst.append(1)\n&gt;&gt;&gt; lst\n[1]\n&gt;&gt;&gt; lst.append(2)\n&gt;&gt;&gt; lst\n[1, 2]\n&gt;&gt;&gt; lst.append(3)\n&gt;&gt;&gt; lst\n[1, 2, 3]\n</code></pre> <p>This is probably the most-used list method. It's very common to use it the way we've used it above: start with an empty list and add elements to it until you end up with the desired list. Notice that the <code>append</code> method doesn't return anything; it just changes the list.</p>"},{"location":"8/reading8/#pop","title":"<code>pop</code>","text":"<p>To remove elements from the end of a list, use the <code>pop</code> method:</p> <pre><code>&gt;&gt;&gt; lst = [1, 2, 3]\n&gt;&gt;&gt; lst.pop()\n3\n&gt;&gt;&gt; lst\n[1, 2]\n</code></pre> <p>The <code>pop</code> method is unusual in that it returns a value (the element \"popped\" off the end of the list) and also changes the list itself (by removing the last element).<sup>5</sup></p>"},{"location":"8/reading8/#index","title":"<code>index</code>","text":"<p>To find an element's location (also called its index) in a list, use the <code>index</code> method:</p> <pre><code>&gt;&gt;&gt; s = 'Monty Python'\n&gt;&gt;&gt; lst = list(s)\n&gt;&gt;&gt; lst\n['M', 'o', 'n', 't', 'y', ' ', 'P', 'y', 't', 'h', 'o', 'n']\n&gt;&gt;&gt; lst.index('y')\n4\n&gt;&gt;&gt; lst.index('z')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: 'z' is not in list\n</code></pre> <p>The first call to <code>lst.index</code> returns 4 because the first <code>'y'</code> character is at index 4 (recall that the first element <code>'M'</code> is at index 0). If there are more than one of a particular element in the list, <code>index</code> returns the index of the first one, which is why it returns 4, not 7. Since there are no <code>'z'</code> characters in the list <code>lst</code>, <code>lst.index('z')</code> raises an exception.</p> <p>Note</p> <p>A <code>ValueError</code> exception is usually raised when a function gets an argument that is of the correct type but isn't valid for some other reason.</p>"},{"location":"8/reading8/#remove","title":"<code>remove</code>","text":"<p>To remove a value from a list, use the <code>remove</code> method. It only removes the first occurrence of the value from the list. It doesn't return anything, but changes the list in place. If the value doesn't exist in the list, a <code>ValueError</code> exception is raised.</p> <pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 1, 2, 3]\n&gt;&gt;&gt; lst.remove(2)\n&gt;&gt;&gt; lst\n[1, 3, 1, 2, 3]\n&gt;&gt;&gt; lst.remove(2)\n&gt;&gt;&gt; lst\n[1, 3, 1, 3]\n&gt;&gt;&gt; lst.remove(2)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: list.remove(x): x not in list\n</code></pre>"},{"location":"8/reading8/#count","title":"<code>count</code>","text":"<p>The <code>count</code> method returns the number of times a value is found in a list. The list is not altered.</p> <pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 2, 4, 1, 5, 2, 1]\n&gt;&gt;&gt; lst.count(1)\n3\n&gt;&gt;&gt; lst.count(2)\n3\n&gt;&gt;&gt; lst.count(5)\n1\n&gt;&gt;&gt; lst.count(100)\n0\n</code></pre>"},{"location":"8/reading8/#sort-and-reverse","title":"<code>sort</code> and <code>reverse</code>","text":"<p>These two methods change the list in place; they don't return anything. The <code>sort</code> method sorts the list into ascending order.<sup>6</sup> The <code>reverse</code> method reverses the list.</p> <pre><code>&gt;&gt;&gt; lst = [5, 1, 4, 2, 6, 3, 5, 1, 2]\n&gt;&gt;&gt; lst.sort()\n&gt;&gt;&gt; lst\n[1, 1, 2, 2, 3, 4, 5, 5, 6]\n&gt;&gt;&gt; lst.reverse()\n&gt;&gt;&gt; lst\n[6, 5, 5, 4, 3, 2, 2, 1, 1]\n</code></pre>"},{"location":"8/reading8/#pitfall-aliasing","title":"Pitfall: aliasing","text":"<p>When you assign a variable containing a list to another variable, it looks like you might be copying it. In fact, you aren't \u2014 all you're doing is giving another name to the same list. This can be a shock if you aren't expecting it!</p> <pre><code>&gt;&gt;&gt; nums = [4, 6, 1503, 2, -3]\n&gt;&gt;&gt; nums2 = nums  # copy of nums?\n&gt;&gt;&gt; nums2[0] = 0\n&gt;&gt;&gt; nums2\n[0, 6, 1503, 2, -3]\n&gt;&gt;&gt; nums\n[0, 6, 1503, 2, -3]   # !!!\n</code></pre> <p>When we assign the list <code>nums</code> to <code>nums2</code>, we are not making a copy of <code>nums</code>. We are just giving another name to the same list. So when we change a value in the list using one of the names, the other variable sees the change. This kind of phenomenon is called aliasing and it's a real pain! The best way to avoid it is to make sure you understand what Python assignment really means, and copy a list if you really need two independent lists.</p> <p>We will show you how to copy lists in a few readings.<sup>7</sup></p> <p>Note</p> <p>One reason this may confuse you is that you might think that a Python variable is a \"location in memory\" where you can copy a value. In fact, this isn't true at all! (In some languages, like C, it is true, but not in Python.) In Python, assigning a value to a variable doesn't copy anything; it just creates a name which refers to the value. If you understand this, aliasing will be much less of a problem for you.</p> <p>To avoid confusion in the future, we won't say that a variable \"contains\" a value; instead we'll say that a variable \"is bound to\" a value or \"refers to\" a value.</p>"},{"location":"8/reading8/#nested-lists","title":"Nested lists","text":"<p>You can have lists within lists; these are called \"nested lists\". To get values from one of the inner lists, you have to double-up on the square bracket syntax.</p> <pre><code>&gt;&gt;&gt; lst = [[1, 2], [3, 4]]\n&gt;&gt;&gt; lst[0][0]\n1\n&gt;&gt;&gt; lst[0][1]\n2\n&gt;&gt;&gt; lst[1][0]\n3\n&gt;&gt;&gt; lst[1][1]\n4\n</code></pre> <p>When you read syntax like <code>lst[0][0]</code>, read it like this: <code>(lst[0])[0]</code>. In other words, the <code>lst[0]</code> picks out the sublist <code>[1, 2]</code>, and the final <code>[0]</code> picks out the number <code>1</code> from the sublist.</p> <p>You can use the same syntax on the left-hand side of an assignment statement to change a value in an inner list.</p> <pre><code>&gt;&gt;&gt; lst[0][0] = 100\n&gt;&gt;&gt; lst\n[[100, 2], [3, 4]]\n</code></pre>"},{"location":"8/reading8/#list-puzzles","title":"List puzzles","text":"<p>Because of aliasing, strange things can happen with nested lists. Can you explain why the following code entered into the Python interpreter behaves the way it does? (Feel free to ask a TA or the instructors if you're not sure.)</p> <pre><code>&gt;&gt;&gt; lst1 = [1, 2, 3]\n&gt;&gt;&gt; lst2 = [lst1, lst1]\n&gt;&gt;&gt; lst2\n[[1, 2, 3], [1, 2, 3]]\n&gt;&gt;&gt; lst1[0] = 42\n&gt;&gt;&gt; lst1\n[42, 2, 3]\n</code></pre> <p>Nothing odd so far.  Let's continue the same interpreter session.</p> <pre><code>&gt;&gt;&gt; lst2\n[[42, 2, 3], [42, 2, 3]]  # ?!?\n&gt;&gt;&gt; lst2[0][0] = 1\n&gt;&gt;&gt; lst2\n[[1, 2, 3], [1, 2, 3]]    # ?!?\n&gt;&gt;&gt; lst1\n[1, 2, 3]                 # ?!?\n</code></pre> <p>Here's another puzzle.</p> <pre><code>&gt;&gt;&gt; lst1 = [1, 2, 3]\n&gt;&gt;&gt; lst2 = lst1 * 3\n&gt;&gt;&gt; lst2\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n&gt;&gt;&gt; lst3 = [lst1] * 3\n&gt;&gt;&gt; lst3\n[[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n&gt;&gt;&gt; lst1[0] = 42\n&gt;&gt;&gt; lst1\n[42, 2, 3]\n&gt;&gt;&gt; lst2\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n&gt;&gt;&gt; lst3\n[[42, 2, 3], [42, 2, 3], [42, 2, 3]]\n</code></pre> <p>Why do all the <code>1</code>s in <code>lst3</code> change to <code>42</code> but the <code>1</code>s in <code>lst2</code> don't?</p> <ol> <li> <p>If you've programmed in other languages, be aware that what Python calls a \"list\" is pretty much the same as what other languages call an \"array\". The main difference is that Python lists can easily be expanded, which is not always true for arrays in other languages.\u00a0\u21a9</p> </li> <li> <p>If you learn the C language, you will find out why this is.\u00a0\u21a9</p> </li> <li> <p>That's kind of a shame. If errors always ended up raising exceptions, we would know that our programs were correct as long as there are no exceptions raised when we run them! Alas, it's not that simple.\u00a0\u21a9</p> </li> <li> <p>We haven't talked about the <code>join</code> method yet, but you can look it up in the Python online documentation.\u00a0\u21a9</p> </li> <li> <p>The word \"pop\" comes from the stack data structure, which you'll learn about in CS 2. Python lists can be used as stacks.\u00a0\u21a9</p> </li> <li> <p>There are other ways to sort using this method. See the Python documentation for details.\u00a0\u21a9</p> </li> <li> <p>There are actually two distinct ways to copy lists. The easy way works for most lists, and the harder way works for all lists. We'll see both of them.\u00a0\u21a9</p> </li> </ol>"},{"location":"9/reading9/","title":"Reading 9: Loops (part 1)","text":"<p>My belt holds my pants up, but the belt loops hold my belt up. I don't really know what's happening down there. Who is the real hero? - Mitch Hedberg</p>"},{"location":"9/reading9/#overview","title":"Overview","text":"<p>We've learned a lot of Python in the readings so far, but there are still a few fundamental programming constructs we haven't seen yet. In this reading we will start exploring loops, and next reading we will cover conditionals. We will complete our discussion of loops in two readings.</p>"},{"location":"9/reading9/#what-a-loop-is","title":"What a loop is","text":"<p>One of the basic things that programs have to be able to do is to repeat a chunk of code over and over. Sometimes there is something that changes every time we execute the chunk of code, and sometimes there isn't. For instance, we might want to print a greeting ten times. In that case, we would be executing the exact same code (print the greeting) ten times. Or we might want to print the numbers from 1 to 20, one per line. In that case, something would change each time (the number to print). Sometimes more than one thing changes each time.</p> <p>In order to allow us to execute chunks of code over and over, programming languages like Python contain loop statements and syntax. Nearly every programming language has loop statements with special syntax, but unfortunately every language seems to choose different syntax for what is basically the same construct. Fortunately, Python's loop syntax is simple and easy to pick up.</p>"},{"location":"9/reading9/#pythons-loop-statements","title":"Python's loop statements","text":"<p>Python has two kinds of loop statements: <code>for</code> loops and <code>while</code> loops. These are named after the keywords <code>for</code> and <code>while</code>. In this reading we'll teach you about <code>for</code> loops, because they are the most common kind of loop in Python programs. We'll teach you about <code>while</code> loops in a couple of readings.<sup>1</sup></p>"},{"location":"9/reading9/#loops-and-lists","title":"Loops and lists","text":"<p>We postponed discussing loops until we learned about lists for a good reason: loops are incredibly useful when used with lists. One common code pattern of a loop used with a list looks like this:</p> <ul> <li>for each element in a list,</li> <li>do the following with the element,</li> <li>and repeat until all the elements in the list have been processed.</li> </ul> <p>Pseudocode</p> <p>What we've just written is an example of what is called pseudocode. It's like code, but written for the benefit of humans, not computers. It describes a computation in English with enough detail that it could in principle be converted to a programming language like Python. Writing pseudocode can be a powerful design technique for working out a solution to a programming problem before you start the actual coding.</p> <p>An example of this might be the following: for each element of the following list, print the element.</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n</code></pre> <p>When run, this will print out:</p> <pre><code>Monty\nPython\nand\nthe\nHoly\nGrail\n</code></pre> <p>(one word per line).</p>"},{"location":"9/reading9/#for-loop-syntax","title":"<code>for</code> loop syntax","text":"<p>The syntax of the <code>for</code> loop is basically the following:</p> <pre><code>for &lt;item&gt; in &lt;list&gt;:\n    &lt;chunk of code&gt;\n</code></pre> <p>Both <code>for</code> and <code>in</code> are keywords (reserved words). The <code>&lt;item&gt;</code> is a variable that will refer to a particular element in the list <code>&lt;list&gt;</code>. The <code>&lt;list&gt;</code> can be either an actual list, a variable which refers to a list, or an expression which evaluates to a list.</p> <p>Note</p> <p>The colon character (<code>:</code>) at the end of the <code>for</code> line is required, much like at the end of a <code>def</code> line in a function definition.</p> <p>The <code>&lt;chunk of code&gt;</code> part is called a block; it consists of one or more lines of Python code, all indented the same.<sup>2</sup></p> <p>The way the loop works is as follows.</p> <ol> <li>The first element of the list <code>&lt;list&gt;</code>    is assigned to the <code>&lt;item&gt;</code> variable.</li> <li>The body of the loop is evaluated.</li> <li>Then the next element of the list    is assigned to the <code>&lt;item&gt;</code> variable and the body is evaluated again.</li> <li>This continues until there are no more elements in the list.</li> <li>After the <code>for</code> loop has completed evaluating,    Python goes on to the next line after the loop.</li> </ol> <p>Lists and iterables</p> <p>The thing that goes in the <code>&lt;list&gt;</code> place in</p> <pre><code>for &lt;item&gt; in &lt;list&gt;:\n    &lt;chunk of code&gt;\n</code></pre> <p>doesn't actually have to be a list. There are many other things that can go there, including strings and other data structures like tuples and dictionaries that we haven't seen yet. Any Python value that is an iterable can go in that place. An iterable basically means \"something that can be looped over in a <code>for</code> loop\". We'll explain this in more detail in later readings, and we'll show you how to use <code>for</code> loops with strings below.</p>"},{"location":"9/reading9/#a-simple-example","title":"A simple example","text":"<p>Let's revisit the simple example above:</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n</code></pre> <p>We know that this will print out the words in the list, one per line. But how does it actually work?</p> <p>When the loop starts, the first element of the list, which is <code>'Monty'</code>, gets assigned to the variable <code>word</code>. Then the body prints that word. Then the second element of the list (<code>'Python'</code>) gets assigned to <code>word</code>, the word gets printed, and so on until all the words in the list have been printed. Once there are no more words in the list to bind to <code>word</code>, the <code>for</code> loop has finished executing.</p> <p>So what Python ends up doing when it evaluates the loop is basically the following:</p> <pre><code>word = 'Monty'\nprint(word)\nword = 'Python'\nprint(word)\nword = 'and'\nprint(word)\n...\n</code></pre> <p>but it's much easier and more concise to express this with the <code>for</code> loop.</p> <p>The list <code>title_words</code> isn't altered in the <code>for</code> loop; Python simply fetches its elements one at a time in order and assigns then to the <code>word</code> variable. There is no significance to the variable name <code>word</code> either; we could call it <code>w</code> or <code>xxx</code> if we wanted to (as long as we changed the body of the loop accordingly), but it's a good idea to use meaningful variable names where possible.</p>"},{"location":"9/reading9/#multiline-blocks","title":"Multiline blocks","text":"<p>A <code>for</code> loop block can consist of multiple lines, all indented the same. Let's extend our simple example:</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n    print('----')\n</code></pre> <p>This will print:</p> <pre><code>Monty\n----\nPython\n----\nand\n----\nthe\n----\nHoly\n----\nGrail\n----\n</code></pre> <p>After the block, the indentation has to go back to the previous level so Python knows that the block is finished:</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n    print('----')\nprint('All done!')\n</code></pre>"},{"location":"9/reading9/#loop-syntax-errors","title":"Loop syntax errors","text":""},{"location":"9/reading9/#forgetting-the-colon","title":"Forgetting the colon","text":"<p>A really, really common error is to forget to put the colon character at the end of the <code>for</code> line:<sup>3</sup></p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words\n    print(word)\n</code></pre> <p>Here's what will happen:</p> <pre><code>for word in title_words\n                      ^\nSyntaxError: invalid syntax\n</code></pre> <p>Like it or not, you have to put that colon in!</p>"},{"location":"9/reading9/#bad-indentation","title":"Bad indentation","text":"<p>If the <code>for</code> loop block has more than one line, the lines have to be indented exactly the same. Failure to do this gives you one of three syntax errors.</p> <p>Too much indentation:</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n     print('----')\n</code></pre> <p>gives:</p> <pre><code>    print('----')\n    ^\nIndentationError: unexpected indent\n</code></pre> <p>Too little indentation:</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n   print('----')\n</code></pre> <p>gives:</p> <pre><code>    print('----')\n                ^\nIndentationError: unindent does not match any outer indentation level\n</code></pre> <p>Python knows that you are indenting less than the previous line, but this is only legal when there is some other code with that indent level (like the <code>for</code> line); here, there isn't one.</p> <p>These two syntax errors are pretty obvious. But there is one more which can be extremely hard to detect. Sometimes when you're writing code in a text editor, the editor will use tab characters to indent code. Other times it might use spaces, or a combination of the two. If different lines in a block are indented using tabs on some lines and spaces on other lines, you can get syntax errors even if it looks like they're indented exactly the same!</p> <p>It's hard to show you what this would look like, but let's imagine that in your editor, tab characters look like four space characters. We'll write a tab character like this: <code>&lt;tab&gt;</code> so you can see them. Consider this code:</p> <pre><code>title_words = ['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']\nfor word in title_words:\n    print(word)\n&lt;tab&gt;print('----')\n</code></pre> <p>The code will look perfectly indented. But Python will give you a syntax error:</p> <pre><code>    print('----')\n                ^\nTabError: inconsistent use of tabs and spaces in indentation\n</code></pre> <p>The reason this happens is that the line <code>print(word)</code> is indented using four spaces but the line <code>print('----')</code> is indented using a tab character. Even though these may look the same, Python considers them to be different, since Python doesn't know how many characters wide a tab character appears in your editor or terminal (since you can set this to whatever you want).</p> <p>This is one reason why every Python style guide says not to use tab characters for indentation.<sup>4</sup></p> <p>Tabs vs. spaces</p> <p>See this video to get a deeper insight into the tabs vs. spaces controversy.</p>"},{"location":"9/reading9/#application-writing-the-sum-function","title":"Application: writing the <code>sum</code> function","text":"<p>We've already seen the built-in <code>sum</code> function:</p> <pre><code>temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\navg_temp = sum(temps) / 7\nprint(avg_temp)\n</code></pre> <p>This prints:</p> <pre><code>42.42857142857143\n</code></pre> <p>Now that we know how to write loops, we can write <code>sum</code> ourselves. Here's our first attempt.</p> <pre><code>def sum(nums):\n    \"\"\"Sum the elements of a list of numbers.\"\"\"\n    sum_nums = 0\n    for n in nums:\n        sum_nums = sum_nums + n\n    return sum_nums\n</code></pre> <p>Note</p> <p>Built-in functions like <code>sum</code> are not keywords. You can redefine them, or even use the name <code>sum</code> for something completely unrelated. This can lead to some very hard-to-find bugs, though, so we recommend that you don't do this. Here, we are deliberately replacing the built-in <code>sum</code> function with a function which does the same thing, so it's OK.</p> <p>Let's test it:</p> <pre><code>temps = [59.6, 72.4, 68.5, 79.0, 66.4, 77.1, -126.0]\navg_temp = sum(temps) / 7\nprint(avg_temp)\n</code></pre> <p>This prints:</p> <pre><code>42.42857142857143\n</code></pre> <p>so we're good.</p>"},{"location":"9/reading9/#aside-the-operator-and-friends","title":"Aside: the <code>+=</code> operator and friends","text":"<p>Look at the <code>sum</code> function we wrote above, and in particular this line:</p> <pre><code>sum_nums = sum_nums + n\n</code></pre> <p>Lines of the form <code>x = x + y</code> are extremely common in programming. The meaning of this line is \"add <code>y</code> to the number <code>x</code>\". Since this is so common, there is a shortcut operator that does the same thing, but more concisely. The operator is called <code>+=</code> and looks like this:</p> <pre><code>sum_nums += n\n</code></pre> <p>Similarly, there are other <code>&lt;op&gt;=</code> operators such as <code>-=</code>, <code>*=</code>, <code>/=</code> and so on which work the same way. So <code>x -= y</code> is the same as <code>x = x - y</code>; <code>x *= y</code> is the same as <code>x = x * y</code> etc.</p> <p>We recommend that you use these operators instead of the longer forms for two reasons:</p> <ol> <li>It's shorter.</li> <li>It's easier to read once you get used to it.</li> </ol>"},{"location":"9/reading9/#sum-again","title":"<code>sum</code> again","text":"<p>Let's update our <code>sum</code> function with this spiffy new operator:</p> <pre><code>def sum(nums):\n   \"\"\"Sum the elements of a list of numbers.\"\"\"\n   sum_nums = 0\n   for n in nums:\n       sum_nums += n\n   return sum_nums\n</code></pre> <p>And that's all we'll say about this function!</p>"},{"location":"9/reading9/#loop-terminology","title":"Loop terminology","text":"<p>At this time, it's appropriate to define some terms that are commonly used with loops:</p> loop body <p>The indented block of code that is executed multiple times in a loop.</p> iteration <p>A single pass through the loop body.</p> iterate over <p>Go through a data structure (e.g. a list) element-by-element, executing the loop body on each element.</p> iterable <p>A Python data structure (such as a list) that can be iterated over in a loop.</p> <p>Don't worry if these definitions don't seem crystal clear to you at this point. As we learn more about what kinds of data can be used in a <code>for</code> loop it will all become clear.</p>"},{"location":"9/reading9/#loop-pitfall","title":"Loop pitfall","text":"<p>In a <code>for</code> loop body, it's not a good idea to manually change either the loop variable or the list being iterated over in the body of the loop. The main reason is that what this does is hard to predict unless you really understand Python well. Python is changing the loop variable for you on every iteration of the loop body, so you shouldn't need to change it yourself. And if you change the list being iterated over, the loop may finish earlier or later than you expected, or behave in other non-intuitive ways.</p> <p>Note</p> <p>There will be problems on the assignments exploring this and other pitfalls.</p>"},{"location":"9/reading9/#loops-and-strings","title":"Loops and strings","text":"<p>We mentioned above that in the <code>for</code> loop syntax, which we wrote as:</p> <pre><code>for &lt;item&gt; in &lt;list&gt;:\n    &lt;chunk of code&gt;\n</code></pre> <p>the <code>&lt;list&gt;</code> part could actually be things other than lists. One such thing is a string. If you loop over a string in a <code>for</code> loop, you are iterating over the characters.</p> <pre><code>for char in 'Python':\n    print(char)\n</code></pre> <p>This will print:</p> <pre><code>P\ny\nt\nh\no\nn\n</code></pre> <p>In each iteration of the <code>for</code> loop, the next character of the string <code>Python</code> is assigned to the variable <code>char</code>.</p> <p>So even though a string is not a list, it can behave like one when iterated over in a <code>for</code> loop. We already know that both lists and strings are what Python calls sequences, so you might think that any Python sequence can be looped over in a <code>for</code> loop. And that is in fact the case. (We will soon see that even some non-sequences can be looped over in a <code>for</code> loop.)</p>"},{"location":"9/reading9/#nested-loops","title":"Nested loops","text":"<p>You are allowed to put one <code>for</code> loop inside another. This is called a nested loop and is actually quite common. Here's a simple example:</p> <pre><code>title = ['Monty', 'Python']\nfor word in title:\n    for char in word:\n        print(char)\n</code></pre> <p>The first <code>for</code> loop starts on line 2. Its loop body consists of lines 3 and 4, which is also a <code>for</code> loop. We say that the <code>for</code> loop starting from line 2 is the \"outer\" <code>for</code> loop and the one starting from line 3 is the \"inner\" <code>for</code> loop. Notice that the loop body of the inner <code>for</code> loop (line 4) is indented twice: once because it's in the loop body of the outer <code>for</code> loop and once because it's also in the loop body of the inner <code>for</code> loop.</p> <p>In the first iteration of the outer <code>for</code> loop, the variable <code>word</code> is <code>'Monty'</code>. Then in the inner <code>for</code> loop, the variable <code>char</code> is <code>'M'</code>, then <code>'o'</code>, etc. Once all the characters in <code>'Monty'</code> have been processed, the variable <code>word</code> in the outer <code>for</code> loop becomes <code>'Python'</code>, and then in the inner <code>for</code> loop the variable <code>char</code> becomes <code>'P'</code>, <code>'y'</code>, etc. Running this code gives this result:</p> <pre><code>M\no\nn\nt\ny\nP\ny\nt\nh\no\nn\n</code></pre> <p>We can write code that is inside the first loop but which comes after the nested loop. That code is executed once the nested loop is finished executing.</p> <pre><code>title = ['Monty', 'Python']\nfor word in title:\n    for char in word:\n        print(char)\n    print('---')  # executed after nested loop finishes\n</code></pre> <p>Running this code gives this result:</p> <pre><code>M\no\nn\nt\ny\n---\nP\ny\nt\nh\no\nn\n---\n</code></pre> <p>You can nest loops as deeply as you like, though it's pretty rare to see loops nested more than two deep.</p>"},{"location":"9/reading9/#coming-up","title":"Coming up","text":"<p>We have more to say about loops, and in particular, Python's other loop construct, the <code>while</code> loop. We'll get to that shortly, but in the next reading we will talk about conditionals (<code>if</code> statements), another fundamental building block of computer programs.</p> <ol> <li> <p>If you know other programming languages like C, C++ or Java, be aware that Python's <code>for</code> loop is quite different from the <code>for</code> loop construct in those languages.\u00a0\u21a9</p> </li> <li> <p>Blocks are found in many other places in Python besides loops. The body of a function, for instance, is a block.\u00a0\u21a9</p> </li> <li> <p>I've been programming in Python for years and I still make this mistake from time to time.\u00a0\u21a9</p> </li> <li> <p>Any decent text editor will allow you to configure it so that when you hit the tab key, four spaces are inserted. We strongly recommend that you figure out how to do this, and do it. It will save you a lot of time chasing down dumb syntax errors. If you're using Visual Studio Code, don't worry: it converts tabs to spaces automatically when editing Python code (assuming you installed the ms-python Python extension or something equivalent).\u00a0\u21a9</p> </li> </ol>"}]}