OCaml coding notes and tips
===========================

Here are some notes and tips
that should improve your OCaml programming experience.
We also describe our expectations
of how we want you to write your OCaml code,
so don't just skip this document!


Warnings
--------

Warnings are always bad, unless you expect them (|eg| because code is only
partially written).  Never ignore warnings.  Your finished code should *never*
generate warnings.


Functional style by default
---------------------------

Code should be written in a functional style (no ``ref``\s, arrays, or records
with mutable fields) except where indicated.  Marks will be taken off if this
rule is violated.  We will let you know when it's OK to use imperative idioms.
Certain imperative idioms (like ``while`` and ``for`` loops) are almost never
used, but we do use ``ref`` cells on occasion to make code simpler.

Many of the tips below describe ways to effectively use functional style.
They are not in any particular order, so feel free to browse until you find
something interesting.


Tail recursion by default
-------------------------

As you recall, a lot of CS 4 was spent teaching you to write functions using
recursion instead of loops, and specifically tail recursion.  We use tail
recursion because it has desirable space properties, so in general,
when you write a recursive function, try hard to make it tail recursive.
If you can't do this, be prepared to explain why during code reviews.


Persistent data structures
--------------------------

Probably the hardest part of using functional programming effectively is
getting used to persistent data structures (like lists) instead of mutable data
structures (like arrays).

In this course, almost all data structures are persistent, which means that
when you change something in the data structure, it returns the updated version
without altering the input version.  This is very different to how imperative
languages work.

.. Tip::

   If you think you need to use ``List.iter``
   (which would be appropriate for a mutable data structure)
   you almost always want to actually use ``List.fold_left``
   or an iterative helper function
   (which is appropriate for a persistent data structure).

Even though you may find functional programming awkward at first,
it is *vastly* easier to write correct code
in a functional style than in an imperative style.
There is simply less that can go wrong.


Type annotations
----------------

We *strongly* recommend that you add type annotations
to all functions that are internal to a module.
It will save you a lot of grief.
Just because OCaml can do type inference
doesn't mean that you have to rely on it!
When you specify the types manually,
you will usually get better error messages.

For example, instead of writing this code:

.. code-block:: OCaml

   let rec insert x lst =
     match lst with
       | [] -> [x]
       | h :: t ->
         if x < h then x :: lst else h :: insert x t

write it like this:

.. code-block:: OCaml

   let rec insert (x : 'a) (lst : 'a list) : 'a list =
     match lst with
       | [] -> [x]
       | h :: t ->
         if x < h then x :: lst else h :: insert x t

(Actually, you'd probably rewrite it to be tail recursive, but that's
another topic.)  In many cases, you could substitute a more specific
type for ``'a`` (say, ``int``), which would be beneficial
in the event that the type that was actually passed to ``insert``
was something other than a list of ``int``\s.

Also, don't remove the type annotations once the code is working
"because it looks prettier"; leave them in.
It's good documentation and it will be really important
if you ever have to modify the code.

.. note::

   We didn't have this guideline in CS 4,
   primarily because the code base was so much smaller.  
   The more complicated the code gets,
   the more helpful explicit type annotations are.


Folds are your friend!
----------------------

Programmers new to OCaml are often frustrated by what they perceive as the
difficulty of doing simple things.  A good example of this is accumulation.
You have a list and want to compute some value from the list elements.
For instance, say you want to get the maximum value of the list (and assume
that you only have a two-element ``max`` function to compute maximums).
A Python programmer could immediately write this code:

.. code-block:: Python

   def max_list(lst):
       """Compute the maximum of a list of positive integers."""
       if len(lst) == 0:
           return 0
       mx = lst[0]
       for item in lst:
           mx = max(mx, item)
       return mx

In OCaml, we do this sort of thing using folds, specifically left folds.

.. code-block:: OCaml

   let max_list lst =
     List.fold_left
       (fun mx item -> max mx item)
       0
       lst

This can be simplified further:

.. code-block:: OCaml

   let max_list lst = List.fold_left max 0 lst

Whenever you need to write code which accumulates something over a list,
you generally want to use a fold.

A common beginner's style error is to do this with an iterative helper
function:

.. code-block:: OCaml

   let max_list lst =
     let rec iter rest mx =
       match rest with
         | [] -> mx
         | h :: t ->
           if h > mx then iter t h else iter t mx
     in
       iter lst 0

This is not so bad, but the iterative helper function can be replaced by
``List.fold_left`` and the entire function becomes a one-liner!
Be alert for this kind of situation --
there's no benefit to using a functional language
if you don't take advantage of what it offers.

On the other hand, sometimes you are accumulating more than one thing in an
iteration. You can still use ``List.fold_left`` in such cases by accumulating a
tuple of all the things you're accumulating, but in my experience, it's often
easier to just write an iterative helper function.

Left *vs.* right folds
^^^^^^^^^^^^^^^^^^^^^^

95% of the time or more, if you want to use a fold in OCaml,
you want to use a left fold (``List.fold_left``)
instead of a right fold (``List.fold_right``).
Left folds are tail recursive (space efficient) and are more natural
than right folds, which are also less space efficient.

On the other hand, there are cases where right folds are the right thing to
use.  When you want to accumulate things in a list from the right going back
to the left, a right fold is usually going to be simpler than a left fold,
and you shouldn't feel bad about using one.


Nested pattern matching
-----------------------

It's very common to want to write a pattern match inside another
pattern match.  There are two cases to consider.

#. Where the two pattern matches can be combined.  Consider this code:

   .. code-block:: OCaml

      let f (maybe_lst : int list option) : int option =
        match maybe_lst with
          | None -> None
          | Some lst ->
            begin
              match lst with
                | h :: _ -> Some h
                | [] -> None
            end

   You can merge both pattern matches as follows:

   .. code-block:: OCaml

      let f (maybe_lst : int list option) : int option =
        match maybe_lst with
          | Some (h :: _) -> Some h
          | _ -> None

   Note how much shorter and clearer the code is.
   Also note the use of the wildcard (``_``) pattern
   for "don't care" situations.

   Merging pattern matches is almost always possible if the
   inner pattern match doesn't depend on a value computed using
   information from the outer pattern match.
   Unnecessary pattern matches are bad style and will be marked down.

#. Where the two pattern matches *can't* be combined.
   Consider this code:

   .. code-block:: OCaml

      let f (lst : int list) : (int * int) option =
        match lst with
          | h :: t ->
            begin
              match List.sort compare t with
                | h' :: _ -> Some (h, h')
                | _ -> None
            end
          | _ -> None

   The inner match is matching on the result of the ``List.sort``
   function applied to the tail of the list.
   You can't combine these pattern matches because the inner one
   depends on a value which must be computed (it's not structural).
   For very simple cases, you can use a ``when`` clause instead of
   the inner match, but often this isn't feasible.
   So you have nested ``match`` expressions.

   When you have nested ``match`` expressions, you must surround them
   by either ``begin``/``end`` delimiters (as we did above) or parentheses,
   which looks like this:

   .. code-block:: OCaml

      let f (lst : int list) : (int * int) option =
        match lst with
          | h :: t ->
            (match List.sort compare t with
               | h' :: _ -> Some (h, h')
               | _ -> None)
          | _ -> None

   Using parentheses looks more concise, but it's easy to forget to close
   the open parenthesis, so we prefer to use ``begin``/``end``.
   (It reads better, too.)  What you definitely do *not* want to do is this:

   .. code-block:: OCaml

      let f (lst : int list) : (int * int) option =
        match lst with
          | h :: t ->
            match List.sort compare t with
              | h' :: _ -> Some (h, h')
              | _ -> None
          | _ -> None

   If you do this, you will get strange error messages because
   OCaml will consider the last line to be part of the inner pattern match.
   Remember, **OCaml is not whitespace sensitive!**
   So don't forget the ``begin``/``end``.


Write stubs!
------------

When you are starting to write a function, write a "stub".
This is an incomplete function. Just put in

* the arguments

* type annotations for arguments and the return type
  (This is _very_ important!  Don't skip this step!)

* and ``failwith "TODO"`` for the body.

Then fill it in later.

Here's an example of a stub:

.. code-block:: OCaml

   let halts_on_all_inputs (f : int -> int) : bool =
     failwith "TODO"

This particular function might be a bit hard to complete, though.

Writing stubs is a great way to get past "coder's block".
Once the stub is written,
you can compile it and make sure it type checks.
If it's recursive, you can usually easily fill in the base cases.
At that point, you're ready to work on the body of the function.


Use wishful thinking!
---------------------

If a function seems too difficult/complex to write directly,
ask yourself "what function do I need
which would make it really easy to write this function?"
Then assume that *that* function exists
(|ie| write a stub for it),
and write your main function using the assumed function.
When that's done, go back and write the body of the assumed function.

This is one of *the* most useful programming tips.  It's explored at some
length in the book SICP (Structure and Interpretation of Computer Programs),
which is an amazing book (and which is the basis of CS 4).


Debugging tips
--------------

Although strictly-typed functional languages like OCaml greatly reduce the
number of bugs in your programs, you will still make mistakes and have to debug
them.  Debugging functional languages can be challenging; here are some tips
we've found to be useful.

``printf``\-style debugging
^^^^^^^^^^^^^^^^^^^^^^^^^^^

"printf"-style debugging is highly effective if you do it right.  The wrong
way is to add ``printf`` statements to otherwise functional code:

.. code-block:: OCaml

   let x = ... in
   Printf.printf "x = %s\n" x;
   let y = ... in
     ...

Even though this can work, you are embedding imperative code inside
functional code, and you can get into tricky syntax issues as a result.
A better way to do it is like this:

.. code-block:: OCaml

   let x = ... in
   let _ = Printf.printf "x = %s\n" x in
   let y = ... in
     ...

This also embeds imperative code, but uses functional syntax, so there
won't be any syntax issues.


.. note::

   If the surrounding code is imperative (like a ``begin`` expression
   or the body of a ``for`` or ``while`` loop), the exact opposite criterion
   applies: favor the naked ``Printf.printf ...`` instead of the
   ``let _ = Printf.printf ...`` idiom.  However, in well-written OCaml
   code, ``while`` and ``for`` loops should be almost nonexistent.

Also, you should add ``%!`` at the end of the ``printf`` format string:

.. code-block:: OCaml

   let x = ... in
   let _ = Printf.printf "x = %s\n%!" x in
   let y = ... in
     ...

This makes OCaml flush the string as soon as the ``printf`` executes.
If you don't do that, sometimes error messages before a crash can be lost.

Finally, for debugging, consider writing your ``printf``\s this way:

.. code-block:: OCaml

       let x = ... in
   let _ = Printf.printf "DEBUG: x = %s\n%!" x in
       let y = ... in
         ...

This way, it's easy to spot these lines, which is good because you are
going to want to delete them once debugging is done.

Using the REPL
^^^^^^^^^^^^^^

"REPL" means "Read-Eval-Print-Loop" and refers to the interactive interpreter
(what you get into if you type ``ocaml`` or ``utop`` at a terminal prompt).
You might think that it's hard to use a REPL in a large, multi-file project
like the compiler assignments, but we've got you covered!

Typing ``make repl`` in any directory will bring up a REPL in which all the
modules of the program are accessible.  This allows you to interactively test
your code.  Some kinds of code are easier to test in this way than others, but
don't underestimate how useful this can be, especially when trying to track
down a tricky bug.  All you need to do is to open the relevant module:

.. code-block:: OCaml

   # open Some_Compiler_Pass_That_Isnt_Working;;

and you can play with all the functions in that module.

Insert debugging code into tricky algorithms
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some passes involve tricky algorithms.  In those cases, it's a good idea to
define a ``debug`` variable at the top of the file:

.. code-block:: OCaml

   let debug = ref false  (* change to `true` when you need debug output *)

and then put debug code into the tricky algorithm that prints out the inputs
and outputs:

.. code-block:: OCaml

   let tricky_algorithm weird_inputs =
     if !debug then
       Printf.printf "INPUT: %s\n" (string_of_weird_inputs weird_inputs);
     ... (* rest of algorithm *)

To do this, you need to be able to convert the algorithm inputs/output
to strings.  Most of the data structures you will be using can be easily
converted to S-expressions, and there is a ``print_sexp`` function in the
``Utils`` module that will print an S-expression in a readable fashion.
This is extremely useful for tracking down algorithm errors.



