Assignment 1: The *Var* language
================================

Overview
--------

This assignment involves writing a compiler for the *Var* language,
which is a simple language of variables and arithmetic
described in chapter 2 of the textbook and in the lectures.

The end result will be a program called ``compile`` which will be able to
compile a source program (with the extension ``.src``) to assembly language.
In addition, the compiler can stop after any pass, including after the parser,
so you can inspect the generated code at each stage.  The compiler also has the
ability to run a single pass given the appropriate inputs.

.. note::

   Let us know about anything that's confusing so we can add clarifications
   to this document!  Also let us know about typos and mistakes.


Due date
--------

This assignment is due on Friday, October 14th at 2 AM
(so, effectively very late Thursday night).


Before you begin
----------------

Make sure that all the action items from assignment 0 have been completed:

* choosing a partner
* installing OCaml and all the necessary OCaml libraries
* setting up a GitHub repository and adding the instructor (Mike)
  as a collaborator


Division of labor
-----------------

These assignments are very much a team effort, and both students will be
credited for all work done.  We don't want one student to do all the work,
though.  Learning how to divide the labor is an interesting challenge,
and there is more than one right way to do it.  Some teams may want to work on
the code together ("pair programming"), which can be highly effective.
Alternatively, you can divide up the passes.  Note that each pass can be tested
individually, though this testing is fairly manual and time-consuming (see
below).  If one team member is more experienced than the other, they may want
to tackle the harder passes (which will be identified below).  The hardest
passes (of which there are none in this assignment!) are the best candidates
for collective work.


Textbook
--------

This assignment is based on chapter 2 of the course textbook
(*Essentials of Compilation* by Jeremy Siek).
Please read this chapter in its entirety before doing this assignment,
and follow the instructions in the chapter exercises,
except where noted below.

One obvious and pervasive difference is that we are using OCaml to write the
compiler, whereas the book uses Racket.  Another is that we aren't asking you
to write your own test cases, though you are encouraged to do that in addition
to the ones we supply if you find it helpful.

Also, you'll notice little differences in the way languages are represented.
The Racket code has a ``Prim`` constructor that we don't use (yet),
and an ``info`` field that we only use in certain languages.
However, for the most part there is a 1-to-1 correspondence between
the Racket datatypes and the datatypes we define in OCaml.
When in doubt, trust the OCaml code.

Finally, in the book, there is skeleton code for some of the passes.
While the OCaml equivalent is broadly similar, you don't need to have
an error case for unhandled cases, because OCaml pattern matching
is required to be exhaustive! [1]_


Starting code base
------------------

The starting code base is the zipfile ``src.zip``, which is posted on the
course Canvas site.  You should unzip this file in your Github repo.
It will create a directory called ``src`` which will contain all of your
compiler code for the entire course.  Inside this directory will be two
subdirectories:

#. ``ch2`` -- this will be the code for this week's assignment
   (the "Var" language compiler),
   as well as test code in the ``tests/`` subdirectory,
   and output from the instructor's version of the compiler
   in the ``reference/`` subdirectory.
   There are also a few other files
   (``Makefile``, ``dune``, ``utop_init``, |etc|)
   whose purposes will be described below.

   The name ``ch2`` refers to the fact that this code corresponds
   to the language in chapter 2 of the textbook

#. ``support`` -- this contains a variety of modules which contain
   useful functions and data structures.  We'll give you suggestions
   on which functions you should consider using, but you can use
   any of them at any time.

In future assignments, we will be giving you a zip file containing only
the code which is specific to the new compiler, in a directory called
|eg| ``ch3``, ``ch4``, etc.  The ``support`` library should not change,
unless there are bugs which need to be fixed.

In addition, there are two other files included in the zipfile at the
root of the ``src/`` directory:

#. ``dune-project``.  This file sets the base of the repository from the
   perspective of the `dune` compilation manager.  Just leave it where it is.

#. ``.gitignore``.  This file tells ``git`` which files to ignore.
   Again, just leave it alone.  Each directory may have additional
   ``.gitignore`` files; in general, you shouldn't have to edit them.

You should check in the entire ``src`` directory and all its subdirectories.
Don't check in the zip file!  (You should probably remove it after you
check it in.)


Sanity checking the code base
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you've installed the code base correctly,
you should be able to do the following:

#. ``cd`` into the ``src/ch2`` subdirectory.

#. Type ``make``.  This will compile the compiler
   (an executable file called ``compile``).
   You should see a number of warnings when you compile the compiler;
   that's expected.
   (As you fill in the code for the compiler passes,
   these warnings will go away).

#. You can use the compiler to convert source files in the ``tests/``
   subdirectory to their "Lvar" AST equivalents.  For instance:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass lvar
     (Program (Int 42))

   Note that the output of the compiler is printed to the terminal.
   Should you want to save the output to a file, you can redirect it:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass lvar > var_test_1.lvar
     $ cat var_test_1.lvar
     (Program (Int 42))

   You can also run the "Lvar" evaluator:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass lvar -eval
     42

   However, if you try to compile to a pass beyond the AST,
   it will fail:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass un
     TODO

#. You can also print out the compiler options:

   .. code-block:: text

     $ ./compile --help

   (or just ``compile`` with no arguments).
   This prints out a usage message.

If everything works as we've described, you are good to go.

Note that each assignments' compiler will be different,
and there may be different or additional command-line options
for each compiler.


Code to write: the compiler passes
----------------------------------

The compiler passes are described in chapter 2 of the textbook,
but here they are again for completeness.  We will only include
passes that you have to implement.
For example, even though the parser can be thought of as a "pass",
you don't have to implement it, so we don't include it here.
Similarly, the "print assembly" pass is provided for you,
as are all the intermediate languages and interpreters.

Note that the *only* files you should modify are the files corresponding to
these compiler passes.  Also, only modify the ``.ml`` files; the ``.mli``
files constitute the interface to these modules and must not be changed.

In addition, when we provide a function stub in an ``.ml`` file that you need
to complete, that means that we expect that you will use that function (with
those arguments and types (if supplied)) as written (filling in the ``TODO``
parts, of course).  In particular, you're not allowed to change the number of
arguments to the function, or their types (if supplied).  If a function is
completely implemented (no ``TODO``\s), you should leave it as-is.
On the other hand, you can write as many extra functions as you like.
(If we don't like your choices, we'll let you know during code reviews!)

1. Uniquify (``uniquify.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this pass, all names bound in ``let`` expressions have to be renamed
to be unique.  This enables a number of further transformations in later
passes.

This is a relatively simple pass to implement.  There are four cases:

#. Forms with no subexpressions and no variables.  These pass through
   unchanged.

#. Forms with subexpressions but no variables.  You have to recurse
   on the subexpressions and build up a new expression.

#. ``Var`` expressions. You need to change the variable to its new name,
   if there is one.
   For this, you will have to have a data structure
   which maps the old names to the new names.
   We recommend that you use the ``VarMap`` module
   (defined in the ``Types`` module |ie| ``types.ml`` and ``types.mli``),
   which is an instance of the ``Map`` functor specialized for the
   ``var`` type.  (Note that ``var`` is just an alias for ``string``.)
   A value of type ``VarMap.t`` is a map from variable names to some other
   type; in this case we map variable names to (new) variable names!
   
   Note that the ``uniquify_exp`` function doesn't have a ``VarMap.t``
   argument, so you will need to write a helper function that does.
   When a ``Var`` expression is encountered,
   check to see if the map has a new name for the variable.
   If it does, substitute the new name for the old one.
   Otherwise, leave the name unchanged.
   (This can happen with some global names.)

#. ``Let`` expressions.  When these are encountered, you have to
   generate a new name from the binding name.
   (In the expression ``(let (x 10) (+ x x))``, for instance,
   ``x`` is the binding name.)
   To generate the new name, call the ``fresh`` function
   (defined in the file)
   with the current name and a separator as the arguments.
   Use ``.`` as the separator, so ``x`` might become ``x.1``.  Note that
   the ``fresh`` function has an internal counter, so the next time it's 
   called with the name ``x`` it will return ``x.2``, |etc|

   .. note::

      This is imperative programming, and the fact that we don't have to
      jump through any major hoops to do it (as we would, say, in
      Haskell) is one reason why OCaml is a convenient language for
      writing a compiler.

   The ``fresh`` function is just an alias for the function ``Utils.gensym``
   from the ``Utils`` module in the ``support`` library.  Feel free to
   look at the code for this function if you're interested.  This function
   also uses OCaml's labelled arguments feature, which we didn't use in CS 4.
   A good reference for labelled arguments is here_.

   .. _here: https://v2.ocaml.org/manual/lablexamples.html

   When you generate a fresh name for a binding name, you also have to
   add it to the map for the body expression of the ``let``, but
   *not* for the binding expression of the ``let``
   (since the new name is not in effect for that expression).

   .. note::

      We **very strongly recommend against** using hash tables
      for the map datatype.
      Hash tables are imperative, and it's much too easy
      to add something to a hash table
      that will persist longer than you want it to.
      In this case, an immutable datatype like ``VarMap.t`` is the way to go:
      when you add something to it, you get a new map,
      and you can use the new or old maps as you see fit.

You should be able to implement this pass in about 50 lines of code
(or less).


2. Remove complex operands (``remove_complex.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The purpose of this pass is simply to make sure
that the operands of arithmetic operations are "simple" |ie|
are not subexpressions but "atomic" expressions like integers or variables.
We define an "atom" datatype in ``lvar_mon.mli`` as follows:

.. code-block:: ocaml

   type atm = Int of int | Var of var

and then use it in the expression datatype:

.. code-block:: ocaml

   type exp =
     | Atm    of atm
     | Read
     | Negate of atm
     | Add    of atm * atm
     | Sub    of atm * atm
     | Let    of var * exp * exp

The basic thing that has to happen in this pass is that non-atomic
subexpressions of arithmetic forms (``Add``, ``Sub``, and ``Negate``)
have to be transformed into ``let``\s binding variable(s) to the
complex subexpression(s).  So it's something like this:

.. code-block:: text

   Negate <complex exp>
   --> Let ("$tmp", <complex exp>, Negate (Var "$tmp")

Clearly, you will need to introduce ``let`` expressions wherever
there are arithmetic expressions with complex subexpressions.

On the other hand, expressions that are already atomic should stay
the way they are:

.. code-block:: text

   Negate (Int 10) --> Negate (Int 10)
   Negate (Var "x") --> Negate (Var "x")

Don't do this:

.. code-block:: text

   Negate (Int 10)
   --> Let ("$tmp", Int 10, Negate (Var "$tmp"))
   Negate (Var "x")
   --> Let ("$tmp", Var "x", Negate (Var "$tmp"))

This is called "generating unnecessary temporaries".
Although this doesn't yield incorrect code, it does yield inefficient code.
(Why do you think that is?)

The key function to write here is ``rco_atom``.
This takes an expression which needs to become atomic
(like a subexpression of ``Add``, say),
and returns both the atomic expression
and a list of (name, expression) bindings.
In many cases you'll need to generate temporary names;
the ``gen_temp_name`` function is provided to you for this purpose.

``rco_atom`` is called from the ``rco_exp`` function,
and the ``rco_exp`` function has to take the (name, expression) pairs
and convert them into ``let`` expressions.
(We wrote a helper function to do this.)

One last thing about this pass:
the subexpressions of a ``let`` expression (both of them)
do *not* need to be atomic, so don't try to make them atomic!
That means that you can have arbitrarily nested ``let`` expressions.
If this bothers you, don't worry: we'll fix it in the next pass!



3. Explicate control (``explicate_control.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

4. Select instructions (``select_instructions.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

5. Assign homes (``assign_homes.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

6. Patch instructions (``patch_instructions.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

7. Prelude and conclusion (``prelude_conclusion.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO


Running the ``compile`` program
-------------------------------

There are three basic ways to run the compiler
(the ``./compile`` program):

#. You can compile a source file up to a particular pass.
   For instance:

   .. code-block:: text

      $ ./compile tests/var_test_1.src -pass un

   will compile the code in ``tests/var_test_1.src`` up to the "un"
   (uniquify) pass, and print the output to the terminal.
   The passes for this assignment are:

   #. ``lvar`` -- AST (not really a pass)
   #. ``un`` -- uniquify
   #. ``rc`` -- remove complex operands
   #. ``ec`` -- explicate control
   #. ``si`` -- select instructions
   #. ``ah`` -- assign homes
   #. ``pi`` -- patch instructions
   #. ``pc`` -- prelude and conclusion
   #. ``pa`` -- print assembly language

   If you don't specify a pass, it will assume the pass ``pa``,
   which means compile all the way to assembly language.

#. You can compile a file up to a particular pass and then run
   an evaluator on the resulting code (for some passes).
   For instance:

   .. code-block:: text

      $ ./compile tests/var_test_1.src -pass un -eval

   will compile up to the ``un`` (uniquify) pass and then evaluate the
   resulting code.  Not all passes have evaluators; only the following
   passes do: ``lvar``, ``un``, ``rc``, ``ec``.

#. You can compile a single pass.  This requires that the input file
   be in the correct format for that pass.  We normally will use
   the file extensions ``.un``, ``.rc`` |etc| to indicate that a file
   has been compiled up to that pass.  For instance:

   .. code-block:: text

      $ ./compile tests/var_test_1.src -pass un > var_test_10.un
      $ cat var_test_10.un
      (Program
        (Let
          x.1
          Read
          (Let
            y.1
            Read
            (Add (Var x.1) (Negate (Var y.1))))))
      $ ./compile var_test_10.un -pass rc -only
      (Program
        (Let
          x.1
          Read
          (Let
            y.1
            Read
            (Let
              $tmp.1
              (Negate (Var y.1))
              (Add (Var x.1) (Var $tmp.1))))))

   This is a good way to test the code for a single pass, and you can do this
   even if the previous passes haven't been written.

   In the ``reference/`` subdirectory you will find the outputs of all the
   test scripts for all passes.  These can be used for one-pass tests.


Compiling and running assembly language code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have a computer running a 64-bit Intel or AMD processor
(which use the x86-64 instruction set), you can compile the
assembly language code that the compiler generates.

Let's use the ``var_test_5.src`` file as an example.
You will also need the C code files ``runtime.c`` and ``runtime.h``,
which should be in your ``ch2`` directory.

Here is the sequence of commands.  Note that assembly language files
normally end in ``.s``, so we redirect the compiler output to the
filename ``var_test_5.s`` and compile it with the ``gcc`` C compiler
(which needs to be installed if it isn't already).

.. code-block:: text

  $ ./compile tests/var_test_5.src > var_test_5.s
  $ gcc -c var_test_5.s
  $ gcc -c runtime.c
  $ gcc var_test_5.o runtime.o -o var_test_5
  $ ./var_test_5
  $ echo $?
  42

This compiles the assembly language file ``var_test_5.s``
to the binary executable program ``var_test_5``.
When this program is run, it doesn't appear to do anything.
However, the program returns an integer return code to the operating system,
which in this case is the number 42.  The line ``echo $?`` prints this number.

.. note::

   These return codes can only be in the range 0 to 255, so if you 
   return an integer outside this range, it will be coerced into that range,
   leading sometimes to peculiar results.

If the program you are compiling has calls to the ``read`` function,
you will have to input the integers to be read when the program runs.


Testing the compiler
--------------------

There are currently two ways to test your compiler, one automated, and one
manual.  Both are valuable.

Automated tests
^^^^^^^^^^^^^^^

We are supplying you with a test script (written in Python) called
``run_eval_tests.py``.  This script can be used to test that a
particular ``.src`` file generate the correct output when given
particular inputs.  It uses metadata stored in comments in the ``.src`` files
in the ``/tests`` subdirectory.  For instance, consider the file
``var_test_10.src``:

.. code-block:: text

   ;; INPUT: 45 3 ; 21 20
   ;; OUTPUT: 42 ; 1
   (let (x (read))
     (let (y (read))
       (+ x (- y))))

The metadata is in the first two lines,
with the ``INPUT:`` and ``OUTPUT:`` tags.
These indicate that the program should be run twice:
the first time with (terminal) inputs ``45`` and ``3``,
producing the output ``42``,
and the second time with (terminal) inputs ``21`` and ``20``,
producing the output ``1``.

You invoke the test script this way:

.. code-block:: text

   $ python run_eval_tests.py tests/var_test_10.src

It will output:

.. code-block:: text

   ----
   input file: var_test_10.src

   * input/output data #1:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).
   Compiling to assembly language and compiling/running the program.

   * input/output data #2:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).
   Compiling to assembly language and compiling/running the program.

This can be done for many files, or even for all tests files at once:

.. code-block:: text

   $ python run_eval_tests.py tests/var_test_*.src

(This will produce a lot of output!)

If one of the evaluators produces incorrect output, an error message
will be printed and the test script will halt.

By default, the test script will not just test the program outputs using
the evaluators of the intermediate languages (``lvar``, ``lvar_mon``, |etc|),
but will also compile the code all the way to assembly language, run it,
and test the output against the expected output.
If you are runnign this script on a non-x86 machine
(like a Mac with an M1 processor), these tests can't run.  In that case,
you can add the ``-no-asm`` command-line argument
to skip the assembly language tests:

.. code-block:: text

   $ python run_eval_tests.py -no-asm tests/var_test_10.src
   ----
   input file: var_test_10.src

   * input/output data #1:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).

   * input/output data #2:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).

Note, though, that if there is a bug in the assembly language
code generation, these tests will not reveal it.
When we test your code, we will run all the tests.


Manual tests
^^^^^^^^^^^^

The automated tests are very useful for detecting problems,
but to really debug your compiler you will need to look at the output
of the compiler for known correct inputs.  These tests are very
difficult to automate, since sometimes you can have more than one
correct output for a particular input.

As a simple example, the "uniquify" pass will change the names of all the
variables to unique names, but what those names are isn't important. (The
course compiler might rename ``x`` to ``x.1`` while your compiler might rename
``x`` to ``x.101``; as long as the variable is used correctly, this is still
fine.)

Therefore, when working on a pass, we recommend that you use the
files in the ``reference/`` subdirectory along with the ``-only``
option of the compiler to compare what your pass does to the input code to
what the instructor's compiler did.
This is what we refer to as "manual tests".

Let's say you are working on the "remove complex operands" pass
and you think you have a working implementation.  You can run your compiler
on the output of the previous pass ("uniquify") and compare to the
corresponding file in the ``reference`` subdirectory.
The output of the ``uniquify`` pass will be a file ending in ``.un``.

.. code-block:: text

   $ cat reference/var_test_10.un
   (Program
     (Let
       x.1
       Read
       (Let
         y.1
         Read
         (Add (Var x.1) (Negate (Var y.1))))))
   $ ./compile reference/var_test_10.un -pass rc -only
   (Program
     (Let
       x.1
       Read
       (Let
         y.1
         Read
         (Let
           $tmp.1
           (Negate (Var y.1))
           (Add (Var x.1) (Var $tmp.1))))))
   $ cat reference/var_test_10.rc
   (Program
     (Let
       x.1
       Read
       (Let
         y.1
         Read
         (Let
           $tmp.1
           (Negate (Var y.1))
           (Add (Var x.1) (Var $tmp.1))))))

You can see that the file that your compiler generated is the same as the file
the instructor's compiler generated, so everything seems to be working. Of
course, some small differences may be found (you might name your temporary
variable ``$temp.1`` instead of ``$tmp.1``, for instance); this doesn't
indicate a mistake.  But if there is a structural difference, something
probably went wrong.

.. note::

   Structural differences do not always indicate incorrect code;
   in some cases you can transform code
   in a different way than what we wanted you to do
   and the resulting code will still evaluate correctly.
   However, in that case you are not implementing the pass correctly,
   so in most cases we will still consider this to be an error.

   A trivial example of this would be a register allocation pass
   where you just put all variables on the stack instead of in
   registers. (This is intentional in this assignment,
   but in most assignments it's not what you are supposed to do.)
   Though this is "wrong", the code will probably still run correctly.

Of course, you should test your compiler on more than just one source file.
Try to test on as many files as you can for a particular pass.
If you know how to write shell scripts,
this can be a useful way of making this kind of test semi-automatic
(just requiring that you look at the files to check for big differences).


"Submitting" your assignment
----------------------------

Unlike most courses, there is nothing to "hand in" in this course.
Instead, you need to inform the instructor (and TAs) when an assignment is
ready to be graded (hopefully, before or on the due date).
The instructor will check out your code, run the tests, and leave comments
in a file called GRADING in your ``ch2`` directory.  The instructor/TAs
may also leave comments in your code itself, with this syntax:

.. code-block:: ocaml

   (*** GRADER COMMENT: ... ***)

These should be removed when you fix whatever the comment complained about.

After the grading comments have been checked in to your repository,
you have one week to make changes (this is the first redo period).
Work redone during this period will be re-evaluated without penalty.
Any subsequent redos after the first redo will result in reduced credit
(typically, any additional marks after the first week
will get at most 50% credit).


Code reviews, office hours, and feedback
----------------------------------------

We will be setting up code review times for each team.  Make sure you choose a
time where both members of the team can meet as well as the instructor
(and/or a TA).

Code reviews do not require that all of the code be written, or that all of the
code is working correctly, but there is no point in doing a code review unless
most of the code has been written.  If you are having trouble at an earlier
stage, we will have office hour times you can come to.


----

.. rubric:: Footnotes

.. [1] That is, in *this* language.  In some of the later languages,
   the situation will change.


