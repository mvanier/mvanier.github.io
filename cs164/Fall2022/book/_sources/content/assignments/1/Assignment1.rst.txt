Assignment 1: The *Var* language
================================

Overview
--------

This assignment involves writing a compiler for the *Var* language,
which is a simple language of variables and arithmetic
described in chapter 2 of the textbook and in the lectures.

The end result will be a program called ``compile`` which will be able to
compile a source program (with the extension ``.src``) to assembly language.
In addition, the compiler can stop after any pass, including after the parser,
so you can inspect the generated code at each stage.  The compiler also has the
ability to run a single pass given the appropriate inputs.

.. note::

   Let us know about anything that's confusing so we can add clarifications
   to this document!  Also let us know about typos and mistakes.


Due date
--------

This assignment is due on Friday, October 14th at 2 AM
(so, effectively very late Thursday night).


Before you begin
----------------

Make sure that all the action items from assignment 0 have been completed:

* choosing a partner
* installing OCaml and all the necessary OCaml libraries
* setting up a GitHub repository and adding the instructor (Mike)
  as a collaborator


Division of labor
-----------------

These assignments are very much a team effort, and both students will be
credited for all work done.  We don't want one student to do all the work,
though.  Learning how to divide the labor is an interesting challenge,
and there is more than one right way to do it.  Some teams may want to work on
the code together ("pair programming"), which can be highly effective.
Alternatively, you can divide up the passes.  Note that each pass can be tested
individually, though this testing is fairly manual and time-consuming (see
below).  If one team member is more experienced than the other, they may want
to tackle the harder passes (which will be identified below).  The hardest
passes (of which there are none in this assignment!) are the best candidates
for collective work.


Textbook
--------

This assignment is based on chapter 2 of the course textbook
(*Essentials of Compilation* by Jeremy Siek).
Please read this chapter in its entirety before doing this assignment,
and follow the instructions in the chapter exercises,
except where noted below.

One obvious and pervasive difference is that we are using OCaml to write the
compiler, whereas the book uses Racket.  Another is that we aren't asking you
to write your own test cases, though you are encouraged to do that in addition
to the ones we supply if you find it helpful.

Also, you'll notice little differences in the way languages are represented.
The Racket code has a ``Prim`` constructor that we don't use (yet),
and an ``info`` field that we only use in certain languages.
However, for the most part there is a 1-to-1 correspondence between
the Racket datatypes and the datatypes we define in OCaml.
When in doubt, trust the OCaml code.

Finally, in the book, there is partial "skeleton" code for some of the passes.
While the OCaml equivalent is broadly similar, you don't need to have an error
case for unhandled cases, because OCaml pattern matching is required to be
exhaustive! [1]_


Starting code base
------------------

The starting code base is the zipfile ``src.zip``, which is posted on the
course Canvas site.  You should unzip this file in your Github repo.
It will create a directory called ``src`` which will contain all of your
compiler code for the entire course.  Inside this directory will be two
subdirectories:

#. ``ch2`` -- this will be the code for this week's assignment
   (the "Var" language compiler),
   as well as test code in the ``tests/`` subdirectory,
   and output from the instructor's version of the compiler
   in the ``reference/`` subdirectory.
   There are also a few other files
   (``Makefile``, ``dune``, ``utop_init``, |etc|)
   whose purposes will be described below.

   The name ``ch2`` refers to the fact that this code corresponds
   to the language in chapter 2 of the textbook

#. ``support`` -- this contains a variety of modules which contain
   useful functions and data structures.  We'll give you suggestions
   on which functions you should consider using, but you can use
   any of them at any time.

In future assignments, we will be giving you a zip file containing only
the code which is specific to the new compiler, in a directory called
|eg| ``ch3``, ``ch4``, etc.  The ``support`` library should not change,
unless there are bugs which need to be fixed.

In addition, there are two other files included in the zipfile at the
root of the ``src/`` directory:

#. ``dune-project``.  This file sets the base of the repository from the
   perspective of the `dune` compilation manager.  Just leave it where it is.

#. ``.gitignore``.  This file tells ``git`` which files to ignore.
   Again, just leave it alone.  Each directory may have additional
   ``.gitignore`` files; in general, you shouldn't have to edit them.

You should check in the entire ``src`` directory and all its subdirectories.
Don't check in the zip file!  (You should probably remove it after you
check it in.)


Sanity checking the code base
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you've installed the code base correctly,
you should be able to do the following:

#. ``cd`` into the ``src/ch2`` subdirectory.

#. Type ``make``.  This will compile the compiler
   (an executable file called ``compile``).
   You should see a number of warnings when you compile the compiler;
   that's expected.
   (As you fill in the code for the compiler passes,
   these warnings will go away).

#. You can use the compiler to convert source files in the ``tests/``
   subdirectory to their "Lvar" AST equivalents.  For instance:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass lvar
     (Program (Int 42))

   Note that the output of the compiler is printed to the terminal.
   Should you want to save the output to a file, you can redirect it:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass lvar > var_test_1.lvar
     $ cat var_test_1.lvar
     (Program (Int 42))

   You can also run the "Lvar" evaluator:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass lvar -eval
     42

   However, if you try to compile to a pass beyond the AST,
   it will fail:

   .. code-block:: text

     $ ./compile tests/var_test_1.src -pass un
     TODO

#. You can also print out the compiler options:

   .. code-block:: text

     $ ./compile --help

   (or just ``compile`` with no arguments).
   This prints out a usage message.

If everything works as we've described, you are good to go.

Note that each assignments' compiler will be different,
and there may be different or additional command-line options
for each compiler.


Code to write: the compiler passes
----------------------------------

The compiler passes are described in chapter 2 of the textbook,
but here they are again for completeness.  We will only include
passes that you have to implement.
For example, even though the parser can be thought of as a "pass",
you don't have to implement it, so we don't include it here.
Similarly, the "print assembly" pass is provided for you,
as are all the intermediate languages and interpreters.

Note that the *only* files you should modify are the files corresponding to
these compiler passes.  Also, only modify the ``.ml`` files; the ``.mli``
files constitute the interface to these modules and must not be changed.

In addition, when we provide a function stub in an ``.ml`` file that you need
to complete, that means that we expect that you will use that function (with
those arguments and types (if supplied)) as written (filling in the ``TODO``
parts, of course).  In particular, you're not allowed to change the number of
arguments to the function, or their types (if supplied).  If a function is
completely implemented (no ``TODO``\s), you should leave it as-is.
On the other hand, you can write as many extra functions as you like.
(If we don't like your choices, we'll let you know during code reviews!)

1. Uniquify (``uniquify.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this pass, all names bound in ``let`` expressions have to be renamed
to be unique.  This enables a number of further transformations in later
passes.  Both the input and output languages for this pass are *Lvar*,
defined in the files ``lvar.ml[i]``.

This is a relatively simple pass to implement.  There are four cases:

#. Forms with no subexpressions and no variables.  These pass through
   unchanged.

#. Forms with subexpressions but no variables.  You have to recurse
   on the subexpressions and build up a new expression.

#. ``Var`` expressions. You need to change the variable to its new name,
   if there is one.
   For this, you will have to have a data structure
   which maps the old names to the new names.
   We recommend that you use the ``VarMap`` module
   (defined in the ``Types`` module |ie| ``types.ml`` and ``types.mli``),
   which is an instance of the ``Map`` functor specialized for the
   ``var`` type.  (Note that ``var`` is just an alias for ``string``.)
   A value of type ``VarMap.t`` is a map from variable names to some other
   type; in this case we map variable names to (new) variable names!

   Note that the ``uniquify_exp`` function doesn't have a ``VarMap.t``
   argument, so you will need to write a helper function that does.
   When a ``Var`` expression is encountered,
   check to see if the map has a new name for the variable.
   If it does, substitute the new name for the old one.
   Otherwise, leave the name unchanged.
   (This can happen with some global names.)

#. ``Let`` expressions.  When these are encountered, you have to
   generate a new name from the binding name.
   (In the expression ``(let (x 10) (+ x x))``, for instance,
   ``x`` is the binding name.)
   To generate the new name, call the ``fresh`` function
   (defined in the file)
   with the current name and a separator as the arguments.
   Use ``.`` as the separator, so ``x`` might become ``x.1``.  Note that
   the ``fresh`` function has an internal counter, so the next time it's
   called with the name ``x`` it will return ``x.2``, |etc|

   .. note::

      This is imperative programming, and the fact that we don't have to
      jump through any major hoops to do it (as we would, say, in
      Haskell) is one reason why OCaml is a convenient language for
      writing a compiler.

   The ``fresh`` function is just an alias for the function ``Utils.gensym``
   from the ``Utils`` module in the ``support`` library.  Feel free to
   look at the code for this function if you're interested.  This function
   also uses OCaml's labelled arguments feature, which we didn't use in CS 4.
   A good reference for labelled arguments is here_.

   .. _here: https://v2.ocaml.org/manual/lablexamples.html

   When you generate a fresh name for a binding name, you also have to
   add it to the map for the body expression of the ``let``, but
   *not* for the binding expression of the ``let``
   (since the new name is not in effect for that expression).

   .. note::

      We **very strongly recommend against** using hash tables
      for the map datatype.
      Hash tables are imperative, and it's much too easy
      to add something to a hash table
      that will persist longer than you want it to.
      In this case, an immutable datatype like ``VarMap.t`` is the way to go:
      when you add something to it, you get a new map,
      and you can use the new or old maps as you see fit.

You should be able to implement this pass in about 50 lines of code
(or less).


2. Remove complex operands (``remove_complex.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The purpose of this pass is simply to make sure
that the operands of arithmetic operations are "simple" |ie|
are not subexpressions but "atomic" expressions like integers or variables.
The input language to this pass is *Lvar* and the output language is
*Lvar_mon*, which is defined in the files ``lvar_mon.ml[i]``.

We define an "atom" datatype in ``lvar_mon.mli`` as follows:

.. code-block:: ocaml

   type atm = Int of int | Var of var

and then use it in the expression datatype:

.. code-block:: ocaml

   type exp =
     | Atm    of atm
     | Read
     | Negate of atm
     | Add    of atm * atm
     | Sub    of atm * atm
     | Let    of var * exp * exp

The basic thing that has to happen in this pass is that non-atomic
subexpressions of arithmetic forms (``Add``, ``Sub``, and ``Negate``)
have to be transformed into ``let``\s binding variable(s) to the
complex subexpression(s).  So it's something like this:

.. code-block:: text

   Negate <complex exp>
   --> Let ("$tmp", <complex exp>, Negate (Var "$tmp")

Clearly, you will need to introduce ``let`` expressions wherever
there are arithmetic expressions with complex subexpressions.

On the other hand, expressions that are already atomic should stay
the way they are:

.. code-block:: text

   Negate (Int 10) --> Negate (Int 10)
   Negate (Var "x") --> Negate (Var "x")

Don't do this:

.. code-block:: text

   Negate (Int 10)
   --> Let ("$tmp", Int 10, Negate (Var "$tmp"))
   Negate (Var "x")
   --> Let ("$tmp", Var "x", Negate (Var "$tmp"))

This is called "generating unnecessary temporaries".
Although this doesn't yield incorrect code, it does yield inefficient code.
(Why do you think that is?)

The key function to write here is ``rco_atom``.
This takes an expression which needs to become atomic
(like a subexpression of ``Add``, say),
and returns both the atomic expression
and a list of (name, expression) bindings.
In many cases you'll need to generate temporary names;
the ``gen_temp_name`` function is provided to you for this purpose.

``rco_atom`` is called from the ``rco_exp`` function,
and the ``rco_exp`` function has to take the (name, expression) pairs
and convert them into ``let`` expressions.
(We wrote a helper function to do this.)

One last thing about this pass:
the subexpressions of a ``let`` expression (both of them)
do *not* need to be atomic, so don't try to make them atomic!
That means that you can have arbitrarily nested ``let`` expressions.
If this bothers you, don't worry: we'll fix it in the next pass!


3. Explicate control (``explicate_control.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The purpose of this pass is to "flatten" the code representation
into a sequence of assignment statements followed by a "return" statement.
The ``let`` statements are gone, replaced by assignments.
There is no more nesting of expressions,
unless you consider the sequence of assignments "nesting".

The input language to the pass is *Lvar_mon*
and the output language is *Cvar*,
defined in the files ``cvar.ml[i]``.
The name *Cvar* was chosen because the straight-line nature of the code
is very similar to the way code is represented in a C language program.

The source code consists of five functions:

* ``convert_atom``
* ``convert_exp``
* ``explicate_assign``
* ``explicate_tail``
* ``explicate_control``

``explicate_control`` is supplied for you.
``convert_atom`` and ``convert_exp`` are straightforward.
``explicate_tail`` converts an expression in tail position,
while ``explicate_assign`` converts an assignment statement
followed by an already-converted tail expression.

In both ``explicate_tail`` and ``explicate_assign``,
the only (slightly) tricky case is the ``let`` case.
Hint: ``explicate_tail`` has to call ``explicate_assign``.
The total code is considerably less than 100 lines.


4. Select instructions (``select_instructions.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This is the first of several passes collectively called the "back end".
Their job is to convert the code into x86-64 assembly language.
There are three intermediate languages specific to these passes:

#. *x86var* (``x86var.ml[i]``)

   This language mixes assembly language instructions with variables.

#. *x86int* (``x86int.ml[i]``)

   This language gets rid of variables.  Variables are represented by
   stack locations (in this assignment) and by a combination of
   stack locations and registers (in later assignments).

#. *x86asm* (``x86asm.ml[i]``)

   This language adds extra code (the "prelude" and "conclusion")
   necessary to make the entire program into a single unit that
   can be compiled into a full executable program. [2]_

After *x86asm*, actual assembly code is trivially generated by the
"print assembly" pass (``print_asm.ml[i]``).

In the "select instructions" pass,
code is converted from the *Cvar* language to the *x86var* language.

The ``select_instructions.ml`` file is mostly empty.  You have to
implement the ``convert_lt`` function, which converts a (label, tail)
pair (*Cvar* language) into a (label, block) pair (*x86var* language).
The labels don't change, so essentially you are changing a Cvar tails
into *x86var* blocks (lists of instructions).  You will want to write
helper functions to do this.  (We put ours outside of the ``convert_lt``
function; you can do it any way you like.)

Quoting from the textbook:

.. pull-quote ::

  We recommend implementing the ``select_instructions`` [pass]
  with three auxiliary functions,
  one for each of the nonterminals of CVar:
  ``atm``, ``stmt``, and ``tail``.

The textbook has a good description of how to convert *Cvar*
tails/statements/expressions/atoms into *x86var* instructions.
Note that a single *Cvar* expression can yield more than one
*x86var* instruction.

Pay particular attention to the opportunities for optimizations.
Let's take addition as an example.
In the most general case,
adding two atoms and storing the result into a variable
requires two instructions:
a ``movq`` instruction to move the first atom into the variable location,
and an ``addq`` to add the second atom into that location.
But if one of the atoms is also the target variable,
then you just need one ``addq`` instruction.
This also applies to the ``subq`` and ``negq`` instructions,
but be careful with ``subq``, since the order of operands matters!
(Only one order can be optimized.)
Note that ``subq x y`` means "subtract ``x`` from ``y``".

.. note ::

   These optimizations are *not* optional!

The ``Return`` instruction requires special treatment.
You don't actually generate a ``Retq`` instruction
since this doesn't actually represent returning from a function
(we'll see why in the "prelude and conclusion" pass below).
Instead, you have to do the following:

#. Convert the expression which is the argument of the ``Return``
   and move that result into the ``Rax`` register
   (this may take one or two instructions, depending on the expression).
   Note that a function call (which can only be ``Read`` here)
   will automatically return its result into the ``Rax`` register.

#. Emit a ``Jmp`` instruction to a label called ``conclusion``.

There is one other peculiarity of this pass that isn't in the book. We've
provided a function called ``fix_label`` which should be used whenever calling
an external function.  In this case, the only external function is
``read_int``, which is what a ``Read`` instruction in Cvar should compile to.
So ``Read`` becomes ``Callq (Label "read_int", 0)``.  (The ``0`` is the
function arity |ie| the number of arguments the function takes.) However,
different operating systems have different conventions for labels. In
particular, MacOS requires that function labels have an initial underscore, so
you should compile this into ``Call1 (Label "_read_int", 0)`` if you're on a
Mac.  To make the compiler more independent of the OS it's being run on, we've
added the ``fix_label`` function, which checks to see if the OS is "MacOS", and
if so, prepends the underscore to the label.  So instead of converting ``Read``
to ``Callq (Label "read_int", 0)``, convert it to ``Callq (Label (fix_label
"read_int"), 0)``. [3]_


5. Assign homes (``assign_homes.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The purpose of this pass is to convert variable names into stack locations.
Note that in this compiler, we are not storing variables in registers.
(In all the later compilers, we will be.)  Therefore, this pass will only
exist in this compiler; in later compilers, it will be replaced by several
register allocation passes.  Fortunately, assigning variables to stack slots
is straightforward.

Although this pass converts x86var programs to x86var programs, the resulting
programs will not use variables.  (We will get rid of variables altogether in
the x86int language.)
However, the ``info`` field of the programs will change;
after the "select instructions" pass the info field is ``info1``,
which stores type information for all variables;
after "assign homes" it's ``info2``, which stores the stack space used.

Variables placed on the stack are identified by their position in memory
relative to the "base pointer".   This is a memory location which is stored in
a special register called ``rbp`` (often written ``%rbp``, though in the OCaml
code we refer to it as ``Rbp``). [4]_
The base pointer represents the start of the stack
used for a particular function.
Variables stored on the stack are identified relative to the base pointer.
Stack variables are placed in memory below the base pointer
(we say that the stack "grows downwards").
Variables are 8 bytes in size (64 bits),
so the first variable will be stored 8 bytes below the base pointer.
In assembly language, this is written as ``-8(%rbp)``;
in the OCaml code we write it as ``Deref (Rbp, -8)``.
The next stack location will be ``-16(%rbp)``, and so on.
The space used for all the stack variables is known as the "stack frame".
One curious requirement is that the total amount of space
used for the stack frame must be a multiple of 16 bytes,
so even if you only need one stack variable (8 bytes),
you have to reserve 16 bytes.

Here's what you need to do in this pass:

#. Use the ``info1`` field to assign stack locations to all variables
   used in the program.  ``info1`` contains a list of all variables
   in the program as well as their types.
   (The types are all ``Integer``, so that isn't relevant
   except that you need to know that all integers are 8 bytes long.)
   You should store the (variable name, stack location) pairs
   as a ``VarMap.t`` map (mapping names to their stack locations).
   You will also need to compute the total amount of stack space
   required.  Since this has to be aligned on a 16 byte boundary,
   we've provided a utility function called ``align_16`` in the
   ``Utils`` module of the ``support`` library.

#. Once this has been done, you need to go through all the instructions
   in the blocks and replace variables with their stack locations.
   If you encounter a variable which doesn't have an assigned stack location,
   signal an error (this shouldn't happen, but it's good to check).

#. Compute an ``info2`` field using the computed stack space,
   and reconstitute the program.


6. Patch instructions (``patch_instructions.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In a perfect world, we would not need to do this pass.
However, the x86-64 instruction set is far from elegant,
and we have to deal with its restrictions.
One such restriction is that no instruction can have
two arguments where both arguments are memory references
(as opposed to (say) immediate values or registers).
If such instructions exist, they need to be "patched" (fixed)
so that the restriction is adhered to.

There are different ways of handling this,
but the book suggests a very simple strategy.
When you have an instruction that uses two stack locations,
convert it into two instructions using the ``%rax`` register (OCaml ``Rax``)
as an intermediary.
There are only three instructions in this compiler where this can happen:
``addq``, ``subq``, and ``movq``.
The ``movq`` case is the simplest.
Change: ::

  movq -8(%rbp), -16(%rbp)

to two instructions: ::

  movq -8(%rbp), %rax
  movq %rax, -16(%rbp)

This doesn't violate the restriction.  The ``addq`` and ``subq`` cases
are similar but slightly trickier.

What you need to do is thus to go through all instructions,
determine if an instruction needs to be patched,
and patch it in those cases.
Don't match instructions that don't need to be patched!
For instance, don't change: ::

  movq $42, -8(%rbp)

into this: ::

  movq $42, %rax
  movq %rax, -8(%rbp)

because the instruction didn't need to be patched
(since there was only one memory reference).

.. note::

   The ``$42`` assembly language syntax means an immediate value;
   in OCaml we write this as ``Imm 42``.

Note also that this pass converts from the *x86var* language to the
*x86int* language, which doesn't have variables.
This means that there will be some trivial "boilerplate" conversions,
like converting an `Imm` constructor in one language
to the exact same constructor in the other language.
This is trivial but a bit tedious.
(It's the price we pay for having precise types.)


7. Prelude and conclusion (``prelude_conclusion.ml``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This is the last pass you need to write.  (Phew!)
The textbook also includes a partial evaluator pass as an optional
"challenge" pass; we won't be doing that.

This pass converts from the *x86int* language to the *x86asm* language,
which is basically x86-64 assembly language,
but in an S-expression representation.
The actual assembly language is generated by the "print assembly" pass,
which you don't have to write.

The purpose of this pass is to add extra code
to make a complete assembly language program.
The code that we have been generating so far
(whether we were aware of it or not)
is the body of the ``main`` function.
However, in order for this to be a proper function,
some code has to be added both before and after the code we've written.
The code that is executed before the code we've written
is called the "prelude",
and the code that comes after is called the "conclusion".
These don't have to come physically before or after our code,
since we have ``jmp`` instructions to transfer control.
Therefore, we put them after our code.

The code we've been working with is all in a single block
labelled ``start``.
The code that comes before this is going to have to jump to this label,
and our code is going to have to eventually jump to the label
called ``conclusion``.
The "prelude" is everything that comes before the jump to ``start``
and the "conclusion`` is everything that comes after the jump to
``conclusion``.

The *actual* beginning of execution is the label called ``main``
(or ``_main`` if you're running on a Mac).
We also have to declare ``main`` to be a "global" name
(as all top-level functions have to be)
by using the ``Global`` instruction.
(This becomes ``.globl`` in the actual assembly code.)
This declaration has to come before the ``main`` label,
and it's the beginning of the prelude.

The prelude does the following:

#. Declares ``main`` as a global name and defines the ``main`` label.
#. Saves the previous base pointer (in the ``%rbp`` register) to
   the stack (using a ``pushq`` instruction).
#. Saves the current stack pointer (in the ``%rsp`` register)
   into the base pointer register ``%rbp``.
#. Reserves space for all the stack variables (a multiple of 16)
   by modifying the stack pointer ``%rsp``.
#. Jumps to the ``start`` label.

The conclusion does the following:

#. Reclaims the stack space used in the code.
#. Restores the old base pointer using a ``popq`` instruction.
#. Returns from the ``main`` function with a ``retq`` instruction.

This code is completely generic except for the stack space,
which is going to depend on how many variables are placed on the stack.
You can look at the examples in the ``reference`` directory to see
what the prelude and conclusion look like.
The code is easy to write,
although there are a number of trivial "boilerplate" conversions
because we are changing the datatype.


Running the ``compile`` program
-------------------------------

There are three basic ways to run the compiler
(the ``./compile`` program):

#. You can compile a source file up to a particular pass.
   For instance:

   .. code-block:: text

      $ ./compile tests/var_test_1.src -pass un

   will compile the code in ``tests/var_test_1.src`` up to the "un"
   (uniquify) pass, and print the output to the terminal.
   The passes for this assignment are:

   #. ``lvar`` -- AST (not really a pass)
   #. ``un`` -- uniquify
   #. ``rc`` -- remove complex operands
   #. ``ec`` -- explicate control
   #. ``si`` -- select instructions
   #. ``ah`` -- assign homes
   #. ``pi`` -- patch instructions
   #. ``pc`` -- prelude and conclusion
   #. ``pa`` -- print assembly language

   If you don't specify a pass, it will assume the pass ``pa``,
   which means compile all the way to assembly language.

#. You can compile a file up to a particular pass and then run
   an evaluator on the resulting code (for some passes).
   For instance:

   .. code-block:: text

      $ ./compile tests/var_test_1.src -pass un -eval

   will compile up to the ``un`` (uniquify) pass and then evaluate the
   resulting code.  Not all passes have evaluators; only the following
   passes do: ``lvar``, ``un``, ``rc``, ``ec``.

#. You can compile a single pass.  This requires that the input file
   be in the correct format for that pass.  We normally will use
   the file extensions ``.un``, ``.rc`` |etc| to indicate that a file
   has been compiled up to that pass.  For instance:

   .. code-block:: text

      $ ./compile tests/var_test_1.src -pass un > var_test_10.un
      $ cat var_test_10.un
      (Program
        (Let
          x.1
          Read
          (Let
            y.1
            Read
            (Add (Var x.1) (Negate (Var y.1))))))
      $ ./compile var_test_10.un -pass rc -only
      (Program
        (Let
          x.1
          Read
          (Let
            y.1
            Read
            (Let
              $tmp.1
              (Negate (Var y.1))
              (Add (Var x.1) (Var $tmp.1))))))

   This is a good way to test the code for a single pass, and you can do this
   even if the previous passes haven't been written.

   In the ``reference/`` subdirectory you will find the outputs of all the
   test scripts for all passes.  These can be used for one-pass tests.


Compiling and running assembly language code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have a computer running a 64-bit Intel or AMD processor
(which use the x86-64 instruction set), you can compile the
assembly language code that the compiler generates.

Let's use the ``var_test_5.src`` file as an example.
You will also need the C code files ``runtime.c`` and ``runtime.h``,
which should be in your ``ch2`` directory.

Here is the sequence of commands.  Note that assembly language files
normally end in ``.s``, so we redirect the compiler output to the
filename ``var_test_5.s`` and compile it with the ``gcc`` C compiler
(which needs to be installed if it isn't already).

.. code-block:: text

  $ ./compile tests/var_test_5.src > var_test_5.s
  $ gcc -c var_test_5.s
  $ gcc -c runtime.c
  $ gcc var_test_5.o runtime.o -o var_test_5
  $ ./var_test_5
  $ echo $?
  42

This compiles the assembly language file ``var_test_5.s``
to the binary executable program ``var_test_5``.
When this program is run, it doesn't appear to do anything.
However, the program returns an integer return code to the operating system,
which in this case is the number 42.  The line ``echo $?`` prints this number.

.. note::

   These return codes can only be in the range 0 to 255, so if you
   return an integer outside this range, it will be coerced into that range,
   leading sometimes to peculiar results.

If the program you are compiling has calls to the ``read`` function,
you will have to input the integers to be read when the program runs.


Testing the compiler
--------------------

There are currently two ways to test your compiler, one automated, and one
manual.  Both are valuable.

Automated tests
^^^^^^^^^^^^^^^

We are supplying you with a test script (written in Python) called
``run_eval_tests.py``.  This script can be used to test that a
particular ``.src`` file generate the correct output when given
particular inputs.  It uses metadata stored in comments in the ``.src`` files
in the ``/tests`` subdirectory.  For instance, consider the file
``var_test_10.src``:

.. code-block:: text

   ;; INPUT: 45 3 ; 21 20
   ;; OUTPUT: 42 ; 1
   (let (x (read))
     (let (y (read))
       (+ x (- y))))

The metadata is in the first two lines,
with the ``INPUT:`` and ``OUTPUT:`` tags.
These indicate that the program should be run twice:
the first time with (terminal) inputs ``45`` and ``3``,
producing the output ``42``,
and the second time with (terminal) inputs ``21`` and ``20``,
producing the output ``1``.

You invoke the test script this way:

.. code-block:: text

   $ python run_eval_tests.py tests/var_test_10.src

It will output:

.. code-block:: text

   ----
   input file: var_test_10.src

   * input/output data #1:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).
   Compiling to assembly language and compiling/running the program.

   * input/output data #2:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).
   Compiling to assembly language and compiling/running the program.

This can be done for many files, or even for all tests files at once:

.. code-block:: text

   $ python run_eval_tests.py tests/var_test_*.src

(This will produce a lot of output!)

If one of the evaluators produces incorrect output, an error message
will be printed and the test script will halt.

By default, the test script will not just test the program outputs using
the evaluators of the intermediate languages (``lvar``, ``lvar_mon``, |etc|),
but will also compile the code all the way to assembly language, run it,
and test the output against the expected output.
If you are runnign this script on a non-x86 machine
(like a Mac with an M1 processor), these tests can't run.  In that case,
you can add the ``-no-asm`` command-line argument
to skip the assembly language tests:

.. code-block:: text

   $ python run_eval_tests.py -no-asm tests/var_test_10.src
   ----
   input file: var_test_10.src

   * input/output data #1:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).

   * input/output data #2:

   Running test file (tests/var_test_10.src) up to pass (lvar).
   Running test file (tests/var_test_10.src) up to pass (un).
   Running test file (tests/var_test_10.src) up to pass (rc).
   Running test file (tests/var_test_10.src) up to pass (ec).

Note, though, that if there is a bug in the assembly language
code generation, these tests will not reveal it.
When we test your code, we will run all the tests.


Manual tests
^^^^^^^^^^^^

The automated tests are very useful for detecting problems,
but to really debug your compiler you will need to look at the output
of the compiler for known correct inputs.  These tests are very
difficult to automate, since sometimes you can have more than one
correct output for a particular input.

As a simple example, the "uniquify" pass will change the names of all the
variables to unique names, but what those names are isn't important. (The
course compiler might rename ``x`` to ``x.1`` while your compiler might rename
``x`` to ``x.101``; as long as the variable is used correctly, this is still
fine.)

Therefore, when working on a pass, we recommend that you use the
files in the ``reference/`` subdirectory along with the ``-only``
option of the compiler to compare what your pass does to the input code to
what the instructor's compiler did.
This is what we refer to as "manual tests".

Let's say you are working on the "remove complex operands" pass
and you think you have a working implementation.  You can run your compiler
on the output of the previous pass ("uniquify") and compare to the
corresponding file in the ``reference`` subdirectory.
The output of the ``uniquify`` pass will be a file ending in ``.un``.

.. code-block:: text

   $ cat reference/var_test_10.un
   (Program
     (Let
       x.1
       Read
       (Let
         y.1
         Read
         (Add (Var x.1) (Negate (Var y.1))))))
   $ ./compile reference/var_test_10.un -pass rc -only
   (Program
     (Let
       x.1
       Read
       (Let
         y.1
         Read
         (Let
           $tmp.1
           (Negate (Var y.1))
           (Add (Var x.1) (Var $tmp.1))))))
   $ cat reference/var_test_10.rc
   (Program
     (Let
       x.1
       Read
       (Let
         y.1
         Read
         (Let
           $tmp.1
           (Negate (Var y.1))
           (Add (Var x.1) (Var $tmp.1))))))

You can see that the file that your compiler generated is the same as the file
the instructor's compiler generated, so everything seems to be working. Of
course, some small differences may be found (you might name your temporary
variable ``$temp.1`` instead of ``$tmp.1``, for instance); this doesn't
indicate a mistake.  But if there is a structural difference, something
probably went wrong.

.. note::

   Structural differences do not always indicate incorrect code;
   in some cases you can transform code
   in a different way than what we wanted you to do
   and the resulting code will still evaluate correctly.
   However, in that case you are not implementing the pass correctly,
   so in most cases we will still consider this to be an error.

   A trivial example of this would be a register allocation pass
   where you just put all variables on the stack instead of in
   registers. (This is intentional in this assignment,
   but in most assignments it's not what you are supposed to do.)
   Though this is "wrong", the code will probably still run correctly.

Of course, you should test your compiler on more than just one source file.
Try to test on as many files as you can for a particular pass.
If you know how to write shell scripts,
this can be a useful way of making this kind of test semi-automatic
(just requiring that you look at the files to check for big differences).


"Submitting" your assignment
----------------------------

Unlike most courses, there is nothing to "hand in" in this course.
Instead, you need to inform the instructor (and TAs) when an assignment is
ready to be graded (hopefully, before or on the due date).
The instructor will check out your code, run the tests, and leave comments
in a file called GRADING in your ``ch2`` directory.  The instructor/TAs
may also leave comments in your code itself, with this syntax:

.. code-block:: ocaml

   (*** GRADER COMMENT: ... ***)

These should be removed when you fix whatever the comment complained about.

After the grading comments have been checked in to your repository,
you have one week to make changes (this is the first redo period).
Work redone during this period will be re-evaluated without penalty.
Any subsequent redos after the first redo will result in reduced credit
(typically, any additional marks after the first week
will get at most 50% credit).


Code reviews, office hours, and feedback
----------------------------------------

We will be setting up code review times for each team.  Make sure you choose a
time where both members of the team can meet as well as the instructor
(and/or a TA).

Code reviews do not require that all of the code be written, or that all of the
code is working correctly, but there is no point in doing a code review unless
most of the code has been written.  If you are having trouble at an earlier
stage, we will have office hour times you can come to.


----

.. rubric:: Footnotes

.. [1] That is, in *this* language.  In some of the later languages,
   the situation will change.

.. [2] Note that this language is not described in the book;
   the book simply outputs assembly language as a string.
   We use a more abstract representation because we plan to
   eventually have an x86-64 emulator which will use this
   language as its input (bypassing the need to parse actual assembly code).

.. [3] Aren't compilers fun?  You have to deal with all of this
   arbitrary nonsense, because otherwise you can't generate working code.
   That's the price you pay for doing something cool.

.. [4] Fun fact: There is no absolute requirement to use the ``%rbp``
   register to store the base pointer.  Many C compilers (|eg| ``gcc``)
   have an option to omit the base pointer entirely, which frees up
   this register to be used to store regular variables.
   This is a big deal for processors with very few registers
   (like 32 bit x86 processors) but less important for us, since
   x86-64 processors have 16 registers.
