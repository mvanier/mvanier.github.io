<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Assignment 3: Conditionals: the Cond language &mdash; The CS 164 book 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Assignment 4: Loops: the Loop language" href="../4/Assignment4.html" />
    <link rel="prev" title="Assignment 2: Register allocation" href="../2/Assignment2.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> The CS 164 book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin/index.html">Administrative information</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Assignments</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../coding_notes.html">OCaml coding notes and tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../0/Installing_OCaml.html">Installing OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../0/Assignment0.html">Assignment 0: Getting set up</a></li>
<li class="toctree-l2"><a class="reference internal" href="../0/Mac_notes.html">Notes on MacOS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/Assignment1.html">Assignment 1: The <em>Var</em> language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/Assignment2.html">Assignment 2: Register allocation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Assignment 3: Conditionals: the <em>Cond</em> language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#textbook-coverage">Textbook coverage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#due-date">Due date</a></li>
<li class="toctree-l3"><a class="reference internal" href="#starting-code-base">Starting code base</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-and-running-the-compiler">Compiling and running the compiler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-your-compiler-the-test-scripts">Testing your compiler: the test scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#new-language-features">New language features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-checking">Type checking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-to-write-the-compiler-passes">Code to write: the compiler passes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shrink-shrink-ml">1. Shrink (<code class="docutils literal notranslate"><span class="pre">shrink.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uniquify-uniquify-ml">2. Uniquify (<code class="docutils literal notranslate"><span class="pre">uniquify.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#remove-complex-operands-remove-complex-ml">3. Remove complex operands (<code class="docutils literal notranslate"><span class="pre">remove_complex.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicate-control-explicate-control-ml">4. Explicate control (<code class="docutils literal notranslate"><span class="pre">explicate_control.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#remove-unused-blocks-remove-unused-ml">5. Remove unused blocks (<code class="docutils literal notranslate"><span class="pre">remove_unused.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#select-instructions-select-instructions-ml">6. Select instructions (<code class="docutils literal notranslate"><span class="pre">select_instructions.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uncover-live-uncover-live-ml">7. Uncover live (<code class="docutils literal notranslate"><span class="pre">uncover_live.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#build-interference-graph-build-interference-ml">8. Build interference graph (<code class="docutils literal notranslate"><span class="pre">build_interference.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#graph-coloring-graph-coloring-ml">9. Graph coloring (<code class="docutils literal notranslate"><span class="pre">graph_coloring.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocate-registers-allocate-registers-ml">10. Allocate registers (<code class="docutils literal notranslate"><span class="pre">allocate_registers.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#remove-jumps-remove-jumps-ml">11. Remove jumps (<code class="docutils literal notranslate"><span class="pre">remove_jumps.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#patch-instructions-patch-instructions-ml">12. Patch instructions (<code class="docutils literal notranslate"><span class="pre">patch_instructions.ml</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prelude-and-conclusion-prelude-conclusion-ml">13. Prelude and conclusion (<code class="docutils literal notranslate"><span class="pre">prelude_conclusion.ml</span></code>)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#submitting-your-assignment">“Submitting” your assignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../4/Assignment4.html">Assignment 4: Loops: the <em>Loop</em> language</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The CS 164 book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Assignments</a> &raquo;</li>
      <li>Assignment 3: Conditionals: the <em>Cond</em> language</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/content/assignments/3/Assignment3.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="assignment-3-conditionals-the-cond-language">
<h1>Assignment 3: Conditionals: the <em>Cond</em> language<a class="headerlink" href="#assignment-3-conditionals-the-cond-language" title="Permalink to this heading"></a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>In this assignment, you will be extending the “Var” language compiler from the
last assignment and adding the following features:</p>
<ul class="simple">
<li><p>conditionals (<code class="docutils literal notranslate"><span class="pre">if</span></code> statements)</p></li>
<li><p>boolean values (true or false, written as <code class="docutils literal notranslate"><span class="pre">#t</span></code> and <code class="docutils literal notranslate"><span class="pre">#f</span></code>)</p></li>
<li><p>type checking (although you don’t have to write the type checking code)</p></li>
</ul>
</div>
<div class="section" id="textbook-coverage">
<h2>Textbook coverage<a class="headerlink" href="#textbook-coverage" title="Permalink to this heading"></a></h2>
<p>This assignment is based on chapter 4 of <em>Essentials of Compilation</em>.</p>
</div>
<div class="section" id="due-date">
<h2>Due date<a class="headerlink" href="#due-date" title="Permalink to this heading"></a></h2>
<p>This assignment is due on Monday, November 21st at 2 AM
(so, effectively very late Sunday night).</p>
</div>
<div class="section" id="starting-code-base">
<h2>Starting code base<a class="headerlink" href="#starting-code-base" title="Permalink to this heading"></a></h2>
<p>The starting code base is the zipfile <code class="docutils literal notranslate"><span class="pre">ch4.zip</span></code>, which is posted on the
course Canvas site.
You should unzip this file in your Github repo, inside the <code class="docutils literal notranslate"><span class="pre">src/</span></code> directory.
It contains partial implementations of all the code for the assignment.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We’ve made additional small changes in the <code class="docutils literal notranslate"><span class="pre">support</span></code> library code,
so you should also download the file <code class="docutils literal notranslate"><span class="pre">support.zip</span></code>
and use it to replace your existing <code class="docutils literal notranslate"><span class="pre">support</span></code> directory as follows
(from your <code class="docutils literal notranslate"><span class="pre">src</span></code> directory):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ git rm -rf support
$ unzip support.zip
$ rm support.zip
$ git add support
$ git commit support
</pre></div>
</div>
<p><strong>Be very careful</strong> when typing <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">support</span></code>.
Make sure you type that exact command; if you do
<code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">*</span></code> you could destroy most of your repository.</p>
</div>
<p>Inside the <code class="docutils literal notranslate"><span class="pre">ch4</span></code> directory will be these subdirectories:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">tests/</span></code> subdirectory contains the test programs for the compiler.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">reference/</span></code> subdirectory contains the output
from the instructor’s version of the compiler.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">scripts/</span></code> subdirectory contains scripts for testing your code.</p></li>
</ul>
</div>
<div class="section" id="compiling-and-running-the-compiler">
<h2>Compiling and running the compiler<a class="headerlink" href="#compiling-and-running-the-compiler" title="Permalink to this heading"></a></h2>
<p>To compile the compiler, <code class="docutils literal notranslate"><span class="pre">cd</span></code> into the <code class="docutils literal notranslate"><span class="pre">src/ch4</span></code> directory
and type <code class="docutils literal notranslate"><span class="pre">make</span></code>.
This will compile the compiler (which is an executable file called <code class="docutils literal notranslate"><span class="pre">compile</span></code>).
You should see a number of warnings when you compile the compiler;
that’s expected.
(As you fill in the code for the compiler passes,
these warnings will go away).</p>
<p>The command-line interface to the <code class="docutils literal notranslate"><span class="pre">compile</span></code> program is identical to that
of the previous assignment, except that there are three new passes:</p>
<ul class="simple">
<li><p>“shrink” (abbreviated <code class="docutils literal notranslate"><span class="pre">sh</span></code>)</p></li>
<li><p>“remove unused blocks” (abbreviated <code class="docutils literal notranslate"><span class="pre">ru</span></code>)</p></li>
<li><p>“remove jumps” (abbreviated <code class="docutils literal notranslate"><span class="pre">rj</span></code>)</p></li>
</ul>
</div>
<div class="section" id="testing-your-compiler-the-test-scripts">
<h2>Testing your compiler: the test scripts<a class="headerlink" href="#testing-your-compiler-the-test-scripts" title="Permalink to this heading"></a></h2>
<p>The test scripts are essentially unchanged from the last assignment,
except for those changes that had to be made
to accommodate the new compiler passes.</p>
</div>
<div class="section" id="new-language-features">
<h2>New language features<a class="headerlink" href="#new-language-features" title="Permalink to this heading"></a></h2>
<p>The new language features are described in the textbook and the lectures, but
in brief, they are:</p>
<ul class="simple">
<li><p>a <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> type</p></li>
<li><p>boolean values: true (<code class="docutils literal notranslate"><span class="pre">#t</span></code>) and false (<code class="docutils literal notranslate"><span class="pre">#f</span></code>)</p></li>
<li><p>relational operators (operators that return boolean values):
<code class="docutils literal notranslate"><span class="pre">eq?</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></li>
<li><p>new expressions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">and</span></code> (boolean AND)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">or</span></code>  (boolean OR)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not</span></code> (boolean NOT)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span></code>  (conditionals)</p></li>
</ul>
</li>
</ul>
<p>Note that <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, and <code class="docutils literal notranslate"><span class="pre">not</span></code> are implemented as operators.
The relational operators <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>
all take two integer operands and return a boolean.
The <code class="docutils literal notranslate"><span class="pre">eq?</span></code> (equality comparison) operator takes either
two integers or two booleans, and returns a boolean.</p>
<p>Operators don’t have separate intermediate language constructors
like <code class="docutils literal notranslate"><span class="pre">Add</span></code> and <code class="docutils literal notranslate"><span class="pre">Negate</span></code> from the <em>Var</em> language compiler;
all of these have been combined together into the <code class="docutils literal notranslate"><span class="pre">Prim</span></code> constructor,
which can take any number of arguments.
Checking that each operator receives the right number of arguments
is the responsibility of the type checkers.</p>
</div>
<div class="section" id="type-checking">
<h2>Type checking<a class="headerlink" href="#type-checking" title="Permalink to this heading"></a></h2>
<p>Since this language has two types (<code class="docutils literal notranslate"><span class="pre">Integer</span></code> and <code class="docutils literal notranslate"><span class="pre">Boolean</span></code>),
it needs a type checker.
In fact, two intermediate languages have type checkers:
the AST language (“Lif”)
and the C-like intermediate language (“Cif”).
The type checkers are supplied to you in the <code class="docutils literal notranslate"><span class="pre">Type_check</span></code>,
<code class="docutils literal notranslate"><span class="pre">Lif_type_check</span></code>, and <code class="docutils literal notranslate"><span class="pre">Cif_type_check</span></code> modules.
You will only notice them if your code fails to type check.</p>
</div>
<div class="section" id="code-to-write-the-compiler-passes">
<h2>Code to write: the compiler passes<a class="headerlink" href="#code-to-write-the-compiler-passes" title="Permalink to this heading"></a></h2>
<p>The compiler passes are described in chapter 4 of the textbook,
but here they are again for completeness.
(You should still read the book for a more in-depth explanation!)
We will only include passes that you have to implement.
As before, the only files you should modify are the <code class="docutils literal notranslate"><span class="pre">.ml</span></code> files
corresponding to these compiler passes.</p>
<div class="section" id="shrink-shrink-ml">
<h3>1. Shrink (<code class="docutils literal notranslate"><span class="pre">shrink.ml</span></code>)<a class="headerlink" href="#shrink-shrink-ml" title="Permalink to this heading"></a></h3>
<p>This is a new pass.
Its purpose is to remove the <code class="docutils literal notranslate"><span class="pre">and</span></code> and <code class="docutils literal notranslate"><span class="pre">or</span></code> forms
by translating them to <code class="docutils literal notranslate"><span class="pre">if</span></code> expressions using this translation:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(and e1 e2) --&gt; (if e1 e2 #f)
(or e1 e2)  --&gt; (if e1 #t e2)
</pre></div>
</div>
<p>This pass converts from the <code class="docutils literal notranslate"><span class="pre">Lif</span></code> language to the <code class="docutils literal notranslate"><span class="pre">Lif_shrink</span></code> language.
The only difference is that instead of using <code class="docutils literal notranslate"><span class="pre">all_op</span></code> as the operator type
for <code class="docutils literal notranslate"><span class="pre">Prim</span></code> expressions, it uses <code class="docutils literal notranslate"><span class="pre">core_op</span></code>,
which is like <code class="docutils literal notranslate"><span class="pre">all_op</span></code> except with <code class="docutils literal notranslate"><span class="pre">`And</span></code> and <code class="docutils literal notranslate"><span class="pre">`Or</span></code> removed.</p>
<p>This is an extremely simple pass to write.  Make sure you reject any calls
to <code class="docutils literal notranslate"><span class="pre">and</span></code> and <code class="docutils literal notranslate"><span class="pre">or</span></code> which don’t have exactly two arguments.</p>
</div>
<div class="section" id="uniquify-uniquify-ml">
<h3>2. Uniquify (<code class="docutils literal notranslate"><span class="pre">uniquify.ml</span></code>)<a class="headerlink" href="#uniquify-uniquify-ml" title="Permalink to this heading"></a></h3>
<p>This is essentially the same as the “uniquify” pass for the “Var” language
compiler, except that you have to add a case for the <code class="docutils literal notranslate"><span class="pre">If</span></code> constructor,
and all the operators have been combined in the <code class="docutils literal notranslate"><span class="pre">Prim</span></code> constructor.</p>
</div>
<div class="section" id="remove-complex-operands-remove-complex-ml">
<h3>3. Remove complex operands (<code class="docutils literal notranslate"><span class="pre">remove_complex.ml</span></code>)<a class="headerlink" href="#remove-complex-operands-remove-complex-ml" title="Permalink to this heading"></a></h3>
<p>The “remove complex operands” pass is essentially the same as in the
“Var” compiler, except for the necessary changes to accommodate
the new language forms.  Note that all three operands of an <code class="docutils literal notranslate"><span class="pre">if</span></code>
expression can be complex, but a <code class="docutils literal notranslate"><span class="pre">not</span></code> operator can only have an
atomic operand (since it’s a true operator).  <code class="docutils literal notranslate"><span class="pre">and</span></code> and <code class="docutils literal notranslate"><span class="pre">or</span></code>
have been removed by the <code class="docutils literal notranslate"><span class="pre">shrink</span></code> pass, so they don’t matter.</p>
</div>
<div class="section" id="explicate-control-explicate-control-ml">
<h3>4. Explicate control (<code class="docutils literal notranslate"><span class="pre">explicate_control.ml</span></code>)<a class="headerlink" href="#explicate-control-explicate-control-ml" title="Permalink to this heading"></a></h3>
<p>The “explicate control” pass has significant changes from the previous compiler.
This pass converts code in the “Lif_mon” language to the “Cif” language.
The “Cif” language is like “Cvar” from the previous compiler,
but with these changes/additions:</p>
<ul class="simple">
<li><p>a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> constructor for boolean literals</p></li>
<li><p>operator expressions using the <code class="docutils literal notranslate"><span class="pre">Prim</span></code> constructor used in the
“Lif” languages</p></li>
<li><p>extra <code class="docutils literal notranslate"><span class="pre">tail</span></code> constructors:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Goto</span></code> for unconditional jumps</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> for conditional jumps</p></li>
</ul>
</li>
</ul>
<p>The most significant change are conditional jumps
represented by the <code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> constructor of the <code class="docutils literal notranslate"><span class="pre">tail</span></code> datatype,
because then the code can go in one of two directions.
The <code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> constructor looks like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>IfStmt of {
  op : cmp_op;
  arg1 : atm;
  arg2 : atm;
  jump_then : label;
  jump_else : label;
}
</pre></div>
</div>
<p>This corresponds to a comparison operator which jumps to one label
if the comparison returns “true” (<code class="docutils literal notranslate"><span class="pre">#t</span></code>)
or to the other label if the comparison returns “false” (<code class="docutils literal notranslate"><span class="pre">#f</span></code>).
The labels correspond to blocks of instructions,
so the entire code is represented as a set of labelled blocks,
which we refer to as “basic blocks”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A “basic block” is a sequence of instructions that has no
internal jumps <em>i.e.</em> if there are any jump instructions
(like <code class="docutils literal notranslate"><span class="pre">Goto</span></code> or <code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> in the “Cif” language)
they only appear at the end of the block.</p>
</div>
<p>With code represented as a set of basic blocks connected by jumps,
the code representation is abstractly a graph, not a tree.
In particular,
code in the “Cif” language corresponds to a <em>directed acyclic graph</em> (DAG),
which we will discuss more below.</p>
<p>The “explicate control” pass from the previous compiler has these functions:</p>
<ul class="simple">
<li><p>a function to convert atoms (<code class="docutils literal notranslate"><span class="pre">convert_atom</span></code>)</p></li>
<li><p>a function to convert expressions (<code class="docutils literal notranslate"><span class="pre">convert_exp</span></code>)</p></li>
<li><p>a function to convert assignments (<code class="docutils literal notranslate"><span class="pre">explicate_assign</span></code>)</p></li>
<li><p>a function to convert expressions in “tail position” (<code class="docutils literal notranslate"><span class="pre">explicate_tail</span></code>)</p></li>
</ul>
<p>All of these are straightforward functions to implement.</p>
<p>For this compiler, we need to extend these functions
to deal with the new language constructs,
and we need to define an additional one for conditional expressions
(<code class="docutils literal notranslate"><span class="pre">explicate_pred</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">convert_atom</span></code> function needs to be extended to deal with the new
<code class="docutils literal notranslate"><span class="pre">Bool</span></code> constructor, which is trivial.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">convert_exp</span></code> function needs to handle operator expressions
differently to reflect the new <code class="docutils literal notranslate"><span class="pre">Prim</span></code> constructor.
Neither the <code class="docutils literal notranslate"><span class="pre">Let</span></code> nor the <code class="docutils literal notranslate"><span class="pre">If</span></code> constructor of the “Lif_mon” language
should be handled here.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">explicate_assign</span></code> function has to deal with <code class="docutils literal notranslate"><span class="pre">if</span></code> expressions
in <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings.  This is essentially this transformation:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(let (y (if e1 e2 e3)) tl)
--&gt;
(if e1 (let (y e2) tl) (let (y e3) tl))
</pre></div>
</div>
<p>except that the tails (<code class="docutils literal notranslate"><span class="pre">tl</span></code>) are not duplicated.  This can be achieved
by converting the tail to a block using the (provided) <code class="docutils literal notranslate"><span class="pre">create_block</span></code>
function and then using a <code class="docutils literal notranslate"><span class="pre">Goto</span></code> to that block for each tail.
To convert the <code class="docutils literal notranslate"><span class="pre">if</span></code> expression itself
requires the <code class="docutils literal notranslate"><span class="pre">explicate_pred</span></code> function, described below.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">explicate_tail</span></code> function needs to be extended
to handle <code class="docutils literal notranslate"><span class="pre">if</span></code> expressions. This also requires a call to <code class="docutils literal notranslate"><span class="pre">explicate_pred</span></code>.</p>
<p>Now we get to <code class="docutils literal notranslate"><span class="pre">explicate_pred</span></code>,
which is the most complicated function of the pass.
It’s the function that is called to convert <code class="docutils literal notranslate"><span class="pre">if</span></code> expressions,
as we’ve seen.
The arguments are:</p>
<ul class="simple">
<li><p>a boolean-valued test expression</p></li>
<li><p>tails for the “then” and “else” clauses of the <code class="docutils literal notranslate"><span class="pre">if</span></code> expression</p></li>
</ul>
<p>The most straightforward case is where
the test expression is an operator expression using a comparison operation.
In that case, an <code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> tail can be generated immediately.</p>
<p>Another simple case is when the test expression is a literal boolean.
In that case, either the “then” tail or the “else” tail
can be returned immediately (depending on the boolean’s value).
Negated literal booleans can be handled similarly.
(This is an example of partial evaluation.)</p>
<p>If the test case is a boolean-valued variable,
this can be converted to an equality comparison: <code class="docutils literal notranslate"><span class="pre">v</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">(eq</span> <span class="pre">v</span> <span class="pre">#t)</span></code>.</p>
<p>This leaves two trickier cases,
both of which can be described in terms of the transformations needed
to compile them.</p>
<ol class="arabic">
<li><p>The test expression is a <code class="docutils literal notranslate"><span class="pre">let</span></code>,
which means that the original <code class="docutils literal notranslate"><span class="pre">if</span></code> expression
is a <code class="docutils literal notranslate"><span class="pre">let</span></code> inside an <code class="docutils literal notranslate"><span class="pre">if</span></code>.
This is compiled using this transformation:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(if (let (x e1) e2) then_tl else_tl)
--&gt;
(let (x e1) (if e2 then_tl else_tl))
</pre></div>
</div>
<p>Of course, the <code class="docutils literal notranslate"><span class="pre">let</span></code> output ends up becoming an
<code class="docutils literal notranslate"><span class="pre">Assign</span></code> statement in the “Cif” language.</p>
</li>
<li><p>The test expression is another <code class="docutils literal notranslate"><span class="pre">if</span></code> expression,
which means that the original <code class="docutils literal notranslate"><span class="pre">if</span></code> expression
is an <code class="docutils literal notranslate"><span class="pre">if</span></code> inside an <code class="docutils literal notranslate"><span class="pre">if</span></code>.
This is compiled using this transformation:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(if (if e1 e2 e3) then_tl else_tl)
--&gt;
(if e1 (if e2 then_tl else_tl) (if e3 then_tl else_tl))
</pre></div>
</div>
<p>It’s important not to duplicate the tails, so convert them
to labels using the <code class="docutils literal notranslate"><span class="pre">create_block</span></code> function.
This will also require recursive calls to <code class="docutils literal notranslate"><span class="pre">explicate_pred</span></code>.</p>
</li>
</ol>
<p>One curious aspect of this pass is that we use imperative programming.
We have a global reference to a map between labels and blocks
to keep track of the basic blocks.
We could have done this using extra arguments,
but we felt that it was simpler with this small amount of
imperative programming. <a class="footnote-reference brackets" href="#id12" id="id1">6</a></p>
</div>
<div class="section" id="remove-unused-blocks-remove-unused-ml">
<h3>5. Remove unused blocks (<code class="docutils literal notranslate"><span class="pre">remove_unused.ml</span></code>)<a class="headerlink" href="#remove-unused-blocks-remove-unused-ml" title="Permalink to this heading"></a></h3>
<p>The “remove unused blocks” pass takes in a program in the “Cif”
intermediate language and also returns a program in this language.
Its job is to remove any blocks that can never be reached.
This could happen, for instance, if the test operand of an <code class="docutils literal notranslate"><span class="pre">if</span></code>
expression is <code class="docutils literal notranslate"><span class="pre">#t</span></code>.
In this kind of situation, any code generated by the “else” case will
end up in an unused block, since no other block will jump to it.
(Although the compilation of the <code class="docutils literal notranslate"><span class="pre">if</span></code> in <code class="docutils literal notranslate"><span class="pre">explicate_pred</span></code>
will discard the unused tail, the block corresponding to the tail
will have already been compiled, and it will become part of the output
of the “explicate control” pass.)
There is no point in having such blocks in the code, so this pass
removes them. <a class="footnote-reference brackets" href="#id7" id="id2">1</a></p>
<p>The basic algorithm is as follows:</p>
<ul class="simple">
<li><p>Start with a list of (label, tail) pairs.
(This is the way programs are represented in the “Cif” language.)</p></li>
<li><p>Convert it to a label to tail map.</p></li>
<li><p>Compute the set of all labels that are reachable from the “start” label.
You probably will want to write one or more helper functions to do this.
The <code class="docutils literal notranslate"><span class="pre">get_jump_labels</span></code> function in the <code class="docutils literal notranslate"><span class="pre">Cif</span></code> module will be useful.</p></li>
<li><p>Compute a list of (label, tail) pairs which only includes the
reachable labels; this is used to generate the output program.</p></li>
</ul>
<p>To figure out which labels are reachable from the “start” label,
use <code class="docutils literal notranslate"><span class="pre">get_jump_labels</span></code> to find the successors of “start”,
then find the successors of each of these, <em>etc.</em> until every reachable
label has been found.</p>
<p>This pass is short and should be fairly straightforward to implement.</p>
</div>
<div class="section" id="select-instructions-select-instructions-ml">
<h3>6. Select instructions (<code class="docutils literal notranslate"><span class="pre">select_instructions.ml</span></code>)<a class="headerlink" href="#select-instructions-select-instructions-ml" title="Permalink to this heading"></a></h3>
<p>The “select instructions” pass converts programs from the “Cif”
intermediate language to the “X86_var_if” intermediate language.
Overall, it is structured in the same way as it is in the “Var” compiler,
but with a number of additions to deal with the new forms of the “Cond”
language.</p>
<p>The new atom case for booleans is converted to one of the integers <code class="docutils literal notranslate"><span class="pre">0</span></code>
(false) or <code class="docutils literal notranslate"><span class="pre">1</span></code> (true).
These integers are stored in a one-byte segment of a register.
(We never put more than one boolean in a register.)</p>
<p>There are a number of new assembly language instructions that are generated:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xorq</span> <span class="pre">&lt;arg1&gt;,</span> <span class="pre">&lt;arg2&gt;</span></code> (XOR: used for logical negation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cmpq</span> <span class="pre">&lt;arg1&gt;,</span> <span class="pre">&lt;arg2&gt;</span></code> (used for comparisons)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setCC</span> <span class="pre">&lt;arg&gt;</span></code>
(sets a byte based on the contents of the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">movzbq</span> <span class="pre">&lt;arg1&gt;,</span> <span class="pre">&lt;arg2&gt;</span></code> (move from a one-byte register to a full register)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jCC</span> <span class="pre">&lt;label&gt;</span></code> (conditionally jump to a label)</p></li>
</ul>
<p>This needs a bit more explanation.</p>
<p>To negate a boolean variable (which is represented as <code class="docutils literal notranslate"><span class="pre">0</span></code> for false or
<code class="docutils literal notranslate"><span class="pre">1</span></code> for true), compute <code class="docutils literal notranslate"><span class="pre">xorq</span> <span class="pre">$1,</span> <span class="pre">&lt;var&gt;</span></code> (where <code class="docutils literal notranslate"><span class="pre">$1</span></code> is just the number 1
in assembly syntax <em>i.e.</em> an “immediate” value).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cmpq</span></code> instruction takes two arguments, compares them, and uses the
comparison to set a special “flags” register called <code class="docutils literal notranslate"><span class="pre">%rflags</span></code>. <a class="footnote-reference brackets" href="#id8" id="id3">2</a>
It takes its arguments in backwards order, so to test if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>, do
<code class="docutils literal notranslate"><span class="pre">cmpq</span> <span class="pre">y,</span> <span class="pre">x</span></code>.  The <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register can’t be read directly,
but the <code class="docutils literal notranslate"><span class="pre">setCC</span></code> family of instructions can set a byte based on its value.
Specifically, the <code class="docutils literal notranslate"><span class="pre">CC</span></code> (condition code) in <code class="docutils literal notranslate"><span class="pre">setCC</span></code> is one of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">e</span></code>  (for “equal”)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code>  (for “less than”)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">le</span></code> (for “less than or equal”)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code>  (for “greater than”)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ge</span></code> (for “greater than or equal”)</p></li>
</ul>
<p>So if the instruction <code class="docutils literal notranslate"><span class="pre">cmpq</span> <span class="pre">y,</span> <span class="pre">x</span></code> was done, and <code class="docutils literal notranslate"><span class="pre">x</span></code> was less than <code class="docutils literal notranslate"><span class="pre">y</span></code>,
the subsequent instruction <code class="docutils literal notranslate"><span class="pre">setl</span> <span class="pre">&lt;var&gt;</span></code> would set <code class="docutils literal notranslate"><span class="pre">&lt;var&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>,
since <code class="docutils literal notranslate"><span class="pre">setl</span></code> means
“set <code class="docutils literal notranslate"><span class="pre">&lt;var&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>
if the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register indicates that the last comparison
yielded a less-than result”.
As if this wasn’t weird enough,
the <code class="docutils literal notranslate"><span class="pre">&lt;var&gt;</span></code> argument of <code class="docutils literal notranslate"><span class="pre">setCC</span></code> instructions
can only be a byte register (a one-byte segment of a full register).
We only use the <code class="docutils literal notranslate"><span class="pre">al</span></code> byte register, which is part of the <code class="docutils literal notranslate"><span class="pre">%rax</span></code> register,
though in principle many more byte registers could be used.
(In the code, byte registers are a new constructor of the <code class="docutils literal notranslate"><span class="pre">arg</span></code> type
called <code class="docutils literal notranslate"><span class="pre">ByteReg</span></code>.)</p>
<p>Since the <code class="docutils literal notranslate"><span class="pre">setCC</span></code> instructions can only set byte registers,
but we normally work with full registers,
we need to be able to “move” a byte register into a full register,
which is what the <code class="docutils literal notranslate"><span class="pre">movzbq</span></code> instruction does.
Specifically, we will move from the <code class="docutils literal notranslate"><span class="pre">al</span></code> byte register
(which is the only such register we use)
to any full register we want.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">jCC</span></code> family of instructions represents conditional jumps;
the possible <code class="docutils literal notranslate"><span class="pre">CC</span></code> values are the same as for the <code class="docutils literal notranslate"><span class="pre">setCC</span></code> instructions.
To give an example, the <code class="docutils literal notranslate"><span class="pre">jle</span> <span class="pre">&lt;label&gt;</span></code> instruction jumps to the label
<code class="docutils literal notranslate"><span class="pre">&lt;label&gt;</span></code> if the value of the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register indicates that
the last <code class="docutils literal notranslate"><span class="pre">cmpq</span></code> instruction yielded a less-than-or-equal result.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">jCC</span></code> family of instructions are represented by the
<code class="docutils literal notranslate"><span class="pre">JmpIf</span></code> instruction in the intermediate languages.</p>
</div>
<p>The textbook (section 4.9) describes the translations between <code class="docutils literal notranslate"><span class="pre">Cif</span></code>
instructions and <code class="docutils literal notranslate"><span class="pre">X86_var_if</span></code> instructions.</p>
<p>Don’t forget to include the optimizations from the previous compiler.
The only new optimization you need to implement here is optimizing
<code class="docutils literal notranslate"><span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">(not</span> <span class="pre">&lt;var&gt;)</span></code> into a single instruction.</p>
</div>
<div class="section" id="uncover-live-uncover-live-ml">
<h3>7. Uncover live (<code class="docutils literal notranslate"><span class="pre">uncover_live.ml</span></code>)<a class="headerlink" href="#uncover-live-uncover-live-ml" title="Permalink to this heading"></a></h3>
<p>This pass has very significant changes, because the “Cond” language can
yield code with multiple blocks (not counting the prelude and conclusion),
and we have to know how to do the liveness analysis with these blocks.</p>
<p>In the previous compiler, we only had one block to deal with,
and we computed the liveness sets for each instruction
starting from the end of the block
and working back towards the beginning.
The liveness set at the end was set to be the registers <code class="docutils literal notranslate"><span class="pre">%rax</span></code> and <code class="docutils literal notranslate"><span class="pre">%rsp</span></code>,
which are used in the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block.</p>
<p>For this compiler, we use a similar strategy per block, but since there are
multiple blocks, we have to know in which order to handle them.
In addition, we have to know what the liveness set is at the end of each block
so that we can use that to work backwards towards the beginning.</p>
<p>Because we only have conditional expressions and not loops,
and because conditional expressions can only jump forwards in the code,
the directed graph formed by the blocks (the graph vertices or nodes)
and the jumps between blocks (the graph edges)
is a <em>directed acyclic graph</em> or “DAG”.
Lecture 12 has some pictures of DAGs formed from code blocks,
which we won’t repeat here.
The endpoint of the DAG is the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block,
since this block has only incoming and no outgoing edges.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, DAGs can have more than one “leaf” node
(node with no outgoing edges)
but in our case, the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block is the only one.
Control flow will always flow into the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block eventually,
as the code progresses towards the end of the <code class="docutils literal notranslate"><span class="pre">main</span></code> function.</p>
</div>
<p>It stands to reason that, since we already know what the liveness set
at the beginning of the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block is
(just the registers <code class="docutils literal notranslate"><span class="pre">%rax</span></code> and <code class="docutils literal notranslate"><span class="pre">%rsp</span></code>),
we should start liveness analysis in a block
that ends in a jump to that block.  But what about all the other blocks?</p>
<p>We need to do two things:</p>
<ol class="arabic simple">
<li><p>Compute the order of the block labels so that we know what order
we should compute the liveness sets in.</p></li>
<li><p>After computing the liveness sets for a block, record the
liveness set at the beginning of the block in a data structure;
this will become the final liveness set of any block
that jumps to this block.</p></li>
</ol>
<p>The way we deal with the first task is to compute a <em>directed graph</em>
of all the block labels by:</p>
<ol class="arabic simple">
<li><p>collecting the jump labels from each block,</p></li>
<li><p>using them to compute the graph edges (label to label pairs),</p></li>
<li><p>and constructing the graph.</p></li>
</ol>
<p>This graph is (potentially) a “multigraph”
(meaning that there can be multiple edges between the same blocks),
although if compilation has proceeded correctly,
there should only be at most one edge between any two blocks. <a class="footnote-reference brackets" href="#id11" id="id4">5</a>
This graph will be a DAG.
If you have a list of (label to label) edges,
you can construct the graph using the <code class="docutils literal notranslate"><span class="pre">LabelMgraph.of_list</span></code> function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before constructing the graph,
filter out the edges that contain the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> label,
since we won’t be doing liveness analysis on the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block!</p>
</div>
<p>Once we have the DAG, getting the right order of blocks
(actually block labels) is simple.
The DAG will point “forward” (towards the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block),
but we want to compute liveness “backwards”
(starting from the blocks which project directly to the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block).
To do this, we “flip the arrows” on the DAG,
which is known as “transposing” the graph.
This is not hard to do manually,
but the <code class="docutils literal notranslate"><span class="pre">LabelMgraph</span></code> module has a <code class="docutils literal notranslate"><span class="pre">transpose</span></code> function
that will do it for you.
After that, we need to order the labels so that
no label appears before all the labels that have edges to it
have already appeared.
This is known as a “topological sort”, and (you guessed it)
there is a function called “topological_sort” in the <code class="docutils literal notranslate"><span class="pre">LabelMgraph</span></code> module.
So once you have the DAG, just transpose it and topologically sort it,
and you have the correct order of block labels!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Topological sorts are in general not unique,
but if you use the library function the order of labels
you generate will be the same as the label order
in the instructor’s compiler.</p>
</div>
<p>Once we have the order of the labels,
we create a map between labels and their live-before sets
called <code class="docutils literal notranslate"><span class="pre">live_before_labels</span></code>.
We initialize this with the live-before set of the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block.
Then we process each block in the order of their labels,
and when we compute the live-before set for each block,
we add it to the <code class="docutils literal notranslate"><span class="pre">live_before_labels</span></code> map.
That way, each block will have the live-before set of all blocks
that the block can jump to precomputed
when the block’s liveness sets are computed.</p>
<p>Computing liveness sets for individual blocks is done the same way
as in the previous compiler,
but with additional cases for the new instructions.
Most of the changes are obvious, but some are not.
<code class="docutils literal notranslate"><span class="pre">movzbq</span></code> instructions act like <code class="docutils literal notranslate"><span class="pre">movq</span></code> instructions
in terms of liveness calculations.
The <code class="docutils literal notranslate"><span class="pre">cmpq</span></code> instruction reads from both arguments
and writes to the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register.
The <code class="docutils literal notranslate"><span class="pre">setCC</span></code> family reads from the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register
and writes to its argument.</p>
<p><code class="docutils literal notranslate"><span class="pre">jmp</span></code> and <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instructions require special treatment.
They only occur at the end of blocks, and there are only two cases
we will encounter.</p>
<ol class="arabic simple">
<li><p>The block ends in a <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instruction followed by a <code class="docutils literal notranslate"><span class="pre">jmp</span></code>
instruction.</p></li>
<li><p>The block ends in a <code class="docutils literal notranslate"><span class="pre">jmp</span></code> instruction without a <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code>
preceding it.</p></li>
</ol>
<p>The second case is easy; we look up the jump target label in the
<code class="docutils literal notranslate"><span class="pre">live_before_labels</span></code> map, and the live-before set we find
is also the live-before set of the <code class="docutils literal notranslate"><span class="pre">jmp</span></code> instruction.</p>
<p>The first case is more subtle.
For the <code class="docutils literal notranslate"><span class="pre">jmp</span></code> instruction which follows the <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instruction,
we again just make the live-before set of the jump target
the live-before set of the instruction.
For the <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instruction, we have <em>two</em> jump targets:
the one from the following <code class="docutils literal notranslate"><span class="pre">jmp</span></code> instruction
and the one from the label in the <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instruction itself.
We need to compute the <em>union</em> of the live-before sets from both jump targets,
since we have no way of knowing which block the instruction will jump to.
So we union the live-before set of the <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instruction’s target
with the live-before set from the <code class="docutils literal notranslate"><span class="pre">jmp</span></code> instruction to compute
the live-before set of the <code class="docutils literal notranslate"><span class="pre">jmpIf</span></code> instruction.
Then we compute the liveness set of each instruction in the block as usual.</p>
<p>That’s all for this pass!
Fortunately, the rest of the passes are much simpler.</p>
</div>
<div class="section" id="build-interference-graph-build-interference-ml">
<h3>8. Build interference graph (<code class="docutils literal notranslate"><span class="pre">build_interference.ml</span></code>)<a class="headerlink" href="#build-interference-graph-build-interference-ml" title="Permalink to this heading"></a></h3>
<p>The main changes needed here are to accommodate the new assembly instructions.
The <code class="docutils literal notranslate"><span class="pre">movzbq</span></code> instruction should be handled like a <code class="docutils literal notranslate"><span class="pre">movq</span></code> instruction.
Byte registers need to be converted to their corresponding registers;
there is a function <code class="docutils literal notranslate"><span class="pre">reg_of_bytereg</span></code> in the <code class="docutils literal notranslate"><span class="pre">Types</span></code> module
that may be useful.  You should consider the destination of the <code class="docutils literal notranslate"><span class="pre">cmpq</span></code>
instruction to be the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This could possiblly have been left out, since <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> isn’t
a register used for register allocation, but we put it in for
completeness.  It doesn’t cause problems, since we always read
from <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> immediately after writing to it.</p>
</div>
<p>Everything else is pretty much as you’d expect.</p>
</div>
<div class="section" id="graph-coloring-graph-coloring-ml">
<h3>9. Graph coloring (<code class="docutils literal notranslate"><span class="pre">graph_coloring.ml</span></code>)<a class="headerlink" href="#graph-coloring-graph-coloring-ml" title="Permalink to this heading"></a></h3>
<p>The graph coloring code is unchanged from the previous assignment. <a class="footnote-reference brackets" href="#id9" id="id5">3</a></p>
</div>
<div class="section" id="allocate-registers-allocate-registers-ml">
<h3>10. Allocate registers (<code class="docutils literal notranslate"><span class="pre">allocate_registers.ml</span></code>)<a class="headerlink" href="#allocate-registers-allocate-registers-ml" title="Permalink to this heading"></a></h3>
<p>We’ve added a couple of features to the template code for the
“allocate registers” pass.
The register color list includes the <code class="docutils literal notranslate"><span class="pre">%rflags</span></code> register, with color <code class="docutils literal notranslate"><span class="pre">-6</span></code>.
A new function called <code class="docutils literal notranslate"><span class="pre">check_no_variables</span></code> checks
that the output of this pass contains no unresolved variable references.
(This could have been added to the previous compilers as well.)
Aside from this, the changes you need to make are in the <code class="docutils literal notranslate"><span class="pre">convert_instr</span></code>
function to handle the new assembly instructions.
The changes are very straightforward,
but you should check that the first argument of <code class="docutils literal notranslate"><span class="pre">movzbq</span></code>
and the argument of <code class="docutils literal notranslate"><span class="pre">setCC</span></code> instructions are byte registers.</p>
</div>
<div class="section" id="remove-jumps-remove-jumps-ml">
<h3>11. Remove jumps (<code class="docutils literal notranslate"><span class="pre">remove_jumps.ml</span></code>)<a class="headerlink" href="#remove-jumps-remove-jumps-ml" title="Permalink to this heading"></a></h3>
<p>This is an optimization pass which is an optional pass in the textbook.
It’s fairly simple to implement, so we’re making it mandatory. <em class="fa fa-smile-o"></em></p>
<p>The pseudocode for the algorithm is given in the file <code class="docutils literal notranslate"><span class="pre">remove_jumps.ml</span></code>,
as well as stubs for the functions we used.
(You can replace them with your functions if you like,
as long as you don’t change the module interface.)
Note that we define a <code class="docutils literal notranslate"><span class="pre">get_jump_labels</span></code> function
which has the same name as a function in the <code class="docutils literal notranslate"><span class="pre">Cif</span></code> module,
but is different because it takes an <code class="docutils literal notranslate"><span class="pre">X86_var_if</span></code> block as its argument,
whereas the other took a <code class="docutils literal notranslate"><span class="pre">Cif</span></code> tail.</p>
<p>This code also uses directed graphs (not multigraphs),
which are implemented in the <code class="docutils literal notranslate"><span class="pre">support/dgraph.ml[i]</span></code> files.
(We could have used multigraphs,
but the actual graphs only have at most one edge between blocks.)
We start the algorithm by converting the (label, block) list into a directed
graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When building the label graph, do not include the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code>
label, because we don’t allow merging with the <code class="docutils literal notranslate"><span class="pre">conclusion</span></code> block.</p>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">merge_blocks</span></code> function, we used two utility functions from the
<code class="docutils literal notranslate"><span class="pre">Utils</span></code> module: <code class="docutils literal notranslate"><span class="pre">last</span></code> and <code class="docutils literal notranslate"><span class="pre">butlast</span></code> to get the last element in a list,
and all but the last element, respectively.</p>
<p>The algorithm consists of finding two labels which correspond to blocks that
can be merged, and merging them using the <code class="docutils literal notranslate"><span class="pre">merge_blocks</span></code> function and the
<code class="docutils literal notranslate"><span class="pre">merge_vertices</span></code> function of the <code class="docutils literal notranslate"><span class="pre">LabelDgraph</span></code> module.  (The latter is
needed because when you merge two blocks, the label of the second block goes
away.)  We find mergeable labels using the <code class="docutils literal notranslate"><span class="pre">get_mergeable_labels</span></code> function,
which returns a pair of mergeable labels if there is one.  We use the
<code class="docutils literal notranslate"><span class="pre">neighbors_in</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbors_out</span></code> functions of the <code class="docutils literal notranslate"><span class="pre">LabelDgraph</span></code> module
to find the candidate pairs.  Essentially, we collect all labels with only one
out neighbor and look in those labels for one that has only one in neighbor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It would probably be more efficient to find all pairs of mergeable labels,
but since merging two labels changes the graph, it’s safer to do it one pair
at a time.  We’re not trying for ultimate efficiency here.</p>
</div>
<p>The algorithm is repeated until there are no more mergeable blocks.</p>
</div>
<div class="section" id="patch-instructions-patch-instructions-ml">
<h3>12. Patch instructions (<code class="docutils literal notranslate"><span class="pre">patch_instructions.ml</span></code>)<a class="headerlink" href="#patch-instructions-patch-instructions-ml" title="Permalink to this heading"></a></h3>
<p>There are a few small additions that need to be made
to the “patch instructions” pass to handle the new assembly instructions.</p>
<div class="section" id="setcc">
<h4><code class="docutils literal notranslate"><span class="pre">setCC</span></code><a class="headerlink" href="#setcc" title="Permalink to this heading"></a></h4>
<p>The argument of any of the <code class="docutils literal notranslate"><span class="pre">setCC</span></code> family of instructions
(<code class="docutils literal notranslate"><span class="pre">setl</span></code>, <code class="docutils literal notranslate"><span class="pre">setle</span></code>, <code class="docutils literal notranslate"><span class="pre">sete</span></code>, <code class="docutils literal notranslate"><span class="pre">setg</span></code>, <code class="docutils literal notranslate"><span class="pre">setge</span></code>)
must be a byte register, or it’s an error.</p>
</div>
<div class="section" id="xorq">
<h4><code class="docutils literal notranslate"><span class="pre">xorq</span></code><a class="headerlink" href="#xorq" title="Permalink to this heading"></a></h4>
<p>As with other operators, only one of the two operands of <code class="docutils literal notranslate"><span class="pre">xorq</span></code>
can be a stack location (<em>i.e.</em> a memory reference).</p>
</div>
<div class="section" id="movzbq">
<h4><code class="docutils literal notranslate"><span class="pre">movzbq</span></code><a class="headerlink" href="#movzbq" title="Permalink to this heading"></a></h4>
<p>The first argument to <code class="docutils literal notranslate"><span class="pre">movzbq</span></code> should be a byte register. <a class="footnote-reference brackets" href="#id10" id="id6">4</a>
It should already be a byte register, so if it isn’t, that’s an error.</p>
<p>The second argument must be a regular register. If it isn’t (<em>e.g.</em> if it’s a
stack location), replace the second argument with <code class="docutils literal notranslate"><span class="pre">%rax</span></code>
and then add a <code class="docutils literal notranslate"><span class="pre">movq</span></code> instruction to put the contents of <code class="docutils literal notranslate"><span class="pre">%rax</span></code>
into the second argument.</p>
</div>
<div class="section" id="cmpq">
<h4><code class="docutils literal notranslate"><span class="pre">cmpq</span></code><a class="headerlink" href="#cmpq" title="Permalink to this heading"></a></h4>
<p>As with other operators, only one of the two operands of <code class="docutils literal notranslate"><span class="pre">cmpq</span></code>
can be a stack location.</p>
<p>In addition, the second argument of <code class="docutils literal notranslate"><span class="pre">cmpq</span></code> can’t be an immediate value,
so if it is, move it to <code class="docutils literal notranslate"><span class="pre">%rax</span></code> and use <code class="docutils literal notranslate"><span class="pre">%rax</span></code> instead.</p>
</div>
</div>
<div class="section" id="prelude-and-conclusion-prelude-conclusion-ml">
<h3>13. Prelude and conclusion (<code class="docutils literal notranslate"><span class="pre">prelude_conclusion.ml</span></code>)<a class="headerlink" href="#prelude-and-conclusion-prelude-conclusion-ml" title="Permalink to this heading"></a></h3>
<p>The only changes to this pass from the previous compiler
are the obvious changes to handle the new assembly instructions
and byte registers.</p>
</div>
</div>
<div class="section" id="submitting-your-assignment">
<h2>“Submitting” your assignment<a class="headerlink" href="#submitting-your-assignment" title="Permalink to this heading"></a></h2>
<p>The assignment will be graded in your Github repository as usual,
in the <code class="docutils literal notranslate"><span class="pre">ch4</span></code> directory.</p>
<hr class="docutils" />
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>This is one example of what is called <em>dead code elimination</em>
in the compiler literature, which means removing code which cannot
have any effect on the final result of a program.  Dead code comes in
many forms besides this.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>The textbook incorrectly calls this EFLAGS,
which is an older name that is appropriate for 32-bit x86 systems only.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>This is the benefit of programming an algorithm as a functor
that works on abstract values! Go OCaml! <em class="fa fa-smile-o"></em></p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>Technically, it could also be an immediate value,
but we won’t be using it that way.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id4">5</a></span></dt>
<dd><p>The textbook insists on using multigraphs,
but in fact, regular directed graphs could have been used instead.
Nevertheless, this doesn’t change the algorithm.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id1">6</a></span></dt>
<dd><p>Of course, one nice thing about OCaml is that you can choose
to use imperative programming whenever it suits you,
and avoid it when it’s unnecessary.</p>
</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../2/Assignment2.html" class="btn btn-neutral float-left" title="Assignment 2: Register allocation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../4/Assignment4.html" class="btn btn-neutral float-right" title="Assignment 4: Loops: the Loop language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Michael C. Vanier. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>