<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OCaml coding notes and tips &mdash; The CS 164 book 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Installing OCaml" href="0/Installing_OCaml.html" />
    <link rel="prev" title="Assignments" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> The CS 164 book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin/index.html">Administrative information</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Assignments</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">OCaml coding notes and tips</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warnings">Warnings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functional-style-by-default">Functional style by default</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tail-recursion-by-default">Tail recursion by default</a></li>
<li class="toctree-l3"><a class="reference internal" href="#persistent-data-structures">Persistent data structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-annotations">Type annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#folds-are-your-friend">Folds are your friend!</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#left-vs-right-folds">Left <em>vs.</em> right folds</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#nested-pattern-matching">Nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#write-stubs">Write stubs!</a></li>
<li class="toctree-l3"><a class="reference internal" href="#use-wishful-thinking">Use wishful thinking!</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-tips">Debugging tips</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printf-style-debugging"><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-repl">Using the REPL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#insert-debugging-code-into-tricky-algorithms">Insert debugging code into tricky algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="0/Installing_OCaml.html">Installing OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="0/Assignment0.html">Assignment 0: Getting set up</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The CS 164 book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Assignments</a> &raquo;</li>
      <li>OCaml coding notes and tips</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/content/assignments/coding_notes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="ocaml-coding-notes-and-tips">
<h1>OCaml coding notes and tips<a class="headerlink" href="#ocaml-coding-notes-and-tips" title="Permalink to this heading"></a></h1>
<p>Here are some notes and tips
that should improve your OCaml programming experience.
We also describe our expectations
of how we want you to write your OCaml code,
so don’t just skip this document!</p>
<div class="section" id="warnings">
<h2>Warnings<a class="headerlink" href="#warnings" title="Permalink to this heading"></a></h2>
<p>Warnings are always bad, unless you expect them (<em>e.g.</em> because code is only
partially written).  Never ignore warnings.  Your finished code should <em>never</em>
generate warnings.</p>
</div>
<div class="section" id="functional-style-by-default">
<h2>Functional style by default<a class="headerlink" href="#functional-style-by-default" title="Permalink to this heading"></a></h2>
<p>Code should be written in a functional style (no <code class="docutils literal notranslate"><span class="pre">ref</span></code>s, arrays, or records
with mutable fields) except where indicated.  Marks will be taken off if this
rule is violated.  We will let you know when it’s OK to use imperative idioms.
Certain imperative idioms (like <code class="docutils literal notranslate"><span class="pre">while</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code> loops) are almost never
used, but we do use <code class="docutils literal notranslate"><span class="pre">ref</span></code> cells on occasion to make code simpler.</p>
<p>Many of the tips below describe ways to effectively use functional style.
They are not in any particular order, so feel free to browse until you find
something interesting.</p>
</div>
<div class="section" id="tail-recursion-by-default">
<h2>Tail recursion by default<a class="headerlink" href="#tail-recursion-by-default" title="Permalink to this heading"></a></h2>
<p>As you recall, a lot of CS 4 was spent teaching you to write functions using
recursion instead of loops, and specifically tail recursion.  We use tail
recursion because it has desirable space properties, so in general,
when you write a recursive function, try hard to make it tail recursive.
If you can’t do this, be prepared to explain why during code reviews.</p>
</div>
<div class="section" id="persistent-data-structures">
<h2>Persistent data structures<a class="headerlink" href="#persistent-data-structures" title="Permalink to this heading"></a></h2>
<p>Probably the hardest part of using functional programming effectively is
getting used to persistent data structures (like lists) instead of mutable data
structures (like arrays).</p>
<p>In this course, almost all data structures are persistent, which means that
when you change something in the data structure, it returns the updated version
without altering the input version.  This is very different to how imperative
languages work.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you think you need to use <code class="docutils literal notranslate"><span class="pre">List.iter</span></code>
(which would be appropriate for a mutable data structure)
you almost always want to actually use <code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code>
or an iterative helper function
(which is appropriate for a persistent data structure).</p>
</div>
<p>Even though you may find functional programming awkward at first,
it is <em>vastly</em> easier to write correct code
in a functional style than in an imperative style.
There is simply less that can go wrong.</p>
</div>
<div class="section" id="type-annotations">
<h2>Type annotations<a class="headerlink" href="#type-annotations" title="Permalink to this heading"></a></h2>
<p>We <em>strongly</em> recommend that you add type annotations
to all functions that are internal to a module.
It will save you a lot of grief.
Just because OCaml can do type inference
doesn’t mean that you have to rely on it!
When you specify the types manually,
you will usually get better error messages.</p>
<p>For example, instead of writing this code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">lst</span> <span class="k">else</span> <span class="n">h</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">t</span>
</pre></div>
</div>
<p>write it like this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">lst</span> <span class="k">else</span> <span class="n">h</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">t</span>
</pre></div>
</div>
<p>(Actually, you’d probably rewrite it to be tail recursive, but that’s
another topic.)  In many cases, you could substitute a more specific
type for <code class="docutils literal notranslate"><span class="pre">'a</span></code> (say, <code class="docutils literal notranslate"><span class="pre">int</span></code>), which would be beneficial
in the event that the type that was actually passed to <code class="docutils literal notranslate"><span class="pre">insert</span></code>
was something other than a list of <code class="docutils literal notranslate"><span class="pre">int</span></code>s.</p>
<p>Also, don’t remove the type annotations once the code is working
“because it looks prettier”; leave them in.
It’s good documentation and it will be really important
if you ever have to modify the code.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We didn’t have this guideline in CS 4,
primarily because the code base was so much smaller.
The more complicated the code gets,
the more helpful explicit type annotations are.</p>
</div>
</div>
<div class="section" id="folds-are-your-friend">
<h2>Folds are your friend!<a class="headerlink" href="#folds-are-your-friend" title="Permalink to this heading"></a></h2>
<p>Programmers new to OCaml are often frustrated by what they perceive as the
difficulty of doing simple things.  A good example of this is accumulation.
You have a list and want to compute some value from the list elements.
For instance, say you want to get the maximum value of the list (and assume
that you only have a two-element <code class="docutils literal notranslate"><span class="pre">max</span></code> function to compute maximums).
A Python programmer could immediately write this code:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">max_list</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the maximum of a list of positive integers.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mx</span>
</pre></div>
</div>
<p>In OCaml, we do this sort of thing using folds, specifically left folds.</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max_list</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">mx</span> <span class="n">item</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">mx</span> <span class="n">item</span><span class="o">)</span>
    <span class="mi">0</span>
    <span class="n">lst</span>
</pre></div>
</div>
<p>This can be simplified further:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max_list</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">max</span> <span class="mi">0</span> <span class="n">lst</span>
</pre></div>
</div>
<p>Whenever you need to write code which accumulates something over a list,
you generally want to use a fold.</p>
<p>A common beginner’s style error is to do this with an iterative helper
function:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max_list</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">iter</span> <span class="n">rest</span> <span class="n">mx</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">rest</span> <span class="k">with</span>
      <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">mx</span>
      <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">mx</span> <span class="k">then</span> <span class="n">iter</span> <span class="n">t</span> <span class="n">h</span> <span class="k">else</span> <span class="n">iter</span> <span class="n">t</span> <span class="n">mx</span>
  <span class="k">in</span>
    <span class="n">iter</span> <span class="n">lst</span> <span class="mi">0</span>
</pre></div>
</div>
<p>This is not so bad, but the iterative helper function can be replaced by
<code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code> and the entire function becomes a one-liner!
Be alert for this kind of situation –
there’s no benefit to using a functional language
if you don’t take advantage of what it offers.</p>
<p>On the other hand, sometimes you are accumulating more than one thing in an
iteration. You can still use <code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code> in such cases by accumulating a
tuple of all the things you’re accumulating, but in my experience, it’s often
easier to just write an iterative helper function.</p>
<div class="section" id="left-vs-right-folds">
<h3>Left <em>vs.</em> right folds<a class="headerlink" href="#left-vs-right-folds" title="Permalink to this heading"></a></h3>
<p>95% of the time or more, if you want to use a fold in OCaml,
you want to use a left fold (<code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code>)
instead of a right fold (<code class="docutils literal notranslate"><span class="pre">List.fold_right</span></code>).
Left folds are tail recursive (space efficient) and are more natural
than right folds, which are also less space efficient.</p>
<p>On the other hand, there are cases where right folds are the right thing to
use.  When you want to accumulate things in a list from the right going back
to the left, a right fold is usually going to be simpler than a left fold,
and you shouldn’t feel bad about using one.</p>
</div>
</div>
<div class="section" id="nested-pattern-matching">
<h2>Nested pattern matching<a class="headerlink" href="#nested-pattern-matching" title="Permalink to this heading"></a></h2>
<p>It’s very common to want to write a pattern match inside another
pattern match.  There are two cases to consider.</p>
<ol class="arabic">
<li><p>Where the two pattern matches can be combined.  Consider this code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">maybe_lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">option</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">maybe_lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">lst</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
          <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">h</span>
          <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="k">end</span>
</pre></div>
</div>
<p>You can merge both pattern matches as follows:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">maybe_lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">option</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">maybe_lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">h</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>Note how much shorter and clearer the code is.
Also note the use of the wildcard (<code class="docutils literal notranslate"><span class="pre">_</span></code>) pattern
for “don’t care” situations.</p>
<p>Merging pattern matches is almost always possible if the
inner pattern match doesn’t depend on a value computed using
information from the outer pattern match.
Unnecessary pattern matches are bad style and will be marked down.</p>
</li>
<li><p>Where the two pattern matches <em>can’t</em> be combined.
Consider this code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">t</span> <span class="k">with</span>
          <span class="o">|</span> <span class="n">h&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">)</span>
          <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="k">end</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>The inner match is matching on the result of the <code class="docutils literal notranslate"><span class="pre">List.sort</span></code>
function applied to the tail of the list.
You can’t combine these pattern matches because the inner one
depends on a value which must be computed (it’s not structural).
For very simple cases, you can use a <code class="docutils literal notranslate"><span class="pre">when</span></code> clause instead of
the inner match, but often this isn’t feasible.
So you have nested <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions.</p>
<p>When you have nested <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions, you must surround them
by either <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> delimiters (as we did above) or parentheses,
which looks like this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="o">(</span><span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">t</span> <span class="k">with</span>
         <span class="o">|</span> <span class="n">h&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">)</span>
         <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>Using parentheses looks more concise, but it’s easy to forget to close
the open parenthesis, so we prefer to use <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code>.
(It reads better, too.)  What you definitely do <em>not</em> want to do is this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">t</span> <span class="k">with</span>
        <span class="o">|</span> <span class="n">h&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">)</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>If you do this, you will get strange error messages because
OCaml will consider the last line to be part of the inner pattern match.
Remember, <strong>OCaml is not whitespace sensitive!</strong>
So don’t forget the <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code>.</p>
</li>
</ol>
</div>
<div class="section" id="write-stubs">
<h2>Write stubs!<a class="headerlink" href="#write-stubs" title="Permalink to this heading"></a></h2>
<p>When you are starting to write a function, write a “stub”.
This is an incomplete function. Just put in</p>
<ul class="simple">
<li><p>the arguments</p></li>
<li><p>type annotations for arguments and the return type
(This is _very_ important!  Don’t skip this step!)</p></li>
<li><p>and <code class="docutils literal notranslate"><span class="pre">failwith</span> <span class="pre">&quot;TODO&quot;</span></code> for the body.</p></li>
</ul>
<p>Then fill it in later.</p>
<p>Here’s an example of a stub:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">halts_on_all_inputs</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span>
  <span class="n">failwith</span> <span class="s2">&quot;TODO&quot;</span>
</pre></div>
</div>
<p>This particular function might be a bit hard to complete, though.</p>
<p>Writing stubs is a great way to get past “coder’s block”.
Once the stub is written,
you can compile it and make sure it type checks.
If it’s recursive, you can usually easily fill in the base cases.
At that point, you’re ready to work on the body of the function.</p>
</div>
<div class="section" id="use-wishful-thinking">
<h2>Use wishful thinking!<a class="headerlink" href="#use-wishful-thinking" title="Permalink to this heading"></a></h2>
<p>If a function seems too difficult/complex to write directly,
ask yourself “what function do I need
which would make it really easy to write this function?”
Then assume that <em>that</em> function exists
(<em>i.e.</em> write a stub for it),
and write your main function using the assumed function.
When that’s done, go back and write the body of the assumed function.</p>
<p>This is one of <em>the</em> most useful programming tips.  It’s explored at some
length in the book SICP (Structure and Interpretation of Computer Programs),
which is an amazing book (and which is the basis of CS 4).</p>
</div>
<div class="section" id="debugging-tips">
<h2>Debugging tips<a class="headerlink" href="#debugging-tips" title="Permalink to this heading"></a></h2>
<p>Although strictly-typed functional languages like OCaml greatly reduce the
number of bugs in your programs, you will still make mistakes and have to debug
them.  Debugging functional languages can be challenging; here are some tips
we’ve found to be useful.</p>
<div class="section" id="printf-style-debugging">
<h3><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style debugging<a class="headerlink" href="#printf-style-debugging" title="Permalink to this heading"></a></h3>
<p>“printf”-style debugging is highly effective if you do it right.  The wrong
way is to add <code class="docutils literal notranslate"><span class="pre">printf</span></code> statements to otherwise functional code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;x = %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">x</span><span class="o">;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Even though this can work, you are embedding imperative code inside
functional code, and you can get into tricky syntax issues as a result.
A better way to do it is like this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;x = %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>This also embeds imperative code, but uses functional syntax, so there
won’t be any syntax issues.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the surrounding code is imperative (like a <code class="docutils literal notranslate"><span class="pre">begin</span></code> expression
or the body of a <code class="docutils literal notranslate"><span class="pre">for</span></code> or <code class="docutils literal notranslate"><span class="pre">while</span></code> loop), the exact opposite criterion
applies: favor the naked <code class="docutils literal notranslate"><span class="pre">Printf.printf</span> <span class="pre">...</span></code> instead of the
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">Printf.printf</span> <span class="pre">...</span></code> idiom.  However, in well-written OCaml
code, <code class="docutils literal notranslate"><span class="pre">while</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code> loops should be almost nonexistent.</p>
</div>
<p>Also, you should add <code class="docutils literal notranslate"><span class="pre">%!</span></code> at the end of the <code class="docutils literal notranslate"><span class="pre">printf</span></code> format string:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;x = %s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>This makes OCaml flush the string as soon as the <code class="docutils literal notranslate"><span class="pre">printf</span></code> executes.
If you don’t do that, sometimes error messages before a crash can be lost.</p>
<p>Finally, for debugging, consider writing your <code class="docutils literal notranslate"><span class="pre">printf</span></code>s this way:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;DEBUG: x = %s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">x</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>This way, it’s easy to spot these lines, which is good because you are
going to want to delete them once debugging is done.</p>
</div>
<div class="section" id="using-the-repl">
<h3>Using the REPL<a class="headerlink" href="#using-the-repl" title="Permalink to this heading"></a></h3>
<p>“REPL” means “Read-Eval-Print-Loop” and refers to the interactive interpreter
(what you get into if you type <code class="docutils literal notranslate"><span class="pre">ocaml</span></code> or <code class="docutils literal notranslate"><span class="pre">utop</span></code> at a terminal prompt).
You might think that it’s hard to use a REPL in a large, multi-file project
like the compiler assignments, but we’ve got you covered!</p>
<p>Typing <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">repl</span></code> in any directory will bring up a REPL in which all the
modules of the program are accessible.  This allows you to interactively test
your code.  Some kinds of code are easier to test in this way than others, but
don’t underestimate how useful this can be, especially when trying to track
down a tricky bug.  All you need to do is to open the relevant module:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Some_Compiler_Pass_That_Isnt_Working</span><span class="o">;;</span>
</pre></div>
</div>
<p>and you can play with all the functions in that module.</p>
</div>
<div class="section" id="insert-debugging-code-into-tricky-algorithms">
<h3>Insert debugging code into tricky algorithms<a class="headerlink" href="#insert-debugging-code-into-tricky-algorithms" title="Permalink to this heading"></a></h3>
<p>Some passes involve tricky algorithms.  In those cases, it’s a good idea to
define a <code class="docutils literal notranslate"><span class="pre">debug</span></code> variable at the top of the file:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">debug</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">false</span>  <span class="c">(* change to `true` when you need debug output *)</span>
</pre></div>
</div>
<p>and then put debug code into the tricky algorithm that prints out the inputs
and outputs:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">tricky_algorithm</span> <span class="n">weird_inputs</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">debug</span> <span class="k">then</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;INPUT: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_weird_inputs</span> <span class="n">weird_inputs</span><span class="o">);</span>
  <span class="o">...</span> <span class="c">(* rest of algorithm *)</span>
</pre></div>
</div>
<p>To do this, you need to be able to convert the algorithm inputs/output
to strings.  Most of the data structures you will be using can be easily
converted to S-expressions, and there is a <code class="docutils literal notranslate"><span class="pre">print_sexp</span></code> function in the
<code class="docutils literal notranslate"><span class="pre">Utils</span></code> module that will print an S-expression in a readable fashion.
This is extremely useful for tracking down algorithm errors.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Assignments" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="0/Installing_OCaml.html" class="btn btn-neutral float-right" title="Installing OCaml" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Michael C. Vanier. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>