<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OCaml coding notes and tips &mdash; The CS 164 book 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Installing OCaml" href="0/Installing_OCaml.html" />
    <link rel="prev" title="Assignments" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> The CS 164 book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin/index.html">Administrative information</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Assignments</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">OCaml coding notes and tips</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warnings">Warnings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functional-programming-tips">Functional programming tips</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#use-functional-style-by-default">Use functional style by default</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-tail-recursion-by-default">Use tail recursion by default</a></li>
<li class="toctree-l4"><a class="reference internal" href="#persistent-data-structures">Persistent data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-annotations">Type annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#folds-are-your-friend">Folds are your friend!</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nested-pattern-matching">Nested pattern matching</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#new-ocaml-features">New OCaml features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-pipe-operator">The <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> (pipe) operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-apply-operator">The <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> (apply) operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#labelled-arguments">Labelled arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#design-tips">Design tips</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#write-stubs">Write stubs!</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-wishful-thinking">Use wishful thinking!</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-the-support-library">Use the <code class="docutils literal notranslate"><span class="pre">support</span></code> library!</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-tips">Debugging tips</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printf-style-debugging"><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-repl">Using the REPL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#insert-debugging-code-into-tricky-algorithms">Insert debugging code into tricky algorithms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#on-s-expressions">On S-expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-s-expressions-are">What S-expressions are</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-we-use-them">How we use them</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="0/Installing_OCaml.html">Installing OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="0/Assignment0.html">Assignment 0: Getting set up</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The CS 164 book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Assignments</a> &raquo;</li>
      <li>OCaml coding notes and tips</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/content/assignments/coding_notes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="ocaml-coding-notes-and-tips">
<h1>OCaml coding notes and tips<a class="headerlink" href="#ocaml-coding-notes-and-tips" title="Permalink to this heading"></a></h1>
<p>Here are some notes and tips
that should improve your OCaml programming experience.
We also describe our expectations
of how we want you to write your OCaml code,
so don’t just skip this document!</p>
<div class="section" id="warnings">
<h2>Warnings<a class="headerlink" href="#warnings" title="Permalink to this heading"></a></h2>
<p>Warnings are always bad, unless you expect them (<em>e.g.</em> because code is only
partially written).  Never ignore warnings.  Your finished code should <em>never</em>
generate warnings.</p>
</div>
<div class="section" id="functional-programming-tips">
<h2>Functional programming tips<a class="headerlink" href="#functional-programming-tips" title="Permalink to this heading"></a></h2>
<div class="section" id="use-functional-style-by-default">
<h3>Use functional style by default<a class="headerlink" href="#use-functional-style-by-default" title="Permalink to this heading"></a></h3>
<p>Code should be written in a functional style (no <code class="docutils literal notranslate"><span class="pre">ref</span></code>s, arrays, or records
with mutable fields) except where indicated.  Marks will be taken off if this
rule is violated.  We will let you know when it’s OK to use imperative idioms.
Certain imperative idioms (like <code class="docutils literal notranslate"><span class="pre">while</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code> loops) are almost never
used, but we do use <code class="docutils literal notranslate"><span class="pre">ref</span></code> cells on occasion to make code simpler.</p>
<p>Many of the tips below describe ways to effectively use functional style.
They are not in any particular order, so feel free to browse until you find
something interesting.</p>
</div>
<div class="section" id="use-tail-recursion-by-default">
<h3>Use tail recursion by default<a class="headerlink" href="#use-tail-recursion-by-default" title="Permalink to this heading"></a></h3>
<p>As you recall, a lot of CS 4 was spent teaching you to write functions using
recursion instead of loops, and specifically tail recursion.  We use tail
recursion because it has desirable space properties, so in general,
when you write a recursive function, try hard to make it tail recursive.
If you can’t do this, be prepared to explain why during code reviews.</p>
</div>
<div class="section" id="persistent-data-structures">
<h3>Persistent data structures<a class="headerlink" href="#persistent-data-structures" title="Permalink to this heading"></a></h3>
<p>Probably the hardest part of using functional programming effectively is
getting used to persistent data structures (like lists) instead of mutable data
structures (like arrays).</p>
<p>In this course, almost all data structures are persistent, which means that
when you change something in the data structure, it returns the updated version
without altering the input version.  This is very different to how imperative
languages work.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you think you need to use <code class="docutils literal notranslate"><span class="pre">List.iter</span></code>
(which would be appropriate for a mutable data structure)
you almost always want to actually use <code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code>
or an iterative helper function
(which is appropriate for a persistent data structure).</p>
</div>
<p>Even though you may find functional programming awkward at first,
it is <em>vastly</em> easier to write correct code
in a functional style than in an imperative style.
There is simply less that can go wrong.</p>
</div>
<div class="section" id="type-annotations">
<h3>Type annotations<a class="headerlink" href="#type-annotations" title="Permalink to this heading"></a></h3>
<p>We <em>strongly</em> recommend that you add type annotations
to all functions that are internal to a module.
It will save you a lot of grief.
Just because OCaml can do type inference
doesn’t mean that you have to rely on it!
When you specify the types manually,
you will usually get better error messages.</p>
<p>For example, instead of writing this code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">lst</span> <span class="k">else</span> <span class="n">h</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">t</span>
</pre></div>
</div>
<p>write it like this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">lst</span> <span class="k">else</span> <span class="n">h</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">t</span>
</pre></div>
</div>
<p>(Actually, you’d probably rewrite it to be tail recursive, but that’s
another topic.)  In many cases, you could substitute a more specific
type for <code class="docutils literal notranslate"><span class="pre">'a</span></code> (say, <code class="docutils literal notranslate"><span class="pre">int</span></code>), which would be beneficial
in the event that the type that was actually passed to <code class="docutils literal notranslate"><span class="pre">insert</span></code>
was something other than a list of <code class="docutils literal notranslate"><span class="pre">int</span></code>s.</p>
<p>Also, don’t remove the type annotations once the code is working
“because it looks prettier”; leave them in.
It’s good documentation and it will be really important
if you ever have to modify the code.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We didn’t have this guideline in CS 4,
primarily because the code base was so much smaller.
The more complicated the code gets,
the more helpful explicit type annotations are.</p>
</div>
</div>
<div class="section" id="folds-are-your-friend">
<h3>Folds are your friend!<a class="headerlink" href="#folds-are-your-friend" title="Permalink to this heading"></a></h3>
<p>Programmers new to functional programming are often frustrated by what they
perceive as the difficulty of doing simple things.  A good example of this is
accumulation. You have a list and want to compute some value from the list
elements. For instance, say you want to get the maximum value of the list (and
assume that you only have a two-element <code class="docutils literal notranslate"><span class="pre">max</span></code> function to compute maximums).
A Python programmer could immediately write this code:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">max_list</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the maximum of a list of positive integers.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mx</span>
</pre></div>
</div>
<p>In OCaml, we do this sort of thing using folds, specifically left folds.</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max_list</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">mx</span> <span class="n">item</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">mx</span> <span class="n">item</span><span class="o">)</span>
    <span class="mi">0</span>
    <span class="n">lst</span>
</pre></div>
</div>
<p>This can be simplified further:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max_list</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">max</span> <span class="mi">0</span> <span class="n">lst</span>
</pre></div>
</div>
<p>Whenever you need to write code which accumulates something over a list,
you generally want to use a fold.</p>
<p>A common beginner’s style error is to do this with an iterative helper
function:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max_list</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">iter</span> <span class="n">rest</span> <span class="n">mx</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">rest</span> <span class="k">with</span>
      <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">mx</span>
      <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iter</span> <span class="n">t</span> <span class="o">(</span><span class="n">max</span> <span class="n">h</span> <span class="n">mx</span><span class="o">)</span>
  <span class="k">in</span>
    <span class="n">iter</span> <span class="n">lst</span> <span class="mi">0</span>
</pre></div>
</div>
<p>This is not so bad, but the iterative helper function can be replaced by
<code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code> and the entire function becomes a one-liner!
Be alert for this kind of situation –
there’s no benefit to using a functional language
if you don’t take advantage of what it offers.</p>
<p>On the other hand, sometimes you are accumulating more than one thing in an
iteration. You can still use <code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code> in such cases by accumulating a
tuple of all the things you’re accumulating, but in my experience, it’s often
easier to just write an iterative helper function.</p>
<div class="section" id="left-vs-right-folds">
<h4>Left <em>vs.</em> right folds<a class="headerlink" href="#left-vs-right-folds" title="Permalink to this heading"></a></h4>
<p>95% of the time or more, if you want to use a fold in OCaml,
you want to use a left fold (<code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code>)
instead of a right fold (<code class="docutils literal notranslate"><span class="pre">List.fold_right</span></code>).
Left folds are tail recursive (space efficient) and are more natural
than right folds, which are not tail recursive
and thus not space efficient.</p>
<p>On the other hand, there are cases where right folds are the right thing to
use.  When you want to accumulate things in a list from the right going back
to the left, a right fold is usually going to be simpler than a left fold,
and you shouldn’t feel bad about using one in that case.</p>
</div>
</div>
<div class="section" id="nested-pattern-matching">
<h3>Nested pattern matching<a class="headerlink" href="#nested-pattern-matching" title="Permalink to this heading"></a></h3>
<p>It’s very common to want to write a pattern match inside another
pattern match.  There are two cases to consider.</p>
<ol class="arabic">
<li><p>Where the two pattern matches can be combined.  Consider this code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">maybe_lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">option</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">maybe_lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">lst</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
          <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">h</span>
          <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="k">end</span>
</pre></div>
</div>
<p>You can merge both pattern matches as follows:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">maybe_lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">option</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">maybe_lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">h</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>Note how much shorter and clearer the code is.
Also note the use of the wildcard (<code class="docutils literal notranslate"><span class="pre">_</span></code>) pattern
for “don’t care” situations.</p>
<p>Merging pattern matches is almost always possible if the
inner pattern match doesn’t depend on a value computed using
information from the outer pattern match.
Unnecessary pattern matches are bad style and will be marked down
(but we’ll try to alert you of this issue during code reviews).</p>
</li>
<li><p>Where the two pattern matches <em>can’t</em> be combined.
Consider this code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">t</span> <span class="k">with</span>
          <span class="o">|</span> <span class="n">h&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">)</span>
          <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="k">end</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>The inner match is matching on the result of the <code class="docutils literal notranslate"><span class="pre">List.sort</span></code>
function applied to the tail of the list.
You can’t combine these pattern matches because the inner one
depends on a value which must be computed (it’s not structural).
For very simple cases, you can use a <code class="docutils literal notranslate"><span class="pre">when</span></code> clause instead of
the inner match, but often this isn’t feasible.
So you have nested <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions.</p>
<p>When you have nested <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions, you <strong>must</strong> surround them
by either <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code> delimiters (as we did above) or parentheses,
which looks like this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="o">(</span><span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">t</span> <span class="k">with</span>
         <span class="o">|</span> <span class="n">h&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">)</span>
         <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>Using parentheses looks more concise, but it’s easy to forget to close
the open parenthesis, so we prefer to use <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code>.
(It reads better, too.)  What you definitely do <em>not</em> want to do is this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">t</span> <span class="k">with</span>
        <span class="o">|</span> <span class="n">h&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">)</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>If you do this, you will get strange error messages because
OCaml will consider the last line to be part of the inner pattern match.
Remember, <strong>OCaml is not whitespace sensitive!</strong>
So don’t forget the <code class="docutils literal notranslate"><span class="pre">begin</span></code>/<code class="docutils literal notranslate"><span class="pre">end</span></code>.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="new-ocaml-features">
<h2>New OCaml features<a class="headerlink" href="#new-ocaml-features" title="Permalink to this heading"></a></h2>
<div class="section" id="the-pipe-operator">
<h3>The <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> (pipe) operator<a class="headerlink" href="#the-pipe-operator" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> (pipe) operator is a reverse-apply operator
(analogous to a Unix pipe).
It’s very convenient when you want to transform some inputs repeatedly
by applying one function after another.</p>
<p>Instead of writing this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">func3</span> <span class="o">(</span><span class="n">func2</span> <span class="o">(</span><span class="n">func1</span> <span class="n">data</span><span class="o">))</span>
</pre></div>
</div>
<p>you can write this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">|&gt;</span> <span class="n">func1</span> <span class="o">|&gt;</span> <span class="n">func2</span> <span class="o">|&gt;</span> <span class="n">func3</span>
</pre></div>
</div>
<p>Aside from having fewer parentheses, it’s often easier to read:
“Create <code class="docutils literal notranslate"><span class="pre">data</span></code>, then apply <code class="docutils literal notranslate"><span class="pre">func1</span></code>, <code class="docutils literal notranslate"><span class="pre">func2</span></code>, and <code class="docutils literal notranslate"><span class="pre">func3</span></code>
to it in succession.”</p>
<p>Also, because of OCaml’s auto-currying of functions, it even works
if one or more of the functions take additional arguments, just as long
as the data structure is the last argument to the function.
So we might have <em>e.g.</em>:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">|&gt;</span> <span class="n">func1</span> <span class="n">arg1</span> <span class="o">|&gt;</span> <span class="n">func2</span> <span class="n">arg2a</span> <span class="n">arg2b</span> <span class="o">|&gt;</span> <span class="n">func3</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">func3</span> <span class="o">(</span><span class="n">func2</span> <span class="n">arg2a</span> <span class="n">arg2b</span> <span class="o">(</span><span class="n">func1</span> <span class="n">arg1</span> <span class="n">data</span><span class="o">))</span>
</pre></div>
</div>
<p>Whether this is clearer is up to you.</p>
<p>When there are a <em>lot</em> of transformations, it’s nice to write them on
multiple lines:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">data</span>
  <span class="o">|&gt;</span> <span class="n">transform1</span>
  <span class="o">|&gt;</span> <span class="n">transform2</span>
  <span class="o">|&gt;</span> <span class="n">transform3</span> <span class="n">arg</span>
  <span class="o">|&gt;</span> <span class="n">transform4</span> <span class="n">arg1</span> <span class="n">arg2</span>
  <span class="c">(* etc. *)</span>
</pre></div>
</div>
<p>This is much more readable than the usual notation:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">transform4</span> <span class="n">arg1</span> <span class="n">arg2</span> <span class="o">(</span><span class="n">transform3</span> <span class="n">arg</span> <span class="o">(</span><span class="n">transform2</span> <span class="o">(</span><span class="n">transform1</span> <span class="n">data</span><span class="o">)))</span>
</pre></div>
</div>
<p>and it’s also easier to extend with more transformations.</p>
</div>
<div class="section" id="the-apply-operator">
<h3>The <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> (apply) operator<a class="headerlink" href="#the-apply-operator" title="Permalink to this heading"></a></h3>
<p>The “cousin” of the <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> operator is the <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> (forward apply) operator.
Like <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code>, it’s never required, but sometimes it can make code a bit nicer by
removing the need for some parentheses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you know the Haskell language, you’ll recognize the <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> operator as
the same thing as the <code class="docutils literal notranslate"><span class="pre">$</span></code> operator in Haskell.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> operator is used to apply a function to its argument,
so <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&#64;&#64;</span> <span class="pre">x</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>.  Seems pointless, right?
But consider <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">2)</span></code>.  With <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> this becomes <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&#64;&#64;</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>
and you’ve eliminated the need for the parentheses.  Similarly:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">func3</span> <span class="o">(</span><span class="n">func2</span> <span class="o">(</span><span class="n">func1</span> <span class="n">data</span><span class="o">))</span>
</pre></div>
</div>
<p>can be written as:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">func3</span> <span class="o">@@</span> <span class="n">func2</span> <span class="o">@@</span> <span class="n">func1</span> <span class="n">data</span>
</pre></div>
</div>
<p>and the parenthesis-saving is even greater!
(Note that this operator associates to the right.)</p>
<p>A common use for this is when signalling errors.  In the course compilers,
most errors use the <code class="docutils literal notranslate"><span class="pre">failwith</span></code> function:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">failwith</span> <span class="s2">&quot;my error message&quot;</span>
</pre></div>
</div>
<p>This is fine, but very often, the error message needs to contain
formatted data <em>e.g.</em></p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_i</span> <span class="k">then</span>
  <span class="n">failwith</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;i value: (%d) is too large&quot;</span> <span class="n">i</span><span class="o">)</span>
<span class="k">else</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>This can be rewritten using the <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> operator as:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_i</span> <span class="k">then</span>
  <span class="n">failwith</span> <span class="o">@@</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;i value: (%d) is too large&quot;</span> <span class="n">i</span>
<span class="k">else</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>and sometimes it’s nice to put the <code class="docutils literal notranslate"><span class="pre">Printf.sprintf</span></code> on its own line:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_i</span> <span class="k">then</span>
  <span class="n">failwith</span> <span class="o">@@</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;i value: (%d) is too large&quot;</span> <span class="n">i</span>
<span class="k">else</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>In fact, this case is so common that we’ve written a helper function called
<code class="docutils literal notranslate"><span class="pre">failwithf</span></code> (“<code class="docutils literal notranslate"><span class="pre">failwith</span></code> with formatting”), so using that,
we could rewrite the above code as:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nn">Support</span><span class="p">.</span><span class="nn">Utils</span>

<span class="p">...</span>

<span class="n">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_i</span> <span class="k">then</span>
  <span class="n">failwithf</span> <span class="s2">&quot;i value: (%d) is too large&quot;</span> <span class="n">i</span>
<span class="k">else</span>
  <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="labelled-arguments">
<h3>Labelled arguments<a class="headerlink" href="#labelled-arguments" title="Permalink to this heading"></a></h3>
<p>OCaml has a neat feature called <a class="reference external" href="https://v2.ocaml.org/manual/lablexamples.html">labelled arguments</a> which we didn’t cover in
CS 4.  Just like you’d expect, this feature means that you can label a function
argument with a name, and you have to use that name when calling the function.
What’s nice is that you don’t have to put labelled arguments in any particular
order; as long as the label is there, the function will know what to do about
them.</p>
<p>The syntax is described in detail in the link, but here’s an example:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">~</span><span class="n">x</span> <span class="o">~</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>     <span class="c">(* x and y are labelled arguments *)</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">f</span> <span class="o">~</span><span class="n">x</span><span class="o">:</span><span class="mi">10</span> <span class="o">~</span><span class="n">y</span><span class="o">:</span><span class="mi">20</span>   <span class="c">(* you need the labels when calling the function *)</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">f</span> <span class="o">~</span><span class="n">y</span><span class="o">:</span><span class="mi">20</span> <span class="o">~</span><span class="n">x</span><span class="o">:</span><span class="mi">10</span>   <span class="c">(* does the same thing *)</span>
</pre></div>
</div>
<p>Why would you use this?</p>
<p>In our experience, the toughest OCaml bugs to track down are in functions that
have more than one argument of the same type.  It’s easy to switch the
arguments by mistake, and then you have a very hard-to-find bug.</p>
<p>The solution is to use labelled arguments.  This way, when you call the
function, you have to specify which argument you mean, which makes errors of
this kind far less likely.</p>
<p>We’re not suggesting you do this for every function, but it’s certainly a
trick to keep in mind, and one which we’ve used in much of the supporting
code.</p>
<p>Also, OCaml supports <em>optional arguments</em>, which are like labelled arguments
except the function gets a default value you specify if the labelled argument
is left off.  The link above describes those too.</p>
</div>
</div>
<div class="section" id="design-tips">
<h2>Design tips<a class="headerlink" href="#design-tips" title="Permalink to this heading"></a></h2>
<div class="section" id="write-stubs">
<h3>Write stubs!<a class="headerlink" href="#write-stubs" title="Permalink to this heading"></a></h3>
<p>When you are starting to write a function, write a “stub”.
This is an incomplete function. Just put in</p>
<ul class="simple">
<li><p>the arguments</p></li>
<li><p>type annotations for arguments and the return type
(This is <em>very</em> important!  Don’t skip this step!)</p></li>
<li><p>and <code class="docutils literal notranslate"><span class="pre">failwith</span> <span class="pre">&quot;TODO&quot;</span></code> for the body.</p></li>
</ul>
<p>Then fill it in later.</p>
<p>Here’s an example of a stub:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">halts_on_all_inputs</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span>
  <span class="n">failwith</span> <span class="s2">&quot;TODO&quot;</span>
</pre></div>
</div>
<p>This particular function might be a bit hard to complete, though.</p>
<p>Writing stubs is a great way to get past “coder’s block”.
Once the stub is written,
you can compile it and make sure it type checks.
If it’s recursive, you can usually easily fill in the base cases.
At that point, you’re ready to work on the body of the function.</p>
</div>
<div class="section" id="use-wishful-thinking">
<h3>Use wishful thinking!<a class="headerlink" href="#use-wishful-thinking" title="Permalink to this heading"></a></h3>
<p>If a function seems too difficult/complex to write directly,
ask yourself “what function do I need
which would make it really easy to write this function?”
Then assume that <em>that</em> function exists
(<em>i.e.</em> write a stub for it),
and write your main function using the assumed function.
When that’s done, go back and write the body of the assumed function.</p>
<p>This is one of <em>the</em> most useful programming tips.  It’s explored at some
length in the book SICP (Structure and Interpretation of Computer Programs),
which is an amazing book (and which is the basis of CS 4).</p>
</div>
<div class="section" id="use-the-support-library">
<h3>Use the <code class="docutils literal notranslate"><span class="pre">support</span></code> library!<a class="headerlink" href="#use-the-support-library" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">support</span></code> library (which is part of the CS 164 code base)
contains a number of modules with useful functions and data structures.
Often, this can save you a lot of time versus writing them yourself.
Here, we will briefly discuss the modules,
but we <strong>strongly</strong> encourage you to read the comments
in the <code class="docutils literal notranslate"><span class="pre">support/*.mli</span></code> files to find out more.
We will remind you in the assignments which functions and data structures
are particularly useful for that assignment.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">support</span></code> library contains these modules:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Functors</span></code></p>
<p>This module defines three module types: <code class="docutils literal notranslate"><span class="pre">OrderedTypeS</span></code>,
<code class="docutils literal notranslate"><span class="pre">SetS.S</span></code> and <code class="docutils literal notranslate"><span class="pre">MapS.S</span></code>.  They are extensions of the standard OCaml
module types <code class="docutils literal notranslate"><span class="pre">OrderedType</span></code>, <code class="docutils literal notranslate"><span class="pre">Set.S</span></code> and <code class="docutils literal notranslate"><span class="pre">Map.S</span></code>.
The extensions mostly have to do with functions that convert
instances of the internal datatypes to and from S-expressions, as well
as a few other utility functions.  There are also new functors called
<code class="docutils literal notranslate"><span class="pre">SetS.Make</span></code> and <code class="docutils literal notranslate"><span class="pre">MapS.Make</span></code> that create modules with the module types
<code class="docutils literal notranslate"><span class="pre">SetS.S</span></code> and <code class="docutils literal notranslate"><span class="pre">MapS.S</span></code> respectively, given a module of module type
<code class="docutils literal notranslate"><span class="pre">OrderedTypeS</span></code>.</p>
<p>In general, you should never be using a module of module type
<code class="docutils literal notranslate"><span class="pre">OrderedType</span></code>, <code class="docutils literal notranslate"><span class="pre">Set.S</span></code>, or <code class="docutils literal notranslate"><span class="pre">Map.S</span></code>.  Always use the extended versions
(<code class="docutils literal notranslate"><span class="pre">OrderedTypeS</span></code>, <code class="docutils literal notranslate"><span class="pre">SetS.S</span></code>, or <code class="docutils literal notranslate"><span class="pre">MapS.S</span></code>).  Usually, all you have to do
is type the extra <code class="docutils literal notranslate"><span class="pre">S</span></code> at the end of the name.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dgraph</span></code></p>
<p>This module contains a functor called <code class="docutils literal notranslate"><span class="pre">Make</span></code>
which makes a module of type <code class="docutils literal notranslate"><span class="pre">Dgraph.S</span></code>,
which implements a directed graph.
The functor takes an ordered type module (module type <code class="docutils literal notranslate"><span class="pre">OrderedTypeS</span></code>)
as its argument.</p>
<p>Note that this (like the other graph implementations in this library)
is implemented in a purely functional way.
This is not as efficient as an imperative graph could be,
but it’s more than sufficient for our needs
and tends to be very well-behaved
(as functional data structures usually are).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Multigraph</span></code></p>
<p>This is like <code class="docutils literal notranslate"><span class="pre">Dgraph</span></code>, but implements a directed multigraph.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PriorityQueue</span></code></p>
<p>This module contains a very simple (some might call it “brain dead”) version
of a priority queue module called <code class="docutils literal notranslate"><span class="pre">PriorityQueue.Simple</span></code>.
One day we’ll implement a more efficient one, but this will do for now.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ugraph</span></code></p>
<p>This is like <code class="docutils literal notranslate"><span class="pre">Dgraph</span></code>, but implements an undirected graph.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Utils</span></code></p>
<p>This contains lots of little utility functions that aren’t found in the
OCaml standard libraries.  There are string and list functions,
functions to generate unique variable names, functions to work with
S-expressions, and so on.  This is a module you will want to get familiar
with.</p>
</li>
</ul>
<p>You use the <code class="docutils literal notranslate"><span class="pre">support</span></code> library by <code class="docutils literal notranslate"><span class="pre">open</span></code>ing it and then <code class="docutils literal notranslate"><span class="pre">open</span></code>ing
whatever modules you need from it:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Support</span>
<span class="k">open</span> <span class="nc">Functors</span>
<span class="k">open</span> <span class="nc">Utils</span>
</pre></div>
</div>
<p>If you only need one module, you can alternatively do this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nn">Support</span><span class="p">.</span><span class="nc">Utils</span>
</pre></div>
</div>
<p>Or you can <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">Support</span></code> and then use a qualified function <em>e.g.</em>
<code class="docutils literal notranslate"><span class="pre">Utils.last</span></code>.</p>
</div>
</div>
<div class="section" id="debugging-tips">
<h2>Debugging tips<a class="headerlink" href="#debugging-tips" title="Permalink to this heading"></a></h2>
<p>Although strictly-typed functional languages like OCaml greatly reduce the
number of bugs in your programs, you will still make mistakes and have to debug
them.  Debugging functional languages can be challenging; here are some tips
we’ve found to be useful.</p>
<div class="section" id="printf-style-debugging">
<h3><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style debugging<a class="headerlink" href="#printf-style-debugging" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">printf</span></code>-style debugging is highly effective if you do it right.  The wrong
way is to add <code class="docutils literal notranslate"><span class="pre">printf</span></code> statements to otherwise functional code:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;x = %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">x</span><span class="o">;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Even though this can work, you are embedding imperative code inside
functional code, and you can get into tricky syntax issues as a result.
A better way to do it is like this:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;x = %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>This also embeds imperative code, but uses functional syntax, so there
won’t be any syntax issues.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the surrounding code is imperative (like a <code class="docutils literal notranslate"><span class="pre">begin</span></code> expression
or the body of a <code class="docutils literal notranslate"><span class="pre">for</span></code> or <code class="docutils literal notranslate"><span class="pre">while</span></code> loop), the exact opposite criterion
applies: favor the naked <code class="docutils literal notranslate"><span class="pre">Printf.printf</span> <span class="pre">...</span></code> instead of the
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">Printf.printf</span> <span class="pre">...</span></code> idiom.  However, in well-written OCaml
code, <code class="docutils literal notranslate"><span class="pre">while</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code> loops should be almost nonexistent.</p>
</div>
<p>Also, you should add <code class="docutils literal notranslate"><span class="pre">%!</span></code> at the end of the <code class="docutils literal notranslate"><span class="pre">printf</span></code> format string:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;x = %s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>This makes OCaml flush the string as soon as the <code class="docutils literal notranslate"><span class="pre">printf</span></code> executes.
If you don’t do that, sometimes error messages before a crash can be lost.</p>
<p>Finally, for debugging, consider writing your <code class="docutils literal notranslate"><span class="pre">printf</span></code>s this way:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;DEBUG: x = %s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">x</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>This way, it’s easy to spot these lines, which is good because you are
going to want to delete them once debugging is done.</p>
</div>
<div class="section" id="using-the-repl">
<h3>Using the REPL<a class="headerlink" href="#using-the-repl" title="Permalink to this heading"></a></h3>
<p>“REPL” means “Read-Eval-Print-Loop” and refers to the interactive interpreter
(what you get into if you type <code class="docutils literal notranslate"><span class="pre">ocaml</span></code> or <code class="docutils literal notranslate"><span class="pre">utop</span></code> at a terminal prompt).
You might think that it’s hard to use a REPL in a large, multi-file project
like the compiler assignments, but we’ve got you covered!</p>
<p>Typing <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">repl</span></code> in any directory will bring up a REPL in which all the
modules of the program are accessible.  This allows you to interactively test
your code.  Some kinds of code are easier to test in this way than others, but
don’t underestimate how useful this can be, especially when trying to track
down a tricky bug.  All you need to do is to open the relevant module:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Some_Compiler_Pass_That_Isnt_Working</span><span class="o">;;</span>
</pre></div>
</div>
<p>and you can play with all the functions in that module.</p>
</div>
<div class="section" id="insert-debugging-code-into-tricky-algorithms">
<h3>Insert debugging code into tricky algorithms<a class="headerlink" href="#insert-debugging-code-into-tricky-algorithms" title="Permalink to this heading"></a></h3>
<p>Some passes involve tricky algorithms.  In those cases, it’s a good idea to
define a <code class="docutils literal notranslate"><span class="pre">debug</span></code> variable at the top of the file:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">debug</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">false</span>  <span class="c">(* change to `true` when you need debug output *)</span>
</pre></div>
</div>
<p>and then put debug code into the tricky algorithm that prints out the inputs
and outputs:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">tricky_algorithm</span> <span class="n">weird_inputs</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">debug</span> <span class="k">then</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;INPUT: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_weird_inputs</span> <span class="n">weird_inputs</span><span class="o">);</span>
  <span class="o">...</span> <span class="c">(* rest of algorithm *)</span>
</pre></div>
</div>
<p>To do this, you need to be able to convert the algorithm inputs/output
to strings.  Most of the data structures you will be using can be easily
converted to S-expressions, and there is a <code class="docutils literal notranslate"><span class="pre">print_sexp</span></code> function in the
<code class="docutils literal notranslate"><span class="pre">Utils</span></code> module that will print an S-expression in a readable fashion
(this is discussed below).
This is extremely useful for tracking down algorithm errors.</p>
</div>
</div>
<div class="section" id="on-s-expressions">
<h2>On S-expressions<a class="headerlink" href="#on-s-expressions" title="Permalink to this heading"></a></h2>
<div class="section" id="what-s-expressions-are">
<h3>What S-expressions are<a class="headerlink" href="#what-s-expressions-are" title="Permalink to this heading"></a></h3>
<p>S-expressions are described in this <a class="reference external" href="https://en.wikipedia.org/wiki/S-expression">Wikipedia article</a>.
Essentially, they are an extremely simple (perhaps the most simple) way to
represent structured data.  The “S” in “S-expression” originally meant
“symbolic”; these were originally the way to represent arbitrary data in the
Lisp programming language.  (They were eventually used to represent Lisp code
as well, but that’s another story.)  Even now, S-expressions are often
associated with Lisp-like programming languages such as Scheme and Racket, but
they are far more generally useful, as we’ll see.</p>
<p>An S-expression is essentially just a nested list of arbitrary symbols.
S-expressions can be described recursively as either</p>
<ul class="simple">
<li><p>a symbol (which can be an arbitrary string,
but normally without internal spaces or quotes)</p></li>
<li><p>or a list of S-expressions</p></li>
</ul>
<p>Usually, we use parentheses to delimit a list.  Here are some sample
S-expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">foo</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(this</span> <span class="pre">is</span> <span class="pre">(a</span> <span class="pre">(nested</span> <span class="pre">list)</span> <span class="pre">of)</span> <span class="pre">symbols)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">((foo</span> <span class="pre">1)</span> <span class="pre">(bar</span> <span class="pre">2)</span> <span class="pre">(baz</span> <span class="pre">3))</span></code></p></li>
</ul>
<p>Basically, any structured data can be represented as an S-expression.</p>
</div>
<div class="section" id="how-we-use-them">
<h3>How we use them<a class="headerlink" href="#how-we-use-them" title="Permalink to this heading"></a></h3>
<p>We use S-expressions as both a serialization format and a visualization
tool.  “Serialization” means that we can take arbitrary OCaml datatypes and
convert them to and from S-expressions without losing any information.  For
visualization, we take some OCaml datatype we want to look at, convert it to an
S-expression, and then pretty-print the S-expression in a readable format.</p>
<p>Visualization is incredibly useful for debugging.  We will be using a lot of
fairly complex OCaml datatypes, and our compiler passes will have the job of
converting one datatype into another.  We would like to be able to inspect
these datatypes to make sure that we converted them correctly.  If we had to
write special string conversion functions for all our datatypes, that would be
an enormous amount of boring work.  Instead, there are OCaml libraries that will
allow us to automatically convert any datatype to an S-expression if we add
small annotations to our code.  (These libraries are the <code class="docutils literal notranslate"><span class="pre">sexplib</span></code> and
<code class="docutils literal notranslate"><span class="pre">ppx_sexp_conv</span></code> libraries.)</p>
<p>In order to get OCaml to generate the S-expression conversion code, we
have to add an annotation after type declarations:</p>
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">value</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="nc">Function</span> <span class="k">of</span> <span class="o">(</span><span class="k">value</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">)</span>
<span class="o">[@@</span><span class="n">deriving</span> <span class="n">sexp</span><span class="o">]</span>   <span class="c">(* this is the annotation *)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">[&#64;&#64;deriving</span> <span class="pre">sexp]</span></code> line is what is called a “PPX extension”;
it’s a kind of code-generating macro which, when interpreted by OCaml,
will proceed to generate two functions:
<code class="docutils literal notranslate"><span class="pre">sexp_of_value</span></code> (convert a <code class="docutils literal notranslate"><span class="pre">value</span></code> to an S-expression)
and <code class="docutils literal notranslate"><span class="pre">value_of_sexp</span></code> (convert an S-expression to a value).
We tend to use the first function(s) much more than the second,
because we usually want to convert our types to S-expressions.</p>
<p>We will use this facility for nearly all our data structures.
Fortunately, you don’t have to worry about it!
Just don’t remove those annotations; they are doing real work.</p>
<p>All you really need to know is that for any datatype <code class="docutils literal notranslate"><span class="pre">foo</span></code>
which has the <code class="docutils literal notranslate"><span class="pre">[&#64;&#64;deriving</span> <span class="pre">sexp]</span></code> annotation, (which is almost all of them)
there will be functions called <code class="docutils literal notranslate"><span class="pre">sexp_of_foo</span></code> and <code class="docutils literal notranslate"><span class="pre">foo_of_sexp</span></code> generated.
There is also a function in the <code class="docutils literal notranslate"><span class="pre">Support.Utils</span></code> module called <code class="docutils literal notranslate"><span class="pre">print_sexp</span></code>
which will print out an S-expression in a readable format.
So if you need to print out the data structure,
just convert it to an S-expression with <code class="docutils literal notranslate"><span class="pre">sexp_of_foo</span></code>
and then print it using <code class="docutils literal notranslate"><span class="pre">print_sexp</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is much, much more that could be said about OCaml’s PPX
extension system, which is a relatively new feature of the language
(and which wasn’t discussed at all in CS 4 or CS 131).
It’s a very powerful code-generation system,
but it also has a fairly steep learning curve.</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Assignments" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="0/Installing_OCaml.html" class="btn btn-neutral float-right" title="Installing OCaml" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Michael C. Vanier. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>