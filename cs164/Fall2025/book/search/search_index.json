{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 164 book: Fall 2025","text":"<p>This book is the official document repository for the Caltech CS 164 course (Compilers).</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 164 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare you or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>As this course is a partnership course, you are expected to collaborate 100% with your partner. You can discuss anything related to the assignments with them, share code with them (obviously), ask each other questions, etc. Nothing is off-limits collaboration-wise as long as it's with your partner. Everything else that is described below refers to \"collaboration\"-style activities with people who are not your partner. When we refer to \"you\" below we mean the collective \"you\" i.e. your team.</p> <p>You are welcome to collaborate informally on your assignments with other students who are taking or have taken the class, but you must write all of your own code and you must not look at code from other groups. Copying another group's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another group's code and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another group's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone not in your group dictate code while you type isn't acceptable either.  Basically, your group has to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine as long as no code sharing is involved.</p> <p>All of the above also applies to student work from previous years. Copying code from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a group who are currently taking the course.</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students in CS classes have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord with VOIP), you may not share your screen with students from another group, whether to help them or to get help from them.  This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software, except (obviously) with your partner.  This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs.  If this happens you may lose the ability to use the discussion board for any purpose.  On the other hand, if you post a private message you can include your partner in the message (if Piazza allows this).</p> <p>This also applies to programs with chat features that are not used in the course (like Slack or Discord), or email for that matter.</p>"},{"location":"admin/collab/#use-of-websites","title":"Use of websites","text":"<p>Your code repository must be and must remain private. Do not allow outsiders to see your code, even after the course is finished. Public repos can quickly make the assignments worthless.</p> <p>In the event that a student from a previous year makes their repo public and you find out about it, please inform the instructor, and, of course, you aren't allowed to consult this code.</p>"},{"location":"admin/collab/#use-of-code-hinting-ai-software","title":"Use of code hinting / AI software","text":"<p>Examples of code hinting / AI software include:</p> <ul> <li>Github Copilot</li> <li>ChatGPT</li> <li>Claude</li> </ul> <p>as well there are many others.</p> <p>You are strictly forbidden to use code hinting software in any way for any part of this course. If your editor is configured to use code hinting software (for instance, if you have a ChatGPT extension installed in Visual Studio Code) you must disable it or uninstall it when working on your CS 164 assignments. The whole point of taking a course on compilers is to learn how to write a compiler yourself, not to learn how to ask an AI to do it for you.</p> <p>Prompts</p> <p>Any use of AI prompts in your code will be dealt with very harshly!</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments.</p> Item Status Course book OK Course textbook OK Official OCaml documentation OK Other OCaml documentation OK Other OCaml books OK Your notes or your partner's notes OK Notes of other students not in your group Not allowed Other students' code repositories (not including your partner) Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting / AI software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor. Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/groups/","title":"Groups","text":"<p>Here are the student groups, along with their graders:</p> Group Grader Alexa Baxter, Amrita Pasupathy Eric Li-Yu (Ryan) Chu, Tianwei Liu Sonica Michael Girma, Pranit Gunjal, Nilo Rivera Eric James Hou, Aditya Mehta Sonica Shallon Kobusinge, Ling-Yi Wu Eric Mia Mutadich, Clare Wu Sonica Bryan Oliveira, Jinhuang Zhou Eric Mario Solis, Tom Zhang Sonica <p>Each group should add the course instructor and their grader to their Github repo with full edit privileges.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the syllabus for CS 164 (Compilers), Fall 2025.</p>"},{"location":"admin/syllabus/#people","title":"People","text":""},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor is Mike Vanier (mvanier@cms.caltech.edu). Mike's office is Annenberg 110.</p> <p> </p> Mike"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for this term:</p> <ul> <li> <p>Eric Lee (he/him) Eric </p> </li> <li> <p>Sonica Prakash (she/her) Sonica </p> </li> </ul> <p>They are both outstanding and we are lucky to have them!</p>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Office hours will be posted on the course Piazza page.</p>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>This course covers the construction of compilers: programs which convert program source code to machine code which is directly executable on modern hardware. The course takes an incremental approach: a series of compilers will be built, all of which generate assembly language code for x86-64 processors, with each compiler adding features to the previous one. The final compiler will compile programs written in a full-fledged high-level programming language to assembly language, which can then be compiled to machine language using standard tools.</p> <p>Topics covered include register allocation, conditionals, loops and dataflow analysis, garbage collection, lexical scoping, and type checking.</p> <p>This course is project-based and programming-intensive. Students will work in teams of two students each. All compilers will be written in the OCaml programming language.</p>"},{"location":"admin/syllabus/#learning-objectives","title":"Learning objectives","text":"<p>At the end of this course, you will have written a compiler from a small subset of a typed dialect of the Scheme programming language to assembly language. Along the way, you will learn the primary ingredients of modern compilers.</p>"},{"location":"admin/syllabus/#prerequisites","title":"Prerequisites","text":"<p>The course has a hard prerequisite of CS 4 (Fundamentals of Computer Programming), because you need to know OCaml in order to take this course.</p> <p>Two recommended (but not required) prerequisites are:</p> <ul> <li> <p>CS 24 (Introduction to Computing Systems), primarily because we will be using   assembly language, and CS 24 includes an introduction to assembly language.   However, we will describe all the assembly language instructions we need   as we get to them.</p> </li> <li> <p>CS 131 (Programming Languages).  CS 131 is useful for these reasons:</p> <ul> <li> <p>CS 131 also uses OCaml, so students who have taken it have   experience writing moderately large multi-file programs in OCaml.</p> </li> <li> <p>Students who have taken CS 131 already know what an abstract syntax   tree (AST) is, and what intermediate representations (IRs) are,   which will be useful.</p> </li> </ul> <p>Again, we will cover the relevant material in this course.</p> </li> </ul>"},{"location":"admin/syllabus/#textbook","title":"Textbook","text":"<p>The course textbook is Essentials of Compilation by Jeremy Siek. This textbook is available either in a printed version (which we recommend you get) or as a free PDF (which we will distribute). We will be following the book quite closely. The main difference is that the book uses the Racket programming language to build the compilers, whereas we will use OCaml.<sup>1</sup></p> <p>The PDF of the textbook we will use is available on the course Canvas site, under Modules/Textbook.</p>"},{"location":"admin/syllabus/#topics-covered","title":"Topics covered","text":"<p>This is a very abbreviated list of topics covered in the course, presented in the order they will be covered. Some additional material may be covered towards the end of the course.</p> <ul> <li>Overview of the compilation process</li> <li>Variables and scoping</li> <li>Register allocation and graph coloring algorithms</li> <li>Conditionals and type checking</li> <li>Loops and dataflow analysis</li> <li>Tuples and garbage collection</li> <li>Functions</li> <li>Lexically-scoped functions (time permitting)</li> </ul>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>The course is on grades.  There are no exams. The marks are assigned as follows:</p> <ul> <li> <p>75% for 6 programming assignments.</p> </li> <li> <p>20% for participation in weekly code reviews.   Students must complete at least 3 code reviews in the term   to get full credit.</p> </li> <li> <p>5% for participation in class.</p> </li> </ul> <p></p> <p>Letter grades are assigned as follows:</p> Numerical grade Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 68-70% C+ 65-68% C 60-65% C- 55-60% D &lt; 55% F"},{"location":"admin/syllabus/#assignment-grades","title":"Assignment grades","text":"<p>Each assignment will be graded as follows:</p> <ul> <li>75% on correctness (up to 10% off per pass up to the limit)</li> <li>25% on coding style<ul> <li>formatting (5%)</li> <li>design (clean, not confusing, good use of functional style, etc.)</li> </ul> </li> </ul> <p>Assignment grades will be given in a file called <code>GRADES</code> written/edited by the grader. See below for more details on this.</p>"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held MWF from 11 AM to noon in Annenberg room 104.</p> <p>Most weeks will only have MW lectures, with the F lecture slot being used for code reviews.</p> <p>Lecture slides will be posted after class, but lectures will not be recorded.</p>"},{"location":"admin/syllabus/#assignments","title":"Assignments","text":""},{"location":"admin/syllabus/#due-dates","title":"Due dates","text":"<p>Assignments will be due on Fridays at 6 PM.</p>"},{"location":"admin/syllabus/#teams","title":"Teams","text":"<p>Assignments are done in teams of two students each. Teams will stay together for the duration of the term (unless one student drops the course or unless there is some serious problem). Teams are expected to split the workload of each assignment evenly, and there may be penalties if it is obvious that one student in the team is doing most or all of the work.</p> <p>Students will create a private Github repository for their code. They will add the course instructor and their TA grader as full contributors to their repository. (This is for testing purposes.)</p>"},{"location":"admin/syllabus/#submitting-assignments-and-receiving-grades","title":"Submitting assignments and receiving grades","text":"<p>Since the instructor and graders will have access to the code repositories of the teams, they can check out the latest version of the code and run the tests at any time. Thus, assignments do not need to be \"submitted\" as such; instead, \"submitting\" an assignment means that the team lets the instructor know when an assignment is ready to be graded (ideally, before the due date/time).</p> <p>The grader will grade the assignment and leave comments in a file at the root of the directory called GRADES. They may also leave comments in the code regarding code that students need to fix/change. Such comments will have this form:</p> <pre><code>(*** REWORK TODO: ... ***)\n</code></pre> <p>We ask that you do not use this style for your own comments. Once the items have been fixed, such comments should be removed before \"resubmitting\" the assignment.</p> <p>If students do not understand a comment, they are encouraged to contact the instructor and the TAs for clarification.</p> <p>Assignments will be graded out of 100. The grade for an assignment will be 75% for code correctness (i.e. passing the tests) and 25% for code quality. Code quality is broken down into:</p> <ul> <li>5% for code formatting</li> <li>20% for everything else</li> </ul> <p>Code quality is necessarily somewhat subjective, but we would like to see readable, well-documented, and well-designed code. In particular, code that is convoluted or unreasonably hard-to-understand or \"tricky\" may lose points.</p> <p>Note</p> <p>If you need to write complicated code, please write comments so that TAs can understand why you wrote it!</p> <p>Different modules will vary in how much leeway you have to implement the code.  In some modules, we want you to write specific functions with very specific goals; in others, we only care about the interface functions (exported functions), and how you write them is up to you (subject to the criteria just described).  You are always allowed to write extra helper functions wherever you feel the need.</p> <p>Also note that code quality will be a major focus of code reviews, so it will be possible to correct these issues before reworks are due.</p>"},{"location":"admin/syllabus/#code-reviews","title":"Code reviews","text":"<p>At least once every two weeks (and optionally more often), teams will meet with the instructor or one of the TAs online for roughly a half hour code review session. These sessions (which will normally happen on Thursday or Friday) are open-ended; they can be used for anything the instructor/TA or the students want. We expect that students will discuss problems they are having with their assignments, points of confusion, or just ask the instructor/TA if a particular piece of code is written the right way. Conversely, the instructor/TA may ask students why they chose to write a particular piece of code a particular way, and may suggest alternatives.</p> <p>To get full marks for code reviews, a group must participate in at least three (3) code review sessions. (You may always sign up for more than three sessions if you find them worthwhile.)</p>"},{"location":"admin/syllabus/#redos","title":"Redos","text":"<p>Once grades have been submitted, teams have one week from that time to rework the assignment for up to full credit.</p> <p>Normally redos will not be accepted after that period unless there are extenuating factors (e.g. health emergencies). Nevertheless, we do encourage students to rework old assignments if necessary, since newer assignments are extensions of older assignments.</p>"},{"location":"admin/syllabus/#late-policies","title":"Late policies","text":"<p>Because the instructor/TAs have access to your code repositories, and thus can run the tests on those repositories at any time, in principle there is no need for a late policy (any assignment can be graded simply by running the tests at any time). However, a team can request that an assignment be graded later than the usual time.</p>"},{"location":"admin/syllabus/#late-days","title":"Late days","text":"<p>Each student gets 10 \"late days\" for the entire term. Each late day allows you to submit an assignment one day late. You are allowed to use more than one late day on an assignment if you need to (but no more than 3 late days per assignment).</p> <p>In order to use late days, you must specify on the assignment when you submit it:</p> <ul> <li>how many late days you have used for the assignment,</li> <li>how many late days you have used up for the entire term.</li> </ul> <p>Please write this information in your <code>README.md</code> file, which you will submit as part of your assignment.</p> <p>Once you have used up all of your late days, you can't use any more.</p> <p>If you don't specify any late days in your assignment submission, we will assume that you are not using any for the assignment.</p> <p>You are never required to use late days, even if you submit an assignment late, but if you do submit an assignment late and don't use late days, you will receive late penalties.</p> <p>Restrictions on late days</p> <p>There are these restrictions on the use of late days:</p> <ol> <li> <p>To keep you from using up all of your late days on a single assignment,     you cannot use more than 3 late days on any single assignment.</p> </li> <li> <p>You cannot use late days on redos.     As specified above, a redo which is late is not graded.</p> </li> </ol>"},{"location":"admin/syllabus/#extensions","title":"Extensions","text":"<p>Normally, if you need an extension, just use your late days.</p> <p>Students may request additional extensions for assignments due to unusual circumstances (e.g. health problems). These extensions have to be approved by the course instructor (Mike). If you get an extension, you must indicate that at the top of your <code>README.md</code> file you submit e.g. something like this:</p> <pre><code>(One day extension granted by Mike Vanier until 10/31.)\n</code></pre> <p>This is so your grader knows not to take off late points.</p>"},{"location":"admin/syllabus/#late-penalties","title":"Late penalties","text":"<p>A late penalty is 10% of the final (unpenalized) grade per day late. It cannot be redeemed through rework.</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There is a course Piazza page, and students will be added to it by the instructor.</p> <p>Code reviews will be done on Zoom.</p> <p>If there is sufficient demand, a Discord server can be set up.</p>"},{"location":"admin/syllabus/#course-software","title":"Course software","text":"<p>Setting up the course software is described in assignment 0.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech\u2019s Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this link.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>Collaboration policies are given in the Collaboration policies document.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated with respect by your classmates and by the course staff. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructor know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student wellness","text":"<p>It is very important that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS). Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made. Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See http://cass.caltech.edu/ for more information.</p> <ol> <li> <p>There is also a Python version of the compiler textbook, which is slightly different and which we won't be using.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/0/","title":"Assignment 0: Getting set up","text":""},{"location":"assignments/0/#due-date","title":"Due date","text":"<p>This assignment has no due date, and isn't graded.</p>"},{"location":"assignments/0/#overview","title":"Overview","text":"<p>This pseudo-assignment covers the steps you need to go through so that you can start working on the real assignments (starting with assignment 1).  It has these steps:</p> <ol> <li> <p>Choose a partner.  All homework will be done collectively by groups of two    students.</p> </li> <li> <p>Get OCaml installed.  Also install all necessary supporting packages.</p> </li> <li> <p>Create a private Github repository.  Add both partners to the repository.    Add the instructor (Mike Vanier, Github name <code>mvanier</code>) to the repo.</p> </li> <li> <p>Add your TA/grader to the repository.    (This doesn't need to be done until your group has been assigned a grader.)</p> </li> </ol> <p>Once this is done, you are ready to start working on compilers! The next sections go through the steps in more detail.</p> <p>If you have any problems completing any of the steps, let the instructor and/or the TAs know.</p>"},{"location":"assignments/0/#choosing-a-partner","title":"Choosing a partner","text":"<p>We will leave this step up to you.  We can discuss it in class. If necessary, we can assign students into groups.</p>"},{"location":"assignments/0/#getting-ocaml-installed","title":"Getting OCaml installed","text":"<p>See the document Installing OCaml.</p>"},{"location":"assignments/0/#creating-a-github-repository","title":"Creating a Github repository","text":""},{"location":"assignments/0/#learning-git","title":"Learning Git","text":"<p>We expect that most of you have used the Git version control system before. If you haven't, don't worry: you only need to learn a handful of Git commands in order to work with Git.  The primary ones are <code>git commit</code>, <code>git pull</code> and <code>git push</code>.  If necessary, you should read some online tutorials.  There are also books you can read, such as Learn Enough Git To Be Dangerous.<sup>1</sup></p> <p>Learning Git is likely to be one of the most useful things you ever do as a programmer, so don't feel like this is a waste of time! All code you write should always be stored in a version control system. This protects you from accidentally deleting your files, misplacing them, etc. and also allows you to precisely track changes to your code (and revert to earlier versions in case you made a change that broke everything!).</p> <p>Warning</p> <p>We very strongly recommend that you do not try to use advanced Git commands (such as <code>git rebase</code>) unless you know exactly what you are doing. Even though Git is a source code repository system, it is possible to mess up a repo through incorrect use, and in extreme cases you might have to recreate the repository from scratch.  Be conservative!</p>"},{"location":"assignments/0/#getting-a-github-account","title":"Getting a Github account","text":"<p>You also need to have an account with Github, which is a website that offers free hosting for Github repositories. It's free to set up an account.</p> <p>Note</p> <p>You may prefer other code hosting services like Bitbucket or GitLab, but for this course, please use Github.</p>"},{"location":"assignments/0/#setting-up-the-repository","title":"Setting up the repository","text":"<p>You should give your repository a name that includes the names of both partners (not necessarily their full names). For instance, if \"John Smith\" and \"Jane Doe\" were partners, a good name for the repo might be e.g. <code>CS164_John_Smith_Jane_Doe</code>. Just <code>CS164</code> isn't good, because your grader will probably keep all of their gradees' repositories in one directory, and they need to have distinct names that indicate which group they correspond to.</p> <p>We require that your repository be private, so other students (and future students!) will not be able to look at your code \u2014 Honor Code rules apply. Newly-created Github repositories normally default to public access, and you need to change that.  (Ask us if you don't know how.)</p> <p>Do not write any code for the assignments until your Github repo is set up and until you have added the instructor (Mike, Github name <code>mvanier</code>) as a full contributor to the repo. Once you know who your grader is going to be, add them too.</p> <p>Finally, create a <code>README.md</code> file for the repository in which you state who the two members of your team are. Include both the name and email addresses of both members. (You can put more information there as well.)</p>"},{"location":"assignments/0/#browse-the-ocaml-coding-notes","title":"Browse the OCaml coding notes","text":"<p>We've collected a bunch of useful OCaml coding notes on this page. Please take a moment to browse these documents! (You don't need to read them in detail at this time, but you should be aware that they are there for when you start writing significant amounts of OCaml code.)</p> <ol> <li> <p>The author of this book (Michael Hartl) is a Caltech graduate and a friend of the instructor. There are a number of other \"Learn Enough\" books in the series, many of which you may find useful.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/overview/","title":"Assignment 1: The Var language","text":""},{"location":"assignments/1/overview/#overview","title":"Overview","text":"<p>This assignment involves writing a compiler for the Var language, which is a simple language of variables and arithmetic described in chapter 2 of the textbook and in the lectures.</p> <p>The end result will be a program called <code>compile</code> which will be able to compile a source program (with the extension <code>.src</code>) to assembly language. In addition, the compiler can stop after any pass, including after the parser, so you can inspect the generated code at each stage.  The compiler also has the ability to run a single pass given the appropriate inputs.</p>"},{"location":"assignments/1/overview/#textbook-coverage","title":"Textbook coverage","text":"<p>This assignment is based on chapter 2 of Essentials of Compilation.</p>"},{"location":"assignments/1/overview/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, October 17 at 6 PM.</p>"},{"location":"assignments/1/overview/#before-you-begin","title":"Before you begin","text":"<p>Make sure that all the action items from assignment 0 have been completed:</p> <ul> <li>choosing a partner</li> <li>installing OCaml and all the necessary OCaml libraries</li> <li>setting up a GitHub repository and adding the instructor (Mike)   and your grader (one of the TAs) as collaborators <sup>1</sup></li> </ul>"},{"location":"assignments/1/overview/#division-of-labor","title":"Division of labor","text":"<p>These assignments are very much a team effort, and both students will be credited for all work done. We don't want one student to do all the work, though. Learning how to divide the labor is an interesting challenge, and there is more than one right way to do it. Some teams may want to work on the code together (\"pair programming\"), which can be highly effective. Alternatively, you can divide up the passes. Note that each pass can be tested individually.</p> <p>If one team member is more experienced than the other, they may want to tackle the harder passes (which will be identified below). The hardest passes (of which there are none in this assignment!) are the best candidates for collective work.</p>"},{"location":"assignments/1/overview/#the-readmemd-file","title":"The <code>README.md</code> file","text":"<p>Create a <code>README.md</code> file in your <code>ch2</code> directory, and in it, identify which person wrote which passes. (If both partners worked on a pass, indicate that too.) Also, if you used any late days on the assignment, indicate how many late days you used.</p> <p>Markdown</p> <p>The <code>.md</code> file extension refers to Markdown, which is a text format that can easily be converted to web pages. You don't need to know anything about Markdown for this course, but it's worthwhile familiarizing yourselves with the most basic features of the format, since Github (for instance) will automatically display text files written in that format in a nice, readable way. A good Markdown tutorial is here, and a cheat sheet is here.</p>"},{"location":"assignments/1/overview/#submitting-your-assignment","title":"\"Submitting\" your assignment","text":"<p>Unlike most courses, there is nothing to \"hand in\" in this course. Instead, you need to inform the instructor and your TA/grader when an assignment is ready to be graded (hopefully, before or on the due date). The instructor/TA will check out your code, run the tests, and leave comments in a markdown file called <code>GRADES.md</code> in your <code>ch2</code> directory.</p> <p>After the grading comments have been checked in to your repository, you have one week to make changes. Work redone during this period will be re-evaluated without penalty.</p> <p>In addition, you can use one of your 10 late days to submit your initial work late. See the late policies in the syllabus. If you do use late days, please indicate this in your <code>README.md</code> file (see below).</p>"},{"location":"assignments/1/overview/#code-reviews-office-hours-and-feedback","title":"Code reviews, office hours, and feedback","text":"<p>We will be setting up code review times for each team. Make sure you choose a time where both members of the team can meet as well as the instructor (and/or a TA).</p> <p>Code reviews do not require that all of the code be written, or that all of the code is working perfectly, but there is no point in doing a code review unless most of the code has been written. If you are having trouble at an earlier stage, we will have office hour times you can come to.</p>"},{"location":"assignments/1/overview/#textbook","title":"Textbook","text":"<p>This assignment is based on chapter 2 of the course textbook (Essentials of Compilation by Jeremy Siek). Please read this chapter in its entirety before doing this assignment.</p> <p>One obvious and pervasive difference between the textbook and this course is that we are using OCaml to write the compiler, whereas the book uses Racket. Another is that we aren't asking you to write your own test cases, though you are encouraged to do that in addition to the ones we supply if you find it helpful.</p> <p>Also, you'll notice little differences in the way languages are represented. The Racket code has a <code>Prim</code> constructor that we don't use (yet), and an <code>info</code> field that we only use in certain languages. However, for the most part there is a close to 1-to-1 correspondence between the Racket datatypes and the datatypes we define in OCaml. When in doubt, trust the OCaml code.</p> <p>Finally, in the book, there is partial \"skeleton\" code for some of the passes. While the OCaml equivalent is broadly similar, you don't need to have an error case for unhandled cases, because OCaml pattern matching is exhaustive! When skeleton code in Racket is included in the book, you are welcome to use the Racket code as a basis for writing your own OCaml code. (Of course, you'll have to translate the Racket code to OCaml!) Learning Racket is not a requirement for this course, but you should be able to pick up enough of it to understand most of the code examples in the book.</p>"},{"location":"assignments/1/overview/#starting-code-base","title":"Starting code base","text":"<p>The starting code base is in two zip files:</p> <ul> <li><code>src.zip</code></li> <li><code>ch2.zip</code></li> </ul> <p>which are posted on the course Canvas site in the \"Assignment code\" module.</p> <p><code>src.zip</code> is the starting code base for the entire course. You should unzip this file in your Github repo. When unzipped, it will create a <code>src/</code> directory which will eventually contain all of your compiler code for the course. Initially, it just contains the file <code>dune-project</code> (which has to be at the base of any OCaml project that uses the <code>dune</code> compilation manager, as we will do), the <code>.gitignore</code> file (which tells <code>git</code> which files don't need to be under version control), and the <code>support/</code> directory. This directory contains a variety of modules which contain useful functions and data structures. We'll give you suggestions on which functions you should consider using, but you can use any of them at any time.</p> <p><code>ch2.zip</code> is the code base for assignment 1 (the Var language compiler). You should move it into the <code>src/</code> directory and unzip it in that directory. This will create the <code>ch2/</code> directory. Inside this directory will be the <code>.ml</code> and <code>.mli</code> files of the compiler, a few other files (<code>Makefile</code>, <code>dune</code>, <code>utop_init</code>, etc.) whose purposes will be described below, and three subdirectories:</p> <ul> <li> <p><code>tests/</code> \u2014 this contains all the test code   in the source language of the compiler   e.g. <code>var_test_1.src</code>;</p> </li> <li> <p><code>scripts/</code> \u2014 this contains the Python and shell test scripts   that you will use to test your compiler;</p> </li> <li> <p><code>reference/</code> \u2014 this contains the output of the reference   compiler (the instructor's compiler) for each test file   and each pass; this is used for testing   as described later in the assignment.</p> </li> </ul> <p>The name <code>ch2</code> refers to the fact that this code corresponds to the language in chapter 2 of the textbook.</p> <p>In future assignments, we will be giving you a zip file containing only the code which is specific to the new compiler, in a directory called e.g. <code>ch3</code>, <code>ch4</code>, etc.  The <code>support</code> library should not change, (unless there are bugs which need to be fixed).</p> <p>You should check in the entire <code>src</code> directory and all of its subdirectories, including the <code>.gitignore</code> files. However, don't check in the zip files! (You should probably remove them once you don't need them anymore.)</p>"},{"location":"assignments/1/overview/#sanity-checking-the-code-base","title":"Sanity checking the code base","text":"<p>If you've installed the code base correctly, you should be able to do the following:</p> <ol> <li> <p><code>cd</code> into the <code>src/ch2</code> subdirectory.</p> </li> <li> <p>Type <code>make</code>.  This will compile the compiler    (an executable file called <code>compile</code>).    You should see a number of warnings when you compile the compiler;    that's expected.    (As you fill in the code for the compiler passes,    these warnings will go away).</p> </li> <li> <p>You can use the compiler as-is to convert source files in the <code>tests/</code>    subdirectory to their \"Lvar\" AST equivalents.    (\"Lvar\" is the name of the abstract syntax tree (AST) language    for the Var compiler.) For instance:</p> <pre><code>$ ./compile tests/var_test_1.src -pass lvar\n(Program (Int 42))\n</code></pre> <p>Note that the output of the compiler is printed to the terminal. Should you want to save the output to a file, you can redirect it:</p> <pre><code>$ ./compile tests/var_test_1.src -pass lvar &gt; var_test_1.lvar\n$ cat var_test_1.lvar\n(Program (Int 42))\n</code></pre> <p>(The <code>cat</code> program simply prints a file to the terminal, though it has other uses as well.)</p> <p>You can also run the \"Lvar\" evaluator:</p> <pre><code>$ ./compile tests/var_test_1.src -pass lvar -eval\n42\n</code></pre> <p>However, if you try to compile to a pass beyond the AST, it will fail:</p> <pre><code>$ ./compile tests/var_test_1.src -pass un\nTODO\n</code></pre> <p>The <code>TODO</code> is the error message that indicates that some part of the compiler needs to be written.</p> </li> <li> <p>You can also print out the compiler options:</p> <pre><code>$ ./compile --help\n</code></pre> <p>(or just <code>compile</code> with no arguments). This prints out a usage message.</p> </li> </ol> <p>If everything works as we've described, you are ready to start work on the assignment.</p> <p>Note that each assignment's compiler will be different, and there may be different or additional command-line options for each compiler.</p> <ol> <li> <p>This assumes that a grader has been assigned to your team. If not, add the grader to your Github repo as soon as you know who they are.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/passes/","title":"Assignment 1: Compiler passes","text":"<p>This section describes the code you have to write.</p> <p>The compiler passes are described in chapter 2 of the textbook, but they are here again for completeness. We will only include passes that you have to implement. For example, even though the parser can be thought of as a \"pass\", you don't have to implement it, so we don't include it here. Similarly, the \"print assembly\" pass is provided for you, as are all the intermediate languages and interpreters.<sup>1</sup></p> <p>Note that the only files you should modify are the files corresponding to these compiler passes.  Also, only modify the <code>.ml</code> files; the <code>.mli</code> files constitute the interface to these modules and must not be changed.</p> <p>In addition, when we provide a function stub in a <code>.ml</code> file that you need to complete, that means that we expect that you will implement that function (with those arguments and types (if supplied)) as written (filling in the <code>TODO</code> parts, of course). In particular, you're not allowed to change the number of arguments to the function, or their types (if supplied). If a function is completely implemented (no <code>TODO</code>s), you should leave it as-is. On the other hand, you can write as many extra functions as you like. (If we don't like your choices, we'll let you know during code reviews!)</p> <p>Note</p> <p>We expect that you will be using the functions we require you to implement! Don't implement a required function and then not use it later. (This would generate a warning anyway.)</p>"},{"location":"assignments/1/passes/#uniquify","title":"Uniquify","text":"<p>[File: <code>uniquify.ml</code>.]</p> <p>In this pass, all names bound in <code>let</code> expressions have to be renamed to be unique.  This enables a number of further transformations in later passes.  Both the input and output languages for this pass are Lvar, defined in the files <code>lvar.ml[i]</code>.</p> <p>This is a relatively simple pass to implement.  There are four cases:</p> <ol> <li> <p>Forms with no subexpressions and no variables.  These pass through     unchanged.</p> </li> <li> <p>Forms with subexpressions but no variables.  You have to recurse     on the subexpressions and build up a new expression.</p> </li> <li> <p><code>Var</code> expressions. You need to change the variable to its new name,     if there is one.     For this, you will have to have a data structure     which maps the old names to the new names.     We recommend that you use the <code>VarMap</code> module     (defined in the <code>Types</code> module i.e. <code>types.ml</code> and <code>types.mli</code>),     which is an instance of the <code>Map</code> functor specialized for the     <code>var</code> type.  (Note that <code>var</code> is just an alias for <code>string</code>.)     A value of type <code>VarMap.t</code> is a map from variable names to some other     type; in this case we map variable names to (new) variable names!</p> <p>Note that the <code>uniquify_exp</code> function doesn't have a <code>VarMap.t</code> argument, so you will need to write a helper function that does. When a <code>Var</code> expression is encountered, check to see if the map has a new name for the variable. If it does, substitute the new name for the old one. Otherwise, leave the name unchanged. (This can happen with some global names.)</p> </li> <li> <p><code>Let</code> expressions.     When these are encountered,     you have to generate a new name from the binding name     of the <code>let</code> expression.     In the expression <code>(let (x 10) (+ x x))</code>, for instance,     <code>x</code> is the binding name.</p> <p>Note</p> <p>In compiler-speak, generated names that are different from all other names are called fresh names.</p> <p>To generate the new name, call the <code>fresh</code> function (defined in the file) with the current name and a separator as the arguments. Use <code>.</code> as the separator, so <code>x</code> might become e.g. <code>x.1</code>. Note that the <code>fresh</code> function has an internal counter, so the next time it's called with the name <code>x</code> it will return <code>x.2</code>, etc.</p> <p>Note</p> <p>This is imperative programming, and the fact that we don't have to jump through any hoops to do it (as we would, say, in Haskell) is one reason why OCaml is a convenient language for writing a compiler. (Despite this, Haskell is also a great language for writing compilers!)</p> <p>The <code>fresh</code> function is just an alias for the function <code>Utils.gensym</code> from the <code>Utils</code> module in the <code>support</code> library.  Feel free to look at the code for this function if you're interested.  This function also uses OCaml's labelled arguments feature, which we didn't use in CS 4. A good reference for labelled arguments is here.</p> <p>When you generate a fresh name for a binding name, you also have to add it to the map for the body expression of the <code>let</code>, but not for the binding expression of the <code>let</code> (since the new name is not in effect for that expression).</p> <p>Note</p> <p>Do not use hash tables for the map datatype. Hash tables are imperative, and it's much too easy to add something to a hash table that will persist longer than you want it to. Instead, use an immutable map datatype (here, <code>VarMap.t</code>). When you add something to an immutable map, you get a new map, and you can use the new or old maps as you see fit.</p> </li> </ol> <p>You should be able to implement this pass in about 50 lines of code (or less).</p> <p>Warning: evaluation order</p> <p>When we convert code in our compilers, we always convert from left-to-right if there is a choice. This sometimes conflicts with OCaml's evaluation rule, which evaluates from right to left. To avoid problems with this, use <code>let</code> expressions in your OCaml code to convert subexpressions, and then assemble the full expression from the converted parts. If you don't do this, your converted code may still be correct, but it will not match the instructor's version and will thus fail the \"compare\" tests, which expect the converted code to be identical to the reference version.</p>"},{"location":"assignments/1/passes/#remove-complex-operands","title":"Remove complex operands","text":"<p>[File: <code>remove_complex.ml</code>]</p> <p>The purpose of this pass is simply to make sure that the operands of arithmetic operations are \"simple\" i.e. are not subexpressions but \"atomic\" expressions like integers or variables. The input language to this pass is Lvar and the output language is Lvar_mon, which is defined in the files <code>lvar_mon.ml[i]</code>.</p> <p>Terminology</p> <p>Integer literal and variable expressions are simple or atomic expressions.  Any other expression is complex.</p> <p>The name Lvar_mon refers to the fact that the language is in monadic normal form, the details of which do not concern us here.</p> <p>We define an \"atom\" datatype in <code>lvar_mon.mli</code> as follows:</p> <pre><code>type atm = Int of int | Var of var\n</code></pre> <p>and then use it in the expression datatype:</p> <pre><code>type exp =\n  | Atm    of atm\n  | Read\n  | Negate of atm\n  | Add    of atm * atm\n  | Sub    of atm * atm\n  | Let    of var * exp * exp\n</code></pre> <p>The basic thing that has to happen in this pass is that non-atomic subexpressions of arithmetic forms (<code>Add</code>, <code>Sub</code>, and <code>Negate</code>) have to be transformed into <code>let</code> expressions which bind variable(s) to the complex subexpression(s). So it's something like this:</p> <pre><code>Negate &lt;complex exp&gt;\n--&gt; Let (\"$tmp\", &lt;complex exp&gt;, Negate (Var \"$tmp\")\n</code></pre> <p>Clearly, you will need to introduce <code>let</code> expressions wherever there are arithmetic expressions with complex subexpressions.</p> <p>On the other hand, expressions that are already atomic should stay the way they are:</p> <pre><code>Negate (Int 10) --&gt; Negate (Int 10)\nNegate (Var \"x\") --&gt; Negate (Var \"x\")\n</code></pre> <p>Don't do this:</p> <pre><code>Negate (Int 10)\n--&gt; Let (\"$tmp\", Int 10, Negate (Var \"$tmp\"))\nNegate (Var \"x\")\n--&gt; Let (\"$tmp\", Var \"x\", Negate (Var \"$tmp\"))\n</code></pre> <p>This is called \"generating unnecessary temporaries\". Although this doesn't yield incorrect code, it does yield inefficient code. (Why do you think that is?)</p> <p>The key function to write here is <code>rco_atom</code>. This takes an expression which needs to become atomic (like a subexpression of <code>Add</code>, say), and returns both the atomic expression and a list of (name, expression) bindings. In many cases you'll need to generate temporary names; the <code>gen_temp_name</code> function is provided to you for this purpose.</p> <p><code>rco_atom</code> is called from the <code>rco_exp</code> function, and the <code>rco_exp</code> function has to take the (name, expression) pairs and convert them into <code>let</code> expressions. (We wrote a helper function to do this; you will probably want to do the same.)</p> <p>Depending on how you write this pass, <code>rco_atom</code> may need to call <code>rco_exp</code>. If so, the two functions should be mutually recursive. (Mutually-recursive functions are common in compilers.)</p> <p><code>let</code> expressions</p> <p><code>let</code> expressions are processed differently in the <code>rco_atom</code> and <code>rco_exp</code> functions.</p> <p>In <code>rco_exp</code>, note that the immediate subexpressions of a <code>let</code> expression (both of them) do not need to be atomic, so don't try to make them atomic! That means that you can have arbitrarily nested <code>let</code> expressions. If this bothers you, don't worry: we'll fix it in the next pass!</p> <p>However, in <code>rco_atom</code>, the whole point of the function is to convert the expression into an atom (plus some bindings). If you think about it, that means that you need to convert the body of the <code>let</code> expression into an atom. The binding part of the <code>let</code> (suitably converted) is just included as part of the bindings that <code>rco_atom</code> has to return.</p>"},{"location":"assignments/1/passes/#explicate-control","title":"Explicate control","text":"<p>[File: <code>explicate_control.ml</code>]</p> <p>The purpose of this pass is to \"flatten\" the code representation into a sequence of assignment statements followed by a \"return\" statement. The <code>let</code> statements are gone, replaced by assignments. There is no more nesting of expressions, unless you consider the sequence of assignments \"nesting\".</p> <p>The input language to the pass is Lvar_mon and the output language is Cvar, defined in the files <code>cvar.ml[i]</code>. The name Cvar was chosen because the straight-line nature of the code is very similar to the way code is represented in a C language program.</p> <p>The source code consists of five functions:</p> <ul> <li><code>convert_atom</code></li> <li><code>convert_exp</code></li> <li><code>explicate_assign</code></li> <li><code>explicate_tail</code></li> <li><code>explicate_control</code></li> </ul> <p><code>explicate_control</code> is supplied for you. <code>convert_atom</code> and <code>convert_exp</code> are straightforward. <code>explicate_tail</code> converts an expression in tail position, while <code>explicate_assign</code> converts an assignment statement followed by an already-converted tail expression.</p> <p>The transformation is described in lecture 4 and chapter 2 of the textbook (section 2.6). (There is also a skeleton implementation in Racket, which may be helpful.) Note that in the textbook, the phrase \"the right-hand side of a <code>let</code>\" means \"the binding expression of a <code>let</code>\"; schematically, a <code>let</code> expression looks like this:</p> <pre><code>(let &lt;binding variable&gt; &lt;binding expression&gt; &lt;body&gt;)\n</code></pre> <p>In both <code>explicate_tail</code> and <code>explicate_assign</code>, the only (slightly) tricky case is the <code>let</code> case. Here are some hints for this case: </p> <ul> <li><code>explicate_tail</code> has to call <code>explicate_assign</code>.</li> <li> <p>In <code>explicate_assign</code>, the transformation is basically this:</p> <pre><code>(let (v (let (v' e1) e2)) tl)\n--&gt;\n(let (v' e1) (let (v e2) tl))\n</code></pre> <p>The code for this is quite simple.</p> </li> </ul> <p>The total code you need to write is considerably less than 100 lines.</p>"},{"location":"assignments/1/passes/#select-instructions","title":"Select instructions","text":"<p>[File: <code>select_instructions.ml</code>]</p> <p>This is the first of several passes collectively called the \"back end\". Their job is to convert the code into x86-64 assembly language. There are three intermediate languages specific to these passes:</p> <ol> <li> <p>x86var (<code>x86var.ml[i]</code>)</p> <p>This language mixes assembly language instructions with variables.</p> </li> <li> <p>x86int (<code>x86int.ml[i]</code>)</p> <p>This language gets rid of variables.  Variables are represented by stack locations (in this assignment) and by a combination of stack locations and registers (in later assignments).</p> </li> <li> <p>x86asm (<code>x86asm.ml[i]</code>)</p> <p>This language adds extra code (the \"prelude\" and \"conclusion\") necessary to make the entire program into a single unit that can be compiled into a full executable program.</p> </li> </ol> <p>The x86asm language</p> <p>The x86asm intermediate language is not described in the book; the book simply outputs assembly language as a string after the \"prelude and conclusion\" pass. We think that having another intermediate language is more elegant, and also could eventually be used by an interpreter which interprets the final assembly code directly.</p> <p>After x86asm, actual assembly code is trivially generated by the \"print assembly\" pass (<code>print_asm.ml[i]</code>). This code is supplied to you.</p> <p>In the \"select instructions\" pass, code is converted from the Cvar language to the x86var language.</p> <p>The <code>select_instructions.ml</code> file is mostly empty.  You have to implement the <code>convert_lt</code> function, which converts a (label, tail) pair (Cvar language) into a (label, block) pair (x86var language). The labels don't change, so essentially you are changing a Cvar tails into x86var blocks (lists of instructions).  You will want to write helper functions to do this.  (We put ours outside of the <code>convert_lt</code> function; you can do it any way you like.)</p> <p>Quoting from the textbook:</p> <p>We recommend implementing the <code>select_instructions</code> [pass] with three auxiliary functions, one for each of the nonterminals of Cvar: <code>atm</code>, <code>stmt</code>, and <code>tail</code>.</p> <p>The textbook has a good description of how to convert Cvar tails/statements/expressions/atoms into x86var instructions. Note that a single Cvar expression can yield more than one x86var instruction.</p> <p>The <code>Return</code> instruction requires special treatment. You don't actually generate a <code>Retq</code> instruction since this doesn't actually represent returning from a function (we'll see why in the \"prelude and conclusion\" pass below). Instead, you have to do the following:</p> <ol> <li> <p>Convert the expression which is the argument of the <code>Return</code>    and move that result into the <code>Rax</code> register    (this may take one or two instructions, depending on the expression).    Note that a function call (which can only be <code>Read</code> here)    will automatically return its result into the <code>Rax</code> register.</p> </li> <li> <p>Emit a <code>Jmp</code> instruction to a label called <code>conclusion</code>.</p> </li> </ol> <p>There is one other peculiarity of this pass that isn't in the book. We've provided a function called <code>fix_label</code> which should be used whenever calling an external function. In this case, the only external function is <code>read_int</code>, which is what a <code>Read</code> instruction in Cvar should compile to. So <code>Read</code> becomes <code>Callq (Label \"read_int\", 0)</code>. (The <code>0</code> in <code>Callq (Label \"read_int\", 0)</code> is the function arity i.e. the number of arguments the function takes.)</p> <p>However, different operating systems have different conventions for labels. In particular, MacOS requires that function labels (but not other labels!) have an initial underscore, so you should compile this into <code>Callq (Label \"_read_int\", 0)</code> if you're on a Mac. To make the compiler more independent of the OS it's being run on, we've added the <code>fix_label</code> function, which checks to see if the OS is \"MacOS\", and if so, prepends the underscore to the label. So instead of converting <code>Read</code> to <code>Callq (Label \"read_int\", 0)</code>, convert it to <code>Callq (Label (fix_label \"read_int\"), 0)</code>.<sup>2</sup></p> <p>Also, chapter 2 of the textbook (section 2.7) describes ways of optimizing certain instructions. For example, an <code>Add</code> expression/assignment of the form <code>v = (+ a1 a2)</code> can be compiled into two instructions, but if <code>a2</code> is the same as <code>v</code> (i.e. <code>v = (+ a1 v)</code>), it could be compiled into a single <code>addq</code> instruction. This is all well and good, but because of the \"uniquify\" pass earlier in the compiler, this will never happen, because <code>v = (+ a1 v)</code> would actually become <code>v1 = (+ a1 v2)</code>. Therefore, you should not write the code to optimize instructions in this way. (This will also reduce the amount of code you need to write.) There is no reason to add code for situations that can't occur and can't be tested. However, you should definitely use as few instructions as possible (in this case, two instructions).</p> <p>Note</p> <p>In later compilers, we will eventually add these optimizations back, because once the language has been sufficiently expanded, these situations can occur.</p>"},{"location":"assignments/1/passes/#assign-homes","title":"Assign homes","text":"<p>[File: <code>assign_homes.ml</code>]</p> <p>The purpose of this pass is to convert variable names into stack locations. Note that in this compiler, we are not storing variables in registers. (In all the later compilers, we will be.)  Therefore, this pass will only exist in this compiler; in later compilers, it will be replaced by several register allocation passes.  Fortunately, assigning variables to stack slots is straightforward.</p> <p>Although this pass converts x86var programs to x86var programs, the resulting programs will not use variables. (We will get rid of variables altogether in the x86int language.) However, the <code>info</code> field of the programs will change; after the \"select instructions\" pass the info field is <code>info1</code>, which stores type information for all variables; after \"assign homes\" it's <code>info2</code>, which only stores the stack space used.</p> <p>Variables placed on the stack are identified by their position in memory relative to the \"base pointer\".   This is a memory location which is stored in a special register called <code>rbp</code> (often written <code>%rbp</code>, though in the OCaml code we refer to it as <code>Rbp</code>).<sup>3</sup> The base pointer represents the start of the stack used for a particular function. Variables stored on the stack are identified relative to the base pointer. Stack variables are placed in memory below the base pointer (we say that the stack \"grows downwards\"). Variables are 8 bytes in size (64 bits), so the first variable will be stored 8 bytes below the base pointer. In assembly language, this is written as <code>-8(%rbp)</code>; in the OCaml code we write it as <code>Deref (Rbp, -8)</code>. The next stack location will be <code>-16(%rbp)</code>, and so on. The space used for all the stack variables is known as the \"stack frame\". One curious requirement of x86-64 assembly language is that the total amount of space used for the stack frame must be a multiple of 16 bytes, so even if you only need one stack variable (8 bytes), you have to reserve 16 bytes.</p> <p>Here's what you need to do in this pass:</p> <ol> <li> <p>Use the <code>info1</code> field to assign stack locations to all variables    used in the program.  <code>info1</code> contains a list of all variables    in the program as well as their types.    (The types are all <code>Integer</code>, so that isn't relevant    except that you need to know that all integers are 8 bytes long.)    You should store the (variable name, stack location) pairs    as an <code>int VarMap.t</code> (mapping names to their stack locations).    You will also need to compute the total amount of stack space    required.  Since this has to be aligned on a 16 byte boundary,    we've provided a utility function called <code>align_16</code> in the    <code>Utils</code> module of the <code>support</code> library.</p> </li> <li> <p>Once this has been done, you need to go through all the instructions    in the blocks and replace variables with their stack locations.    If you encounter a variable which doesn't have an assigned stack location,    signal an error (this shouldn't happen, but it's good to check).</p> </li> <li> <p>Compute an <code>info2</code> field using the computed stack space,    and reconstitute the program.</p> </li> </ol>"},{"location":"assignments/1/passes/#patch-instructions","title":"Patch instructions","text":"<p>[File: <code>patch_instructions.ml</code>]</p> <p>In a perfect world, we would not need to do this pass. However, the x86-64 instruction set is far from elegant, and we have to deal with its restrictions. One such restriction is that no instruction can have two arguments where both arguments are memory references (as opposed to (say) immediate values or registers). If such instructions exist, they need to be \"patched\" (fixed) so that the restriction is adhered to.</p> <p>There are different ways of handling this, but the textbook suggests a very simple strategy. When you have an instruction that uses two stack locations, convert it into two instructions using the <code>%rax</code> register (OCaml <code>Rax</code>) as an intermediary. There are only three instructions in this compiler where this can happen: <code>addq</code>, <code>subq</code>, and <code>movq</code>. The <code>movq</code> case is the simplest. Change:</p> <pre><code>movq -8(%rbp), -16(%rbp)\n</code></pre> <p>to two instructions:</p> <pre><code>movq -8(%rbp), %rax\nmovq %rax, -16(%rbp)\n</code></pre> <p>This doesn't violate the restriction.  The <code>addq</code> and <code>subq</code> cases are similar but slightly trickier.</p> <p>What you need to do is to go through all instructions, determine if an instruction needs to be patched, and patch it in those cases. Don't patch instructions that don't need to be patched! For instance, don't change:</p> <pre><code>movq $42, -8(%rbp)\n</code></pre> <p>into this:</p> <pre><code>movq $42, %rax\nmovq %rax, -8(%rbp)\n</code></pre> <p>because the instruction didn't need to be patched (since there was only one memory reference).</p> <p>Note</p> <p>The <code>$42</code> assembly language syntax means an immediate value; in OCaml we write this as <code>Imm 42</code>.</p> <p>Note also that this pass converts from the x86var language to the x86int language, which doesn't have variables. This means that there will be some trivial \"boilerplate\" conversions, like converting an <code>Imm</code> constructor in one language to the exact same constructor in the other language. This is trivial but a bit tedious. (It's the price we pay for having precise types.)</p>"},{"location":"assignments/1/passes/#prelude-and-conclusion","title":"Prelude and conclusion","text":"<p>[File: <code>prelude_conclusion.ml</code>]</p> <p>This is the last pass you need to write. The textbook also includes a partial evaluator pass as an optional \"challenge\" pass; we won't be doing that.</p> <p>This pass converts from the x86int language to the x86asm language, which is basically x86-64 assembly language, but in an S-expression representation. The actual assembly language is generated by the \"print assembly\" pass, which you don't have to write.</p> <p>The purpose of this pass is to add extra code to make a complete assembly language program. The code that we have been generating so far (whether we were aware of it or not) is the body of the <code>main</code> function. However, in order for this to be a proper function, some code has to be added both before and after the code we've written. The code that is executed before the code we've written is called the prelude, and the code that comes after is called the conclusion. These don't have to come physically before or after our code, since we have <code>jmp</code> instructions to transfer control. Therefore, we put them after our code.</p> <p>The code we've been working with is all in a single block labelled <code>start</code>. The code that comes before this is going to have to jump to this label, and our code is going to have to eventually jump to the label called <code>conclusion</code>. The \"prelude\" is everything that comes before the jump to <code>start</code> and the \"conclusion\" is everything that comes after the jump to <code>conclusion</code>.</p> <p>The actual beginning of execution is the label called <code>main</code> (or <code>_main</code> if you're running on a Mac). We also have to declare <code>main</code> to be a \"global\" name (as all top-level functions have to be) by using the <code>Global</code> instruction. (This becomes <code>.globl</code> in the actual assembly code.) This declaration has to come before the <code>main</code> label, and it's the beginning of the prelude.</p> <p>The prelude does the following:</p> <ol> <li>Declares <code>main</code> as a global name and defines the <code>main</code> label.</li> <li>Saves the previous base pointer (in the <code>%rbp</code> register) to    the stack (using a <code>pushq</code> instruction).</li> <li>Saves the current stack pointer (in the <code>%rsp</code> register)    into the base pointer register <code>%rbp</code>.</li> <li>Reserves space for all the stack variables (a multiple of 16)    by modifying the stack pointer <code>%rsp</code>.</li> <li>Jumps to the <code>start</code> label.</li> </ol> <p>The conclusion does the following:</p> <ol> <li>Reclaims the stack space used in the code.</li> <li>Restores the old base pointer using a <code>popq</code> instruction.</li> <li>Returns from the <code>main</code> function with a <code>retq</code> instruction.</li> </ol> <p>This code is completely generic except for the stack space, which is going to depend on how many variables are placed on the stack. You can look at the examples in the <code>reference</code> directory to see what the prelude and conclusion look like. The code is easy to write, although there are a number of trivial \"boilerplate\" conversions because we are changing the datatype.</p> <ol> <li> <p>The interpreters are not part of the compiler per se, but they are used for testing.\u00a0\u21a9</p> </li> <li> <p>Aren't compilers fun?  You have to deal with all of this arbitrary nonsense, because otherwise you can't generate working code. That's the price you pay for doing something cool.\u00a0\u21a9</p> </li> <li> <p>Fun fact: There is no absolute requirement to use the <code>%rbp</code> register to store the base pointer.  Many C compilers (e.g. <code>gcc</code>) have an option to omit the base pointer entirely, which frees up this register to be used to store regular variables. This is a big deal for processors with very few registers (like 32 bit x86 processors, which only have 8 registers) but less important for us, since x86-64 processors have 16 registers.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/testing/","title":"Assignment 1: Testing the compiler","text":""},{"location":"assignments/1/testing/#compiling-the-compile-program","title":"Compiling the <code>compile</code> program","text":"<p>To compile the compiler, <code>cd</code> into the <code>src/ch2</code> directory and type <code>make</code>. This will compile the compiler (which is an executable file called <code>compile</code>). You should see a number of warnings when you compile the compiler; that's expected. (As you fill in the code for the compiler passes, these warnings will go away).</p>"},{"location":"assignments/1/testing/#running-the-compile-program","title":"Running the <code>compile</code> program","text":"<p>To run the compiler, type <code>./compile</code> in the <code>ch2</code> directory, along with the path of a file to compile and (optionally) some command-line options. Typing <code>./compile --help</code> (or just <code>./compile</code> with no arguments) will display this usage message:</p> <pre><code>usage: compile &lt;filename&gt; [-pass &lt;pass&gt;] [-only] [-eval] [-no-fix-label]\n                          [-sexp-width n] [-sexp-indent n] [-help]\n  -pass Last compiler pass (one of: lvar un rc ec si ah pi pc pa)\n  -only Only do one compiler pass\n  -eval Evaluate after compiling\n  -no-fix-label disable `fix_label`\n  -sexp-width S-expression maximum line width\n  -sexp-indent S-expression indent\n  -help  Display this list of options\n  --help  Display this list of options\n</code></pre> <p>Note that the filename argument is required. (Don't type the <code>&lt;</code> <code>&gt;</code> characters; that's just to indicate that the name <code>filename</code> is a placeholder for the actual filename.) We will describe the command line options below. If there are no command-line options, the file will be compiled all the way to assembly language, and the output will be printed to the terminal. If you want to save the output to a file, you can redirect it with the Unix shell operator <code>&gt;</code> as follows:</p> <pre><code>$ ./compile tests/var_test_1.src &gt; var_test_1.s\n</code></pre> <p>This will save the printed output to a file named <code>var_test_1.s</code>. (This is an appropriate name, since assembly language files conventionally end in <code>.s</code>.) From there, it can be compiled to an executable and run as described below.</p> <p>Here are the command-line arguments for the <code>compile</code> program:</p> <ul> <li><code>-help</code> (or <code>--help</code>, or no arguments).</li> </ul> <p>This prints out the usage message.</p> <ul> <li><code>-pass &lt;pass&gt;</code></li> </ul> <p>This tells the compiler to stop and print the output after the pass   <code>&lt;pass&gt;</code>.  The allowed passes for this compiler are:</p> <ul> <li><code>lvar</code> -- the \"Lvar\" language AST (not technically a pass)</li> <li><code>un</code>   -- the \"uniquify\" pass</li> <li><code>rc</code>   -- the \"remove complex operands\" pass</li> <li><code>ec</code>   -- the \"explicate control\" pass</li> <li><code>si</code>   -- the \"select instructions\" pass</li> <li><code>ah</code>   -- the \"assign homes\" pass</li> <li><code>pi</code>   -- the \"patch instructions\" pass</li> <li><code>pc</code>   -- the \"prelude and conclusion\" pass</li> <li><code>pa</code>   -- the \"print assembly\" pass</li> </ul> <p>The <code>lvar</code> \"pass\" just runs the parser.  This converts the source code   to the <code>Lvar</code> AST form.</p> <ul> <li><code>-only</code></li> </ul> <p>Adding this option causes the compiler to run only the pass specified   by the <code>-pass</code> option.  For this to work, the input file must be   in the correct format, representing an S-expression version   of the datatype that is the input to the pass.   We normally will use the file extensions <code>.un</code>, <code>.rc</code> etc.   to indicate that a file has been compiled up to that pass.</p> <p>This option is normally used with the reference outputs; these provide   outputs of the compiler for all passes and for all test programs.   Each file in the <code>reference/</code> directory contains a file extension   which gives information about the last pass which was used to compile it.   Therefore, you can use this file as input to the next pass.   For instance:</p> <pre><code>$ ./compile reference/var_test_11.rc -pass ec -only\n</code></pre> <p>will compile the file <code>reference/var_test_11.rc</code>   (which has already been compiled up to the \"remove complex operands\" pass)   using only the \"explicate control\" pass (which is the next pass).</p> <p>If you attempt to compile a file this way using the wrong input,   you will get an error message which may be hard to understand.</p> <p>This is a good way to test the code for a single pass, and you can do this   even if the previous passes haven't been written.</p> <ul> <li><code>-eval</code></li> </ul> <p>Adding this option causes the compiler to run an evaluator after compiling.   Note that not all passes have evaluators; only the ones up to <code>ec</code> do.   Also, note that <code>-eval</code> and <code>-only</code> are mutually exclusive.</p> <ul> <li><code>-sexp-width n</code></li> </ul> <p>If the S-expressions printed are too narrow or wide for your taste,   you can adjust it with this option, which sets the width of the   S-expression display in columns.  By default, <code>n</code> is 40.</p> <p>Note that if <code>n</code> is too small, the S-expressions may be spread out over   more lines than you care to view.  Conversely, if it's too large,   too many S-expression forms may be crammed into a single line.</p> <ul> <li><code>-sexp-indent n</code></li> </ul> <p>This allows you to set the degree of indentation for S-expressions.   By default, it's 2.  It's unlikely that you'll want/need to change this.</p>"},{"location":"assignments/1/testing/#compiling-and-running-assembly-language-code","title":"Compiling and running assembly language code","text":""},{"location":"assignments/1/testing/#manual-compilation","title":"Manual compilation","text":"<p>Once you've compiled the source programs all the way down to assembly language, you will probably be wondering how to turn the assembly language into a working executable program. If you have a computer running a 64-bit Intel or AMD processor (which use the x86-64 instruction set),  or a Mac with an M-series processor (e.g. M1, M2) and Rosetta 2 installed, you can compile the assembly language code that the compiler generates.</p> <p>Note</p> <p>So, basically, almost any computer you are likely to have will be able to compile the assembly code you generate.</p> <p>Let's use the <code>var_test_5.src</code> file as an example. You will also need the C code files <code>runtime.c</code> and <code>runtime.h</code>, which should be in your <code>ch2</code> directory.</p> <p>Here is the sequence of commands.  Note that assembly language files normally end in <code>.s</code>, so we redirect the compiler output to the filename <code>var_test_5.s</code> and compile it with the <code>gcc</code> C compiler (which needs to be installed if it isn't already).</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ gcc -c var_test_5.s\n$ gcc -c runtime.c\n$ gcc var_test_5.o runtime.o -o var_test_5\n$ ./var_test_5\n$ echo $?\n42\n</code></pre> <p>Note</p> <p>On an M-series Mac with Rosetta 2 installed, change these commands to:</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ clang -c var_test_5.s -arch x86_64\n$ clang -c runtime.c -arch x86_64\n$ clang var_test_5.o runtime.o -o var_test_5 -arch x86_64\n$ ./var_test_5\n$ echo $?\n42\n</code></pre> <p>This compiles the assembly language file <code>var_test_5.s</code> to the binary executable program <code>var_test_5</code>. When this program is run, it doesn't appear to do anything. However, the program returns an integer return code to the operating system, which in this case is the number 42.  The line <code>echo $?</code> prints this number.</p> <p>Note</p> <p>These return codes can only be in the range 0 to 255, so if you return an integer outside this range, it will be coerced into that range, which sometimes leads to peculiar results.</p> <p>If the program you are compiling has calls to the <code>read</code> function, you will have to input the integers to be read when the program runs.</p> <p>The <code>run_eval_tests.py</code> test script handles all of this for you, so there is no need to actually go through these steps, but you should know how to do them anyway.</p>"},{"location":"assignments/1/testing/#run_asmpy","title":"<code>run_asm.py</code>","text":"<p>You can also use the script <code>run_asm.py</code> which is in the <code>scripts/</code> subdirectory of the <code>ch2</code> directory. For example:</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ python scripts/run_asm.py var_test_5.s\n</code></pre> <p>which will output:</p> <pre><code>COMMAND: gcc -c var_test_5.s\nCOMMAND: gcc -c runtime.c\nCOMMAND: gcc var_test_5.o runtime.o -o var_test_5\nCOMMAND: ./var_test_5\nOUTPUT (return code): 42\n</code></pre> <p>If you are running the code on an M-series Mac, add the <code>-arm64</code> command-line argument to <code>run_asm.py</code>:</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ python scripts/run_asm.py var_test_5.s -arm64\n</code></pre> <p>This will output:</p> <pre><code>COMMAND: clang -c var_test_5.s -arch x86_64\nCOMMAND: clang -c runtime.c -arch x86_64\nCOMMAND: clang var_test_5.o runtime.o -o var_test_5 -arch x86_64\nCOMMAND: ./var_test_5\nOUTPUT (return code): 42\n</code></pre> <p>Note that the C compiler name has been switched to <code>clang</code> (which, for our purposes, works the same as <code>gcc</code>), and some extra arguments are present.</p> <p>The <code>run_asm.py</code> script also removes all generated files, so you don't have to.</p> <p>Note that you don't need to use this script. The <code>run_eval_tests.py</code> script will do all of this for you. However, <code>run_asm.py</code> is convenient if you have an assembly language file and you want to compile and run it separately from the tests.</p>"},{"location":"assignments/1/testing/#testing-your-compiler-the-test-scripts","title":"Testing your compiler: the test scripts","text":"<p>There are five scripts in the <code>ch2/scripts</code> subdirectory; three Python scripts and two shell scripts. One Python script is the <code>run_asm.py</code> script described above; the other two are described here. <sup>1</sup> The two shell scripts are described after the Python scripts.</p>"},{"location":"assignments/1/testing/#run_eval_testspy","title":"<code>run_eval_tests.py</code>","text":"<p>This script can be used to test that a particular <code>.src</code> file generates the correct output when given particular inputs. It uses metadata stored in comments in the <code>.src</code> files in the <code>/tests</code> subdirectory. For instance, consider the file <code>var_test_10.src</code>:</p> <pre><code>;; INPUT: 45 3 ; 21 20\n;; OUTPUT: 42 ; 1\n(let (x (read))\n  (let (y (read))\n    (+ x (- y))))\n</code></pre> <p>The metadata is in the first two lines, with the <code>INPUT:</code> and <code>OUTPUT:</code> tags. These indicate that the program should be run twice: the first time with (terminal) inputs <code>45</code> and <code>3</code>, producing the output <code>42</code>, and the second time with (terminal) inputs <code>21</code> and <code>20</code>, producing the output <code>1</code>.</p> <p>You invoke the test script this way:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src\n</code></pre> <p>Note</p> <p>On an M-series Mac, add the command-line argument <code>-arm64</code> to the above command:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src -arm64\n</code></pre> <p>It will output:</p> <pre><code>----\ninput file: var_test_10.src\n\n* input/output data #1:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\nCompiling to assembly language and compiling/running the program.\n\n* input/output data #2:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\nCompiling to assembly language and compiling/running the program.\n</code></pre> <p>This can be done for many files, or even for all tests files at once:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_*.src\n</code></pre> <p>(This will produce a lot of output!)</p> <p>If one of the evaluators produces incorrect output, an error message will be printed and the test script will halt.</p> <p>By default, the test script will not just test the program outputs using the evaluators of the intermediate languages (<code>lvar</code>, <code>lvar_mon</code>, etc.), but will also compile the code all the way to assembly language, run it, and test the output against the expected output.</p> <p>If, for some reason, you don't want to run the final step on your tests (compiling to assembly language and compiling/running the program), pass the <code>-no-asm</code> command-line option when invoking the script:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src -no-asm\n</code></pre> <p>It will output this:</p> <pre><code>----\ninput file: var_test_10.src\n\n* input/output data #1:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\n\n* input/output data #2:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\n</code></pre> <p>Notice that the lines that say:</p> <pre><code>Compiling to assembly language and compiling/running the program.\n</code></pre> <p>are no longer there. This option is good for quick tests, since these tests will run dramatically faster if they don't have to compile and run the final assembly language program.</p>"},{"location":"assignments/1/testing/#comparepy","title":"<code>compare.py</code>","text":"<p>The idea of this test script is to simplify the process of comparing the output of compiling a file using only a single pass with the corresponding output file in the <code>reference/</code> subdirectory. Of course, you can do this yourself manually; for instance, you can do this:</p> <pre><code>$ ./compile reference/var_test_11.rc -pass ec -only &gt; var_test_11.ec\n</code></pre> <p>and compare the file <code>var_test_11.ec</code> that was generated by your compiler to the file <code>reference/var_test_11.ec</code> in the <code>reference/</code> subdirectory. If they are the same, all is well. However, repeating this for a lot of files and a lot of passes is very tedious! Also, you might miss something if you just compare them visually (\"eyeballing it\").  Instead, you can use the <code>diff</code> program to test if the files are different:</p> <pre><code>$ diff var_test_11.ec reference/var_test_11.ec\n</code></pre> <p>If there is no output, the files are identical. If there is any difference, the lines that are different will be printed in a format which shows what's different. But again, doing this for a lot of files is going to be tedious.</p> <p>Note</p> <p>It's important to realize that your output files can have some differences from the reference output files and still be acceptable. For instance, the \"uniquify\" pass is not required to give the exact same names to variables whose names are changed, as long as the names are changed consistently. Nevertheless, if you can make the outputs identical, it will greatly simplify testing. Therefore, we want you to do your best to make the test outputs identical to the reference outputs. If you are having trouble doing this, ask questions during office hours or during code reviews.</p> <p>The purpose of the <code>compare.py</code> script is to simplify this process. If you run it with no arguments, you get a usage message:</p> <pre><code>$ python scripts/compare.py\nusage: python compare.py [-pause] [-diff] [-random n] filename [filename ...]\n</code></pre> <p>The required arguments are one or more filenames. These files should be in the <code>reference/</code> subdirectory. The files in that directory have file extensions corresponding to the last compiler pass that was used to generate them, so (for instance) <code>var_test_11.ec</code> is what the compiler outputs when compiling the file <code>var_test_11.src</code> up to and including the <code>ec</code> (explicate control) pass. If you want to test your <code>var_test_11.ec</code> against the reference version, you should start with the output of the previous pass, which in this case is <code>var_test_11.rc</code> (the <code>rc</code> or \"remove complex operands\" pass). Since this file is also in the <code>reference/</code> subdirectory, you can use it as the compiler input.  So if you type:</p> <pre><code>$ python scripts/compare.py reference/var_test_11.rc\n</code></pre> <p>the script will:</p> <ul> <li> <p>run <code>./compile reference/var_test_11.rc -pass ec -only</code>   and redirect the output to a file called <code>var_test_11.ec</code>   in the <code>ch2</code> directory;</p> </li> <li> <p>display the files <code>var_test_11.ec</code> (your compiler's output)   and <code>reference/var_test_11.ec</code> (the reference output)   side-by-side so you can compare them visually.</p> </li> </ul> <p>Which reference file extension to use</p> <p>This behavior is extremely counterintuitive for a lot of people. It's natural to assume that if you want to compare the result of the \"explicate control\" (<code>ec</code>) pass, for instance, you should pass the <code>compare.py</code> script as its input a file (or files) with the <code>.ec</code> extension. However, this isn't the way it works. Files with the <code>.ec</code> extension have already been processed by the \"explicate control\" pass. Put differently, the file extension refers to the last pass the code went through before the file was output. The <code>compare.py</code> script needs (in this case) the output of the pass before \"explicate control\", so it can run just that specific pass on the file. The pass before \"explicate control\" is \"remove complex operands\", with the file extension <code>.rc</code>. Therefore, if you want to compare the results of the \"explicate control\" pass, you need to invoke the <code>compare.py</code> script on a file with the file extension <code>.rc</code>, not <code>.ec</code>.</p> <p>Put simply, the files you need for the <code>compare.py</code> script are the input files for the pass you are testing, so their file extension is the extension for the previous pass, not the file extension for the pass that you are testing.</p> <p>The best way to make sure that you have the correct previous pass is to run the <code>compile</code> program without arguments:</p> <pre><code>usage: compile &lt;filename&gt; [-pass &lt;pass&gt;] [-only] [-eval] [-no-fix-label]\n                      [-sexp-width n] [-sexp-indent n] [-help]\n-pass Last compiler pass (one of: lvar un rc ec si ah pi pc pa)\n...\n</code></pre> <p>The <code>-pass</code> options are listed in order, so you can see that the pass preceding <code>ec</code> (explicate control) is <code>rc</code> (remove complex operands). Therefore, to test the \"explicate control\" pass, you need to run the <code>compare.py</code> script on reference files with the <code>.rc</code> file extension. This is pretty obvious for this compiler, but later compilers will have type checking passes (which are supplied to you) interleaved with passes that you have to write, so the \"previous pass\" may not be the pass you think it is! It's always good to check this before running <code>compare.py</code> tests, because otherwise you may think that the code for your pass is correct when it isn't!</p> <p>The output will look like this:</p> <pre><code>$ python scripts/compare.py reference/var_test_11.rc\n--------------\ninput: reference/var_test_11.rc\noutput: reference/var_test_11.ec\n\n# Student version.                                        # Reference version.\n(CProgram                                                 (CProgram\n  (Info                                                     (Info\n    (locals_types                                             (locals_types\n      ((x.1 Integer)                                            ((x.1 Integer)\n       (x.2 Integer)                                             (x.2 Integer)\n       (y.1 Integer))))                                          (y.1 Integer))))\n  (((Label start)                                           (((Label start)\n    (Seq                                                      (Seq\n      (Assign x.1 (Atm (Int 20)))                               (Assign x.1 (Atm (Int 20)))\n      (Seq                                                      (Seq\n        (Assign x.2 (Atm (Int 22)))                               (Assign x.2 (Atm (Int 22)))\n        (Seq                                                      (Seq\n          (Assign y.1 (Add (Var x.1) (Var x.2)))                    (Assign y.1 (Add (Var x.1) (Var x.2)))\n          (Return (Atm (Var y.1)))))))))                            (Return (Atm (Var y.1)))))))))\n</code></pre> <p>(You can scroll this output horizontally to see it all, but the two files are identical.) If you just want to check if the files are identical, use the <code>-diff</code> option:</p> <pre><code>$ python scripts/compare.py reference/var_test_11.rc -diff\nreference/var_test_11.rc : OK\n</code></pre> <p>If there is no difference, you'll get an <code>OK</code> as you see here.</p> <p>Note</p> <p>Most people just use the <code>-diff</code> option, since it will also print the differences if there are any.</p> <p>In either case, any generated files are removed before the <code>compare.py</code> script exits.</p> <p>This can be repeated for any number of files:</p> <pre><code>$ python scripts/compare.py reference/var_test_?.rc -diff\nreference/var_test_1.rc : OK\nreference/var_test_2.rc : OK\nreference/var_test_3.rc : OK\nreference/var_test_4.rc : OK\nreference/var_test_5.rc : OK\nreference/var_test_6.rc : OK\nreference/var_test_7.rc : OK\nreference/var_test_8.rc : OK\nreference/var_test_9.rc : OK\n</code></pre> <p>If you do this without the <code>-diff</code> option, though, the output can get very large, and you'll have to scroll back to check each file. To make this easier, we've added a <code>-pause</code> option, which will display one file at a time (both versions: yours and the reference one) and wait for you to hit the return key before the next one is displayed.</p> <p>The last feature is the <code>-random</code> option. It's used with an argument, which should be a positive integer. With <code>-random N</code>, up to <code>N</code> randomly-selected files will be chosen from the list of files on the command line and compared. This is useful to quickly check if a pass is working well; you can type something like this:</p> <pre><code>$ python scripts/compare.py reference/var_test_*.rc -diff -random 10\n</code></pre> <p>and get comparisons of (in this case) 10 random files selected from the files specified on the command line:</p> <pre><code>reference/var_test_4.rc : OK\nreference/var_test_6.rc : OK\nreference/var_test_15.rc : OK\nreference/var_test_27.rc : OK\nreference/var_test_38.rc : OK\nreference/var_test_40.rc : OK\nreference/var_test_57.rc : OK\nreference/var_test_58.rc : OK\nreference/var_test_62.rc : OK\nreference/var_test_67.rc : OK\n</code></pre> <p>However, most people just test all of the files in a pass:</p> <pre><code>$ python scripts/compare.py reference/var_test_*.rc -diff\nreference/var_test_1.rc : OK\nreference/var_test_2.rc : OK\nreference/var_test_3.rc : OK\n(etc.)\n</code></pre>"},{"location":"assignments/1/testing/#run_all_eval_testssh","title":"<code>run_all_eval_tests.sh</code>","text":"<p>This is a shell script, not a Python script (hence the <code>.sh</code> suffix). It runs all the \"eval\" tests with a single command. In the <code>ch2</code> directory, type this:</p> <pre><code>$ sh scripts/run_all_eval_tests.sh\n</code></pre> <p>Note</p> <p>Don't type the <code>$</code>, which is just the terminal prompt.</p> <p>Also, if the terminal complains about not being able to find the <code>sh</code> program, try <code>bash</code> or <code>zsh</code> instead.</p> <p>If you are running the tests on a Mac with Rosetta 2 installed, type this instead:</p> <pre><code>$ sh scripts/run_all_eval_tests.sh -arm64\n</code></pre> <p>If you want to skip the final \"eval\" tests (running the compiled assembly code), just add the <code>-no-asm</code> optional argument.</p>"},{"location":"assignments/1/testing/#run_all_compare_testssh","title":"<code>run_all_compare_tests.sh</code>","text":"<p>This is also a shell script. It simplifies the process of running \"compare\" tests. One problem with \"compare\" tests is that it's easy to skip a pass without realizing it. This script will run each individual pass in order (not skipping any passes), it will pause after running each pass so you can look at the output, and it will continue until all compare tests have been run.</p> <p>To run it, type this into the terminal from the <code>ch2</code> directory:</p> <pre><code>$ sh scripts/run_all_compare_tests.sh\n</code></pre> <p>This will print the name of the tests to be run next (e.g. \"Uniquify tests\", \"Remove complex operands tests\", etc.), and then it will pause. At that point, you should hit the \"return\" key (or \"enter\" on some keyboards), at which point it will run the indicated tests and pause again. The tests are run using the <code>-diff</code> option, so ideally you will see a bunch of lines ending in <code>OK</code>. Keep pressing the \"return\" key when the program pauses, and eventually all tests will be run. If you find an error, you probably will want to exit the script so you can track down the error; hit \"control-C\" to do this.</p>"},{"location":"assignments/1/testing/#once-everything-works","title":"Once everything works","text":"<p>Congratulations!  You have written your first compiler!</p> <p>The workflow for subsequent compilers will basically be the same as for this one. There will be many more passes, and occasionally some other things that need to be tested.</p> <ol> <li> <p>Since the compiler is written in OCaml, you might wonder why the testing scripts are written in Python. We don't think it's a good idea to get too obsessed with any one programming language. OCaml is a fine language for writing a compiler, but Python is more convenient when working with large numbers of files and calling programs to act on those files.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/2/overview/","title":"Assignment 2: Register allocation","text":""},{"location":"assignments/2/overview/#overview","title":"Overview","text":"<p>In this assignment, you will be extending your Var language compiler from the last assignment to do register allocation in the back end instead of putting all variables on the stack.</p>"},{"location":"assignments/2/overview/#textbook-coverage","title":"Textbook coverage","text":"<p>This assignment is based on chapter 3 of Essentials of Compilation.</p>"},{"location":"assignments/2/overview/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, October 24 at 6 PM.</p>"},{"location":"assignments/2/overview/#starting-code-base","title":"Starting code base","text":"<p>The starting code base is the zipfile <code>ch3.zip</code>, which is posted on the course Canvas site. You should unzip this file in your Github repo, inside the <code>src/</code> directory. It contains partial implementations of all the code for the assignment.</p> <p>Inside the <code>ch3</code> directory will be these subdirectories:</p> <ul> <li> <p>The <code>tests/</code> subdirectory contains the same test programs   as in the previous assignment.</p> </li> <li> <p>The <code>reference/</code> subdirectory contains the output   from the instructor's version of the compiler.   Note that there are many more files in this directory than in the   previous assignment, for reasons which will be explained below.</p> </li> <li> <p>The <code>scripts/</code> subdirectory contains scripts for testing your code.   These are mostly the same as in the last assignment,   but there are a few additional features, described below.</p> </li> </ul>"},{"location":"assignments/2/overview/#the-readmemd-file","title":"The <code>README.md</code> file","text":"<p>Create a <code>README.md</code> file in your <code>ch3</code> directory, and in it, identify which person wrote which passes. (If both partners worked on a pass, indicate that too.) Also, if you used any late days on the assignment, indicate how many late days you used.</p>"},{"location":"assignments/2/overview/#submitting-your-assignment","title":"\"Submitting\" your assignment","text":"<p>The process for \"submitting\" the code is the same as in the previous assignment, except that the code is in the <code>ch3</code> directory, of course.</p>"},{"location":"assignments/2/passes/","title":"Assignment 2: Compiler passes","text":"<p>The compiler passes are described in chapter 3 of the textbook, but here they are again for completeness.  We will only include passes that you have to implement. As before, the only files you should modify are the <code>.ml</code> files corresponding to these compiler passes.</p> <p>In addition, when we provide a function stub in a <code>.ml</code> file that you need to complete, that means (unless otherwise specified) that we expect that you will use that function (with those arguments and types (if supplied)) as written (filling in the <code>TODO</code> parts, of course). In particular, you're not allowed to change the number of arguments to the function, or their types (if supplied). If a function is completely implemented (no <code>TODO</code>s), you should leave it as-is. On the other hand, you can write as many extra functions as you like. (If we don't like your choices, we'll let you know during code reviews!)</p> <p>Note</p> <p>The one exception to this rule is in the <code>graph_coloring.ml</code> file. We provide function stubs with <code>TODO</code>s as usual, as well as an implementation of the <code>color</code> function that uses those functions, but if you don't like this, you are allowed to completely rewrite the entire module, as long as you end up with a <code>color</code> function with the correct type signature which works correctly.</p>"},{"location":"assignments/2/passes/#passes-that-are-unchanged-from-assignment-1","title":"Passes that are unchanged from assignment 1","text":"<p>Since the focus of this assignment is on register allocation, those passes that come before register allocation do not have to be modified from assignment 1 (in your <code>ch2/</code> directory).  This includes:</p> <ul> <li><code>uniquify.ml</code></li> <li><code>remove_complex.ml</code></li> <li><code>explicate_control.ml</code></li> </ul> <p>Note that you are free to edit your old code, in case you think you have a better way of doing things than what you wrote previously, or in case you found bugs in those passes that you need to fix.</p>"},{"location":"assignments/2/passes/#1-select-instructions-select_instructionsml","title":"1. Select instructions (<code>select_instructions.ml</code>)","text":"<p>The \"select instructions\" pass has no fundamental changes, but there are some trivial changes because the <code>X86Program</code> type in <code>x86_var.ml[i]</code> has changed. The new version has different info types for the program and also has block info types.  For this pass, the block info is a placeholder type (containing no information) called <code>binfo1</code>. (This will change in later passes.) Some of the type annotations will need to be changed slightly, and the blocks will all contain a <code>Binfo1</code> constructor. The type checker should point out exactly where your old code needs to be changed.</p>"},{"location":"assignments/2/passes/#2-uncover-live-uncover_liveml","title":"2. Uncover live (<code>uncover_live.ml</code>)","text":"<p>The \"uncover live\" pass does liveness analysis. It has to implement the function <code>uncover_live</code> with this signature:</p> <pre><code>val uncover_live :\n  (X86_var.info1, X86_var.binfo1) X86_var.program -&gt;\n  (X86_var.info1, X86_var.binfo2) X86_var.program\n</code></pre> <p>The <code>X86_var.program</code> type is parameterized on two kinds of \"info\" types: one for the program as a whole (with variants <code>info1</code>, <code>info2</code>, and <code>info3</code>), and one for blocks (with variants <code>binfo1</code> and <code>binfo2</code>). The <code>info1</code> and <code>binfo1</code> types are placeholder types, containing no data. All that this pass does is compute the <code>binfo2</code> value, which contains the liveness information described in the textbook (section 3.2) and in the lectures. The instructions should not be changed. The <code>binfo2</code> type has this definition:</p> <pre><code>type live =\n  {\n    initial : LocSet.t;       (* initial live variables/registers *)\n    afters  : LocSet.t list;  (* live vars/regs after each instruction *)\n  }\n\ntype binfo2 = Binfo2 of live\n</code></pre> <p>The liveness data is represented as a list of sets of locations, where a \"location\" is a variable, a register, or a stack location. Sets of locations are represented by the type <code>LocSet.t</code>. Since liveness sets apply between instructions, we use the <code>initial</code> field to represent the initial set of live locations, and the <code>afters</code> field represents, for each instruction, the set of live locations after that instruction.</p> <p>Note</p> <p>In principle, we could have added the liveness data directly to the instructions, but we prefer to keep it separate, partly because it's only used in this pass. It's important to be aware that there is a one-to-one correspondence between the instructions in the program and the <code>after</code> sets of the <code>live</code> record: the Nth item in the <code>after</code> sets is the after set for the Nth instruction in the program.</p> <p>We provide an implementation for the <code>uncover_live</code> function, which calls the function <code>uncover_live_in_block</code> to compute the liveness sets.  You have to implement that function. The inputs to that function are the list of instructions in the block, and <code>live_before_labels</code>, which is a map between block names and the live locations before that block executes. Here, there is only one such block: <code>conclusion</code>, with live locations (registers) <code>%rax</code> and <code>%rsp</code>.</p> <p>Note</p> <p>Recall that we compute liveness backwards, from the last instruction back towards the first. The live locations before the <code>conclusion</code> block constitute the live-after set of the last instruction in the code you are compiling.</p> <p>You can implement <code>uncover_live_in_block</code> as you like (as long as it's functional \u2014 don't use mutation!) but we recommend that you define a helper function to compute the liveness set for a single instruction given the instruction and its live-after set.</p> <p>Also, be aware that <code>callq</code> instructions require special handling. First, executing a <code>callq</code> instruction can result in any of the caller-saved registers being overwritten. There is a list of caller-saved registers in the <code>Types</code> module as <code>caller_saved_regs</code>; don't hard-code the caller-saved registers! Second, <code>callq</code> instructions with arity (number of arguments) greater than 0 have to read from registers for the first 6 arguments. These registers are given in the <code>Types</code> module as <code>arg_passing_regs</code>; these arguments are (in order) <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code> (all of which are caller-saved registers, which should make sense). We recommend that you write a helper function to determine the change in the liveness set just for <code>callq</code> instructions, incorporating all of this information.</p> <p>Note</p> <p>Basically, for a <code>callq</code> instruction, all the caller-saved registers get added to the write set, and the arg-passing registers needed (but only those that are needed) get added to the read set.</p> <p>The algorithm for computing liveness sets is described in detail in section 3.2 of the textbook and in the lectures.</p>"},{"location":"assignments/2/passes/#3-build-interference-graph-build_interferenceml","title":"3. Build interference graph (<code>build_interference.ml</code>)","text":"<p>The \"build interference\" pass has to implement the function <code>build_interference</code> with this signature:</p> <pre><code>val build_interference :\n  (X86_var.info1, X86_var.binfo2) X86_var.program -&gt;\n  (X86_var.info2, X86_var.binfo1) X86_var.program\n</code></pre> <p>From this, we can see that the block info <code>binfo2</code> value (containing the liveness data) goes back to the placeholder <code>binfo1</code> type, but the program info <code>info1</code> value (containing nothing but the types of variables) gets extended into the <code>info2</code> type, which has this definition:</p> <pre><code>type info2 = Info2 of\n  {\n    locals_types : (var * ty) list;\n    conflicts    : LocUgraph.t\n  }\n</code></pre> <p>What this does is add the interference graph information (as the <code>conflicts</code> field) to the program.</p> <p>Note</p> <p>You might wonder why the liveness data is stored in a block info type while the interference graph is stored in a program info type. The liveness data is stored in a block-by-block manner, while there is only one interference graph per function. (Here, our programs are a single <code>main</code> function.) Note that most functions will have multiple blocks. Ours do also (the <code>start</code> block plus the prelude and conclusion) but we don't have to compute the liveness data for the prelude and conclusion because they are so simple. In later compilers, our programs will have many more blocks to handle conditionals, loops and user-defined functions.</p> <p>We supply you with an implementation of the <code>build_interference</code> function which calls the <code>make_graph</code> function to compute the interference graph. You need to implement <code>make_graph</code>, following the algorithm given in section 3.3 of the textbook and in the lectures. You'll almost certainly want to split this function up into multiple helper functions. Pay particular attention to <code>movq</code> and <code>callq</code> instructions; remember that for <code>callq</code> you need to create an edge between all the locations in the live-after set and all caller-save registers.</p> <p>Note</p> <p>This is unrelated to the handling of caller-save registers in liveness analysis, which normally does nothing but is included for completeness.  Here, creating the edges between call-live variables and caller-save registers is extremely important, because it prevents call-live variables from being placed into caller-save registers, where they would have to be saved and restored before and after the call.  Thus, they will normally be put into callee-save registers, unless there are none available, in which case they will be placed onto the stack.  The register allocation algorithm handles all of this automatically!</p> <p>You might wonder if instead of spilling a call-live variable to the stack, it might be better to just put it in a caller-save register (assuming there is one) and pay the price of saving and restoring. This is a fine question, and one that preoccupies people writing optimizing compilers, but our goals are less lofty. We just want to generate reasonably good code, not maximally optimal code.</p> <p>Please review section 3.3 of the textbook before attempting this pass, since it has detailed rules for which instructions give rise to which edges in the interference graph. Also, recall that the way we are building the interference graph is to focus on writes, because the writes performed by an instruction must not overwrite something in a live location. As the book says:</p> <p>So for each instruction, we create an edge between the locations being written to and the live locations. (However, a location never interferes with itself.)</p> <p>One consequence of this is that instructions that don't write to a live location don't change the interference graph.</p>"},{"location":"assignments/2/passes/#4-graph-coloring-graph_coloringml","title":"4. Graph coloring (<code>graph_coloring.ml</code>)","text":"<p>This module is not technically a compiler pass, but it's an integral part of the \"allocate registers\" pass.  However, the algorithm is more general, and the implementation is not specialized to locations (registers, variables and stack locations) until the <code>GraphColor</code> functor (defined in this module) is specialized to locations in <code>allocate_registers.ml</code>.  The algorithm is described in some detail in section 3.4 of the textbook as well as in the lectures.</p> <p>The <code>GraphColor</code> functor is parameterized on several modules:</p> <ul> <li> <p>a module defining the graph element type   (which will be locations in <code>allocate_registers.ml</code>)</p> </li> <li> <p>a module defining the element map type   (made from the <code>MapS</code> functor specialized on element keys);   <code>MapS</code> is just an extension of the normal OCaml <code>Map</code> functor   and is defined in <code>support/functors.ml[i]</code></p> </li> <li> <p>a priority queue module   (defined in <code>support/priority_queue.ml[i]</code>)</p> </li> <li> <p>an undirected graph module (the interference graph;   defined in <code>support/ugraph.ml[i]</code>)</p> </li> </ul> <p>The functor is instantiated in <code>allocate_registers.ml</code>, so you don't have to worry about how to do that. Inside the functor, a type <code>node_data</code> is defined that contains information about the elements (locations) which isn't stored in the interference graph, and that changes as the algorithm progresses. The two components of a <code>node_data</code> record are the color of the element (an <code>int option</code>, since the element is initially uncolored), and the saturation set (a set of integers, representing the colors that the element is not allowed to have). As the algorithm progresses, the colors (which mostly start as <code>None</code>) get filled in, and the saturation sets increase in size, which constrains the color choices.</p> <p>We define a <code>nodemap</code> type which is a map between elements and <code>node_data</code> records. We also provide a debugging function called <code>_print_nodemap</code> which can print out the nodemap at any point in the algorithm to help debugging.</p> <p>Note</p> <p>The name is <code>_print_nodemap</code> instead of <code>print_nodemap</code> because it isn't exported from the functor, and OCaml issues a warning about unused functions if their names don't start with an underscore.</p> <p>The only function that needs to be implemented is the <code>color</code> function, which takes an interference graph and a map of precolored elements (an element-to-<code>int</code> map) as its arguments. Recall that the only precolored elements we are using are the reserved registers, which for this compiler are <code>%rax</code> (color <code>-1</code>), and <code>%rsp</code> (color <code>-2</code>). The return value of the function is the full element-to-<code>int</code> map, containing color assignments for all variables.</p> <p>Because this is a somewhat tricky algorithm, we've provided you with a starting point. We've given our version of the <code>color</code> function, which calls a number of helper functions. You may choose to simply implement all the helper functions in <code>graph_coloring.ml</code>. Or, if you would prefer to implement the <code>color</code> function from scratch, you are free to delete any or all of our helper functions and rewrite the <code>color</code> function accordingly. (Don't change its type, though!)</p> <p>Note</p> <p>The only restriction we'll insist on is that your code for this module should be purely functional. Don't use <code>ref</code> cells or any other imperative features. In a real-world setting, you might choose to use imperative code for efficiency or convenience, but it's definitely not necessary. Also, functional code is easier to get right.</p> <p>The total amount of code you need to write is less than 100 extra lines.</p>"},{"location":"assignments/2/passes/#testing-the-graph-coloring-algorithm","title":"Testing the graph coloring algorithm","text":"<p>There is a very trivial test script for the graph coloring algorithm only in the file <code>test_graph_coloring.ml</code>. You can run it in the interactive interpreter as follows:</p> <pre><code>$ make repl\n# #use \"test_graph_coloring.ml\";;\n</code></pre> <p>This will run the test and print <code>TEST PASSED!</code> if it passes or <code>TEST FAILED!</code> if not. More importantly, since this is done interactively, you can inspect the results of graph coloring to see how they differed from the expected results. The example given is the same one given in the book and in the lectures.</p> <p>Note</p> <p>In future, we plan to have much more comprehensive tests of this algorithm. If you are looking for a topic for a CS 81 project, this course is a gold mine! In addition to more tests, there are lots of features we want to add.</p>"},{"location":"assignments/2/passes/#5-allocate-registers-allocate_registersml","title":"5. Allocate registers (<code>allocate_registers.ml</code>)","text":"<p>Once you've implemented the graph coloring algorithm, the \"allocate registers\" pass is simple.  You need to do these things:</p> <ol> <li> <p>Run the graph coloring algorithm and assign registers    (or, if there are no available registers, stack locations)    to all variables.    This is done in the functions <code>get_variable_location_map</code>,    which is supplied to you, and <code>varmap_of_colormap</code>,    which you need to fill in.    Your implementation of <code>varmap_of_colormap</code>    should use the helper function <code>location_of_color</code>,    which you also need to fill in.</p> <p>Note</p> <p>The <code>location_of_color</code> function should make use of the <code>last_register_color</code> variable. This gives the index of the last register that can be used for register allocation. It's set in the <code>set_register_color_list</code> function, and will correctly track the <code>-regs</code> argument of the compiler. Don't use the size of <code>register_color_list</code> or of the maps computed by it, since they also contain the reserved registers (with negative color numbers).</p> <p>Also note that <code>last_register_color</code> is an <code>int ref</code>, not an <code>int</code>, so you will need to dereference it to get its value. Please don't set it, though!</p> </li> <li> <p>Use the mapping between variable bindings and locations    (registers or stack locations)    to determine the number of stack slots needed, if any.    This is done in the function <code>get_num_spilled</code>,    which you need to fill in.    Be careful that you don't count a stack location more than once!    Hint: sets, specifically <code>LocSet</code>s, are your friend!</p> </li> <li> <p>Use the same mapping between variable bindings and locations    to collect a set of all the callee-save registers    used in the program.    This is done in the function <code>get_used_callee</code>,    which you need to fill in.</p> </li> <li> <p>Convert all the instructions that use variables    to use the corresponding registers or stack locations.    This is done in the function <code>convert_block</code>,    which you need to fill in.    You'll probably want to define some helper functions    in your implementation of this function.</p> </li> </ol> <p>All the other code for this pass has been supplied. In particular, code for selecting which registers are available (based ultimately on the command-line arguments to the <code>compile</code> program) is supplied and should not be altered.</p>"},{"location":"assignments/2/passes/#6-patch-instructions-patch_instructionsml","title":"6. Patch instructions (<code>patch_instructions.ml</code>)","text":"<p>Aside from trivial type changes, the only significant change in this pass is that instructions of the form <code>Movq (x, x)</code> (moving a value from a location to the same location) are removed.</p>"},{"location":"assignments/2/passes/#7-prelude-and-conclusion-prelude_conclusionml","title":"7. Prelude and conclusion (<code>prelude_conclusion.ml</code>)","text":"<p>This pass has a few changes from the corresponding pass in the last assignment.</p> <p>The <code>info</code> record type attached to the <code>program</code> type in <code>x86_int.mli</code> has these fields:</p> <pre><code>locals_types : (var * ty) list;\nnum_spilled  : int;\nused_callee  : RegSet.t\n</code></pre> <p>We won't be concerned with <code>locals_types</code>, but the other two are relevant to generating a correct prelude and conclusion. <code>num_spilled</code> is the number of stack slots needed for variables that were not placed in registers. <code>used_callee</code> are the names of the callee-save registers that are used in the program.</p> <p>Recall that the program is one big function (the <code>main</code> function), and so the values of any callee-saved variables that are used inside this function must be saved in the prelude and restored in the conclusion. They will be saved to the stack and restored from the stack. Therefore, the total number of stack slots needed can be more than <code>num_spilled</code>; it's actually <code>num_spilled</code> plus the number of callee-save registers used. And to make it even more confusing, the size of the stack frame (the total amount of stack space reserved for the function) must be a multiple of 16 bytes, so it can be even bigger!</p> <p>Recall from the previous assignment that we have defined a function called <code>align_16</code> in the <code>Utils</code> module of the <code>support</code> directory. This will take a non-negative integer and round it up to the nearest multiple of 16. So the total stack space required is actually (in pseudocode):</p> <pre><code>stack_space = align_16(8 * (num_spilled + size(used_callees)))\n</code></pre> <p>However, it's still a bit more complicated than this. We will be saving the callee-save registers by pushing them to the stack with the <code>pushq</code> instruction, and restoring them with the <code>popq</code> instruction. The <code>pushq</code> instruction subtracts 8 bytes from the stack pointer, and the <code>popq</code> adds it back. The effect of this is that, after all the callee-save registers have been pushed to the stack using <code>pushq</code> instructions, we've already allocated a big chunk of the total stack space required. The additional stack space we need to allocate can be computed from these equations (in pseudocode):</p> <pre><code>n_callees = size(used_callees)\nextra_stack_space = align_16 (8 * (num_spilled + n_callees)) - 8 * n_callees\n</code></pre> <p>This is already computed for you in the <code>prelude_conclusion</code> function.</p> <p>From here, you have to do two things:</p> <ol> <li> <p>Compute the prelude and conclusion    (collectively called the \"epilog\" in the code because we place it    after the code in the <code>start</code> block).    This is done in the <code>epilog</code> function which takes the    set of callee-save registers and the amount of extra stack space needed    as arguments.</p> </li> <li> <p>Adjust all instructions in the <code>start</code> block that access stack locations,    because the callee-save registers on the stack use up space    at the beginning of the stack frame,    which means that any stack location access    which is relative to the base pointer in <code>%rbp</code>    has to be changed to account for this extra space.    This is done in the <code>asm_of_lb</code> function,    which takes a labelled block (the <code>start</code> block, in this case)    and the amount of space that stack locations need to be shifted by    (called <code>deref_adjust</code>)    as its arguments.  You'll probably want to define helper functions    to write this function, as (we hope) you did in the last assignment.</p> </li> </ol> <p>The <code>prelude_conclusion</code> function appends the epilog to the <code>start</code> block code to generate the final program.</p> <p>Here are a couple of notes about the functions you need to write.</p> <ol> <li> <p>For <code>asm_of_lb</code>, all you need to do is go through all instructions,    changing any stack location accesses    by subtracting the <code>deref_adjust</code> value.</p> </li> <li> <p>For <code>epilog</code>, after you've established the base pointer in the prelude,    you need to push the callee-save register values onto the stack, and then    adjust the stack pointer by subtracting the extra space needed for    the stack-resident variables before jumping to the <code>start</code> block.    (Recall that the stack grows downwards,    so subtracting from the stack pointer reserves stack space.)    In the conclusion, you have to add the extra space for the stack-resident    variables back to the stack (reclaiming the stack space),    and then pop the callee-save register values back to their registers    before resetting the base pointer and returning.    Make sure that you pop the callee-save registers in reverse order    to the order in which you pushed them!    (Remember, the stack is a last-in, first out (LIFO) data structure.)    Also, only push and pop the callee-save registers you actually used;    if your program didn't use any,    you don't have to do any pushing and popping.</p> </li> </ol> <p>This sounds much more complicated than it is! This pass is really just a little bit of (somewhat annoying) bookkeeping.</p>"},{"location":"assignments/2/testing/","title":"Assignment 2: Testing the compiler","text":""},{"location":"assignments/2/testing/#compiling-the-compile-program","title":"Compiling the <code>compile</code> program","text":"<p>To compile the compiler, <code>cd</code> into the <code>src/ch3</code> directory and type <code>make</code>. This will compile the compiler (which is an executable file called <code>compile</code>). You should see a number of warnings when you compile the compiler; that's expected. (As you fill in the code for the compiler passes, these warnings will go away).</p>"},{"location":"assignments/2/testing/#running-the-compile-program","title":"Running the <code>compile</code> program","text":"<p>To run the compiler, type <code>./compile</code> in the <code>ch3</code> directory, along with the path of a file to compile and (optionally) some command-line options. Most of this is the same as it was in the last assignment.</p> <p>Typing <code>./compile --help</code> (or just <code>./compile</code> with no arguments) will display this usage message:</p> <pre><code>usage: compile &lt;filename&gt; [-pass &lt;pass&gt;] [-only] [-eval] [-no-fix-label]\n                          [-sexp-width n] [-sexp-indent n]\n                          [-regs reg1,reg2,...] [-help]\n  -pass Last compiler pass (one of: lvar un rc ec si ul bi ar pi pc pa)\n  -only Only do one compiler pass\n  -eval Evaluate after compiling\n  -no-fix-label disable `fix_label`\n  -sexp-width S-expression maximum line width\n  -sexp-indent S-expression indent\n  -regs Registers to use\n  -help  Display this list of options\n  --help  Display this list of options\n</code></pre> <p>This is the same as the <code>compile</code> usage message from the previous assignment, except that there is a new command-line option:</p> <ul> <li><code>-regs reg1,reg2,...</code></li> </ul> <p>This is a new feature of the compiler, starting with this assignment   and continuing through all the subsequent ones.   It allows you to select which registers can be used for register allocation.   If this option is not used, all registers (other than the reserved ones)   can be used.   This is extremely useful for checking whether variables get spilled   to the stack correctly once there are no more registers available,   and for whether callee-saved registers are handled correctly   in the preludes and conclusions of functions.</p> <p>The test scripts use this option in these ways:</p> <ul> <li>unused -- use all available registers</li> <li><code>-regs rcx</code> -- only use the <code>%rcx</code> register (caller-saved)</li> <li><code>-regs rbx</code> -- only use the <code>%rbx</code> register (callee-saved)</li> <li><code>-regs rcx,rbx</code> -- only use the <code>%rcx</code> and <code>%rbx</code> registers</li> <li><code>-regs rbx,r12</code> -- only use the <code>%rbx</code> and <code>%r12</code> registers</li> </ul> <p>For instance, if the only register you use is <code>%rbx</code>   (a callee-saved register),   then if you don't save and restore callee-saved registers properly,   you'll get an error.</p>"},{"location":"assignments/2/testing/#testing-your-compiler-the-test-scripts","title":"Testing your compiler: the test scripts","text":"<p>The test scripts are the same as those described in the previous assignment, except that the test scripts will also use the <code>-regs</code> command-line option as described above. As a result, there will be many more reference files generated for passes that use registers.</p>"},{"location":"assignments/3/overview/","title":"Assignment 3: Conditionals: the Cond language","text":""},{"location":"assignments/3/overview/#overview","title":"Overview","text":"<p>In this assignment, you will be extending the \"Var\" language compiler from the last assignment and adding the following features:</p> <ul> <li>conditionals (<code>if</code> statements)</li> <li>boolean values (true or false, written as <code>#t</code> and <code>#f</code>)</li> <li>type checking (although you don't have to write the type checking code)</li> </ul>"},{"location":"assignments/3/overview/#textbook-coverage","title":"Textbook coverage","text":"<p>This assignment is based on chapter 4 of Essentials of Compilation.</p>"},{"location":"assignments/3/overview/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, November 7 at 6 PM.</p>"},{"location":"assignments/3/overview/#starting-code-base","title":"Starting code base","text":"<p>The starting code base is the zipfile <code>ch4.zip</code>, which is posted on the course Canvas site. You should unzip this file in your Github repo, inside the <code>src/</code> directory. It contains partial implementations of all the code for the assignment.</p> <p>Inside the <code>ch4</code> directory will be these familiar subdirectories:</p> <ul> <li> <p>The <code>tests/</code> subdirectory contains the test programs for the compiler.</p> </li> <li> <p>The <code>reference/</code> subdirectory contains the output   from the instructor's version of the compiler.</p> </li> <li> <p>The <code>scripts/</code> subdirectory contains scripts for testing your code.</p> </li> </ul>"},{"location":"assignments/3/overview/#readmemd-file","title":"<code>README.md</code> file","text":"<p>Create a <code>README.md</code> file in your <code>ch4</code> directory, and in it, identify which person wrote which passes. (If both partners worked on a pass, indicate that too.) Also, if you used any late days on the assignment, indicate how many late days you used.</p>"},{"location":"assignments/3/overview/#new-language-features","title":"New language features","text":"<p>The new language features are described in the textbook and the lectures, but in brief, they are:</p> <ul> <li>a <code>Boolean</code> type</li> <li>boolean values: true (<code>#t</code>) and false (<code>#f</code>)</li> <li>relational operators (operators that return boolean values):   <code>eq?</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code></li> <li> <p>new expressions:</p> <ul> <li><code>and</code> (boolean AND)</li> <li><code>or</code>  (boolean OR)</li> <li><code>if</code>  (conditionals)</li> </ul> </li> </ul> <p>In addition, there is a boolean <code>not</code> function.</p> <p>Operators no longer have separate intermediate language constructors like <code>Add</code> and <code>Negate</code> from the Var language compiler; all of these have been combined together into the <code>Prim</code> constructor (which stands for \"primitive operation\") which can take any number of arguments. Checking that each operator receives the right number of arguments is the responsibility of the type checkers.</p>"},{"location":"assignments/3/overview/#type-checking","title":"Type checking","text":"<p>Since this language has two types (<code>Integer</code> and <code>Boolean</code>), it needs a type checker. In fact, two intermediate languages have type checkers: the AST language (\"Lif\") and the C-like intermediate language (\"Cif\"). The type checkers are supplied to you in the <code>Type_check</code>, <code>Type_check_lif</code>, and <code>Type_check_cif</code> modules. You will only notice them if your code fails to type check.</p>"},{"location":"assignments/3/passes/","title":"Assignment 3: Compiler passes","text":"<p>The compiler passes are described in chapter 4 of the textbook and in the lectures, but here they are again for completeness. (You should still read the book for a more in-depth explanation!) We will only include passes that you have to implement. As before, the only files you should modify are the <code>.ml</code> files corresponding to these compiler passes.</p>"},{"location":"assignments/3/passes/#1-shrink-shrinkml","title":"1. Shrink (<code>shrink.ml</code>)","text":"<p>This is a new pass. Its purpose is to remove the <code>and</code> and <code>or</code> forms by translating them to <code>if</code> expressions using this translation:</p> <pre><code>(and e1 e2) --&gt; (if e1 e2 #f)\n(or e1 e2)  --&gt; (if e1 #t e2)\n</code></pre> <p>This pass converts from the <code>Lif</code> language to the <code>Lif_shrink</code> language. The only difference between them is that in <code>Lif_shrink</code>, the <code>And</code> and <code>Or</code> constructors have been removed.</p>"},{"location":"assignments/3/passes/#2-uniquify-uniquifyml","title":"2. Uniquify (<code>uniquify.ml</code>)","text":"<p>This is essentially the same as the \"uniquify\" pass for the Var language compiler, except that you have to add a case for the <code>If</code> constructor, and all the operators have been combined into the <code>Prim</code> constructor.</p>"},{"location":"assignments/3/passes/#3-remove-complex-operands-remove_complexml","title":"3. Remove complex operands (<code>remove_complex.ml</code>)","text":"<p>The \"remove complex operands\" pass is essentially the same as in the Var compiler, except for the necessary changes to accommodate the new language forms and the folding of operator expressions into the <code>Prim</code> constructor. Note that all three operands of an <code>if</code> expression can be complex, so don't convert them to atoms.</p>"},{"location":"assignments/3/passes/#4-explicate-control-explicate_controlml","title":"4. Explicate control (<code>explicate_control.ml</code>)","text":"<p>The \"explicate control\" pass has significant changes from the previous compiler. This pass converts code in the \"Lif_mon\" language to the \"Cif\" language. The \"Cif\" language is like \"Cvar\" from the previous compiler, but with these changes/additions:</p> <ul> <li>a <code>Bool</code> constructor for boolean literals</li> <li>operator expressions using the <code>Prim</code> constructor used in the   \"Lif\" languages</li> <li> <p>extra <code>tail</code> constructors:</p> <ul> <li><code>Goto</code> for unconditional jumps</li> <li><code>IfStmt</code> for conditional jumps</li> </ul> </li> </ul> <p>The most significant change are conditional jumps represented by the <code>IfStmt</code> constructor of the <code>tail</code> datatype, because the code can then go in one of two directions. The <code>IfStmt</code> constructor looks like this:</p> <pre><code>IfStmt of {\n  op : cmp_op;\n  arg1 : atm;\n  arg2 : atm;\n  jump_then : label;\n  jump_else : label;\n}\n</code></pre> <p>This corresponds to a comparison operator which jumps to one label if the comparison returns \"true\" (<code>#t</code>) or to the other label if the comparison returns \"false\" (<code>#f</code>). The labels correspond to blocks of instructions, so the entire code is represented as a set of labelled blocks, which we refer to as \"basic blocks\".</p> <p>Note</p> <p>A \"basic block\" is a sequence of instructions that has no internal jumps i.e. if there are any jump instructions (like <code>Goto</code> or <code>IfStmt</code> in the \"Cif\" language) they only appear at the end of the block.</p> <p>With code represented as a set of basic blocks connected by jumps, the code representation is abstractly a graph, not a tree. In particular, code in the \"Cif\" language corresponds to a directed acyclic graph (DAG), which we will discuss below.</p> <p>The \"explicate control\" pass from the previous (Var) compiler has these functions:</p> <ul> <li>a function to convert atoms (<code>convert_atom</code>)</li> <li>a function to convert expressions (<code>convert_exp</code>)</li> <li>a function to convert assignments (<code>explicate_assign</code>)</li> <li>a function to convert expressions in \"tail position\" (<code>explicate_tail</code>)</li> </ul> <p>All of these are straightforward functions to implement.</p> <p>For this compiler, we need to extend these functions to deal with the new language constructs, and we need to define an additional one for conditional expressions (<code>explicate_pred</code>).</p> <p>The <code>convert_atom</code> function needs to be extended to deal with the new <code>Bool</code> constructor, which is trivial.</p> <p>The <code>convert_exp</code> function needs to handle operator expressions differently to reflect the new <code>Prim</code> constructor. Neither the <code>Let</code> nor the <code>If</code> constructor of the \"Lif_mon\" language should be handled here, so signal an error if you get one of these as an input.</p> <p>The <code>explicate_assign</code> function has to deal with <code>if</code> expressions in <code>let</code> bindings.  This is essentially this transformation:</p> <pre><code>(let (y (if e1 e2 e3)) tl)\n--&gt;\n(if e1 (let (y e2) tl) (let (y e3) tl))\n</code></pre> <p>except that the tails (<code>tl</code>) are not duplicated.  This can be achieved by converting the tail to a block using the (provided) <code>create_block</code> function and then using a <code>Goto</code> to that block for each tail. To convert the <code>if</code> expression itself requires the <code>explicate_pred</code> function, described below.</p> <p>Note</p> <p>If the tail is already a <code>Goto</code>, the <code>create_block</code> function returns it unaltered, as you would expect.</p> <p>The <code>explicate_tail</code> function needs to be extended to handle <code>if</code> expressions. This requires recursive calls to itself and also requires a call to <code>explicate_pred</code>.</p> <p>Now we get to <code>explicate_pred</code>, which is the most complicated function of the pass. It's the function that is called to convert <code>if</code> expressions, as we've seen. The arguments are:</p> <ul> <li>a boolean-valued test expression (an \"Lif_mon\" expression)</li> <li>converted (\"Cif\") tails   for the \"then\" and \"else\" clauses of the <code>if</code> expression</li> </ul> <p>The most straightforward case is where the test expression is an operator expression using a comparison operation. In that case, an <code>IfStmt</code> tail can be generated immediately.</p> <p>Pattern matching</p> <p>There is a trick you can use in pattern-matching so that you only match operators which are comparison operators. It takes advantage of the fact that the operators are represented as polymorphic variants. The pattern match case looks like this:</p> <pre><code>| Prim (#cmp_op as op, [a1; a2]) -&gt; ...\n</code></pre> <p>This will match a <code>Prim</code> constructor whose operator is a comparison operator, and give it the local name <code>op</code>. The <code>#cmp_op</code> syntax says to take the subset of the operators (type <code>core_op</code>) which match the <code>cmp_op</code> polymorphic variant datatype. (Both the <code>core_op</code> and the <code>cmp_op</code> types are defined in <code>types.ml</code>.)</p> <p>Another simple case is when the test expression is a literal boolean. In that case, either the \"then\" tail or the \"else\" tail can be returned immediately (depending on the boolean's value). Negated literal booleans can be handled similarly. (This is an example of partial evaluation.)</p> <p>If the test case is a boolean-valued variable, this can be converted to an equality comparison: <code>v</code> becomes <code>(eq v #t)</code>.</p> <p>This leaves two trickier cases, both of which can be described in terms of the transformations needed to compile them.</p> <ol> <li> <p>The test expression is a <code>let</code>,    which means that the original <code>if</code> expression    is a <code>let</code> inside an <code>if</code>.    This is compiled using this transformation:</p> <pre><code>(if (let (x e1) e2) then_tl else_tl)\n--&gt;\n(let (x e1) (if e2 then_tl else_tl))\n</code></pre> <p>Of course, the <code>let</code> output ends up becoming an <code>Assign</code> statement in the \"Cif\" language.</p> </li> <li> <p>The test expression is another <code>if</code> expression,    which means that the original <code>if</code> expression    is an <code>if</code> inside an <code>if</code>.    This is compiled using this transformation:</p> </li> </ol> <pre><code>(if (if e1 e2 e3) then_tl else_tl)\n--&gt;\n(if e1 (if e2 then_tl else_tl) (if e3 then_tl else_tl))\n</code></pre> <p>It's important not to duplicate the tails, so convert them    to labels using the <code>create_block</code> function.    This will also require recursive calls to <code>explicate_pred</code>.</p> <p>One curious aspect of this pass is that we use imperative programming. We have a global reference to a map between labels and blocks to keep track of the basic blocks. We could have done this using extra arguments, but we felt that it was simpler with this small amount of imperative programming.<sup>1</sup></p>"},{"location":"assignments/3/passes/#5-remove-unused-blocks-remove_unusedml","title":"5. Remove unused blocks (<code>remove_unused.ml</code>)","text":"<p>The \"remove unused blocks\" pass takes in a program in the \"Cif\" intermediate language and also returns a program in this language. Its job is to remove any blocks that can never be reached.</p> <p>Where do unused blocks come from?</p> <p>Here is an example of how unused blocks can arise.</p> <p>Let's say that the test operand of an <code>if</code> expression is <code>#t</code>, and the tail (the \"else\" case) is a <code>Goto</code>. Although the compilation of the <code>if</code> in <code>explicate_pred</code> will discard the \"else\" tail, the block corresponding to the tail will have already been compiled, and it will become part of the output of the \"explicate control\" pass. If no other code jumps to that block, it's an unused block.</p> <p>There is no point in having unused blocks in the code, so this pass removes them.<sup>2</sup></p> <p>The basic algorithm is as follows:</p> <ul> <li>Start with a list of (label, tail) pairs.   (This is the way programs are represented in the \"Cif\" language.)</li> <li>Convert it to a label to tail map   (a <code>tail LabelMap.t</code> in OCaml).</li> <li>Compute the set of all labels that are reachable from the \"start\" label.   You probably will want to write one or more helper functions to do this.   The <code>get_jump_labels</code> function in the <code>Cif</code> module will be useful.</li> <li>Compute a list of (label, tail) pairs which only includes the   reachable labels; this is used to generate the output program.</li> </ul> <p>To figure out which labels are reachable from the \"start\" label, use <code>get_jump_labels</code> to find the successors of \"start\", then find the successors of each of these, etc. until every reachable label has been found.</p> <p>This pass is short and should be fairly straightforward to implement.</p> <p>Label order</p> <p>In the label-to-tail list output from the pass, make sure that the block labels are in alphabetical order, since that is the order in the reference files. If you convert a label map to a list using the <code>bindings</code> function, this will happen automatically. This label order will be used in all subsequent passes.</p> <p>(In \"explicate control\", the \"start\" block label is output first, which is just for convenience. That code is supplied to you. In the rest of the passes, the \"start\" block label is output in its alphabetical order with respect to the rest of the block labels. The order doesn't matter except to make testing easier.)</p>"},{"location":"assignments/3/passes/#6-select-instructions-select_instructionsml","title":"6. Select instructions (<code>select_instructions.ml</code>)","text":"<p>The \"select instructions\" pass converts programs from the \"Cif\" intermediate language to the \"X86_var_if\" intermediate language. Overall, it is structured in the same way as it is in the Var compiler, but with a number of additions to deal with the new forms of the Cond language.</p> <p>The new atom case for booleans is converted to one of the integers <code>0</code> (false) or <code>1</code> (true). These integers will be stored in a one-byte segment of a register. (We never put more than one boolean in a register.)</p> <p>There are a number of new assembly language instructions that are generated:</p> <ul> <li><code>xorq &lt;arg1&gt;, &lt;arg2&gt;</code> (XOR: used for logical negation)</li> <li><code>cmpq &lt;arg1&gt;, &lt;arg2&gt;</code> (used for comparisons)</li> <li><code>setCC &lt;arg&gt;</code>   (sets a byte based on the contents of the <code>%rflags</code> register)</li> <li><code>movzbq &lt;arg1&gt;, &lt;arg2&gt;</code> (move from a one-byte register to a full register)</li> <li><code>jCC &lt;label&gt;</code> (conditionally jump to a label)</li> </ul> <p>This needs a bit more explanation.</p> <p>To negate a boolean variable (which is represented as <code>0</code> for false or <code>1</code> for true), compute <code>xorq $1, &lt;var&gt;</code> (where <code>$1</code> is just the number 1 in assembly syntax i.e. an \"immediate\" value).</p> <p>The <code>cmpq</code> instruction takes two arguments, compares them, and uses the comparison to set a special \"flags\" register called <code>%rflags</code>.<sup>3</sup> It takes its arguments in backwards order, so to test if <code>x &lt; y</code>, do <code>cmpq y, x</code>.  The <code>%rflags</code> register can't be read directly, but the <code>setCC</code> family of instructions can set a byte based on its value. Specifically, the <code>CC</code> (condition code) in <code>setCC</code> is one of:</p> <ul> <li><code>e</code>  (for \"equal\")</li> <li><code>l</code>  (for \"less than\")</li> <li><code>le</code> (for \"less than or equal\")</li> <li><code>g</code>  (for \"greater than\")</li> <li><code>ge</code> (for \"greater than or equal\")</li> </ul> <p>So if the instruction <code>cmpq y, x</code> has been done, and <code>x</code> was less than <code>y</code>, the subsequent instruction <code>setl &lt;var&gt;</code> would set <code>&lt;var&gt;</code> to <code>1</code>, since <code>setl</code> means \"set <code>&lt;var&gt;</code> to <code>1</code> if the <code>%rflags</code> register indicates that the last comparison yielded a less-than result\". As if this wasn't weird enough, the <code>&lt;var&gt;</code> argument of <code>setCC</code> instructions can only be a byte register (a one-byte segment of a full register). We only use the <code>al</code> byte register, which is part of the <code>%rax</code> register, though in principle many more byte registers could be used. (In the code, byte registers are a new constructor of the <code>arg</code> type called <code>ByteReg</code>.)</p> <p>Since the <code>setCC</code> instructions can only set byte registers, but we normally work with full registers, we need to be able to \"move\" a byte register into a full register, which is what the <code>movzbq</code> instruction does. Specifically, we will move from the <code>al</code> byte register (which is the only such register we use) to any full register we want.</p> <p>The <code>jCC</code> family of instructions represents conditional jumps; the possible <code>CC</code> values are the same as for the <code>setCC</code> instructions. To give an example, the <code>jle &lt;label&gt;</code> instruction jumps to the label <code>&lt;label&gt;</code> if the value of the <code>%rflags</code> register indicates that the last <code>cmpq</code> instruction yielded a less-than-or-equal result.</p> <p>Note</p> <p>The <code>jCC</code> family of instructions are represented by the <code>JmpIf</code> instruction in the intermediate languages.</p> <p>The textbook (section 4.9) describes the translations between <code>Cif</code> instructions and <code>X86_var_if</code> instructions.</p>"},{"location":"assignments/3/passes/#7-uncover-live-uncover_liveml","title":"7. Uncover live (<code>uncover_live.ml</code>)","text":"<p>This pass has very significant changes, because the Cond language can yield code with multiple blocks (not counting the prelude and conclusion), and we have to know how to do the liveness analysis with these blocks.</p> <p>In the previous compiler, we only had one block to deal with, and we computed the liveness sets for each instruction starting from the end of the block and working back towards the beginning. The liveness set at the end was set to be the registers <code>%rax</code> and <code>%rsp</code>, which are used in the <code>conclusion</code> block.</p> <p>For this compiler, we use a similar strategy per block, but since there are multiple blocks, we have to know in which order to handle them. In addition, we have to know what the liveness set is at the end of each block so that we can use that to work backwards towards the beginning.</p> <p>Because we only have conditional expressions and not loops, and because conditional expressions can only jump forwards in the code, the directed graph formed by the blocks (the graph vertices or nodes) and the jumps between blocks (the graph edges) is a directed acyclic graph or \"DAG\". Lecture 12 has some pictures of DAGs formed from code blocks, which we won't repeat here. The endpoint of the DAG is the <code>conclusion</code> block, since this block has only incoming and no outgoing edges.</p> <p>Note</p> <p>In general, DAGs can have more than one \"leaf\" node (node with no outgoing edges) but in our case, the <code>conclusion</code> block is the only one. Control flow will always flow into the <code>conclusion</code> block eventually, as the code progresses towards the end of the <code>main</code> function.</p> <p>It stands to reason that, since we already know what the liveness set at the beginning of the <code>conclusion</code> block is (just the registers <code>%rax</code> and <code>%rsp</code>), we should start liveness analysis in a block that ends in a jump to that block.  But what about all the other blocks?</p> <p>We need to do two things:</p> <ol> <li> <p>Compute the order of the block labels    so that we know in what order to compute the liveness sets.</p> </li> <li> <p>After computing the liveness sets for a block, record the    liveness set at the beginning of the block in a data structure;    this will become the final liveness set of any block    that jumps to this block.</p> </li> </ol> <p>The way we deal with the first task is to compute a directed graph of all the block labels by:</p> <ol> <li>collecting the jump labels from each block,</li> <li>using them to compute the graph edges (label to label pairs),</li> <li>and constructing the graph.</li> </ol> <p>This graph is (potentially) a \"multigraph\" (meaning that there can be multiple edges between the same blocks), although if compilation has proceeded correctly, there should only be at most one edge between any two blocks.<sup>4</sup> This graph will be a DAG. If you have a list of (block label to block label) edges, you can construct the graph using the <code>LabelMgraph.of_list</code> function.</p> <p>Note</p> <p>Before constructing the graph, filter out the edges that contain the <code>conclusion</code> label, since we won't be doing liveness analysis on the <code>conclusion</code> block!</p> <p>Once we have the DAG, getting the right order of blocks (actually block labels) is simple. The DAG will point \"forward\" (towards the <code>conclusion</code> block), but we want to compute liveness \"backwards\" (starting from the blocks which project directly to the <code>conclusion</code> block). To do this, we \"flip the arrows\" on the DAG, which is known as \"transposing\" the graph. This is not hard to do manually, but the <code>LabelMgraph</code> module has a <code>transpose</code> function that will do it for you. After that, we need to order the labels so that no label appears before all the labels that have edges to it have already appeared. This is known as a \"topological sort\", and (fortunately!) there is a function called <code>topological_sort</code> in the <code>LabelMgraph</code> module. So once you have the DAG, just transpose it and topologically sort it, and you have the correct order of block labels!</p> <p>Note</p> <p>Topological sorts are in general not unique, but if you use the library function the order of labels you generate will be the same as the label order in the instructor's compiler, which will make testing easier.</p> <p>Once we have the order of the labels, we create a map between labels and their live-before sets called <code>live_before_labels</code>. We initialize this with the live-before set of the <code>conclusion</code> block. Then we process each block in the order of their labels, and when we compute the live-before set for each block, we add it to the <code>live_before_labels</code> map. That way, each block will have the live-before set of all blocks that the block can jump to precomputed when the block's liveness sets are computed.</p> <p>Note</p> <p>We don't use imperative programming to add to the <code>live_before_labels</code> map, since it's used locally and standard functional programming methods (specifically a <code>fold_left</code>) are sufficient here.</p> <p>Computing liveness sets for individual blocks is done the same way as in the previous compiler, but with additional cases for the new instructions. Most of the changes are obvious, but some are not.</p> <ul> <li> <p><code>movzbq</code> instructions act like <code>movq</code> instructions    in terms of liveness calculations.</p> </li> <li> <p>The <code>cmpq</code> instruction reads from both arguments   and writes to the <code>%rflags</code> register.</p> </li> <li> <p>The <code>setCC</code> family reads from the <code>%rflags</code> register   and writes to its argument.</p> </li> </ul> <p>We keep track of the <code>%rflags</code> register in addition to the <code>%rax</code> and <code>%rsp</code> registers in liveness analysis from now on.</p> <p><code>jmp</code> and <code>jmpIf</code> instructions require special treatment. They only occur at the end of blocks, and there are only two cases we will encounter.</p> <ol> <li> <p>The block ends in a <code>jmpIf</code> instruction followed by a <code>jmp</code>    instruction.</p> </li> <li> <p>The block ends in a <code>jmp</code> instruction without a <code>jmpIf</code>    preceding it.</p> </li> </ol> <p>The second case is easy; we look up the jump target label in the <code>live_before_labels</code> map, and the live-before set we find is also the live-before set of the <code>jmp</code> instruction.</p> <p>The first case is more subtle. For the <code>jmp</code> instruction which follows the <code>jmpIf</code> instruction, we again just make the live-before set of the jump target the live-before set of the instruction. For the <code>jmpIf</code> instruction, we have two jump targets: the one from the following <code>jmp</code> instruction and the one from the label in the <code>jmpIf</code> instruction itself. We need to compute the union of the live-before sets from both jump targets, since we have no way of knowing which block the instruction will jump to. So we union the live-before set of the <code>jmpIf</code> instruction's target with the live-before set from the <code>jmp</code> instruction to compute the live-before set of the <code>jmpIf</code> instruction. Then we compute the liveness set of each instruction in the block as usual.</p> <p>That's all for this pass! Fortunately, the rest of the passes are much simpler.</p>"},{"location":"assignments/3/passes/#8-build-interference-graph-build_interferenceml","title":"8. Build interference graph (<code>build_interference.ml</code>)","text":"<p>The main changes needed here are to accommodate the new assembly instructions. The <code>movzbq</code> instruction should be handled like a <code>movq</code> instruction. Byte registers need to be converted to their corresponding full registers; there is a function <code>reg_of_bytereg</code> in the <code>Types</code> module that may be useful.  You should consider the destination of the <code>cmpq</code> instruction to be the <code>%rflags</code> register.</p> <p>Note</p> <p>This could possiblly have been left out, since <code>%rflags</code> isn't a register used for register allocation, but we put it in for completeness.  It doesn't cause problems, since we always read from <code>%rflags</code> immediately after writing to it.</p> <p>Everything else is pretty much as you'd expect.</p>"},{"location":"assignments/3/passes/#9-graph-coloring-graph_coloringml","title":"9. Graph coloring (<code>graph_coloring.ml</code>)","text":"<p>The graph coloring code is unchanged from the previous assignment.<sup>5</sup></p>"},{"location":"assignments/3/passes/#10-allocate-registers-allocate_registersml","title":"10. Allocate registers (<code>allocate_registers.ml</code>)","text":"<p>We've added a couple of features to the template code for the \"allocate registers\" pass. The register color list includes the <code>%rflags</code> register, with color <code>-6</code>. Aside from this, the changes you need to make are in the <code>convert_instr</code> function to handle the new assembly instructions. The changes are very straightforward, but you should check that the first argument of <code>movzbq</code> and the argument of <code>setCC</code> instructions are byte registers.</p>"},{"location":"assignments/3/passes/#11-remove-jumps-remove_jumpsml","title":"11. Remove jumps (<code>remove_jumps.ml</code>)","text":"<p>This is an optimization pass which is an optional pass in the textbook. It's fairly simple to implement, so we're making it mandatory.  The idea is that if you have a block which is jumped to from only one other block, you can merge the two blocks and eliminate the jump entirely. This case can happen if you have removed unused blocks in a previous pass.</p> <p>The pseudocode for the algorithm is given in the file <code>remove_jumps.ml</code>, as well as stubs for the functions we used. (You can replace them with your functions if you like, as long as you don't change the module interface.) Note that we define a <code>get_jump_labels</code> function which has the same name as a function in the <code>Cif</code> module, but is different because it takes an <code>X86_var_if</code> block as its argument, whereas the other took a <code>Cif</code> tail.</p> <p>This code also uses directed graphs (not multigraphs), which are implemented in the <code>support/dgraph.ml[i]</code> files. (We could have used multigraphs, but the actual graphs only have at most one edge between blocks.) We start the algorithm by converting the (label, block) list into a directed graph.</p> <p>Note</p> <p>When building the label graph, do not include the <code>conclusion</code> label, because we don't allow merging with the <code>conclusion</code> block.</p> <p>In the <code>merge_blocks</code> function, we used two utility functions from the <code>Utils</code> module: <code>last</code> and <code>butlast</code> to get the last element in a list, and all but the last element, respectively.</p> <p>The algorithm consists of finding two labels which correspond to blocks that can be merged, and merging them using the <code>merge_blocks</code> function and the <code>merge_vertices</code> function of the <code>LabelDgraph</code> module. (The latter is needed because when you merge two blocks, the label of the second block goes away.) We find mergeable labels using the <code>get_mergeable_labels</code> function, which returns a pair of mergeable labels if there is one. We use the <code>neighbors_in</code> and <code>neighbors_out</code> functions of the <code>LabelDgraph</code> module to find the candidate pairs. Essentially, we collect all labels with only one out neighbor and look in the target of those labels for one that has only one in neighbor. In that case, the corresponding blocks can be merged.</p> <p>Note</p> <p>It might be more efficient to find all pairs of mergeable labels at the start, but since merging two labels changes the graph, it's safer to do it one pair at a time. We're not trying for ultimate efficiency here.</p> <p>The algorithm is repeated until there are no more mergeable blocks.</p>"},{"location":"assignments/3/passes/#12-patch-instructions-patch_instructionsml","title":"12. Patch instructions (<code>patch_instructions.ml</code>)","text":"<p>There are a few small additions that need to be made to the \"patch instructions\" pass to handle the new assembly instructions.</p>"},{"location":"assignments/3/passes/#setcc","title":"<code>setCC</code>","text":"<p>The argument of any of the <code>setCC</code> family of instructions (<code>setl</code>, <code>setle</code>, <code>sete</code>, <code>setg</code>, <code>setge</code>) must be a byte register, or it's an error.</p>"},{"location":"assignments/3/passes/#xorq","title":"<code>xorq</code>","text":"<p>As with other operators, only one of the two operands of <code>xorq</code> can be a stack location (i.e. a memory reference). Therefore, if you encounter that, you should patch the instruction as is done for other instructions.</p>"},{"location":"assignments/3/passes/#movzbq","title":"<code>movzbq</code>","text":"<p>The first argument to <code>movzbq</code> should be a byte register.<sup>6</sup> It should already be a byte register, so if it isn't, that's an error.</p> <p>The second argument must be a regular register. If it isn't (e.g. if it's a stack location), replace the second argument with <code>%rax</code> and then add a <code>movq</code> instruction to put the contents of <code>%rax</code> into the second argument.</p>"},{"location":"assignments/3/passes/#cmpq","title":"<code>cmpq</code>","text":"<p>As with other operators, only one of the two operands of <code>cmpq</code> can be a stack location. Again, if you encounter that, you should patch the instruction as is done for other instructions.</p> <p>In addition, the second argument of <code>cmpq</code> can't be an immediate value, so if it is, move it to <code>%rax</code> and use <code>%rax</code> instead.</p>"},{"location":"assignments/3/passes/#13-prelude-and-conclusion-prelude_conclusionml","title":"13. Prelude and conclusion (<code>prelude_conclusion.ml</code>)","text":"<p>The only changes to this pass from the previous compiler are the obvious changes to handle the new assembly instructions and byte registers.</p>"},{"location":"assignments/3/passes/#submitting-your-assignment","title":"\"Submitting\" your assignment","text":"<p>The assignment will be graded in your Github repository as usual, in the <code>ch4</code> directory.</p> <ol> <li> <p>Of course, one nice thing about OCaml is that you can choose to use imperative programming whenever it suits you, and avoid it when it's unnecessary.\u00a0\u21a9</p> </li> <li> <p>This is one example of what is called dead code elimination in the compiler literature, which means removing code which cannot have any effect on the final result of a program.  Dead code comes in many forms besides this.\u00a0\u21a9</p> </li> <li> <p>The textbook calls this EFLAGS, which is an older name that is appropriate for 32-bit x86 systems only.\u00a0\u21a9</p> </li> <li> <p>The textbook insists on using multigraphs, but in fact, regular directed graphs could have been used instead. Nevertheless, this doesn't change the algorithm.\u00a0\u21a9</p> </li> <li> <p>This is the benefit of programming an algorithm as a functor that works on abstract values! Go OCaml!  \u21a9</p> </li> <li> <p>Technically, it could also be an immediate value, but we won't be using it that way.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/3/testing/","title":"Assignment 3: Testing the compiler","text":""},{"location":"assignments/3/testing/#compiling-and-running-the-compiler","title":"Compiling and running the compiler","text":"<p>To compile the compiler, <code>cd</code> into the <code>src/ch4</code> directory and type <code>make</code>. This will compile the compiler (which is an executable file called <code>compile</code>). You should see a number of warnings when you compile the compiler; that's expected. (As you fill in the code for the compiler passes, these warnings will go away).</p> <p>The command-line interface to the <code>compile</code> program is identical to that of the previous assignment, except that there are three new passes:</p> <ul> <li>\"shrink\" (abbreviated <code>sh</code>)</li> <li>\"remove unused blocks\" (abbreviated <code>ru</code>)</li> <li>\"remove jumps\" (abbreviated <code>rj</code>)</li> </ul>"},{"location":"assignments/3/testing/#testing-your-compiler-the-test-scripts","title":"Testing your compiler: the test scripts","text":"<p>The test scripts are essentially unchanged from the last assignment, except for those changes that had to be made to accommodate the new compiler passes.</p>"},{"location":"assignments/4/overview/","title":"Assignment 4: Loops: the Loop language","text":""},{"location":"assignments/4/overview/#overview","title":"Overview","text":"<p>In this assignment, you will be extending the \"Cond\" language compiler from the last assignment to create the \"Loop\" language. This language will add the following features:</p> <ul> <li>loops (<code>while</code> statements)</li> <li>mutable variables (<code>set!</code> statements)</li> <li>sequence expressions (<code>begin</code> statements)</li> <li>the <code>Void</code> type and the <code>(void)</code> expression</li> </ul>"},{"location":"assignments/4/overview/#textbook-coverage","title":"Textbook coverage","text":"<p>This assignment is based on chapter 5 of Essentials of Compilation.</p>"},{"location":"assignments/4/overview/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, November 14 at 6 PM.</p>"},{"location":"assignments/4/overview/#starting-code-base","title":"Starting code base","text":"<p>The starting code base is the zipfile <code>ch5.zip</code>, which is posted on the course Canvas site. You should unzip this file in your Github repo, inside the <code>src/</code> directory. It contains partial implementations of all the code for the assignment.</p> <p>Inside the <code>ch5</code> directory will be the usual subdirectories:</p> <ul> <li> <p>The <code>tests/</code> subdirectory contains the test programs for the compiler.</p> </li> <li> <p>The <code>reference/</code> subdirectory contains the output   from the instructor's version of the compiler.</p> </li> <li> <p>The <code>scripts/</code> subdirectory contains scripts for testing your code.</p> </li> </ul>"},{"location":"assignments/4/overview/#readmemd-file","title":"<code>README.md</code> file","text":"<p>Create a <code>README.md</code> file in your <code>ch5</code> directory, and in it, identify which person wrote which passes. (If both partners worked on a pass, indicate that too.) Also, if you used any late days on the assignment, indicate how many late days you used.</p>"},{"location":"assignments/4/overview/#new-language-features","title":"New language features","text":"<p>The new language features are described in the textbook and the lectures, but in brief, they are:</p> <ul> <li>a <code>Void</code> type</li> <li>new expressions:<ul> <li><code>while</code> (looping construct)</li> <li><code>begin</code> (sequencing expression)</li> <li><code>set!</code>  (mutating (re-assigning) variables to new values)</li> </ul> </li> <li>and a <code>print</code> function has been added.</li> </ul>"},{"location":"assignments/4/passes/","title":"Assignment 4: Compiler passes","text":"<p>The compiler passes are described in chapter 5 of the textbook and in the lectures, but here they are again for completeness. (You should still read the book and lectures for a more in-depth explanation!) We will only include passes that you have to implement. As before, the only files you should modify are the <code>.ml</code> files corresponding to these compiler passes.</p>"},{"location":"assignments/4/passes/#a-passes-that-are-unchanged-from-the-previous-assignment","title":"A. Passes that are unchanged from the previous assignment","text":"<p>These passes are identical except possibly for the names of imported modules (<code>e.g.</code> <code>Cif</code> changing to <code>Cloop</code>).</p> <ul> <li>remove unused blocks (but see note below)</li> <li>build interference graph</li> <li>graph coloring</li> <li>allocate registers</li> <li>remove jumps (but see note below)</li> <li>patch instructions</li> <li>add prelude and conclusion</li> </ul> <p>Note</p> <p>The \"remove unused blocks\" and the \"remove jumps\" passes may or may not require modifications, depending on how you implemented them in the previous assignment. If you took advantage of the topological ordering of blocks in that assignment, you'll have to change that here. If not, you won't.</p>"},{"location":"assignments/4/passes/#b-passes-that-have-minimal-modifications-from-the-previous-assignment","title":"B. Passes that have minimal modifications from the previous assignment","text":"<p>These passes have to be extended to handle the new forms, but the extensions should be straightforward.</p> <ul> <li> <p>shrink</p> </li> <li> <p>uniquify</p> </li> </ul> <p>Note</p> <p>In the \"uniquify\" pass, note that <code>set!</code> requires the variable being set to have already been renamed. Otherwise, signal an error.</p>"},{"location":"assignments/4/passes/#c-passes-that-are-new","title":"C. Passes that are new","text":""},{"location":"assignments/4/passes/#uncover-get-uncover_getml","title":"Uncover <code>get!</code> (<code>uncover_get.ml</code>)","text":"<p>This pass is discussed in lecture 13 and in the textbook. The idea is to annotate any variable expression that corresponds to a variable which is reassigned by <code>set!</code>. Such variables are converted to <code>get!</code> expressions, so <code>Var x</code> becomes <code>GetBang x</code>. This is used in the \"remove complex operands\" pass, as described in lecture 13.</p> <p>Implementing this pass is quite simple.  You go through the code twice. The first time, you collect a set of all the variables that are assigned to in a <code>set!</code> expression.  The second time, you convert any variable reference to one of these variables to a <code>get!</code> (<code>GetBang</code>) form. Since variable names are unique (thanks to the \"uniquify\" pass), any reference to a variable which is assigned to in a <code>set!</code> expression must refer to the same variable as any reference to that variable.</p>"},{"location":"assignments/4/passes/#d-passes-with-significant-modifications-from-the-previous-assignment","title":"D. Passes with significant modifications from the previous assignment","text":""},{"location":"assignments/4/passes/#1-remove-complex-operands-remove_complexml","title":"1. Remove complex operands (<code>remove_complex.ml</code>)","text":"<p>In this pass, the <code>set!</code>, <code>begin</code>, and <code>while</code> forms are all considered to be complex operands. In addition, the subexpressions of <code>set!</code>, <code>begin</code>, and <code>while</code> are allowed to be complex. Also, <code>Void</code> has to be added as an additional case.</p> <p>The <code>get!</code> (<code>GetBang</code>) form added in the \"uncover get\" pass is converted back to a regular variable (<code>Var</code>) in this pass. In <code>rco_atom</code>, the variable is bound to a new fresh variable name which becomes the atom returned from the function. In <code>rco_exp</code>, the variable is simply the returned expression.</p> <p>It's legal to pass <code>set!</code> and <code>while</code> expressions to the <code>rco_atom</code> function, since they return <code>Void</code> values. These would not normally be function arguments, but we handle this case for completeness. In such cases, <code>rco_atom</code> returns the <code>Void</code> atom, and binds the expression to the dummy variable <code>$_</code>, which will never be accessed.</p>"},{"location":"assignments/4/passes/#2-explicate-control-explicate_controlml","title":"2. Explicate control (<code>explicate_control.ml</code>)","text":"<p>The following changes need to be made to the \"explicate control\" pass.</p> <ul> <li> <p>New forms need to be handled in <code>convert_atom</code> and <code>convert_exp</code>.   This should be straightforward.</p> </li> <li> <p>The new <code>while</code>, <code>begin</code>, and <code>set!</code> forms need to be handled   in <code>explicate_assign</code>.  Both the <code>while</code> and <code>begin</code> forms   have side effects; these are handled in the new <code>explicate_effect</code>   function described below, and that function is called from   <code>explicate_assign</code>.  The return value of <code>begin</code> is the return value   of the last expression; all others are evaluated for side effects.   The return values of <code>while</code> and <code>set!</code> are <code>Void</code>.   Make sure to accumulate the subexpressions of <code>begin</code> in the correct order.   (Hint: the <code>List.fold_right</code> function will be useful.)</p> </li> <li> <p>The <code>explicate_pred</code> function has to be extended to deal with   the <code>while</code>, <code>begin</code>, and <code>set!</code> forms.   Since <code>while</code> and <code>set!</code> can only return <code>Void</code>, not booleans,   handling them is easy: it's an error.   A <code>begin</code> can return a boolean, but the subexpressions need to    be handled first, and in the correct order.</p> </li> <li> <p>The <code>explicate_tail</code> function has to be extended to deal with   the <code>while</code>, <code>begin</code>, and <code>set!</code> forms.   This will involve calls to <code>explicate_assign</code> and/or <code>explicate_effect</code>   as needed.</p> </li> <li> <p>The new function <code>explicate_effect</code> has been added to deal with forms   that have side effects.  Note that any form can be in a side-effecting   position (<code>e.g.</code> inside a <code>begin</code> expression), even ones that   have no side effects.  These pure expressions should be discarded   because they have no effect (they are \"dead code\").   Effectful primitives (<code>read</code> and <code>print</code>) can be converted using   the <code>PrimS</code> constructor.   Converting the rest of the forms should be straightforward,   with the exception of the <code>if</code> and <code>while</code> forms.</p> </li> </ul> <p>The form <code>(if &lt;test&gt; &lt;then&gt; &lt;else&gt;)</code>, when evaluated for its effects,   is going to either evaluate the <code>&lt;then&gt;</code> clause or the <code>&lt;else&gt;</code>   clause for its effects.  That means that those clauses will have to   be processed by <code>explicate_effect</code> as well.  When doing this,   be careful not to duplicate the original tail passed to the   <code>explicate_effect</code> function; to avoid that, make it into a block   and use a <code>Goto</code> to that block.</p> <p>The form <code>(while &lt;test&gt; &lt;body&gt;)</code> followed by a tail <code>tail</code>   should be converted to the equivalent of this code:</p> <pre><code>```\nloop:\n  if test then\n    body\n    goto loop\n  else\n    tail\n```\n</code></pre> <p>You will need to generate the loop label (marked as <code>loop</code> here).   Use the <code>fresh</code> function as you did in the <code>uniquify</code> pass   with the base <code>loop</code> and the separator <code>_</code>   so you get <code>loop_N</code> for some number <code>N</code>.</p> <p>The body of the loop is evaluated only for its effects,   so it has to be processed by <code>explicate_effect</code>.   The <code>if</code> equivalent form has to be processed by <code>explicate_pred</code>,   returning a tail which constitutes a basic block.   The loop label will correspond to this block;   this has to be added to the <code>basic_blocks</code> variable   and a <code>Goto</code> to this block's label should be returned.   (Don't call <code>create_block</code> here, since <code>explicate_pred</code>   will do this if necessary.)</p> <p>See section 5.6 in the book for further discussion of this.</p>"},{"location":"assignments/4/passes/#3-select-instructions-select_instructionsml","title":"3. Select instructions (<code>select_instructions.ml</code>)","text":"<p>The following changes need to be made to the \"select instructions\" pass.</p> <ul> <li> <p>A <code>Void</code> expression becomes the integer <code>0</code>.</p> </li> <li> <p>A <code>Read</code> can be a stand-alone statement, as well as an expression.   Stand-alone statements use the new <code>PrimS</code> constructor   of the \"Cloop\" intermediate language.</p> </li> <li> <p>The <code>Print</code> function we added can also be a stand-alone statement.   (Note that <code>Print</code> is our addition; it's not in the textbook.)   Its return value (<code>Void</code>) can also be assigned to a variable,   and it can be a tail expression.   <code>Print</code> takes one argument, which must be placed into   the <code>%rdi</code> register before calling the function.</p> </li> </ul> <p>Note that just as <code>read</code> in the source language becomes <code>read_int</code> in assembly language, <code>print</code> in the source language becomes <code>print_int</code> in assembly language.</p>"},{"location":"assignments/4/passes/#4-uncover-live-uncover_liveml","title":"4. Uncover live (<code>uncover_live.ml</code>)","text":"<p>The only parts of the \"uncover live\" pass that have changed are:</p> <ul> <li> <p>The <code>order_labels</code> function has been replaced   with the <code>compute_liveness</code> function,   which uses the dataflow analysis described   in sections 5.2 and 5.8 of the textbook,   and also in lecture 14.   This function iteratively computes the live-before sets of all blocks   until it reaches a fixpoint.   This is necessary because the control flow graph   is no longer a directed acyclic graph   in the presence of looping constructs,   so we can't use a topological sort as we did in the previous compiler.</p> </li> <li> <p>The <code>uncover_live</code> function has been modified to use the   <code>compute_liveness</code> function.   Note that this function is supplied to you in its entirety   (which wasn't the case in the previous assignment's compiler),   because the steps are straightforward.</p> </li> </ul> <p>Therefore, your job for this pass is to implement the <code>compute_liveness</code> function. The algorithm is described in some detail in the comment preceding the function. This algorithm is not extremely difficult, but we recommend that you use the <code>_debug</code> variable and print out various important data structures if debugging is enabled. For one thing, you should check that the algorithm really does converge to a final state.</p> <p>The <code>_debug</code> variable (which is a <code>ref</code>, but doesn't really need to be) is for your benefit.  If you want to put in debugging code that can be switched off, you can write something like this:</p> <pre><code>if !_debug then\n   (* print a debug message *)\n</code></pre> <p>If the <code>_debug</code> variable is set to <code>true</code>, the debug messages will be printed. If it's set to <code>false</code>, they won't be. If you change it, you have to recompile your code for it to take effect.</p>"},{"location":"assignments/4/testing/","title":"Assignment 4: Testing the compiler","text":""},{"location":"assignments/4/testing/#compiling-and-running-the-compiler","title":"Compiling and running the compiler","text":"<p>To compile the compiler, <code>cd</code> into the <code>src/ch5</code> directory and type <code>make</code>. This will compile the compiler (which is an executable file called <code>compile</code>). You should see a number of warnings when you compile the compiler; that's expected. (As you fill in the code for the compiler passes, these warnings will go away).</p> <p>The command-line interface to the <code>compile</code> program is identical to that of the previous assignment, except that there is one new pass: \"uncover get\" (abbreviated \"ug\").</p>"},{"location":"assignments/4/testing/#testing-your-compiler-the-test-scripts","title":"Testing your compiler: the test scripts","text":"<p>The test scripts are essentially unchanged from the last assignment, except for those changes that had to be made to accommodate the new compiler pass.</p>"},{"location":"intro/language/","title":"Implementation language","text":"<p>In principle, any programming language can be used to write a compiler. Many compiled languages, after \"bootstrapping\" their compiler from another language, then rewrite the compiler in the language being compiled (this is called \"self-hosting\").  Self-hosting serves as a test of the power of the language (any language that is powerful enough to write its own compiler has to be pretty powerful) and allows the language developers to only use the new language in later development (often called \"eating one's own dog food\", or \"dogfooding\" for short).</p> <p>In this course, we will use the OCaml programming language exclusively. Out of all the possible choices of programming language, why did we choose this comparatively obscure language for writing our compilers?</p> <p>Part of the reason is subjective: we like OCaml as a language, we are very familiar with it, and we find that it occupies a useful \"sweet spot\" between lower-level languages like C, Java and Python and very high-level languages like Haskell.  Its functional programming support is useful in reducing code duplication, and its impurity means that you can also use imperative code when it's desirable to do so.</p> <p>The main reason, though, is that OCaml is a language which is superbly well-adapted to the task of writing a compiler! Features that are particularly helpful include:</p> <ul> <li> <p>Very strong static type checking.   Compilers are large, complicated and subtle programs,   and we need all the help we can get in preventing and tracking down errors.   OCaml's type checking is extremely stringent,   to the point that if a program compiles at all,   there is a very good chance that it will run correctly.   More importantly, type checking rules out almost all trivial errors.</p> </li> <li> <p>Algebraic datatypes.  These map almost perfectly to the structure of a   compiler's various intermediate languages, and provide an extremely   lightweight way to specify new datatypes.</p> </li> <li> <p>Garbage collection.  Compilers are complicated enough without having   to worry about memory leaks from manual memory management.</p> </li> <li> <p>A fast compiler.  Waiting for your compiler to compile isn't fun, and our   compilers will compile our code almost instantaneously.</p> </li> <li> <p>An excellent build system.   The dune build system   makes compiling OCaml projects nearly effortless.</p> </li> <li> <p>An excellent package manager.   The opam package manager   makes installing new packages completely painless.</p> </li> <li> <p>Excellent serialization. OCaml has the facility   (not built-in, but provided by libraries)   to convert any complex datatype to an \"S-expression\"   (a simple and readable serialization format).   Since compilers consist of a series of code transformations,   being able to easily view the output of each transformation   is incredibly useful for debugging.</p> </li> </ul> <p>There are other useful features of OCaml we will encounter as we proceed.</p> <p>One indication of how useful OCaml is as a language for writing compilers is to consider which languages' compilers and other language-related tools were originally written in OCaml.<sup>1</sup> These include:</p> <ul> <li> <p>the Rust language compiler</p> </li> <li> <p>the Hack language compiler   (a statically-typed PHP dialect from Facebook)</p> </li> <li> <p>the Flow   static analyzer for Javascript from Facebook</p> </li> <li> <p>the Infer   static analyzer for Java/C/C++/Objective-C from Facebook</p> </li> <li> <p>the pyre-check   static analyzer for Python from Facebook</p> </li> <li> <p>ReasonML,   an alternative syntax for OCaml which compiles to Javascript   (also from Facebook!)</p> </li> <li> <p>Frama-C,   a static analysis framework for the C language</p> </li> <li> <p>The WebAssembly language   reference implementation   (WebAssembly is a low-level language for running code in a web browser) <sup>2</sup></p> </li> <li> <p>the Rocq (previously called Coq) proof assistant   (take CS 128 to learn about Rocq)</p> </li> </ul> <p>and no doubt many more.  OCaml is an excellent tool for building language-related tools, including compilers.</p> <ol> <li> <p>In some of these cases, the compiler was eventually rewritten in the language being compiled, so that the language could be self-hosted.\u00a0\u21a9</p> </li> <li> <p>Technically, the WebAssembly implementation is a reference interpreter, which is a language evaluator/runtime instead of a compiler, but it still illustrates the usefulness of OCaml for language implementations.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/welcome/","title":"Welcome to CS 164!","text":"<p>This course is called Compilers, and is a course on implementing compilers, which are programs which convert program source code to code that can run directly on a computer. Compilers is a tremendously interesting and fun topic, and can teach you a great deal about programming and about how computers work. We hope you enjoy this subject as much as we do!</p> <p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about compilers. In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus   (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>coding notes and tips</li> </ul> <p>and anything else we consider useful.</p> <p>Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>the PDF of the textbook</li> <li>lecture slides</li> <li>assignment code zip files</li> <li>some administrative information</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"ocaml/install/","title":"Installing OCaml","text":"<p>Here are the steps you should go through to install OCaml on your computer. You should install the latest OCaml version, which as of this writing is version 5.3.0.</p>"},{"location":"ocaml/install/#install-ocaml-and-opam","title":"Install OCaml and <code>opam</code>","text":"<p>See the instructions on the OCaml website. Note that <code>opam</code> is the OCaml package manager, which needs to be installed in order to install critical libraries.</p>"},{"location":"ocaml/install/#macos","title":"MacOS","text":"<p>The instructions for MacOS refer to the Homebrew package manager, which needs to be installed first (it's very easy). Follow the instructions on the Homebrew website to install it.</p> <p>Note</p> <p>Don't use any other package manager for MacOS (e.g. MacPorts).</p>"},{"location":"ocaml/install/#linux","title":"Linux","text":"<p>If you are using Linux, you should install OCaml using your distribution's package manager. The instructions linked to above contain more details. For example, for Ubuntu Linux the commands are</p> <pre><code>$ sudo apt update\n$ sudo apt install opam\n</code></pre> <p>The <code>sudo</code> is so you don't have to install the software as the root user. You may be asked to enter your password, which you should do.</p>"},{"location":"ocaml/install/#windows","title":"Windows","text":"<p>If you are using Windows, you should install an Ubuntu Linux system inside of Windows using the Windows Subsystem for Linux, also known as \"WSL\". Then you can use <code>apt</code> like on any Ubuntu Linux system.</p> <p>It's possible to install OCaml directly on Windows, but it's probably not worth the trouble. WSL is a much easier solution, and it will work fine with external editors like VS Code (discussed below). This course does not support OCaml directly on Windows, because we assume a Unix-like environment (<code>Makefile</code>s etc.) for much of our tooling.</p>"},{"location":"ocaml/install/#initialization","title":"Initialization","text":"<p>Once you have a version of OCaml and <code>opam</code> installed, you need to set it up, and, if necessary, upgrade the versions. Start up your terminal program and go through the following steps.</p> <ul> <li> <p>Initialize <code>opam</code> by typing <code>opam init</code> in a terminal and following the   instructions.</p> <p>Note</p> <p>There is an issue with initializing <code>opam</code> inside of WSL (Windows Subsystem for Linux). Basically, due to the way WSL works, you have to initialize <code>opam</code> differently by disabling sandboxing.  This theoretically can cause some problems if a package does something really stupid, but it probably won't. The fix is to use this command instead of just <code>opam init</code>:</p> <pre><code>$ opam init --disable-sandboxing\n</code></pre> </li> </ul> <ul> <li> <p>At the end of the <code>opam init</code> command,   it will ask you to run <code>eval ${opam env}</code>.   (Or it might say <code>eval ${opam config env}</code> or something similar.   It all does the same thing.)   This sets up the <code>PATH</code> variable of your shell   to point to the <code>opam</code> directories.   This is important, because if you don't do this,   adding new packages (and new OCaml versions) will not work.   Opam will also ask you if it can change your shell initialization file   (e.g. <code>~/.bashrc</code> for <code>bash</code>)   by adding some commands.   You should say yes, because if you don't,   every time you start up a new terminal   you will have to type <code>eval ${opam env}</code>   to get <code>opam</code> to work correctly.</p> </li> <li> <p>In your terminal, type</p> <pre><code>$ opam update\n$ opam upgrade\n</code></pre> <p>to make sure the package repository is up to date and all OCaml packages have been upgraded to the most recent versions.</p> </li> <li> <p>Check the OCaml version by typing <code>ocaml --version</code>.   If it's the most current version   (which is 5.3.0 as of this writing)   you are done with this part.   Otherwise do <code>opam switch create 5.3.0</code>   and wait for the new version to be installed.   (This will take a while.)</p> </li> <li> <p>Install these libraries:</p> <pre><code>$ opam install ocamlfind dune utop sexplib ppx_sexp_conv ocaml-lsp-server\n</code></pre> </li> </ul> <p>Note particularly the <code>utop</code> library,   which installs the <code>utop</code> program.   <code>utop</code> is an improved version of the <code>ocaml</code> interpreter,   and you should use it instead of <code>ocaml</code> when testing code interactively.</p> <p>The <code>ocaml-lsp-server</code> library is important   if you want to use Visual Studio Code as your editor (see below).</p>"},{"location":"ocaml/install/#using-ocaml","title":"Using OCaml","text":"<p>There are only a few things you need to know in order to use OCaml effectively.</p>"},{"location":"ocaml/install/#starting-ocaml","title":"Starting OCaml","text":"<p>You can start the OCaml interpreter by opening a terminal and typing:</p> <pre><code>$ utop\n</code></pre> <p>at the terminal prompt. This will bring up the OCaml interactive interpreter, which is a good environment for experimenting with the language and for testing code you've written.</p> <p>Note</p> <p>You can also use <code>ocaml</code> instead of <code>utop</code>, but <code>utop</code> is much more full-featured.</p> <p><code>utop</code> makes it possible to easily recall and edit previously-input lines of text by using the up and down arrow keys. To see what it can do, start it up</p> <pre><code>$ utop\n</code></pre> <p>and type the following commands (one per line, hitting the return key at the end of each line):</p> <pre><code># Printf.printf \"hello\\n\" ;;\n# Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>Note that the OCaml interpreter prompt is the hash sign (<code>#</code>); don't type that!  These lines should, when evaluated, print the words <code>hello</code> and <code>goodbye</code> respectively.  Once you've done this, you should be able to recall either line by using the up arrow key.  For instance, you can hit the up arrow key once to get the line:</p> <pre><code>Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>and edit it so that it says:</p> <pre><code>Printf.printf \"adios\\n\" ;;\n</code></pre> <p>When you hit return, it should print out <code>adios</code> on a separate line. You can also use control-a to get to the beginning of a line you are editing and control-e to get to the end. control-l (lower-case L) clears the terminal and puts the cursor at the top of the terminal window.</p> <p>One annoying thing about <code>utop</code> is that it tends to go overboard on command completion.  You can disable this by typing this inside <code>utop</code>:</p> <pre><code># #utop_prompt_dummy;;\n# UTop.set_show_box false;;\n</code></pre> <p>It's annoying to type this every time you start <code>utop</code>, so what I do is make a <code>utop</code> initialization file called <code>init.ml</code> and put it in the directory <code>~/.config/utop</code> (creating that directory if necessary). Then these commands will be run every time <code>utop</code> starts.</p> <p>Note</p> <p>Unfortunately, this will not work properly if used in a directory that has a <code>.ocamlinit</code> file in it (usually your home directory).  There are workarounds, but most of the time it will work properly.  Other than that, <code>utop</code> is far superior to the basic <code>ocaml</code> interpreter.</p>"},{"location":"ocaml/install/#using-visual-studio-code","title":"Using Visual Studio Code","text":"<p>You can use any text editor you like to write OCaml code, but we recommend you try Visual Studio Code (also known as VS Code), which has excellent OCaml support. In order to use it, you need to do the following steps:</p> <ul> <li> <p>Make sure you've install the OCaml Language Server Protocol   (we did this above).  If you haven't, type this:</p> <pre><code>$ opam install ocaml-lsp-server\n</code></pre> </li> <li> <p>Install Visual Studio Code from https://code.visualstudio.com/.</p> </li> <li> <p>When inside VS Code, look at the Extensions pane   (select View/Extensions from the menu).   Type \"OCaml\" into the search bar at the top,   and select and install \"OCaml Platform\".</p> </li> </ul> <p>Now you will get nice syntax highlighting and code completion when you edit OCaml source code.  You can also start a terminal while inside VS Code to test your code by running the OCaml interpreter.  When you do, make sure you choose a WSL (Ubuntu Linux) terminal, not a PowerShell terminal!</p> <p>Now you are ready to write OCaml code!</p> <p>Disabling Github Copilot</p> <p>If you have previously installed the Github Copilot Extension for VS Code, you must disable it while working on your CS 164 code! (See the  Administrative/Collaboration Policies document for more on this.) The way to do this is as follows:</p> <ul> <li>Open VS Code.</li> <li>Go to the Extensions view by clicking the Extensions icon   in the Activity Bar (or press Ctrl+Shift+X). </li> <li>Search for \"GitHub Copilot.\"</li> <li>Click the gear icon next to the \"GitHub Copilot\" extension   and select \"Disable.\"    You may be prompted to restart VS Code   or to reload the window in order for changes to take effect.</li> </ul>"},{"location":"ocaml/install/#using-the-terminal","title":"Using the terminal","text":"<p>In this book, we assume that you will be running OCaml from inside a Unix-like terminal environment, such as you can find on Linux, MacOS, or Windows (if you're using WSL).  This means that we will assume that you know how to do basic terminal tasks and commands such as</p> <ul> <li>creating a directory (<code>mkdir</code>)</li> <li>removing a directory (<code>rmdir</code>)</li> <li>changing directories (<code>cd</code>)</li> <li>removing files (<code>rm</code>)</li> <li>running programs</li> </ul> <p>In addition, we will be using the GNU <code>make</code> program to build our compilers. We will include instructions on how to use <code>make</code> in the assignments, but you should ensure that <code>make</code> is installed by typing</p> <pre><code>$ which make\n</code></pre> <p>If it replies with <code>make not found</code> or something similar, you need to install it.  On a Mac with Homebrew, type:</p> <pre><code>$ brew install make\n</code></pre> <p>On an Ubuntu Linux system or Windows with WSL, type:</p> <pre><code>$ sudo apt install make\n</code></pre> <p>However, it's likely that <code>make</code> is already installed.</p>"},{"location":"ocaml/macos/","title":"Notes on MacOS","text":"<p>The compilers we will write in this course all generate x86-64 assembly language as their final output. This is the assembly language used by Intel processors, and is very widely used, especially on Windows and Linux computers. Older Mac computers also use x86-64 assembly language, but newer ones (Macs which use the M1 to M4 processors) use Arm64 assembly language, which is completely different from x86-64 assembly language and is not compatible with it. However, Apple has also had the foresight to provide a way to run x86-64 code on their M-series computers, called Rosetta 2. If you have an M-series Mac, you will need to install this. Start a terminal and type this:</p> <pre><code>$ softwareupdate --install-rosetta\n</code></pre> <p>Agree to the terms and conditions and hit return.  Now Rosetta is installed!</p> <p>Note</p> <p>What Rosetta does is allow you to run x86-64 binary executable programs on a Mac which natively runs Arm64 code. It does this by translating the x86-64 code to Arm64 code on-the-fly. Surprisingly, there is little or no performance loss in most cases when doing this!</p> <p>Having Rosetta installed is not all that is needed in order to run your compilers and generate working executables. You also need to be able to compile the assembly code to x86-64 executables. Again fortunately, the <code>clang</code> C compiler that Apple uses has the ability to \"cross-compile\" to x86-64 executables simply by adding the command-line arguments <code>-arch x86_64</code>. Our test scripts will do this if you add the <code>-arm64</code> command-line argument to them; this will be covered in the assignment writeups.</p> <p>Note also that in order to be able to use the C compiler on a Mac at all, you have to install the Apple command-line tools by typing this:</p> <pre><code>$ xcode-select --install\n</code></pre> <p>In the future, we may offer the option of compiling to Arm64 assembly language directly. For now, Mac users should compile to x86-64 as described above and run their code using Rosetta.</p>"},{"location":"ocaml/notes/basic/","title":"Basic programming tips","text":""},{"location":"ocaml/notes/basic/#warnings","title":"Warnings","text":"<p>Warnings are always bad, unless you expect them (e.g. because code is only partially written). Never ignore warnings. Your finished code should never generate warnings.</p>"},{"location":"ocaml/notes/basic/#use-let-instead-of-match-when-there-is-only-one-variant","title":"Use <code>let</code> instead of <code>match</code> when there is only one variant","text":"<p>It's not uncommon to have types that only have one variant. We see this in the <code>program</code> types of our compilers, for instance:</p> <pre><code>type program = Program of exp\n</code></pre> <p>If you have a <code>program</code> value and you want to extract the <code>exp</code> component, you can use a pattern match as usual:</p> <pre><code>match prog with\n  | Program e -&gt; e  (* the only case *)\n</code></pre> <p>However, this is overkill for such a simple case. The idiomatic way to do this is with a <code>let</code>:</p> <pre><code>let (Program e) = prog in ...\n</code></pre> <p>You can think of a <code>let</code> used in this way as a one-variant pattern match.  Never use a <code>match</code> when a <code>let</code> suffices; a <code>match</code> in this case is excessive and harder to read.</p>"},{"location":"ocaml/notes/debug/","title":"Debugging tips","text":"<p>Although strictly-typed functional languages like OCaml greatly reduce the number of bugs in your programs, you will still make mistakes and have to debug them.  Debugging functional languages can be challenging; here are some tips we've found to be useful.</p>"},{"location":"ocaml/notes/debug/#printf-style-debugging","title":"<code>printf</code>-style debugging","text":"<p><code>printf</code>-style debugging is highly effective if you do it right.  The wrong way is to add <code>printf</code> statements to otherwise functional code:</p> <pre><code>let x = ... in\nPrintf.printf \"x = %s\\n\" x;\nlet y = ... in\n  ...\n</code></pre> <p>Even though this can work, you are embedding imperative code inside functional code, and you can get into tricky syntax issues as a result. A better way to do it is like this:</p> <pre><code>let x = ... in\nlet _ = Printf.printf \"x = %s\\n\" x in\nlet y = ... in\n  ...\n</code></pre> <p>This also embeds imperative code, but uses functional syntax, so there won't be any syntax issues.</p> <p>Note</p> <p>If the surrounding code is imperative (like a <code>begin</code> expression), the exact opposite criterion applies: favor the naked <code>Printf.printf ...</code> instead of the <code>let _ = Printf.printf ...</code> idiom.</p> <p>Also, you should add <code>%!</code> at the end of the <code>printf</code> format string:</p> <pre><code>let x = ... in\nlet _ = Printf.printf \"x = %s\\n%!\" x in\nlet y = ... in\n  ...\n</code></pre> <p>This makes OCaml flush the string as soon as the <code>printf</code> executes. If you don't do that, sometimes error messages before a crash can be lost.</p> <p>Finally, for debugging, consider writing your <code>printf</code>s unindented this way:</p> <pre><code>    let x = ... in\nlet _ = Printf.printf \"DEBUG: x = %s\\n%!\" x in\n    let y = ... in\n      ...\n</code></pre> <p>This way, it's easy to spot these lines, which is good because you are going to want to delete them once debugging is done.</p>"},{"location":"ocaml/notes/debug/#using-the-repl","title":"Using the REPL","text":"<p>\"REPL\" means \"Read-Eval-Print-Loop\" and refers to the interactive interpreter (what you get into if you type <code>ocaml</code> or <code>utop</code> at a terminal prompt). You might think that it's hard to use a REPL in a large, multi-file project like the compiler assignments, but we've got you covered!</p> <p>Typing <code>make repl</code> in any directory will bring up a REPL in which all the modules of the program are accessible.  This allows you to interactively test your code.  Some kinds of code are easier to test in this way than others, but don't underestimate how useful this can be, especially when trying to track down a tricky bug.  All you need to do is to open the relevant module:</p> <pre><code># open Some_Compiler_Pass_That_Isnt_Working;;\n</code></pre> <p>and you can play with all the functions in that module.</p>"},{"location":"ocaml/notes/debug/#insert-debugging-code-into-tricky-algorithms","title":"Insert debugging code into tricky algorithms","text":"<p>Some passes involve tricky algorithms.  In those cases, it's a good idea to define a <code>debug</code> variable at the top of the file:</p> <pre><code>let debug = ref false  (* change to `true` when you need debug output *)\n</code></pre> <p>and then put debug code into the tricky algorithm that prints out the inputs and outputs:</p> <pre><code>let tricky_algorithm weird_inputs =\n  if !debug then\n    Printf.printf \"INPUT: %s\\n\" (string_of_weird_inputs weird_inputs);\n  ... (* rest of algorithm *)\n</code></pre> <p>To do this, you need to be able to convert the algorithm inputs/output to strings.  Most of the data structures you will be using can be easily converted to S-expressions, and there is a <code>print_sexp</code> function in the <code>Utils</code> module that will print an S-expression in a readable fashion (this is discussed in the next section). This is extremely useful for tracking down algorithm errors.</p>"},{"location":"ocaml/notes/design/","title":"Design tips","text":""},{"location":"ocaml/notes/design/#write-stubs","title":"Write stubs!","text":"<p>When you are starting to write a function, write a \"stub\". This is an incomplete function. Just put in</p> <ul> <li> <p>the arguments</p> </li> <li> <p>type annotations for arguments and the return type   (This is very important!  Don't skip this step!)</p> </li> <li> <p>and <code>failwith \"TODO\"</code> for the body.</p> </li> </ul> <p>Then fill it in later.</p> <p>Here's an example of a stub:</p> <pre><code>let halts_on_all_inputs (f : int -&gt; int) : bool =\n  failwith \"TODO\"\n</code></pre> <p>(This particular function might be a bit hard to write, though. )</p> <p>Writing stubs is a great way to get past \"coder's block\". Once the stub is written, you can compile it and make sure it type checks. If it's recursive, you can usually easily fill in the base cases. At that point, you're ready to work on the body of the function.</p>"},{"location":"ocaml/notes/design/#use-wishful-thinking","title":"Use wishful thinking!","text":"<p>If a function seems too difficult/complex to write directly, ask yourself \"what function do I need which would make it really easy to write this function?\" Then assume that that function exists (i.e. write a stub for it), and write your main function using the assumed function. When that's done, go back and write the body of the assumed function.</p> <p>This is one of the most useful programming tips. It's explored at some length in the CS 4 textbook Structure and Interpretation of Computer Programs (SICP).</p>"},{"location":"ocaml/notes/design/#use-the-support-library","title":"Use the <code>support</code> library!","text":"<p>The <code>support</code> library (which is part of the CS 164 code base) contains a number of modules with useful functions and data structures. Often, this can save you a lot of time versus writing them yourself. Here, we will briefly discuss the modules, but we strongly encourage you to read the comments in the <code>support/*.mli</code> files to find out more. We will remind you in the assignments which functions and data structures are particularly useful for that assignment.</p> <p>The <code>support</code> library contains these modules:</p> <ul> <li><code>Functors</code></li> </ul> <p>This module defines three module types: <code>OrderedTypeS</code>,   <code>SetS.S</code> and <code>MapS.S</code>.  They are extensions of the standard OCaml   module types <code>OrderedType</code>, <code>Set.S</code> and <code>Map.S</code>.   The extensions mostly have to do with functions that convert   instances of the internal datatypes to and from S-expressions, as well   as a few other utility functions.  There are also new functors called   <code>SetS.Make</code> and <code>MapS.Make</code> that create modules with the module types   <code>SetS.S</code> and <code>MapS.S</code> respectively, given a module of module type   <code>OrderedTypeS</code>.</p> <p>In general, you should never be using a module of module type   <code>OrderedType</code>, <code>Set.S</code>, or <code>Map.S</code>.  Always use the extended versions   (<code>OrderedTypeS</code>, <code>SetS.S</code>, or <code>MapS.S</code>).  Usually, all you have to do   is type the extra <code>S</code> at the end of the name.</p> <ul> <li><code>Dgraph</code></li> </ul> <p>This module contains a functor called <code>Make</code>   which makes a module of type <code>Dgraph.S</code>,   which implements a directed graph.   The functor takes an ordered type module (module type <code>OrderedTypeS</code>)   as its argument.</p> <p>Note that this (like the other graph implementations in this library)   is implemented in a purely functional way.   This is not as efficient as an imperative graph could be,   but it's more than sufficient for our needs   and tends to be very well-behaved   (as functional data structures usually are).</p> <ul> <li><code>Multigraph</code></li> </ul> <p>This is like <code>Dgraph</code>, but implements a directed multigraph.</p> <ul> <li><code>PriorityQueue</code></li> </ul> <p>This module contains a very simple (some might call it \"brain dead\") version   of a priority queue module called <code>PriorityQueue.Simple</code>.   One day we may provide a more efficient one, but this will do for now.</p> <ul> <li><code>Ugraph</code></li> </ul> <p>This is like <code>Dgraph</code>, but implements an undirected graph.</p> <ul> <li><code>Utils</code></li> </ul> <p>This contains lots of little utility functions that aren't found in the   OCaml standard libraries.  There are string and list functions,   functions to generate unique variable names, functions to work with   S-expressions, and so on.  This is a module you will want to get familiar   with.</p> <p>You use the <code>support</code> library by <code>open</code>ing it and then <code>open</code>ing whatever modules you need from it:</p> <pre><code>open Support\nopen Functors\nopen Utils\n</code></pre> <p>If you only need one module, you can alternatively do this:</p> <pre><code>open Support.Utils\n</code></pre> <p>Or you can <code>open Support</code> and then use a qualified function e.g. <code>Utils.last</code>.</p>"},{"location":"ocaml/notes/design/#avoid-functions-that-raise-unhelpful-exceptions","title":"Avoid functions that raise unhelpful exceptions!","text":"<p>Avoid using functions that raise unhelpful and hard-to-track-down exceptions like <code>Not_found</code>. One example is the <code>find</code> function of the <code>Map</code> functor. You should prefer to use the <code>find_opt</code> variant, which returns an option type. Then handle the <code>None</code> case explicitly, usually by raising an exception with a specific error message.</p> <p>Also, most uses of <code>find_opt</code> use this pattern:</p> <pre><code>match Map.find_opt key map with\n  | None -&gt; failwith \"some error message\"\n  | Some v -&gt; (* do something with `v` *)\n</code></pre> <p>We've provided a helper function called <code>find_or_fail</code> in the extended <code>MapS</code> implementation in the <code>support</code> library.  The above code would become:</p> <pre><code>let v = Map.find_or_fail key map ~err_msg: \"some error message\" in\n  (* do something with `v` *)\n</code></pre> <p>We recommend you use <code>find_or_fail</code> for this case, and only use <code>find_opt</code> when this isn't sufficient.  You should never use plain <code>find</code> unless you are 100% certain that there is no way that the key won't be found.</p> <p>Note</p> <p>Somehow, the OCaml gods delight in showing you that something that \"can't possibly happen\" can indeed happen, so we recommend coding somewhat defensively.</p> <p>We also provide a more general function called <code>find_or</code>, which can do arbitrary actions in the case of a lookup failure. It takes a labelled argument called <code>f</code> which is a function of type <code>(unit -&gt; 'a)</code>, where <code>'a</code> is the value type. You can use this to return a default value, or to raise an arbitrary exception on lookup failure.</p>"},{"location":"ocaml/notes/design/#avoid-catch-all-match-cases","title":"Avoid catch-all <code>match</code> cases!","text":"<p>Many functions in your compilers will be large <code>match</code> expressions handling a lot of different constructors. In addition, new constructors for many types will be added with each new version of the compiler. Some functions will require that you handle (say) one case specially, and then all other cases can be handled in a generic manner. It's totally natural to write such functions with a <code>match</code> expression that looks like this:</p> <pre><code>match &lt;thing to match&gt; with\n  | &lt;special case&gt; -&gt; &lt;special case code&gt;\n  | _ -&gt; &lt;generic code for all other cases&gt;\n</code></pre> <p>In normal OCaml programming, this would be fine. For us, it's not optimal, because it's very easy to forget to handle new constructors when you add them in later compilers. If that happens, the new constructors will be handled by the generic code (the catch-all handler), which will probably be wrong and which may be hard to debug.</p> <p>Fragile pattern matches</p> <p>OCaml's documentation refers to this case as a \"fragile pattern match\". There is even a warning option in the OCaml compiler (warning 4) to flag this case. For instance, consider this code:</p> <pre><code>type foo =\n  | Foo of int\n  | Bar of float\n  | Baz of string\n\nlet f x =\n  match x with\n    | Foo _ -&gt; 'f'\n    | _ -&gt; 'x'\n</code></pre> <p>If you save it in a file called <code>foo.ml</code> and compile it like this:</p> <pre><code>$ ocamlc -w +4 foo.ml\n</code></pre> <p>you get this warning:</p> <pre><code>File \"foo.ml\", lines 7-9, characters 2-14:\n7 | ..match x with\n8 |     | Foo _ -&gt; 'f'\n9 |     | _ -&gt; 'x'\nWarning 4 [fragile-match]: this pattern-matching is fragile.\n  It will remain exhaustive when constructors are added to type foo.\n</code></pre> <p>This is nice, so why don't we enable this warning in our <code>dune</code> files? It's because some of the libraries we depend on (like the S-expression conversion libraries) have fragile pattern matches, and we don't want to look at a bunch of warnings we can't fix! In addition, some trivial uses of fragile pattern matches are harmless. However, if you want to try it out, go to the <code>dune</code> file and change these lines:</p> <pre><code>(env\n  (dev\n    (flags (:standard -warn-error -A))))\n</code></pre> <p>to:</p> <pre><code>(env\n  (dev\n    (flags (:standard -warn-error -A -w +4))))\n</code></pre> <p>Then recompile. We think you'll quickly want to go back to the original warning settings </p> <p>Instead of this, we recommend this style:</p> <pre><code>match &lt;thing to match&gt; with\n  | &lt;special case&gt; -&gt; &lt;special case code&gt;\n  | &lt;case 1&gt;\n  | &lt;case 2&gt;\n  | &lt;case 3&gt;\n  | ... -&gt;\n    &lt;generic code for all other cases&gt;\n</code></pre> <p>Each <code>&lt;case N&gt;</code> form is a constructor with a wildcard for the constructor arguments e.g. for a constructor <code>Foo</code> it would be <code>Foo _</code> (assuming that <code>Foo</code> has arguments). This way, if you add another constructor in the next compiler, and you forget to handle that case, you will get a warning about a non-exhaustive pattern match, and you will be able to fix the problem right away!</p> <p>You can also write this more concisely as:</p> <pre><code>match &lt;thing to match&gt; with\n  | &lt;special case&gt; -&gt; &lt;special case code&gt;\n  | &lt;case 1&gt; | &lt;case 2&gt; | &lt;case 3&gt; | ... -&gt;\n    &lt;generic code for all other cases&gt;\n</code></pre> <p>This is a bit easier on the eyes.</p>"},{"location":"ocaml/notes/format/","title":"Formatting your code","text":"<p>Instead of giving a long style guide on how to format your OCaml code, we recommend that you use <code>ocamlformat</code>, which is an auto-formatter for OCaml code.  Here's how.</p>"},{"location":"ocaml/notes/format/#installing-ocamlformat","title":"Installing <code>ocamlformat</code>","text":"<p>To install <code>ocamlformat</code>, type these commands into a terminal:</p> <pre><code>$ opam update\n$ opam install ocamlformat\n</code></pre> <p>Then type this to verify that it has been installed:</p> <pre><code>$ ocamlformat --version\n</code></pre> <p>The most recent version is 0.27.0, which is what you should see.</p>"},{"location":"ocaml/notes/format/#configuring-ocamlformat","title":"Configuring <code>ocamlformat</code>","text":"<p>Create a file in your <code>src</code> directory called <code>.ocamlformat</code> (the leading <code>.</code> is important!), with these contents:</p> <pre><code>profile = ocamlformat\nversion = 0.27.0\nfield-space = loose\n</code></pre> <p>This sets the <code>ocamlformat</code> profile as the one to use (there are a couple of others which don't concern us). The <code>field-space = loose</code> line is our personal preference; type <code>ocamlformat --help</code> to learn more about this.</p>"},{"location":"ocaml/notes/format/#using-ocamlformat","title":"Using <code>ocamlformat</code>","text":"<p>There are two ways to use <code>ocamlformat</code> from the terminal command line.</p> <p>The first is just to see if the new format is acceptable to you. Say you are reformatting a file called <code>remove_complex.ml</code>. Then type:</p> <pre><code>$ ocamlformat remove_complex.ml\n</code></pre> <p>and it will output the reformatted file on the screen. Assuming this is acceptable to you, and you want to permanently change the file to the reformatted one, add the <code>-i</code> argument (<code>-i</code> means \"in place\" since the file is modified in place):</p> <pre><code>$ ocamlformat -i remove_complex.ml\n</code></pre> <p>Of course, after you've added code to this file, you may want/need to run <code>ocamlformat</code> again.</p> <p>Note</p> <p>Use of <code>ocamlformat</code> is optional. You're not required to use it, but if you find that formatting is a nuisance to you, go ahead and give it a try.</p>"},{"location":"ocaml/notes/format/#to-learn-more","title":"To learn more","text":"<p>The \"home page\" for <code>ocamlformat</code> is here.</p>"},{"location":"ocaml/notes/functional/","title":"Functional programming tips","text":""},{"location":"ocaml/notes/functional/#use-functional-style-by-default","title":"Use functional style by default","text":"<p>Code should be written in a functional style (no <code>ref</code>s, arrays, or records with mutable fields) except where indicated.  Marks will be taken off if this rule is violated.  We will let you know when it's OK to use imperative idioms. Certain imperative idioms (like <code>while</code> and <code>for</code> loops) are almost never used, but we do use <code>ref</code> cells on occasion to make code simpler.</p> <p>Many of the tips below describe ways to effectively use functional style. They are not in any particular order, so feel free to browse until you find something interesting.</p>"},{"location":"ocaml/notes/functional/#use-tail-recursion-by-default","title":"Use tail recursion by default","text":"<p>As you recall, a lot of CS 4 was spent teaching you to write functions using recursion instead of loops, and specifically using tail recursion. We use tail recursion because it has desirable space properties, so in general, when you write a recursive function, we generally try to make it tail recursive. In particular, any function that can operate on arbitrarily-sized data structures should really be tail-recursive so as not to use up excessive amounts of stack space.</p> <p>However, there is no need to be obsessive about this. Most of the code compiled by a compiler will be comparatively short (e.g. the size of a typical function), so if the input to a function is that code, optimizing for space efficiency may not buy you very much. So if it's significantly easier to write a particular recursive function in a non-tail-recursive style, it's OK to do that. But be prepared to defend this choice in code reviews.</p> <p>Also note that it's often desirable to use a fold (see below) instead of using recursion at all!</p>"},{"location":"ocaml/notes/functional/#persistent-data-structures","title":"Persistent data structures","text":"<p>Probably the hardest part of using functional programming effectively is getting used to persistent data structures (like lists) instead of mutable data structures (like arrays).</p> <p>In this course, almost all data structures are persistent, which means that when you change something in the data structure, it returns the updated version without altering the input version.  This is very different to how imperative languages work.</p> <p>Tip</p> <p>If you think you need to use <code>List.iter</code> (which would be appropriate for a mutable data structure) you almost always want to actually use <code>List.fold_left</code> or an iterative helper function (which is appropriate for a persistent data structure).</p> <p>Even though you may find functional programming awkward at first, it is vastly easier to write correct code in a functional style than in an imperative style. There is simply less that can go wrong.</p>"},{"location":"ocaml/notes/functional/#maps-are-your-friend","title":"Maps are your friend!","text":"<p>Consider this tail-recursive function:</p> <pre><code>let rec convert_nums (scale : int) (ns : int list) (acc : int list) : int list =\n  match ns with\n    | [] -&gt; acc\n    | h :: t -&gt;\n        convert_nums scale t (acc @ [scale * h])\n</code></pre> <p>This function would be called like this:</p> <pre><code># convert_nums 10 [1;2;3;4;5] []\n- : int list = [10; 20; 30; 40; 50]\n</code></pre> <p>When you look at what the function is actually doing, it becomes clear that it is simply multiplying each element of the list by 10. A much simpler way to achieve this would be to use a map:</p> <pre><code># List.map (fun n -&gt; 10 * n) [1;2;3;4;5]\n- : int list = [10; 20; 30; 40; 50]\n</code></pre> <p>You should develop your intuition for where a recursive function can be replaced by a higher-order function, and <code>List.map</code> is a simple example of this.</p> <p>Note on efficiency</p> <p>The other thing wrong about this function is that it's gratuitously inefficient, because of the line</p> <pre><code>    convert_nums scale t (acc @ [scale * h])\n</code></pre> <p>The <code>acc @ [scale * h]</code> expression adds a new value <code>scale * h</code> to the end of a list, which is an \\(O(n)\\) operation, giving the entire function an \\(O(n^2)\\) time complexity. A better approach would be to add to the front of the list and reverse it at the end.</p> <p>Now consider this (non tail-recursive) function:</p> <pre><code>let rec spread_nums (ns : int list) : int list =\n  match ns with\n    | [] -&gt; []\n    | h :: t -&gt; [h - 1; h; h + 1] @ spread_nums t\n</code></pre> <p>It could be used like this:</p> <pre><code># spread_nums [1;2;3];;\n- : int list = [0; 1; 2; 1; 2; 3; 2; 3; 4]\n</code></pre> <p>You might think you can't use a map here:</p> <pre><code># List.map (fun n -&gt; [n - 1; n; n + 1]) [1;2;3];;\n- : int list list = [[0; 1; 2]; [1; 2; 3]; [2; 3; 4]]\n</code></pre> <p>However, you can combine the list of lists into a list using the <code>List.concat</code> function:</p> <pre><code># List.concat (List.map (fun n -&gt; [n - 1; n; n + 1]) [1;2;3]);;\n- : int list list = [0; 1; 2; 1; 2; 3; 2; 3; 4]\n</code></pre> <p>This is so common that there is a function called <code>List.concat_map</code> which does both the mapping and the combining:</p> <pre><code># List.concat_map (fun n -&gt; [n - 1; n; n + 1]) [1;2;3];;\n- : int list list = [0; 1; 2; 1; 2; 3; 2; 3; 4]\n</code></pre> <p>So again there is no need for a recursive function when all the function is doing is mapping a function over a list of values and flattening the resulting list of lists; this is just the same as using <code>List.concat_map</code>.</p>"},{"location":"ocaml/notes/functional/#folds-are-your-friend","title":"Folds are your friend!","text":"<p>Programmers new to functional programming are often frustrated by what they perceive as the difficulty of doing simple things.  A good example of this is accumulation. You have a list and want to compute some value from the list elements. For instance, say you want to get the maximum value of the list (and assume that you only have a two-element <code>max</code> function to compute maximums). A Python programmer could immediately write this code:</p> <pre><code>def max_list(lst):\n    \"\"\"Compute the maximum of a list of positive integers.\"\"\"\n    if len(lst) == 0:\n        return 0\n    mx = lst[0]\n    for item in lst:\n        mx = max(mx, item)\n    return mx\n</code></pre> <p>In OCaml, we do this sort of thing using folds, specifically left folds.</p> <pre><code>let max_list lst =\n  List.fold_left\n    (fun mx item -&gt; max mx item)\n    0\n    lst\n</code></pre> <p>This can be simplified further:</p> <pre><code>let max_list lst = List.fold_left max 0 lst\n</code></pre> <p>Whenever you need to write code which accumulates something over a list, you generally want to use a fold.</p> <p>A common beginner's style error is to do this with an iterative helper function:</p> <pre><code>let max_list lst =\n  let rec iter rest mx =\n    match rest with\n      | [] -&gt; mx\n      | h :: t -&gt; iter t (max h mx)\n  in\n    iter lst 0\n</code></pre> <p>This is not so bad, but the iterative helper function can be replaced by <code>List.fold_left</code> and the entire function becomes a one-liner! Be alert for this kind of situation -- there's no benefit to using a functional language if you don't take advantage of what it offers.</p> <p>On the other hand, sometimes you are accumulating more than one thing in an iteration, or you may be passing more than just the thing you are accumulating through each iteration of the computation. In these cases, you can still use <code>List.fold_left</code>  by creating a tuple of everything that needs to be passed from one iteration to another and using that as the accumulation value, but in my experience, it's often easier to just write an iterative helper function.</p>"},{"location":"ocaml/notes/functional/#left-vs-right-folds","title":"Left vs. right folds","text":"<p>95% of the time or more, if you want to use a fold in OCaml, you want to use a left fold (<code>List.fold_left</code>) instead of a right fold (<code>List.fold_right</code>). Left folds are tail recursive (space efficient) and are more natural than right folds, which are not tail recursive and thus not space efficient.</p> <p>On the other hand, there are cases where right folds are the right thing to use.  When you want to accumulate things in a list from the right going back to the left, a right fold is usually going to be simpler than a left fold, and you shouldn't feel bad about using one in that case (unless you expect that the list could be very long, in which case you don't want to use a right fold because it would use up too much stack space).</p>"},{"location":"ocaml/notes/functional/#nested-pattern-matching","title":"Nested pattern matching","text":"<p>It's very common to want to write a pattern match inside another pattern match.  There are two cases to consider.</p> <ol> <li> <p>Where the two pattern matches can be combined.  Consider this code:</p> <pre><code>let f (maybe_lst : int list option) : int option =\n  match maybe_lst with\n    | None -&gt; None\n    | Some lst -&gt;\n      begin\n        match lst with\n          | h :: _ -&gt; Some h\n          | [] -&gt; None\n      end\n</code></pre> <p>You can merge both pattern matches as follows:</p> <pre><code>let f (maybe_lst : int list option) : int option =\n  match maybe_lst with\n    | Some (h :: _) -&gt; Some h\n    | _ -&gt; None\n</code></pre> <p>Note how much shorter and clearer the code is. Also note the use of the wildcard (<code>_</code>) pattern for \"don't care\" situations.</p> <p>Merging pattern matches is almost always possible if the inner pattern match doesn't depend on a value computed using information from the outer pattern match. Unnecessary pattern matches are bad style and will be marked down (but we'll try to alert you of this issue during code reviews).</p> </li> <li> <p>Where the two pattern matches can't be combined.    Consider this code:</p> <pre><code>let f (lst : int list) : (int * int) option =\n  match lst with\n    | h :: t -&gt;\n      begin\n        match List.sort compare t with\n          | h' :: _ -&gt; Some (h, h')\n          | _ -&gt; None\n      end\n    | _ -&gt; None\n</code></pre> <p>The inner match is matching on the result of the <code>List.sort</code> function applied to the tail of the list. You can't combine these pattern matches because the inner one depends on a value which must be computed (it's not structural). For very simple cases, you can use a <code>when</code> clause instead of the inner match, but often this isn't feasible. So you have nested <code>match</code> expressions.</p> <p>When you have nested <code>match</code> expressions, you must surround them by either <code>begin</code>/<code>end</code> delimiters (as we did above) or parentheses, which looks like this:</p> <pre><code>let f (lst : int list) : (int * int) option =\n  match lst with\n    | h :: t -&gt;\n      (match List.sort compare t with\n         | h' :: _ -&gt; Some (h, h')\n         | _ -&gt; None)\n    | _ -&gt; None\n</code></pre> <p>Using parentheses looks more concise, but it's easy to forget to close the open parenthesis, so we prefer to use <code>begin</code>/<code>end</code>. (It reads better, too.)  What you definitely do not want to do is this:</p> <pre><code>let f (lst : int list) : (int * int) option =\n  match lst with\n    | h :: t -&gt;\n      match List.sort compare t with\n        | h' :: _ -&gt; Some (h, h')\n        | _ -&gt; None\n    | _ -&gt; None\n</code></pre> <p>If you do this, you will get strange error messages because OCaml will consider the last line to be part of the inner pattern match. Remember, OCaml is not whitespace sensitive! So don't forget the <code>begin</code>/<code>end</code>.</p> </li> </ol>"},{"location":"ocaml/notes/new_features/","title":"OCaml features you may not be familiar with","text":"<p>Here are some OCaml features that weren't discussed in CS 4, but which are very useful in day-to-day programming.</p>"},{"location":"ocaml/notes/new_features/#the-pipe-operator","title":"The <code>|&gt;</code> (pipe) operator","text":"<p>The <code>|&gt;</code> (pipe) operator is a reverse-apply operator (analogous to a Unix pipe). It's very convenient when you want to transform some inputs repeatedly by applying one function after another.</p> <p>Instead of writing this:</p> <pre><code>func3 (func2 (func1 data))\n</code></pre> <p>you can write this:</p> <pre><code>data |&gt; func1 |&gt; func2 |&gt; func3\n</code></pre> <p>Aside from having fewer parentheses, it's often easier to read: \"Create <code>data</code>, then apply <code>func1</code>, <code>func2</code>, and <code>func3</code> to it in succession.\"</p> <p>Also, because of OCaml's auto-currying of functions, it even works if one or more of the functions take additional arguments, just as long as the data structure is the last argument to the function. So we might have e.g.:</p> <pre><code>data |&gt; func1 arg1 |&gt; func2 arg2a arg2b |&gt; func3\n</code></pre> <p>instead of:</p> <pre><code>func3 (func2 arg2a arg2b (func1 arg1 data))\n</code></pre> <p>Whether this is clearer is a matter of opinion.</p> <p>When there are a lot of transformations, it's nice to write them on  multiple lines:</p> <pre><code>data\n  |&gt; transform1\n  |&gt; transform2\n  |&gt; transform3 arg\n  |&gt; transform4 arg1 arg2\n  (* etc. *)\n</code></pre> <p>This is much more readable than the usual notation:</p> <pre><code>transform4 arg1 arg2 (transform3 arg (transform2 (transform1 data)))\n</code></pre> <p>and it's also easier to extend with more transformations.</p>"},{"location":"ocaml/notes/new_features/#the-apply-operator","title":"The <code>@@</code> (apply) operator","text":"<p>The \"cousin\" of the <code>|&gt;</code> operator is the <code>@@</code> (forward apply) operator. Like <code>|&gt;</code>, it's never required, but sometimes it can make code a bit nicer by removing the need for some parentheses.</p> <p>Note</p> <p>If you know the Haskell language, you'll recognize the <code>@@</code> operator as the same thing as the <code>$</code> operator in Haskell.</p> <p>The <code>@@</code> operator is used to apply a function to its argument, so <code>f @@ x</code> is the same as <code>f x</code>.  Seems pointless, right? But consider <code>f (1 + 2)</code>.  With <code>@@</code> this becomes <code>f @@ 1 + 2</code> and you've eliminated the need for the parentheses.  Similarly:</p> <pre><code>func3 (func2 (func1 data))\n</code></pre> <p>can be written as:</p> <pre><code>func3 @@ func2 @@ func1 data\n</code></pre> <p>and the parenthesis-saving is even greater! (Note that this operator associates to the right.)</p> <p>A common use for this is when signalling errors.  In the course compilers, most errors use the <code>failwith</code> function:</p> <pre><code>failwith \"my error message\"\n</code></pre> <p>This is fine, but very often, the error message needs to contain formatted data e.g.</p> <pre><code>if i &gt; max_i then\n  failwith (Printf.sprintf \"i value: (%d) is too large\" i)\nelse\n  ...\n</code></pre> <p>This can be rewritten using the <code>@@</code> operator as:</p> <pre><code>if i &gt; max_i then\n  failwith @@ Printf.sprintf \"i value: (%d) is too large\" i\nelse\n  ...\n</code></pre> <p>and sometimes it's nice to put the <code>Printf.sprintf</code> on its own line:</p> <pre><code>if i &gt; max_i then\n  failwith @@\n    Printf.sprintf \"i value: (%d) is too large\" i\nelse\n  ...\n</code></pre> <p>In fact, this case is so common that we've written a helper function called <code>failwithf</code> (\"<code>failwith</code> with formatting\"). Using that, we could rewrite the above code as:</p> <pre><code>open Support.Utils\n\n...\n\nif i &gt; max_i then\n  failwithf \"i value: (%d) is too large\" i\nelse\n  ...\n</code></pre>"},{"location":"ocaml/notes/new_features/#labelled-arguments","title":"Labelled arguments","text":"<p>OCaml has a neat feature called labelled arguments which we didn't cover in CS 4. Just like you'd expect, this feature means that you can label a function argument with a name, and you have to use that name when calling the function. What's nice is that you don't have to put labelled arguments in any particular order; as long as the label is there, the function will know what to do about them.</p> <p>The syntax is described in detail in the link, but here's an example:</p> <pre><code>let f ~x ~y = x - y     (* x and y are labelled arguments *)\n\nlet _ = f ~x:10 ~y:20   (* you need the labels when calling the function *)\nlet _ = f ~y:20 ~x:10   (* does the same thing *) \n</code></pre> <p>Why would you use this?</p> <p>In our experience, the toughest OCaml bugs to track down are in functions that have more than one argument of the same type.  It's easy to switch the arguments by mistake, and then you have a very hard-to-find bug.</p> <p>The solution is to use labelled arguments.  This way, when you call the function, you have to specify which argument you mean, which makes errors of this kind far less likely.</p> <p>We're not suggesting you do this for every function, but it's certainly a trick to keep in mind, and one which we've used in much of the supporting code.</p> <p>Also, OCaml supports optional arguments, which are like labelled arguments except the function gets a default value you specify if the labelled argument is left off.  The link above describes those too.</p>"},{"location":"ocaml/notes/overview/","title":"Coding notes: overview","text":"<p>In this section we will cover some notes and tips that should improve your OCaml programming experience. We also describe our expectations of how we want you to write your OCaml code, so don't just skip this document!</p>"},{"location":"ocaml/notes/poly/","title":"Polymorphic variants","text":"<p>Pattern matching polymorphic variants has some extra capabilities that you should be aware of. This occurs in the compilers starting from assignment 3 when operators are defined in terms of different polymorphic variant types:</p> <pre><code>type base_op = [\n  | `Read\n  | `Add\n  | `Sub\n  | `Negate\n  | `Not\n]\n\ntype cmp_op = [\n  | `Eq\n  | `Lt\n  | `Le\n  | `Gt\n  | `Ge\n] \n\ntype core_op = [\n  | base_op\n  | cmp_op\n]\n</code></pre> <p>As you can see, you can define <code>core_op</code> as the union of two other polymorphic variant types without defining a new constructor. (This is something you can't do with regular algebraic datatypes.) But when you are pattern-matching on <code>core_op</code> values (which can have any of the constructors of <code>base_op</code> or <code>cmp_op</code>) you may need to split them back into the two classes. This is done rather easily:</p> <pre><code>match (op : core_op) with  (* type annotation is optional *)\n  | #base_op as b_op -&gt;    (* your code with (b_op : base_op) *)\n  | #cmp_op as c_op -&gt;     (* your code with (c_op : cmp_op) *)\n</code></pre> <p>The new syntax <code>#base_op as b_op</code> (or <code>#cmp_op as c_op</code>) will match any of the <code>base_op</code> (or  <code>cmp_op</code>) constructors, and you can then do whatever you want with those.</p> <p>This is described (somewhat briefly) in the OCaml manual:</p> <p>To make this even more comfortable, you may use type definitions as abbreviations for or-patterns. That is, if you have defined <code>type myvariant = [`Tag1 of int | `Tag2 of bool]</code>, then the pattern <code>#myvariant</code> is equivalent to writing <code>(`Tag1(_ : int) | `Tag2(_ : bool))</code>.</p>"},{"location":"ocaml/notes/sexp/","title":"On S-expressions","text":""},{"location":"ocaml/notes/sexp/#what-s-expressions-are","title":"What S-expressions are","text":"<p>S-expressions are described in this Wikipedia article. Essentially, they are an extremely simple way (perhaps the most simple way) to represent structured data. The \"S\" in \"S-expression\" originally meant \"symbolic\"; these were originally the way to represent arbitrary data in the Lisp programming language. (They were also used to represent Lisp code as well, but that's another story.) Even now, S-expressions are often associated with Lisp-like programming languages such as Scheme, Clojure, and Racket, but they are more generally useful, as we'll see.</p> <p>An S-expression is essentially just a nested list of arbitrary symbols. S-expressions can be described recursively as either</p> <ul> <li>a symbol   (a string without quotes which   doesn't have internal spaces, quotes, or parentheses)</li> <li>a list of S-expressions</li> </ul> <p>Usually, we use parentheses to delimit a list.  Here are some sample S-expressions:</p> <ul> <li><code>foo</code></li> <li><code>(a b c)</code></li> <li><code>(this is (a (nested list) of) symbols)</code></li> <li><code>((foo 1) (bar 2) (baz 3))</code></li> </ul> <p>Any kind of structured data can be represented as an S-expression.</p>"},{"location":"ocaml/notes/sexp/#how-we-use-them","title":"How we use them","text":"<p>We use S-expressions as both a serialization format and a visualization tool. \"Serialization\" means that we can take arbitrary OCaml datatypes and convert them to and from S-expressions without losing any information.  For visualization, we take some OCaml datatype we want to look at, convert it to an S-expression, and then pretty-print the S-expression in a readable format.</p> <p>Visualization is incredibly useful for debugging.  We will be using a lot of fairly complex OCaml datatypes, and our compiler passes will have the job of converting one datatype into another.  We would like to be able to inspect these datatypes to make sure that we converted them correctly.  If we had to write special string conversion functions for all our datatypes, that would be an enormous amount of boring work.  Instead, there are OCaml libraries that will allow us to automatically convert any datatype to an S-expression if we add small annotations to our code.  (These libraries are the <code>sexplib</code> and <code>ppx_sexp_conv</code> libraries.)</p> <p>In order to get OCaml to generate the S-expression conversion code, we  have to add an annotation after type declarations:</p> <pre><code>type value =\n  | Bool of bool\n  | Int of int\n  | Function of (value -&gt; value)\n[@@deriving sexp]   (* this is the annotation *)\n</code></pre> <p>The <code>[@@deriving sexp]</code> line is what is called a PPX extension; it's a kind of code-generating macro which, when interpreted by OCaml, will generate two functions: <code>sexp_of_value</code> (convert a <code>value</code> to an S-expression) and <code>value_of_sexp</code> (convert an S-expression to a value). We tend to use the first function(s) much more than the second, because we usually want to convert our types to S-expressions.</p> <p>We will use this facility for nearly all our data structures. Fortunately, you don't have to worry about it! Just don't remove those annotations; they are doing real work.</p> <p>All you really need to know is that for any datatype <code>foo</code> which has the <code>[@@deriving sexp]</code> annotation, (which is almost all of them) there will be functions called <code>sexp_of_foo</code> and <code>foo_of_sexp</code> generated. There is also a function in the <code>Support.Utils</code> module called <code>print_sexp</code> which will print out an S-expression in a readable format. So if you need to print out the data structure, just convert it to an S-expression with (say) <code>sexp_of_foo</code> and then print it using <code>print_sexp</code>.</p> <p>Note</p> <p>There is much, much more that could be said about OCaml's PPX extension system, which is a relatively new feature of the language (and which wasn't discussed at all in CS 4 or CS 131). It's a very powerful code-generation system, but it also has a steep learning curve.</p>"},{"location":"ocaml/notes/style/","title":"Style tips","text":"<p>In general, we encourage you to use the <code>ocamlformat</code> autoformatter, as described in the \"Formatting your code\" page. However, here are some additional style tips in case you don't use it.</p>"},{"location":"ocaml/notes/style/#dont-use-unnecessary-parentheses","title":"Don't use unnecessary parentheses!","text":"<p>Programmers not familiar with OCaml often add unnecessary parentheses. OCaml doesn't require parentheses around function arguments, so this code:</p> <pre><code># let foo(x) = x + 1;;\n# foo(4);;\n</code></pre> <p>should be written as:</p> <pre><code># let foo x  = x + 1;;\n# foo 4 ;;\n</code></pre> <p>OCaml will accept either form, but when there is more than one argument, the parentheses change the meaning:</p> <pre><code># let foo1(x, y) = x + y;;\n# let foo2 x y = x + y;;    (* different! *)\n</code></pre> <p>In this case, the first argument takes a 2-tuple as its sole argument, whereas the second function has two distinct arguments.</p> <p>This also comes up with constructors:</p> <pre><code># type foo = Foo of int;;\n# Foo(10);;\n- : foo = Foo 10\n# Foo 10;;\n- : foo = Foo 10\n</code></pre> <p>The version without parentheses is always preferred.</p> <p>In general, only add parentheses when you need to. There is one exception: OCaml often allows you to omit the parentheses around a tuple value or a tuple pattern. I consider it much more readable to include them in this case:</p> <pre><code># 1, 2, 3;;\n- : int * int * int = (1, 2, 3)\n# (1, 2, 3);;\n- : int * int * int = (1, 2, 3)\n</code></pre> <p>The second form is preferred.</p>"},{"location":"ocaml/notes/types/","title":"Type annotations","text":"<p>We strongly recommend that you add type annotations to all functions that are internal to a module. It will save you a lot of grief. Just because OCaml can do type inference doesn't mean that you have to rely on it! When you specify the types manually, you will usually get better error messages.</p> <p>For example, instead of writing this code:</p> <pre><code>let rec insert x lst =\n  match lst with\n    | [] -&gt; [x]\n    | h :: t -&gt;\n        if x &lt; h then x :: lst else h :: insert x t\n</code></pre> <p>we recomment that you write it like this:</p> <pre><code>let rec insert (x : 'a) (lst : 'a list) : 'a list =\n  match lst with\n    | [] -&gt; [x]\n    | h :: t -&gt;\n        if x &lt; h then x :: lst else h :: insert x t\n</code></pre> <p>(Actually, you'd probably rewrite it to be tail recursive, but that's another topic.)</p> <p>In many cases, you could substitute a more specific type for <code>'a</code> (say, <code>int</code>), which would be beneficial in the event that you wanted to disallow any input list which was not a list of <code>int</code>s.</p> <p>Also, don't remove the type annotations once the code is working \"because it looks prettier\"; leave them in. It's good documentation and it will be really important if you ever have to modify the code.</p> <p>Note</p> <p>We didn't have this guideline in CS 4, primarily because the code base was so much smaller. The more complicated the code gets, the more helpful explicit type annotations are.</p>"}]}