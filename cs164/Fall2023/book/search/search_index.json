{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CS 164 book: Fall 2023","text":"<p>This book is the official document repository for the Caltech CS 164 course (Compilers).</p> <p>The course instructor is Mike Vanier. See the syllabus for administrative information.</p>"},{"location":"admin/collab/","title":"Collaboration policies","text":""},{"location":"admin/collab/#overview","title":"Overview","text":"<p>The CS 164 collaboration policies determine if, and how much, you are allowed to collaborate with other students while working on your assignments.</p> <p>Please read this document to the very end, because you are responsible for abiding by all the rules set forth here. Failure to abide by these rules may cause you to get sent to the Board of Control (BoC), and that is not pleasant for anyone concerned. Therefore, we want to be extra clear on what constitutes fair collaboration in this course.</p> <p>Note</p> <p>In some places in this document, you will read that some kind of behavior is strictly forbidden. We are not trying to scare you or intimidate you, and we're not trying to be jerks. We just want to make absolutely sure that you know what the rules are, and saying that something is strictly forbidden is pretty unambiguous. (We apologize in advance if you find this annoying.)</p>"},{"location":"admin/collab/#basic-policy","title":"Basic policy","text":"<p>As this course is a partnership course, you are expected to collaborate 100% with your partner. You can discuss anything related to the assignments with them, share code with them (obviously), ask each other questions, etc. Nothing is off-limits collaboration-wise as long as it's with your partner. Everything else that is described below refers to \"collaboration\"-style activities with people who are not your partner. When we refer to \"you\" below we mean the collective \"you\" i.e. your team.</p> <p>You are welcome to collaborate informally on your assignments with other students who are taking or have taken the class, but you must write all of your own code and you must not look at code from other groups. Copying another group's code verbatim or nearly verbatim (from a file, a whiteboard, a screen share or anywhere else) is not acceptable and is an Honor Code violation. Taking another group's code and modifying it to make it look different is definitely not acceptable and is an Honor Code violation. Consulting a printed or electronically displayed version of another group's code and referring to it while you write your own code is not acceptable either, and is also an Honor Code violation. Having someone not in your group dictate code while you type isn't acceptable either.  Basically, your group has to do your own work.</p> <p>Getting advice on algorithms or syntactic details of the language, or suggestions on how to debug a part of your program that isn't working, is fine as long as no code sharing is involved.</p> <p>All of the above also applies to student work from previous years. Copying code from an assignment that was submitted in previous years is an Honor Code violation just as much as copying from a group who are currently taking the course.</p>"},{"location":"admin/collab/#use-and-abuse-of-pseudocode","title":"Use and abuse of pseudocode","text":"<p>In the past, some students in CS classes have been called in to the BoC because of very similar code that was ultimately traced to pseudocode written on a whiteboard which was almost exactly like the final code. Pseudocode is supposed to be an informal, non-executable description of an algorithm. If you write or consult pseudocode which is (say) 80% or more of the way to being actual runnable code as a way to do an end run around the collaboration policies, be advised that we and the BoC are well aware of this problem and you will not get away with it. On the other hand, if you (or a TA) write out or read pseudocode which is a human-readable description of an algorithm without any actual code in it, you are fine. If in doubt, ask the instructor.</p>"},{"location":"admin/collab/#teleconferencing-software-eg-zoom","title":"Teleconferencing software (e.g. Zoom)","text":"<p>If you use teleconferencing software (like Zoom) or software with teleconferencing capabilities (like Discord with VOIP), you may not share your screen with students from another group, whether to help them or to get help from them.  This also applies to non-students (with the obvious exception of the course instructor or TAs).</p> <p>Also, it is strictly forbidden to dictate code over teleconferencing software, except (obviously) with your partner.  This is consistent with the rules in the other sections of this document.</p>"},{"location":"admin/collab/#discussion-boards-and-chat-programs","title":"Discussion boards and chat programs","text":"<p>You are strictly forbidden from posting code from your assignments to a discussion board (such as Piazza) unless it's a private message to one or more instructors/TAs.  If this happens you may lose the ability to use the discussion board for any purpose.  On the other hand, if you post a private message you can include your partner in the message (if Piazza allows this).</p> <p>This also applies to programs with chat features that are not used in the course (like Slack or Discord), or email for that matter.</p>"},{"location":"admin/collab/#use-of-websites","title":"Use of websites","text":"<p>Your code repository must be and must remain private. Do not allow outsiders to see your code, even after the course is finished. Public repos can quickly make the assignments worthless.</p> <p>In the event that a student from a previous year makes their repo public and you find out about it, please inform the instructor, and, of course, you aren't allowed to consult this code.</p>"},{"location":"admin/collab/#use-of-code-hinting-software-eg-github-copilot-chatgpt","title":"Use of code hinting software (e.g. Github Copilot, ChatGPT)","text":"<p>You are strictly forbidden to use code hinting software such as Github Copilot or ChatGPT for any part of this course. It's unlikely that it would benefit you anyway, but whether it would be helpful or not, you can't use it.</p>"},{"location":"admin/collab/#summary","title":"Summary","text":"<p>These are resources that you may or may not be allowed to consult while working on your assignments.</p> Item Status Course book OK Course textbook OK Official OCaml documentation OK Other OCaml documentation OK Other OCaml books OK Your notes or your partner's notes OK Notes of other students not in your group Not allowed Other students' code repositories (not including your partner) Not allowed Material in non-course code repositories (Github, Bitbucket, Gitlab etc.) Not allowed Code hinting software (e.g. Github Copilot, ChatGPT) Not allowed"},{"location":"admin/collab/#consequences-for-violating-these-policies","title":"Consequences for violating these policies","text":"<p>Be aware that letting another student copy from you is just as bad as copying from another student, and can get you into just as much trouble.</p>"},{"location":"admin/collab/#finally","title":"Finally...","text":"<p>If you have any questions about the course collaboration policies, please contact the instructor. Do not ask the teaching assistants; they may not give you the best answer.</p> <p>We realize that the vast majority of you (hopefully all of you) have no intention of cheating or overcollaboration in any way, and we hope that this collaboration policy won't get in the way of your enjoyment of the course.</p>"},{"location":"admin/syllabus/","title":"Syllabus","text":"<p>This is the syllabus for CS 164 (Compilers), Fall 2023. Everything is subject to revision.</p>"},{"location":"admin/syllabus/#people","title":"People","text":""},{"location":"admin/syllabus/#instructor","title":"Instructor","text":"<p>The instructor is Mike Vanier (mvanier@cms.caltech.edu). Mike's office is Annenberg 110.</p> <p> </p> Mike"},{"location":"admin/syllabus/#teaching-assistants","title":"Teaching assistants","text":"<p>Here are the teaching assistants for this term:</p> <ul> <li>Astral Grayson</li> <li>Adishree Ghatare</li> <li>Inhoo Lee</li> <li>Kyla Yu-Swanson</li> </ul> <p>They are all outstanding and we are lucky to have them!</p>"},{"location":"admin/syllabus/#office-hours","title":"Office hours","text":"<p>Office hours will be posted on the course Piazza page.</p>"},{"location":"admin/syllabus/#course-description","title":"Course description","text":"<p>This course covers the construction of compilers: programs which convert program source code to machine code which is directly executable on modern hardware.  The course takes an incremental approach: a series of compilers will be built, all of which generate assembly language code for x86-64 processors, with each compiler adding features to the previous one. The final compiler will compile programs written in a full-fledged high-level programming language to assembly language, which can then be compiled to machine language using standard tools.</p> <p>Topics covered include register allocation, conditionals, loops and dataflow analysis, garbage collection, lexical scoping, and type checking.</p> <p>This course is project-based and programming-intensive.  Students will work in teams of two students each. All compilers will be written in the OCaml programming language.</p>"},{"location":"admin/syllabus/#learning-objectives","title":"Learning objectives","text":"<p>At the end of this course, you will have written a compiler from a small subset of a typed dialect of the Scheme programming language to assembly language. Along the way, you will learn the primary ingredients of modern compilers.</p>"},{"location":"admin/syllabus/#prerequisites","title":"Prerequisites","text":"<p>The course has a hard prerequisite of CS 4 (Fundamentals of Computer Programming), because you need to know OCaml in order to take this course.</p> <p>Two recommended (but not required) prerequisites are:</p> <ul> <li> <p>CS 24 (Introduction to Computing Systems), primarily because we will be using   assembly language, and CS 24 includes an introduction to assembly language.   However, we will describe all the assembly language instructions we need   as we get to them.</p> </li> <li> <p>CS 131 (Programming Languages).  This course is useful because:</p> <ul> <li> <p>CS 131 also uses OCaml, so students who have taken it have   experience writing moderately large multi-file programs in OCaml;</p> </li> <li> <p>students who have taken CS 131 already know what an abstract syntax   tree (AST) is, and what intermediate representations (IRs) are,   which will be useful.</p> </li> </ul> <p>Again, we will cover the relevant material in this course.</p> </li> </ul>"},{"location":"admin/syllabus/#textbook","title":"Textbook","text":"<p>The course textbook is Essentials of Compilation by Jeremy Siek. This textbook is available either in a printed version (which we recommend you get) or as a free PDF (which we will distribute). We will be following the book quite closely. The main difference is that the book uses the Racket programming language to build the compilers, whereas we will use OCaml.1</p> <p>The PDF of the textbook we will use is available on the course Canvas site, under Modules/Resources.</p>"},{"location":"admin/syllabus/#topics-covered","title":"Topics covered","text":"<p>This is a very abbreviated list of topics covered in the course, presented in the order they will be covered. Some additional material may be covered towards the end of the course.</p> <ul> <li>Overview of the compilation process</li> <li>Variables and scoping</li> <li>Register allocation and graph coloring algorithms</li> <li>Conditionals and type checking</li> <li>Loops and dataflow analysis</li> <li>Tuples and garbage collection</li> <li>Functions</li> <li>Lexically-scoped functions (time permitting)</li> </ul>"},{"location":"admin/syllabus/#grading-scheme","title":"Grading scheme","text":"<p>The course is on grades.  There are no exams. The marks are assigned as follows:</p> <ul> <li> <p>75% for 6 programming assignments.</p> </li> <li> <p>20% for participation in weekly code reviews.</p> </li> <li> <p>5% for participation in class.   Lecture slides will be posted after class,   but lectures will not be recorded.</p> </li> </ul> <p>Letter grades are assigned as follows:</p> Numerical grade Letter grade 95-100% A+ 90-95% A 85-90% A- 80-85% B+ 75-80% B 70-75% B- 68-70% C+ 65-68% C 60-65% C- 55-60% D &lt; 55% F"},{"location":"admin/syllabus/#lectures","title":"Lectures","text":"<p>Lectures will be held MWF from 11 AM to noon in Annenberg room 104.</p> <p>Most weeks will only have MW lectures, with the F lecture slot being used for code reviews.</p>"},{"location":"admin/syllabus/#assignments","title":"Assignments","text":""},{"location":"admin/syllabus/#assignment-due-dates","title":"Assignment due dates","text":"<p>Assignments will be due on Fridays at 2 AM.  (This is effectively very late Thursday night.)</p>"},{"location":"admin/syllabus/#teams","title":"Teams","text":"<p>Assignments are done in teams of two students each. Teams will stay together for the duration of the term (unless one student drops the course or unless there is some serious problem). Teams are expected to split the workload of each assignment evenly, and there may be penalties if it is obvious that one student in the team is doing most or all of the work.</p> <p>Students will create a private Github repository for their code. They will add the course instructor and their TA grader as full contributors to their repository. (This is for testing purposes.)</p>"},{"location":"admin/syllabus/#submitting-assignments-and-receiving-grades","title":"Submitting assignments and receiving grades","text":"<p>Since the instructor and graders will have access to the code repositories of the teams, they can check out the latest version of the code and run the tests at any time. Thus, assignments do not need to be \"submitted\" as such; instead, \"submitting\" an assignment means that the team lets the instructor know when an assignment is ready to be graded (ideally, before the due date/time).</p> <p>The grader will grade the assignment and leave comments in a file at the root of the directory called GRADES. They will also usually leave comments in the code regarding code that students need to fix/change. Such comments will have this form:</p> <pre><code>(*** REWORK TODO: ... ***)\n</code></pre> <p>We ask that you do not use this style for your own comments. Once the items have been fixed, such comments should be removed before \"resubmitting\" the assignment.</p> <p>If students do not understand a comment, they are encouraged to contact the instructor and the TAs for clarification.</p>"},{"location":"admin/syllabus/#code-reviews","title":"Code reviews","text":"<p>Once a week, teams will meet with the instructor or one of the TAs online for roughly a half hour code review session. These sessions (which will normally happen on Thursday or Friday) are open-ended; they can be used for anything the instructor/TA or the students want. We expect that students will discuss problems they are having with their assignments, points of confusion, or just ask the instructor/TA if a particular piece of code is written the right way. Conversely, the instructor/TA may ask students why they chose to write a particular piece of code a particular way, and may suggest alternatives.</p>"},{"location":"admin/syllabus/#redos","title":"Redos","text":"<p>Once grades have been submitted, teams have one week from that time to rework the assignment for up to full credit.</p> <p>Normally redos will not be accepted after that period unless there are extenuating factors or unless late days (see below) are used. Nevertheless, we do encourage students to rework old assignments if necessary, since newer assignments are extensions of older assignments.</p>"},{"location":"admin/syllabus/#late-policies","title":"Late policies","text":"<p>Because the instructor/TAs have access to your code repositories, and thus can run the tests on those repositories at any time, in principle there is no need for a late policy (any assignment can be graded simply by running the tests at any time). However, a team can request that an assignment be graded later than the usual time.</p> <p>Teams get 10 \"late days\" for the entire term.  A \"late day\" can be used to defer grading without penalty.  Once late days are up, if a team still wants grading of an assignment to be deferred, they have two choices:</p> <ol> <li>allow the incomplete assignment to be graded</li> <li>request further late days, with late penalties</li> </ol> <p>A late penalty is 10% of the final (unpenalized) grade per day late. It cannot be redeemed through rework.</p> <p>Example: team A has used up all its late days, and wants another late day for assignment X. They submit the assignment one day late, get 80/100, and submit a rework to get 100/100. Because of the late day, their final grade for the assignment is 90/100 (losing 10 points for the late day).</p>"},{"location":"admin/syllabus/#external-websites","title":"External websites","text":"<p>There will be a course Piazza page (to be set up).</p> <p>Code reviews will be done on Zoom.</p> <p>If there is sufficient demand, a Discord server can be set up.</p>"},{"location":"admin/syllabus/#course-software","title":"Course software","text":"<p>Setting up the course software is described in assignment 0.</p>"},{"location":"admin/syllabus/#academic-integrity","title":"Academic integrity","text":"<p>Caltech\u2019s Honor Code states that: \"No member of the Caltech community shall take unfair advantage of any other member of the Caltech community.\"</p> <p>Understanding and avoiding plagiarism: Plagiarism is the appropriation of another person's ideas, processes, results, or words without giving appropriate credit, and it violates the honor code in a fundamental way. You can find more information at this link.</p>"},{"location":"admin/syllabus/#collaboration-policies","title":"Collaboration policies","text":"<p>Collaboration policies are given in the Collaboration policies document.</p>"},{"location":"admin/syllabus/#diversity-and-inclusion","title":"Diversity and inclusion","text":"<p>You all belong in this class and as such should expect to be treated with respect by your classmates and by the course staff. It is our goal, as the course staff, to provide an interesting and challenging environment that is conducive to learning. If any incident occurs that challenges this commitment to a supportive and inclusive environment, please let the instructor know so the issue can be addressed.</p>"},{"location":"admin/syllabus/#accessibility","title":"Accessibility","text":"<p>We consider accessibility to be an extremely important issue. If some aspect of the course is making it more difficult for you to learn the material, we want to hear about it! We want this course to be an enjoyable experience for you, not a burden.</p>"},{"location":"admin/syllabus/#student-wellness","title":"Student wellness","text":"<p>It is very important that you take care of your mental wellness throughout the course. Everyone on the course staff is available to chat, and you can always attend office hours for a non-academic conversation if necessary.</p>"},{"location":"admin/syllabus/#students-with-documented-disabilities","title":"Students with documented disabilities","text":"<p>Students who may need an academic accommodation based on the impact of a disability must initiate the request with Caltech Accessibility Services for Students (CASS).  Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter for faculty dated in the current quarter in which the request is being made. Students should contact CASS as soon as possible, since timely notice is needed to coordinate accommodations. See http://cass.caltech.edu/ for more.</p> <p>Undergraduate students should contact Dr. Lesley Nye, associate Dean of Undergraduate Students and graduate students should contact R. Darrell Peterson, Associate Dean of Graduate Studies.</p> <ol> <li> <p>There is also a Python version of the compiler textbook, which is slightly different and which we won't be using.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/0/","title":"Assignment 0: Getting set up","text":""},{"location":"assignments/0/#due-date","title":"Due date","text":"<p>This assignment has no due date, and isn't graded.</p>"},{"location":"assignments/0/#overview","title":"Overview","text":"<p>This pseudo-assignment covers the steps you need to go through so that you can start working on the real assignments (starting with assignment 1).  It has these steps:</p> <ol> <li> <p>Choose a partner.  All homework will be done collectively by groups of two    students.</p> </li> <li> <p>Get OCaml installed.  Also install all necessary supporting packages.</p> </li> <li> <p>Create a private Github repository.  Add both partners to the repository.    Add the instructor (Mike Vanier, Github name <code>mvanier</code>) to the repo.</p> </li> <li> <p>Add your TA/grader to the repository.    (This doesn't need to be done until your group has been assigned a grader.)</p> </li> </ol> <p>Once this is done, you are ready to start working on compilers! The next sections go through the steps in more detail.</p> <p>If you have any problems completing any of the steps, let the instructor and/or the TAs know.</p>"},{"location":"assignments/0/#choosing-a-partner","title":"Choosing a partner","text":"<p>We will leave this step up to you.  We can discuss it in class. If necessary, we can assign students into groups.</p>"},{"location":"assignments/0/#getting-ocaml-installed","title":"Getting OCaml installed","text":"<p>See the document Installing OCaml.</p>"},{"location":"assignments/0/#creating-a-github-repository","title":"Creating a Github repository","text":"<p>We expect that most of you have used the Git version control system before. If you haven't, don't worry: you only need to learn a handful of Git commands in order to work with Git.  The primary ones are <code>git commit</code>, <code>git pull</code> and <code>git push</code>.  If necessary, you should read some online tutorials.  There are also books you can read, such as Learn Enough Git To Be Dangerous.1</p> <p>Learning Git is likely to be one of the most useful things you ever do as a programmer, so don't feel like this is a waste of time! All code you write should always be stored in a version control system. This protects you from accidentally deleting your files, misplacing them, etc. and also allows you to precisely track changes to your code (and revert to earlier versions in case you made a change that broke everything!).</p> <p>Warning</p> <p>We very strongly recommend that you do not try to use advanced Git commands (such as <code>git rebase</code>) unless you know exactly what you are doing. Even though Git is a source code repository system, it is possible to mess up a repo through incorrect use, and in extreme cases you might have to recreate the repository from scratch.  Be conservative!</p> <p>You also need to have an account with Github, which is a website that offers free hosting for Github repositories. Note that we require that your repository be private, so other students (and future students!) will not be able to look at your code -- Honor Code rules apply. Newly-created Github repositories normally default to public access, and you need to change that.</p> <p>Note</p> <p>You may prefer other code hosting services like Bitbucket or GitLab, but for this course, please use Github.</p> <p>Do not write any code for the assignments until your Github repo is set up and until you have added the instructor (Mike, Github name <code>mvanier</code>) as a full contributor to the repo.</p> <p>Finally, create a <code>README.md</code> file for the repository in which you state who the two members of your team are. Include both the name and email addresses of both members. (You can put more information there as well.)</p> <ol> <li> <p>The author of this book (Michael Hartl) is a Caltech graduate and a friend of the instructor. There are a number of other \"Learn Enough\" books in the series, many of which you may find useful.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/overview/","title":"Assignment 1: The Var language","text":""},{"location":"assignments/1/overview/#overview","title":"Overview","text":"<p>This assignment involves writing a compiler for the Var language, which is a simple language of variables and arithmetic described in chapter 2 of the textbook and in the lectures.</p> <p>The end result will be a program called <code>compile</code> which will be able to compile a source program (with the extension <code>.src</code>) to assembly language. In addition, the compiler can stop after any pass, including after the parser, so you can inspect the generated code at each stage.  The compiler also has the ability to run a single pass given the appropriate inputs.</p>"},{"location":"assignments/1/overview/#textbook-coverage","title":"Textbook coverage","text":"<p>This assignment is based on chapter 2 of Essentials of Compilation.</p>"},{"location":"assignments/1/overview/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, October 13th at 2 AM.</p>"},{"location":"assignments/1/overview/#before-you-begin","title":"Before you begin","text":"<p>Make sure that all the action items from assignment 0 have been completed:</p> <ul> <li>choosing a partner</li> <li>installing OCaml and all the necessary OCaml libraries</li> <li>setting up a GitHub repository and adding the instructor (Mike)   and your grader (one of the TAs) as collaborators 1</li> </ul>"},{"location":"assignments/1/overview/#division-of-labor","title":"Division of labor","text":"<p>These assignments are very much a team effort, and both students will be credited for all work done. We don't want one student to do all the work, though. Learning how to divide the labor is an interesting challenge, and there is more than one right way to do it. Some teams may want to work on the code together (\"pair programming\"), which can be highly effective. Alternatively, you can divide up the passes. Note that each pass can be tested individually.</p> <p>If one team member is more experienced than the other, they may want to tackle the harder passes (which will be identified below). The hardest passes (of which there are none in this assignment!) are the best candidates for collective work.</p>"},{"location":"assignments/1/overview/#submitting-your-assignment","title":"\"Submitting\" your assignment","text":"<p>Unlike most courses, there is nothing to \"hand in\" in this course. Instead, you need to inform the instructor and your TA/grader when an assignment is ready to be graded (hopefully, before or on the due date). The instructor/TA will check out your code, run the tests, and leave comments in a file called GRADE in your <code>ch2</code> directory.</p> <p>After the grading comments have been checked in to your repository, you have one week to make changes (this is the first redo period). Work redone during this period will be re-evaluated without penalty. Any subsequent redos after the first redo will result in reduced credit (typically, any additional marks after the first week will get at most 50% credit).</p>"},{"location":"assignments/1/overview/#code-reviews-office-hours-and-feedback","title":"Code reviews, office hours, and feedback","text":"<p>We will be setting up code review times for each team. Make sure you choose a time where both members of the team can meet as well as the instructor (and/or a TA).</p> <p>Code reviews do not require that all of the code be written, or that all of the code is working correctly, but there is no point in doing a code review unless most of the code has been written. If you are having trouble at an earlier stage, we will have office hour times you can come to.</p>"},{"location":"assignments/1/overview/#textbook","title":"Textbook","text":"<p>This assignment is based on chapter 2 of the course textbook (Essentials of Compilation by Jeremy Siek). Please read this chapter in its entirety before doing this assignment.</p> <p>One obvious and pervasive difference between the textbook and this course is that we are using OCaml to write the compiler, whereas the book uses Racket. Another is that we aren't asking you to write your own test cases, though you are encouraged to do that in addition to the ones we supply if you find it helpful.</p> <p>Also, you'll notice little differences in the way languages are represented. The Racket code has a <code>Prim</code> constructor that we don't use (yet), and an <code>info</code> field that we only use in certain languages. However, for the most part there is a close to 1-to-1 correspondence between the Racket datatypes and the datatypes we define in OCaml. When in doubt, trust the OCaml code.</p> <p>Finally, in the book, there is partial \"skeleton\" code for some of the passes. While the OCaml equivalent is broadly similar, you don't need to have an error case for unhandled cases, because OCaml pattern matching is exhaustive! When skeleton code in Racket is included in the book, you are welcome to use the Racket code as a basis for writing your own OCaml code. (Of course, you'll have to translate the Racket code to OCaml!) Learning Racket is not a requirement for this course, but you should be able to pick up enough of it to understand most of the code examples in the book.</p>"},{"location":"assignments/1/overview/#starting-code-base","title":"Starting code base","text":"<p>The starting code base is in two zip files:</p> <ul> <li><code>src.zip</code></li> <li><code>ch2.zip</code></li> </ul> <p>which are posted on the course Canvas site in the \"Assignment code\" module.</p> <p><code>src.zip</code> is the starting code base for the entire course. You should unzip this file in your Github repo. When unzipped, it will create a <code>src/</code> directory which will eventually contain all of your compiler code for the course. Initially, it just contains the file <code>dune-project</code> (which has to be at the base of any OCaml project that uses the <code>dune</code> compilation manager, as we will do), the <code>.gitignore</code> file (which tells <code>git</code> which files don't need to be under version control), and the <code>support/</code> directory. This directory contains a variety of modules which contain useful functions and data structures. We'll give you suggestions on which functions you should consider using, but you can use any of them at any time.</p> <p><code>ch2.zip</code> is the code base for assignment 1 (the Var language compiler). You should move it into the <code>src/</code> directory and unzip it in that directory. This will create the <code>ch2/</code> directory. Inside this directory will be the <code>.ml</code> and <code>.mli</code> files of the compiler, a few other files (<code>Makefile</code>, <code>dune</code>, <code>utop_init</code>, etc.) whose purposes will be described below, and three subdirectories:</p> <ul> <li> <p><code>tests/</code> \u2014 this contains all the test code   in the source language of the compiler   e.g. <code>var_test_1.src</code>;</p> </li> <li> <p><code>scripts/</code> \u2014 this contains the Python test scripts   that you will use to test your compiler;</p> </li> <li> <p><code>reference/</code> \u2014 this contains the output of the reference   compiler (the instructor's compiler) for each test file   and each pass; this is used for testing   as described later in the assignment.</p> </li> </ul> <p>The name <code>ch2</code> refers to the fact that this code corresponds to the language in chapter 2 of the textbook.</p> <p>In future assignments, we will be giving you a zip file containing only the code which is specific to the new compiler, in a directory called e.g. <code>ch3</code>, <code>ch4</code>, etc.  The <code>support</code> library should not change, (unless there are bugs which need to be fixed).</p> <p>You should check in the entire <code>src</code> directory and all of its subdirectories, including the <code>.gitignore</code> files. However, don't check in the zip files! (You should probably remove them once you don't need them anymore.)</p>"},{"location":"assignments/1/overview/#sanity-checking-the-code-base","title":"Sanity checking the code base","text":"<p>If you've installed the code base correctly, you should be able to do the following:</p> <ol> <li> <p><code>cd</code> into the <code>src/ch2</code> subdirectory.</p> </li> <li> <p>Type <code>make</code>.  This will compile the compiler    (an executable file called <code>compile</code>).    You should see a number of warnings when you compile the compiler;    that's expected.    (As you fill in the code for the compiler passes,    these warnings will go away).</p> </li> <li> <p>You can use the compiler to convert source files in the <code>tests/</code>    subdirectory to their \"Lvar\" AST equivalents.    (\"Lvar\" is the name of the abstract syntax tree (AST) language    for the Var compiler.) For instance:</p> <pre><code>$ ./compile tests/var_test_1.src -pass lvar\n(Program (Int 42))\n</code></pre> <p>Note that the output of the compiler is printed to the terminal. Should you want to save the output to a file, you can redirect it:</p> <pre><code>$ ./compile tests/var_test_1.src -pass lvar &gt; var_test_1.lvar\n$ cat var_test_1.lvar\n(Program (Int 42))\n</code></pre> <p>You can also run the \"Lvar\" evaluator:</p> <pre><code>$ ./compile tests/var_test_1.src -pass lvar -eval\n42\n</code></pre> <p>However, if you try to compile to a pass beyond the AST, it will fail:</p> <pre><code>$ ./compile tests/var_test_1.src -pass un\nTODO\n</code></pre> <p>The <code>TODO</code> is the error message that indicates that some part of the compiler needs to be written.</p> </li> <li> <p>You can also print out the compiler options:</p> <pre><code>$ ./compile --help\n</code></pre> <p>(or just <code>compile</code> with no arguments). This prints out a usage message.</p> </li> </ol> <p>If everything works as we've described, you are ready to start work on the assignment.</p> <p>Note that each assignment's compiler will be different, and there may be different or additional command-line options for each compiler.</p> <ol> <li> <p>This assumes that a grader has been assigned to your team. If not, add the grader to your Github repo as soon as you know who they are.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/passes/","title":"Assignment 1: Compiler passes","text":"<p>This section describes the code you have to write.</p> <p>The compiler passes are described in chapter 2 of the textbook, but they are here again for completeness. We will only include passes that you have to implement. For example, even though the parser can be thought of as a \"pass\", you don't have to implement it, so we don't include it here. Similarly, the \"print assembly\" pass is provided for you, as are all the intermediate languages and interpreters.1</p> <p>Note that the only files you should modify are the files corresponding to these compiler passes.  Also, only modify the <code>.ml</code> files; the <code>.mli</code> files constitute the interface to these modules and must not be changed.</p> <p>In addition, when we provide a function stub in a <code>.ml</code> file that you need to complete, that means that we expect that you will implement that function (with those arguments and types (if supplied)) as written (filling in the <code>TODO</code> parts, of course). In particular, you're not allowed to change the number of arguments to the function, or their types (if supplied). If a function is completely implemented (no <code>TODO</code>s), you should leave it as-is. On the other hand, you can write as many extra functions as you like. (If we don't like your choices, we'll let you know during code reviews!)</p> <p>Note</p> <p>We expect that you will be using the functions we require you to implement! Don't implement a required function and then not use it later. (This would generate a warning anyway.)</p>"},{"location":"assignments/1/passes/#uniquify","title":"Uniquify","text":"<p>[File: <code>uniquify.ml</code>.]</p> <p>In this pass, all names bound in <code>let</code> expressions have to be renamed to be unique.  This enables a number of further transformations in later passes.  Both the input and output languages for this pass are Lvar, defined in the files <code>lvar.ml[i]</code>.</p> <p>This is a relatively simple pass to implement.  There are four cases:</p> <ol> <li> <p>Forms with no subexpressions and no variables.  These pass through     unchanged.</p> </li> <li> <p>Forms with subexpressions but no variables.  You have to recurse     on the subexpressions and build up a new expression.</p> </li> <li> <p><code>Var</code> expressions. You need to change the variable to its new name,     if there is one.     For this, you will have to have a data structure     which maps the old names to the new names.     We recommend that you use the <code>VarMap</code> module     (defined in the <code>Types</code> module i.e. <code>types.ml</code> and <code>types.mli</code>),     which is an instance of the <code>Map</code> functor specialized for the     <code>var</code> type.  (Note that <code>var</code> is just an alias for <code>string</code>.)     A value of type <code>VarMap.t</code> is a map from variable names to some other     type; in this case we map variable names to (new) variable names!</p> <p>Note that the <code>uniquify_exp</code> function doesn't have a <code>VarMap.t</code> argument, so you will need to write a helper function that does. When a <code>Var</code> expression is encountered, check to see if the map has a new name for the variable. If it does, substitute the new name for the old one. Otherwise, leave the name unchanged. (This can happen with some global names.)</p> </li> <li> <p><code>Let</code> expressions.     When these are encountered,     you have to generate a new name from the binding name     of the <code>let</code> expression.     In the expression <code>(let (x 10) (+ x x))</code>, for instance,     <code>x</code> is the binding name.</p> <p>Note</p> <p>In compiler-speak, generated names that are different from all other names are called \"fresh\" names.</p> <p>To generate the new name, call the <code>fresh</code> function (defined in the file) with the current name and a separator as the arguments. Use <code>.</code> as the separator, so <code>x</code> might become e.g. <code>x.1</code>. Note that the <code>fresh</code> function has an internal counter, so the next time it's called with the name <code>x</code> it will return <code>x.2</code>, etc.</p> <p>Note</p> <p>This is imperative programming, and the fact that we don't have to jump through any hoops to do it (as we would, say, in Haskell) is one reason why OCaml is a convenient language for writing a compiler. (Despite this, Haskell is also a great language for writing compilers!)</p> <p>The <code>fresh</code> function is just an alias for the function <code>Utils.gensym</code> from the <code>Utils</code> module in the <code>support</code> library.  Feel free to look at the code for this function if you're interested.  This function also uses OCaml's labelled arguments feature, which we didn't use in CS 4. A good reference for labelled arguments is here.</p> <p>When you generate a fresh name for a binding name, you also have to add it to the map for the body expression of the <code>let</code>, but not for the binding expression of the <code>let</code> (since the new name is not in effect for that expression).</p> <p>Note</p> <p>We very strongly recommend against using hash tables for the map datatype. Hash tables are imperative, and it's much too easy to add something to a hash table that will persist longer than you want it to. In this case, an immutable datatype like <code>VarMap.t</code> is the way to go: when you add something to it, you get a new map, and you can use the new or old maps as you see fit.</p> </li> </ol> <p>You should be able to implement this pass in about 50 lines of code (or less).</p>"},{"location":"assignments/1/passes/#remove-complex-operands","title":"Remove complex operands","text":"<p>[File: <code>remove_complex.ml</code>]</p> <p>The purpose of this pass is simply to make sure that the operands of arithmetic operations are \"simple\" i.e. are not subexpressions but \"atomic\" expressions like integers or variables. The input language to this pass is Lvar and the output language is Lvar_mon, which is defined in the files <code>lvar_mon.ml[i]</code>.</p> <p>Note</p> <p>Terminology: integer literal and variable expressions are simple or atomic expressions.  Any other expression is complex.</p> <p>The name Lvar_mon refers to the fact that the language is in monadic normal form, the details of which do not concern us here.</p> <p>We define an \"atom\" datatype in <code>lvar_mon.mli</code> as follows:</p> <pre><code>type atm = Int of int | Var of var\n</code></pre> <p>and then use it in the expression datatype:</p> <pre><code>type exp =\n| Atm    of atm\n| Read\n| Negate of atm\n| Add    of atm * atm\n| Sub    of atm * atm\n| Let    of var * exp * exp\n</code></pre> <p>The basic thing that has to happen in this pass is that non-atomic subexpressions of arithmetic forms (<code>Add</code>, <code>Sub</code>, and <code>Negate</code>) have to be transformed into <code>let</code> expressions which bind variable(s) to the complex subexpression(s). So it's something like this:</p> <pre><code>Negate &lt;complex exp&gt;\n--&gt; Let (\"$tmp\", &lt;complex exp&gt;, Negate (Var \"$tmp\")\n</code></pre> <p>Clearly, you will need to introduce <code>let</code> expressions wherever there are arithmetic expressions with complex subexpressions.</p> <p>On the other hand, expressions that are already atomic should stay the way they are:</p> <pre><code>Negate (Int 10) --&gt; Negate (Int 10)\nNegate (Var \"x\") --&gt; Negate (Var \"x\")\n</code></pre> <p>Don't do this:</p> <pre><code>Negate (Int 10)\n--&gt; Let (\"$tmp\", Int 10, Negate (Var \"$tmp\"))\nNegate (Var \"x\")\n--&gt; Let (\"$tmp\", Var \"x\", Negate (Var \"$tmp\"))\n</code></pre> <p>This is called \"generating unnecessary temporaries\". Although this doesn't yield incorrect code, it does yield inefficient code. (Why do you think that is?)</p> <p>The key function to write here is <code>rco_atom</code>. This takes an expression which needs to become atomic (like a subexpression of <code>Add</code>, say), and returns both the atomic expression and a list of (name, expression) bindings. In many cases you'll need to generate temporary names; the <code>gen_temp_name</code> function is provided to you for this purpose.</p> <p><code>rco_atom</code> is called from the <code>rco_exp</code> function, and the <code>rco_exp</code> function has to take the (name, expression) pairs and convert them into <code>let</code> expressions. (We wrote a helper function to do this; you will probably want to do the same.)</p> <p>One last thing about this pass: the immediate subexpressions of a <code>let</code> expression (both of them) do not need to be atomic, so don't try to make them atomic! That means that you can have arbitrarily nested <code>let</code> expressions. If this bothers you, don't worry: we'll fix it in the next pass!</p>"},{"location":"assignments/1/passes/#explicate-control","title":"Explicate control","text":"<p>[File: <code>explicate_control.ml</code>]</p> <p>The purpose of this pass is to \"flatten\" the code representation into a sequence of assignment statements followed by a \"return\" statement. The <code>let</code> statements are gone, replaced by assignments. There is no more nesting of expressions, unless you consider the sequence of assignments \"nesting\".</p> <p>The input language to the pass is Lvar_mon and the output language is Cvar, defined in the files <code>cvar.ml[i]</code>. The name Cvar was chosen because the straight-line nature of the code is very similar to the way code is represented in a C language program.</p> <p>The source code consists of five functions:</p> <ul> <li><code>convert_atom</code></li> <li><code>convert_exp</code></li> <li><code>explicate_assign</code></li> <li><code>explicate_tail</code></li> <li><code>explicate_control</code></li> </ul> <p><code>explicate_control</code> is supplied for you. <code>convert_atom</code> and <code>convert_exp</code> are straightforward. <code>explicate_tail</code> converts an expression in tail position, while <code>explicate_assign</code> converts an assignment statement followed by an already-converted tail expression.</p> <p>In both <code>explicate_tail</code> and <code>explicate_assign</code>, the only (slightly) tricky case is the <code>let</code> case. Hint: <code>explicate_tail</code> has to call <code>explicate_assign</code>. The total code is considerably less than 100 lines.</p>"},{"location":"assignments/1/passes/#select-instructions","title":"Select instructions","text":"<p>[File: <code>select_instructions.ml</code>]</p> <p>This is the first of several passes collectively called the \"back end\". Their job is to convert the code into x86-64 assembly language. There are three intermediate languages specific to these passes:</p> <ol> <li> <p>x86var (<code>x86var.ml[i]</code>)</p> <p>This language mixes assembly language instructions with variables.</p> </li> <li> <p>x86int (<code>x86int.ml[i]</code>)</p> <p>This language gets rid of variables.  Variables are represented by stack locations (in this assignment) and by a combination of stack locations and registers (in later assignments).</p> </li> <li> <p>x86asm (<code>x86asm.ml[i]</code>)</p> <p>This language adds extra code (the \"prelude\" and \"conclusion\") necessary to make the entire program into a single unit that can be compiled into a full executable program.2</p> </li> </ol> <p>After x86asm, actual assembly code is trivially generated by the \"print assembly\" pass (<code>print_asm.ml[i]</code>).</p> <p>In the \"select instructions\" pass, code is converted from the Cvar language to the x86var language.</p> <p>The <code>select_instructions.ml</code> file is mostly empty.  You have to implement the <code>convert_lt</code> function, which converts a (label, tail) pair (Cvar language) into a (label, block) pair (x86var language). The labels don't change, so essentially you are changing a Cvar tails into x86var blocks (lists of instructions).  You will want to write helper functions to do this.  (We put ours outside of the <code>convert_lt</code> function; you can do it any way you like.)</p> <p>Quoting from the textbook:</p> <p>We recommend implementing the <code>select_instructions</code> [pass] with three auxiliary functions, one for each of the nonterminals of Cvar: <code>atm</code>, <code>stmt</code>, and <code>tail</code>.</p> <p>The textbook has a good description of how to convert Cvar tails/statements/expressions/atoms into x86var instructions. Note that a single Cvar expression can yield more than one x86var instruction.</p> <p>The <code>Return</code> instruction requires special treatment. You don't actually generate a <code>Retq</code> instruction since this doesn't actually represent returning from a function (we'll see why in the \"prelude and conclusion\" pass below). Instead, you have to do the following:</p> <ol> <li> <p>Convert the expression which is the argument of the <code>Return</code>    and move that result into the <code>Rax</code> register    (this may take one or two instructions, depending on the expression).    Note that a function call (which can only be <code>Read</code> here)    will automatically return its result into the <code>Rax</code> register.</p> </li> <li> <p>Emit a <code>Jmp</code> instruction to a label called <code>conclusion</code>.</p> </li> </ol> <p>There is one other peculiarity of this pass that isn't in the book. We've provided a function called <code>fix_label</code> which should be used whenever calling an external function.  In this case, the only external function is <code>read_int</code>, which is what a <code>Read</code> instruction in Cvar should compile to. So <code>Read</code> becomes <code>Callq (Label \"read_int\", 0)</code>.  (The <code>0</code> is the function arity i.e. the number of arguments the function takes.) However, different operating systems have different conventions for labels. In particular, MacOS requires that function labels have an initial underscore, so you should compile this into <code>Call1 (Label \"_read_int\", 0)</code> if you're on a Mac.  To make the compiler more independent of the OS it's being run on, we've added the <code>fix_label</code> function, which checks to see if the OS is \"MacOS\", and if so, prepends the underscore to the label.  So instead of converting <code>Read</code> to <code>Callq (Label \"read_int\", 0)</code>, convert it to <code>Callq (Label (fix_label \"read_int\"), 0)</code>.3</p> <p>Also, chapter 2 of the textbook (section 2.7) describes ways of optimizing certain instructions. For example, an <code>Add</code> expression/assignment of the form <code>v = (+ a1 a2)</code> can be compiled into two instructions, but if <code>a2</code> is the same as <code>v</code> (i.e. <code>v = (+ a1 v)</code>), it could be compiled into a single <code>addq</code> instruction. This is all well and good, but because of the \"uniquify\" pass earlier in the compiler, this will never happen because <code>v = (+ a1 v)</code> would actually become <code>v1 = (+ a1 v2)</code>. Therefore, you should not write the code to optimize instructions in this way. (This will also reduce the amount of code you need to write.) There is no reason to add code for situations that can't occur and can't be tested. However, you should definitely use as few instructions as possible (in this case, two instructions).</p> <p>Note</p> <p>In later compilers, we will eventually add these optimizations back, because once the language has been sufficiently expanded, these situations can occur.</p>"},{"location":"assignments/1/passes/#assign-homes","title":"Assign homes","text":"<p>[File: <code>assign_homes.ml</code>]</p> <p>The purpose of this pass is to convert variable names into stack locations. Note that in this compiler, we are not storing variables in registers. (In all the later compilers, we will be.)  Therefore, this pass will only exist in this compiler; in later compilers, it will be replaced by several register allocation passes.  Fortunately, assigning variables to stack slots is straightforward.</p> <p>Although this pass converts x86var programs to x86var programs, the resulting programs will not use variables. (We will get rid of variables altogether in the x86int language.) However, the <code>info</code> field of the programs will change; after the \"select instructions\" pass the info field is <code>info1</code>, which stores type information for all variables; after \"assign homes\" it's <code>info2</code>, which only stores the stack space used.</p> <p>Variables placed on the stack are identified by their position in memory relative to the \"base pointer\".   This is a memory location which is stored in a special register called <code>rbp</code> (often written <code>%rbp</code>, though in the OCaml code we refer to it as <code>Rbp</code>).4 The base pointer represents the start of the stack used for a particular function. Variables stored on the stack are identified relative to the base pointer. Stack variables are placed in memory below the base pointer (we say that the stack \"grows downwards\"). Variables are 8 bytes in size (64 bits), so the first variable will be stored 8 bytes below the base pointer. In assembly language, this is written as <code>-8(%rbp)</code>; in the OCaml code we write it as <code>Deref (Rbp, -8)</code>. The next stack location will be <code>-16(%rbp)</code>, and so on. The space used for all the stack variables is known as the \"stack frame\". One curious requirement is that the total amount of space used for the stack frame must be a multiple of 16 bytes, so even if you only need one stack variable (8 bytes), you have to reserve 16 bytes.</p> <p>Here's what you need to do in this pass:</p> <ol> <li> <p>Use the <code>info1</code> field to assign stack locations to all variables    used in the program.  <code>info1</code> contains a list of all variables    in the program as well as their types.    (The types are all <code>Integer</code>, so that isn't relevant    except that you need to know that all integers are 8 bytes long.)    You should store the (variable name, stack location) pairs    as an <code>int VarMap.t</code> (mapping names to their stack locations).    You will also need to compute the total amount of stack space    required.  Since this has to be aligned on a 16 byte boundary,    we've provided a utility function called <code>align_16</code> in the    <code>Utils</code> module of the <code>support</code> library.</p> </li> <li> <p>Once this has been done, you need to go through all the instructions    in the blocks and replace variables with their stack locations.    If you encounter a variable which doesn't have an assigned stack location,    signal an error (this shouldn't happen, but it's good to check).</p> </li> <li> <p>Compute an <code>info2</code> field using the computed stack space,    and reconstitute the program.</p> </li> </ol>"},{"location":"assignments/1/passes/#patch-instructions","title":"Patch instructions","text":"<p>[File: <code>patch_instructions.ml</code>]</p> <p>In a perfect world, we would not need to do this pass. However, the x86-64 instruction set is far from elegant, and we have to deal with its restrictions. One such restriction is that no instruction can have two arguments where both arguments are memory references (as opposed to (say) immediate values or registers). If such instructions exist, they need to be \"patched\" (fixed) so that the restriction is adhered to.</p> <p>There are different ways of handling this, but the textbook suggests a very simple strategy. When you have an instruction that uses two stack locations, convert it into two instructions using the <code>%rax</code> register (OCaml <code>Rax</code>) as an intermediary. There are only three instructions in this compiler where this can happen: <code>addq</code>, <code>subq</code>, and <code>movq</code>. The <code>movq</code> case is the simplest. Change:</p> <pre><code>movq -8(%rbp), -16(%rbp)\n</code></pre> <p>to two instructions:</p> <pre><code>movq -8(%rbp), %rax\nmovq %rax, -16(%rbp)\n</code></pre> <p>This doesn't violate the restriction.  The <code>addq</code> and <code>subq</code> cases are similar but slightly trickier.</p> <p>What you need to do is to go through all instructions, determine if an instruction needs to be patched, and patch it in those cases. Don't match instructions that don't need to be patched! For instance, don't change:</p> <pre><code>movq $42, -8(%rbp)\n</code></pre> <p>into this:</p> <pre><code>movq $42, %rax\nmovq %rax, -8(%rbp)\n</code></pre> <p>because the instruction didn't need to be patched (since there was only one memory reference).</p> <p>Note</p> <p>The <code>$42</code> assembly language syntax means an immediate value; in OCaml we write this as <code>Imm 42</code>.</p> <p>Note also that this pass converts from the x86var language to the x86int language, which doesn't have variables. This means that there will be some trivial \"boilerplate\" conversions, like converting an <code>Imm</code> constructor in one language to the exact same constructor in the other language. This is trivial but a bit tedious. (It's the price we pay for having precise types.)</p>"},{"location":"assignments/1/passes/#prelude-and-conclusion","title":"Prelude and conclusion","text":"<p>[File: <code>prelude_conclusion.ml</code>]</p> <p>This is the last pass you need to write. The textbook also includes a partial evaluator pass as an optional \"challenge\" pass; we won't be doing that.</p> <p>This pass converts from the x86int language to the x86asm language, which is basically x86-64 assembly language, but in an S-expression representation. The actual assembly language is generated by the \"print assembly\" pass, which you don't have to write.</p> <p>The purpose of this pass is to add extra code to make a complete assembly language program. The code that we have been generating so far (whether we were aware of it or not) is the body of the <code>main</code> function. However, in order for this to be a proper function, some code has to be added both before and after the code we've written. The code that is executed before the code we've written is called the \"prelude\", and the code that comes after is called the \"conclusion\". These don't have to come physically before or after our code, since we have <code>jmp</code> instructions to transfer control. Therefore, we put them after our code.</p> <p>The code we've been working with is all in a single block labelled <code>start</code>. The code that comes before this is going to have to jump to this label, and our code is going to have to eventually jump to the label called <code>conclusion</code>. The \"prelude\" is everything that comes before the jump to <code>start</code> and the \"conclusion\" is everything that comes after the jump to <code>conclusion</code>.</p> <p>The actual beginning of execution is the label called <code>main</code> (or <code>_main</code> if you're running on a Mac). We also have to declare <code>main</code> to be a \"global\" name (as all top-level functions have to be) by using the <code>Global</code> instruction. (This becomes <code>.globl</code> in the actual assembly code.) This declaration has to come before the <code>main</code> label, and it's the beginning of the prelude.</p> <p>The prelude does the following:</p> <ol> <li>Declares <code>main</code> as a global name and defines the <code>main</code> label.</li> <li>Saves the previous base pointer (in the <code>%rbp</code> register) to    the stack (using a <code>pushq</code> instruction).</li> <li>Saves the current stack pointer (in the <code>%rsp</code> register)    into the base pointer register <code>%rbp</code>.</li> <li>Reserves space for all the stack variables (a multiple of 16)    by modifying the stack pointer <code>%rsp</code>.</li> <li>Jumps to the <code>start</code> label.</li> </ol> <p>The conclusion does the following:</p> <ol> <li>Reclaims the stack space used in the code.</li> <li>Restores the old base pointer using a <code>popq</code> instruction.</li> <li>Returns from the <code>main</code> function with a <code>retq</code> instruction.</li> </ol> <p>This code is completely generic except for the stack space, which is going to depend on how many variables are placed on the stack. You can look at the examples in the <code>reference</code> directory to see what the prelude and conclusion look like. The code is easy to write, although there are a number of trivial \"boilerplate\" conversions because we are changing the datatype.</p> <ol> <li> <p>The interpreters are not part of the compiler per se, but they are used for testing.\u00a0\u21a9</p> </li> <li> <p>Note that this language is not described in the book; the book simply outputs assembly language as a string.\u00a0\u21a9</p> </li> <li> <p>Aren't compilers fun?  You have to deal with all of this arbitrary nonsense, because otherwise you can't generate working code. That's the price you pay for doing something cool.\u00a0\u21a9</p> </li> <li> <p>Fun fact: There is no absolute requirement to use the <code>%rbp</code> register to store the base pointer.  Many C compilers (e.g. <code>gcc</code>) have an option to omit the base pointer entirely, which frees up this register to be used to store regular variables. This is a big deal for processors with very few registers (like 32 bit x86 processors) but less important for us, since x86-64 processors have 16 registers.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/testing/","title":"Assignment 1: Testing the compiler","text":""},{"location":"assignments/1/testing/#compiling-the-compile-program","title":"Compiling the <code>compile</code> program","text":"<p>To compile the compiler, <code>cd</code> into the <code>src/ch2</code> directory and type <code>make</code>. This will compile the compiler (which is an executable file called <code>compile</code>). You should see a number of warnings when you compile the compiler; that's expected. (As you fill in the code for the compiler passes, these warnings will go away).</p>"},{"location":"assignments/1/testing/#running-the-compile-program","title":"Running the <code>compile</code> program","text":"<p>To run the compiler, type <code>./compile</code> in the <code>ch2</code> directory, along with the path of a file to compile and (optionally) some command-line options. Typing <code>./compile --help</code> (or just <code>./compile</code> with no arguments) will display this usage message (wrapped for readability):</p> <pre><code>usage: compile &lt;filename&gt; [-pass &lt;pass&gt;] [-only] [-eval] [-sexp-width n]\n                          [-sexp-indent n] [-help]\n  -pass Last compiler pass (one of: lvar un rc ec si ah pi pc pa)\n  -only Only do one compiler pass\n  -eval Evaluate after compiling\n  -sexp-width S-expression maximum line width\n  -sexp-indent S-expression indent\n  -help  Display this list of options\n  --help  Display this list of options\n</code></pre> <p>Note that the filename argument is required. (Don't type the <code>&lt;</code> <code>&gt;</code> characters; that's just to indicate that the name <code>filename</code> is a placeholder for the actual filename.) We will describe the command line options below. If there are no command-line options, the file will be compiled all the way to assembly language, and the output will be printed to the terminal. If you want to save the output to a file, you can redirect it with the Unix shell operator <code>&gt;</code> as follows:</p> <pre><code>$ ./compile tests/var_test_1.src &gt; var_test_1.s\n</code></pre> <p>This will save the printed output to a file named <code>var_test_1.s</code>. (This is an appropriate name, since assembly language files conventionally end in <code>.s</code>.) From there, it can be compiled to an executable and run as described below.</p> <p>Here are the command-line arguments for the <code>compile</code> program:</p> <ul> <li><code>-help</code> (or <code>--help</code>, or no arguments).</li> </ul> <p>This prints out a usage message.</p> <ul> <li><code>-pass &lt;pass&gt;</code></li> </ul> <p>This tells the compiler to stop and print the output after the pass   <code>&lt;pass&gt;</code>.  The allowed passes for this compiler are:</p> <ul> <li><code>lvar</code> -- the \"Lvar\" language AST (not technically a pass)</li> <li><code>un</code>   -- the \"uniquify\" pass</li> <li><code>rc</code>   -- the \"remove complex operands\" pass</li> <li><code>ec</code>   -- the \"explicate control\" pass</li> <li><code>si</code>   -- the \"select instructions\" pass</li> <li><code>ah</code>   -- the \"assign homes\" pass</li> <li><code>pi</code>   -- the \"patch instructions\" pass</li> <li><code>pc</code>   -- the \"prelude and conclusion\" pass</li> <li><code>pa</code>   -- the \"print assembly\" pass</li> </ul> <p>The <code>lvar</code> \"pass\" just runs the parser.  This converts the source code   to the <code>Lvar</code> AST form.</p> <ul> <li><code>-only</code></li> </ul> <p>Adding this option causes the compiler to run only the pass specified   by the <code>-pass</code> option.  For this to work, the input file must be   in the correct format, representing an S-expression version   of the datatype that is the input to the pass.   We normally will use the file extensions <code>.un</code>, <code>.rc</code> etc.   to indicate that a file has been compiled up to that pass.</p> <p>This option is normally used with the reference outputs; these provide   outputs of the compiler for all passes and for all test programs.   Each file in the <code>reference/</code> directory contains a file extension   which gives information about the last pass which was used to compile it.   Therefore, you can use this file as input to the next pass.   For instance:</p> <pre><code>$ ./compile reference/var_test_11.rc -pass ec -only\n</code></pre> <p>will compile the file <code>reference/var_test_11.rc</code>   (which has already been compiled up to the \"remove complex operands\" pass)   using only the \"explicate control\" pass (which is the next pass).</p> <p>If you attempt to compile a file this way using the wrong input,   you will get an error message which may be hard to understand.</p> <p>This is a good way to test the code for a single pass, and you can do this   even if the previous passes haven't been written.</p> <ul> <li><code>-eval</code></li> </ul> <p>Adding this option causes the compiler to run an evaluator after compiling.   Note that not all passes have evaluators; only the ones up to <code>ec</code> do.   Also, note that <code>-eval</code> and <code>-only</code> are mutually exclusive.</p> <ul> <li><code>-sexp-width n</code></li> </ul> <p>If the S-expressions printed are too narrow or wide for your taste,   you can adjust it with this option, which sets the width of the   S-expression display in columns.  By default, <code>n</code> is 40.</p> <p>Note that if <code>n</code> is too small, the S-expressions may be spread out over   more lines than you care to view.  Conversely, if it's too large,   too many S-expression forms may be crammed into a single line.</p> <ul> <li><code>-sexp-indent n</code></li> </ul> <p>This allows you to set the degree of indentation for S-expressions.   By default, it's 2.  It's unlikely that you'll want/need to change this.</p>"},{"location":"assignments/1/testing/#compiling-and-running-assembly-language-code","title":"Compiling and running assembly language code","text":"<p>Once you've compiled the source programs all the way down to assembly language, you will probably be wondering how to turn the assembly language into a working executable program. If you have a computer running a 64-bit Intel or AMD processor (which use the x86-64 instruction set),  or a Mac with an M-series processor (e.g. M1, M2) and Rosetta 2 installed, you can compile the assembly language code that the compiler generates.</p> <p>Note</p> <p>So, basically, almost any computer you are likely to have will be able to compile the assembly code you generate.</p> <p>Let's use the <code>var_test_5.src</code> file as an example. You will also need the C code files <code>runtime.c</code> and <code>runtime.h</code>, which should be in your <code>ch2</code> directory.</p> <p>Here is the sequence of commands.  Note that assembly language files normally end in <code>.s</code>, so we redirect the compiler output to the filename <code>var_test_5.s</code> and compile it with the <code>gcc</code> C compiler (which needs to be installed if it isn't already).</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ gcc -c var_test_5.s\n$ gcc -c runtime.c\n$ gcc var_test_5.o runtime.o -o var_test_5\n$ ./var_test_5\n$ echo $?\n42\n</code></pre> <p>Note</p> <p>On an M-series Mac with Rosetta 2 installed, change these commands to:</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ clang -c var_test_5.s -arch x86_64\n$ clang -c runtime.c -arch x86_64\n$ clang var_test_5.o runtime.o -o var_test_5 -arch x86_64\n$ ./var_test_5\n$ echo $?\n42\n</code></pre> <p>This compiles the assembly language file <code>var_test_5.s</code> to the binary executable program <code>var_test_5</code>. When this program is run, it doesn't appear to do anything. However, the program returns an integer return code to the operating system, which in this case is the number 42.  The line <code>echo $?</code> prints this number.</p> <p>Note</p> <p>These return codes can only be in the range 0 to 255, so if you return an integer outside this range, it will be coerced into that range, leading sometimes to peculiar results.</p> <p>If the program you are compiling has calls to the <code>read</code> function, you will have to input the integers to be read when the program runs.</p> <p>The <code>run_eval_tests.py</code> test script handles all of this for you, so there is no need to actually go through these steps, but you should know how to do them anyway.</p>"},{"location":"assignments/1/testing/#testing-your-compiler-the-test-scripts","title":"Testing your compiler: the test scripts","text":"<p>There are three scripts in the <code>ch2/scripts</code> subdirectory. Two of them are for testing, and the third is for visualizing the output (though it's completely optional). All of these are Python scripts. 1</p>"},{"location":"assignments/1/testing/#run_eval_testspy","title":"<code>run_eval_tests.py</code>","text":"<p>This script can be used to test that a particular <code>.src</code> file generates the correct output when given particular inputs. It uses metadata stored in comments in the <code>.src</code> files in the <code>/tests</code> subdirectory. For instance, consider the file <code>var_test_10.src</code>:</p> <pre><code>;; INPUT: 45 3 ; 21 20\n;; OUTPUT: 42 ; 1\n(let (x (read))\n  (let (y (read))\n    (+ x (- y))))\n</code></pre> <p>The metadata is in the first two lines, with the <code>INPUT:</code> and <code>OUTPUT:</code> tags. These indicate that the program should be run twice: the first time with (terminal) inputs <code>45</code> and <code>3</code>, producing the output <code>42</code>, and the second time with (terminal) inputs <code>21</code> and <code>20</code>, producing the output <code>1</code>.</p> <p>You invoke the test script this way:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src\n</code></pre> <p>Note</p> <p>On an M-series Mac, add the command-line argument <code>-arm64</code> to the above command:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src -arm64\n</code></pre> <p>It will output:</p> <pre><code>----\ninput file: var_test_10.src\n\n* input/output data #1:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\nCompiling to assembly language and compiling/running the program.\n\n* input/output data #2:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\nCompiling to assembly language and compiling/running the program.\n</code></pre> <p>This can be done for many files, or even for all tests files at once:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_*.src\n</code></pre> <p>(This will produce a lot of output!)</p> <p>If one of the evaluators produces incorrect output, an error message will be printed and the test script will halt.</p> <p>By default, the test script will not just test the program outputs using the evaluators of the intermediate languages (<code>lvar</code>, <code>lvar_mon</code>, etc.), but will also compile the code all the way to assembly language, run it, and test the output against the expected output.</p>"},{"location":"assignments/1/testing/#comparepy","title":"<code>compare.py</code>","text":"<p>The idea of this test script is to simplify the process of comparing the output of compiling a file using only a single pass with the corresponding output file in the <code>reference/</code> subdirectory. Of course, you can do this yourself manually; for instance, you can do this:</p> <pre><code>$ ./compile reference/var_test_11.rc -pass ec -only &gt; var_test_11.ec\n</code></pre> <p>and compare the file <code>var_test_11.ec</code> that was generated by your compiler to the file <code>reference/var_test_11.ec</code> in the <code>reference/</code> subdirectory. If they are the same, all is well. However, repeating this for a lot of files and a lot of passes is very tedious! Also, you might miss something if you just compare them visually (\"eyeballing it\").  Instead, you can use the <code>diff</code> program to test if the files are different:</p> <pre><code>$ diff var_test_11.ec reference/var_test_11.ec\n</code></pre> <p>If there is no output, the files are identical. If there is any difference, the lines that are different will be printed in a format which shows what's different. But again, doing this for a lot of files is going to be tedious.</p> <p>Note</p> <p>It's important to realize that your output files can have some differences from the reference output files and still be acceptable. For instance, the \"uniquify\" pass is not required to give the exact same names to variables whose names are changed, as long as the names are changed consistently. Nevertheless, if you can make the outputs identical, it will greatly simplify testing.</p> <p>The purpose of the <code>compare.py</code> script is to simplify this process. If you run it with no arguments, you get a usage message:</p> <pre><code>$ python scripts/compare.py\nusage: python compare.py [-pause] [-diff] [-random n] filename [filename ...]\n</code></pre> <p>The required arguments are one or more filenames. These files should be in the <code>reference/</code> subdirectory. The files in that directory have file extensions corresponding to the last compiler pass that was used to generate them, so (for instance) <code>var_test_11.ec</code> is what the compiler output when compiling the file <code>var_test_11.src</code> up to the <code>ec</code> (explicate control) pass. If you want to test your <code>var_test_11.ec</code> against the reference version, you should start with the output of the previous pass, which in this case is <code>var_test_11.rc</code> (the <code>rc</code> or \"remove complex operands\" pass). Since this file is also in the <code>reference/</code> subdirectory, you can use it as the compiler input.  So if you type:</p> <pre><code>$ python scripts/compare.py reference/var_test_11.rc\n</code></pre> <p>the script will:</p> <ul> <li> <p>run <code>./compile reference/var_test_11.rc -pass ec -only</code>   and redirect the output to a file called <code>var_test_11.ec</code>   in the <code>ch2</code> directory;</p> </li> <li> <p>display the files <code>var_test_11.ec</code> (your compiler's output)   and <code>reference/var_test_11.ec</code> (the reference output)   side-by-side so you can compare them visually.</p> </li> </ul> <p>It will look like this:</p> <pre><code>$ python scripts/compare.py reference/var_test_11.rc\n--------------\ninput: reference/var_test_11.rc\noutput: reference/var_test_11.ec\n\n# Student version.                                        # Reference version.\n(CProgram                                                 (CProgram\n  (Info                                                     (Info\n    (locals_types                                             (locals_types\n      ((x.1 Integer)                                            ((x.1 Integer)\n       (x.2 Integer)                                             (x.2 Integer)\n       (y.1 Integer))))                                          (y.1 Integer))))\n  (((Label start)                                           (((Label start)\n    (Seq                                                      (Seq\n      (Assign x.1 (Atm (Int 20)))                               (Assign x.1 (Atm (Int 20)))\n      (Seq                                                      (Seq\n        (Assign x.2 (Atm (Int 22)))                               (Assign x.2 (Atm (Int 22)))\n        (Seq                                                      (Seq\n          (Assign y.1 (Add (Var x.1) (Var x.2)))                    (Assign y.1 (Add (Var x.1) (Var x.2)))\n          (Return (Atm (Var y.1)))))))))                            (Return (Atm (Var y.1)))))))))\n</code></pre> <p>(You can scroll this output horizontally to see it all, but the two files are identical.) If you just want to check if the files are identical, use the <code>-diff</code> option:</p> <pre><code>$ python scripts/compare.py reference/var_test_11.rc -diff\nreference/var_test_11.rc : OK\n</code></pre> <p>If there is no difference, you'll get an <code>OK</code> as you see here.</p> <p>In either case, any generated files are removed before the <code>compare.py</code> script exits.</p> <p>This can be repeated for any number of files:</p> <pre><code>$ python scripts/compare.py reference/var_test_?.rc -diff\nreference/var_test_1.rc : OK\nreference/var_test_2.rc : OK\nreference/var_test_3.rc : OK\nreference/var_test_4.rc : OK\nreference/var_test_5.rc : OK\nreference/var_test_6.rc : OK\nreference/var_test_7.rc : OK\nreference/var_test_8.rc : OK\nreference/var_test_9.rc : OK\n</code></pre> <p>If you do this without the <code>-diff</code> option, though, the output can get very large, and you'll have to scroll back to check each file. To make this easier, we've added a <code>-pause</code> option, which will display one file at a time (both versions: yours and the reference one) and wait for you to hit the return key before the next one is displayed.</p> <p>The last feature is the <code>-random</code> option. It's used with an argument, which should be a positive integer. With <code>-random N</code>, up to <code>N</code> randomly-selected files will be chosen from the list of files on the command line and compared. This is useful to quickly check if a pass is working well; you can type something like this:</p> <pre><code>$ python scripts/compare.py reference/var_test_*.rc -diff -random 10\n</code></pre> <p>and get comparisons of (in this case) 10 random files selected from the files specified on the command line:</p> <pre><code>reference/var_test_4.rc : OK\nreference/var_test_6.rc : OK\nreference/var_test_15.rc : OK\nreference/var_test_27.rc : OK\nreference/var_test_38.rc : OK\nreference/var_test_40.rc : OK\nreference/var_test_57.rc : OK\nreference/var_test_58.rc : OK\nreference/var_test_62.rc : OK\nreference/var_test_67.rc : OK\n</code></pre>"},{"location":"assignments/1/testing/#show_asmpy","title":"<code>show_asm.py</code>","text":"<p>This is a simple utility script whose purpose is to make assembly language instructions in S-expression form easier to read. Let's say you generate code for the \"patch instructions\" pass (say) and get this:</p> <pre><code>(X86Program\n  (Info (stack_space 32))\n  (((Label start)\n    (Block\n      ((Movq (Imm 20) (Deref Rbp -8))\n       (Movq (Imm 22) (Deref Rbp -16))\n       (Movq (Deref Rbp -8) (Reg Rax))\n       (Movq (Reg Rax) (Deref Rbp -24))\n       (Movq (Deref Rbp -16) (Reg Rax))\n       (Addq (Reg Rax) (Deref Rbp -24))\n       (Movq (Deref Rbp -24) (Reg Rax))\n       (Jmp (Label conclusion)))))))\n</code></pre> <p>(This is from the file <code>reference/var_test_11.pi</code>.)</p> <p>Even though this isn't that hard to read, the assembly instructions don't look like real assembly instructions. This can be improved by using the <code>show_asm.py</code> script, which can be invoked like this:</p> <pre><code>$ cat reference/var_test_11.pi | python scripts/show_asm.py\n</code></pre> <p>which will output this: 2</p> <pre><code>(X86Program\n  (Info (stack_space 32))\n  (((Label start)\n    (Block\n      ((movq $20 -8(%rbp))\n       (movq $22 -16(%rbp))\n       (movq -8(%rbp) %rax)\n       (movq %rax -24(%rbp))\n       (movq -16(%rbp) %rax)\n       (addq %rax -24(%rbp))\n       (movq -24(%rbp) %rax)\n       (jmp (Label conclusion)))))))\n</code></pre> <p>Notice that the assembly language instructions look a lot more like real assembly language instructions. Specifically, the immediate integer values are written with the <code>$N</code> notation, registers are written with the <code>%rxy</code> notation that you see in real assembly language, and instructions are uncapitalized. And that's basically all that this script does.</p> <p>You may find that this helps you to \"read\" the output of compiler passes that emit code with assembly instructions. If so, great.  If not, just don't use it.</p> <ol> <li> <p>Since the compiler is written in OCaml, you might wonder why the testing scripts are written in Python. We don't think it's a good idea to get too obsessed with any one programming language. OCaml is a fine language for writing a compiler, but Python is more convenient when working with large numbers of files and calling programs to act on those files. Traditionally, this kind of thing is done with shell scripts, but Python is vastly more powerful and flexible, as well as cross-platform, and all of you already know it.\u00a0\u21a9</p> </li> <li> <p>In case you haven't seen this kind of use of the <code>|</code> character before, this is an example of a Unix \"pipe\". What this does is take the output of the first program (the <code>cat</code> program, which normally just prints the file to the terminal), and passes it to the second program as its input.\u00a0\u21a9</p> </li> </ol>"},{"location":"assignments/1/testing_old/","title":"Assignment 1: Running and testing the compiler","text":""},{"location":"assignments/1/testing_old/#running-the-compile-program","title":"Running the <code>compile</code> program","text":"<p>There are three basic ways to run the compiler (the <code>./compile</code> program):</p> <ol> <li> <p>You can compile a source file up to a particular pass.     For instance:</p> <pre><code>$ ./compile tests/var_test_1.src -pass un\n</code></pre> <p>will compile the code in <code>tests/var_test_1.src</code> up to the \"un\" (uniquify) pass, and print the output to the terminal. The passes for this assignment are:</p> <ol> <li><code>lvar</code> \u2014 AST (not really a pass)</li> <li><code>un</code> \u2014 uniquify</li> <li><code>rc</code> \u2014 remove complex operands</li> <li><code>ec</code> \u2014 explicate control</li> <li><code>si</code> \u2014 select instructions</li> <li><code>ah</code> \u2014 assign homes</li> <li><code>pi</code> \u2014 patch instructions</li> <li><code>pc</code> \u2014 prelude and conclusion</li> <li><code>pa</code> \u2014 print assembly language</li> </ol> <p>If you don't specify a pass, it will assume the pass <code>pa</code>, which means compile all the way to assembly language.</p> </li> <li> <p>You can compile a file up to a particular pass and then run     an evaluator on the resulting code (for some passes).     For instance:</p> <pre><code>$ ./compile tests/var_test_1.src -pass un -eval\n</code></pre> <p>will compile up to the <code>un</code> (uniquify) pass and then evaluate the resulting code.  Not all passes have evaluators; only the following passes do: <code>lvar</code>, <code>un</code>, <code>rc</code>, <code>ec</code>.</p> </li> <li> <p>You can compile a single pass.  This requires that the input file     be in the correct format for that pass.  We normally will use     the file extensions <code>.un</code>, <code>.rc</code> etc. to indicate that a file     has been compiled up to that pass.  For instance:</p> <pre><code>$ ./compile tests/var_test_1.src -pass un &gt; var_test_10.un\n$ cat var_test_10.un\n(Program\n  (Let\n    x.1\n    Read\n    (Let\n      y.1\n      Read\n      (Add (Var x.1) (Negate (Var y.1))))))\n$ ./compile var_test_10.un -pass rc -only\n(Program\n  (Let\n    x.1\n    Read\n    (Let\n      y.1\n      Read\n      (Let\n        $tmp.1\n        (Negate (Var y.1))\n        (Add (Var x.1) (Var $tmp.1))))))\n</code></pre> <p>This is a good way to test the code for a single pass, and you can do this even if the previous passes haven't been written.</p> <p>In the <code>reference/</code> subdirectory you will find the outputs of all the test scripts for all passes.  These can be used for one-pass tests.</p> </li> </ol>"},{"location":"assignments/1/testing_old/#compiling-and-running-assembly-language-code","title":"Compiling and running assembly language code","text":"<p>If you have a computer running a 64-bit Intel or AMD processor (which use the x86-64 instruction set),  or a Mac with an M-series processor (e.g. M1, M2) and Rosetta 2 installed, you can compile the assembly language code that the compiler generates.</p> <p>Let's use the <code>var_test_5.src</code> file as an example. You will also need the C code files <code>runtime.c</code> and <code>runtime.h</code>, which should be in your <code>ch2</code> directory.</p> <p>Here is the sequence of commands.  Note that assembly language files normally end in <code>.s</code>, so we redirect the compiler output to the filename <code>var_test_5.s</code> and compile it with the <code>gcc</code> C compiler (which needs to be installed if it isn't already).</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ gcc -c var_test_5.s\n$ gcc -c runtime.c\n$ gcc var_test_5.o runtime.o -o var_test_5\n$ ./var_test_5\n$ echo $?\n42\n</code></pre> <p>Note</p> <p>On an M-series Mac with Rosetta 2 installed, change these commands to:</p> <pre><code>$ ./compile tests/var_test_5.src &gt; var_test_5.s\n$ clang -c var_test_5.s -arch x86_64\n$ clang -c runtime.c -arch x86_64\n$ clang var_test_5.o runtime.o -o var_test_5 -arch x86_64\n$ ./var_test_5\n$ echo $?\n42\n</code></pre> <p>This compiles the assembly language file <code>var_test_5.s</code> to the binary executable program <code>var_test_5</code>. When this program is run, it doesn't appear to do anything. However, the program returns an integer return code to the operating system, which in this case is the number 42.  The line <code>echo $?</code> prints this number.</p> <p>Note</p> <p>These return codes can only be in the range 0 to 255, so if you return an integer outside this range, it will be coerced into that range, leading sometimes to peculiar results.</p> <p>If the program you are compiling has calls to the <code>read</code> function, you will have to input the integers to be read when the program runs.</p>"},{"location":"assignments/1/testing_old/#testing-the-compiler","title":"Testing the compiler","text":"<p>There are currently two ways to test your compiler, one automated, and one manual.  Both are valuable.</p>"},{"location":"assignments/1/testing_old/#automated-tests","title":"Automated tests","text":"<p>We are supplying you with a test script (written in Python) called <code>run_eval_tests.py</code>. This script can be used to test that a particular <code>.src</code> file generates the correct output when given particular inputs. It uses metadata stored in comments in the <code>.src</code> files in the <code>/tests</code> subdirectory. For instance, consider the file <code>var_test_10.src</code>:</p> <pre><code>;; INPUT: 45 3 ; 21 20\n;; OUTPUT: 42 ; 1\n(let (x (read))\n  (let (y (read))\n    (+ x (- y))))\n</code></pre> <p>The metadata is in the first two lines, with the <code>INPUT:</code> and <code>OUTPUT:</code> tags. These indicate that the program should be run twice: the first time with (terminal) inputs <code>45</code> and <code>3</code>, producing the output <code>42</code>, and the second time with (terminal) inputs <code>21</code> and <code>20</code>, producing the output <code>1</code>.</p> <p>You invoke the test script this way:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src\n</code></pre> <p>Note</p> <p>On an M-series Mac, add the command-line argument <code>-arm64</code> to the above command:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_10.src -arm64\n</code></pre> <p>It will output:</p> <pre><code>----\ninput file: var_test_10.src\n\n* input/output data #1:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\nCompiling to assembly language and compiling/running the program.\n\n* input/output data #2:\n\nRunning test file (tests/var_test_10.src) up to pass (lvar).\nRunning test file (tests/var_test_10.src) up to pass (un).\nRunning test file (tests/var_test_10.src) up to pass (rc).\nRunning test file (tests/var_test_10.src) up to pass (ec).\nCompiling to assembly language and compiling/running the program.\n</code></pre> <p>This can be done for many files, or even for all tests files at once:</p> <pre><code>$ python scripts/run_eval_tests.py tests/var_test_*.src\n</code></pre> <p>(This will produce a lot of output!)</p> <p>If one of the evaluators produces incorrect output, an error message will be printed and the test script will halt.</p> <p>By default, the test script will not just test the program outputs using the evaluators of the intermediate languages (<code>lvar</code>, <code>lvar_mon</code>, etc.), but will also compile the code all the way to assembly language, run it, and test the output against the expected output.</p>"},{"location":"assignments/1/testing_old/#manual-tests","title":"Manual tests","text":"<p>The automated tests are very useful for detecting problems, but to really debug your compiler you will need to look at the output of the compiler for known correct inputs. These tests are tricky to automate, since sometimes you can have more than one correct output for a particular input.</p> <p>As a simple example, the \"uniquify\" pass will change the names of all the variables to unique names, but what those names are isn't important. (The course compiler might rename <code>x</code> to <code>x.1</code> while your compiler might rename <code>x</code> to <code>x.101</code>; as long as the variable is used correctly, this is still fine.)</p> <p>Therefore, when working on a pass, we recommend that you use the files in the <code>reference/</code> subdirectory along with the <code>-only</code> option of the compiler to compare what your pass does to the input code to what the instructor's compiler did. This is what we refer to as \"manual tests\".</p> <p>Let's say you are working on the \"remove complex operands\" pass and you think you have a working implementation.  You can run your compiler on the output of the previous pass (\"uniquify\") and compare to the corresponding file in the <code>reference</code> subdirectory. The output of the <code>uniquify</code> pass will be a file ending in <code>.un</code>.</p> <pre><code>$ cat reference/var_test_10.un\n(Program\n  (Let\n    x.1\n    Read\n    (Let\n      y.1\n      Read\n      (Add (Var x.1) (Negate (Var y.1))))))\n$ ./compile reference/var_test_10.un -pass rc -only\n(Program\n  (Let\n    x.1\n    Read\n    (Let\n      y.1\n      Read\n      (Let\n        $tmp.1\n        (Negate (Var y.1))\n(Add (Var x.1) (Var $tmp.1))))))\n$ cat reference/var_test_10.rc\n(Program\n  (Let\n    x.1\n    Read\n    (Let\n      y.1\n      Read\n      (Let\n        $tmp.1\n        (Negate (Var y.1))\n(Add (Var x.1) (Var $tmp.1))))))\n</code></pre> <p>You can see that the file that your compiler generated is the same as the file the instructor's compiler generated, so everything seems to be working. Of course, some small differences may be found (you might name your temporary variable <code>$temp.1</code> instead of <code>$tmp.1</code>, for instance); this doesn't indicate a mistake.  But if there is a structural difference, something probably went wrong.</p> <p>Note</p> <p>Structural differences do not always indicate incorrect code; in some cases you can transform code in a different way than what we wanted you to do and the resulting code will still evaluate correctly. However, in that case you are not implementing the pass correctly, so in most cases we will still consider this to be an error.</p> <p>A trivial example of this would be a register allocation pass where you just put all variables on the stack instead of in registers. (This is intentional in this assignment, but in most assignments it's not what you are supposed to do.) Though this is \"wrong\", the code will probably still run correctly.</p> <p>Of course, you should test your compiler on more than just one source file. Try to test on as many files as you can for a particular pass. If you know how to write shell scripts, this can be a useful way of making this kind of test semi-automatic (just requiring that you look at the files to check for big differences).</p>"},{"location":"assignments/2/overview/","title":"Assignment 2: Register allocation","text":""},{"location":"assignments/2/overview/#overview","title":"Overview","text":"<p>In this assignment, you will be extending your Var language compiler from the last assignment to do register allocation in the back end instead of putting all variables on the stack.</p>"},{"location":"assignments/2/overview/#textbook-coverage","title":"Textbook coverage","text":"<p>This assignment is based on chapter 3 of Essentials of Compilation.</p>"},{"location":"assignments/2/overview/#due-date","title":"Due date","text":"<p>This assignment is due on Friday, October 27th at 2 AM (so, effectively very late Thursday night).</p>"},{"location":"assignments/2/overview/#starting-code-base","title":"Starting code base","text":"<p>The starting code base is the zipfile <code>ch3.zip</code>, which is posted on the course Canvas site.  You should unzip this file in your Github repo, inside the <code>src/</code> directory.  It contains partial implementations of all code for the assignment.</p> <p>Inside the <code>ch3</code> directory will be these subdirectories:</p> <ul> <li> <p>The <code>tests/</code> subdirectory contains the same test programs   as in the previous assignment.</p> </li> <li> <p>The <code>reference/</code> subdirectory contains the output   from the instructor's version of the compiler.   Note that there are many more files in this directory than in the   previous assignment, for reasons which will be explained below.</p> </li> <li> <p>The <code>scripts/</code> subdirectory contains scripts for testing your code.   These are mostly the same as in the last assignment,   but there are a few additional features, described below.</p> </li> </ul>"},{"location":"assignments/2/overview/#submitting-your-assignment","title":"\"Submitting\" your assignment","text":"<p>The process for \"submitting\" the code is the same as in the previous assignment, except that the code is in the <code>ch3</code> directory, of course.</p>"},{"location":"assignments/2/passes/","title":"Assignment 2: Compiler passes","text":"<p>The compiler passes are described in chapter 3 of the textbook, but here they are again for completeness.  We will only include passes that you have to implement. As before, the only files you should modify are the <code>.ml</code> files corresponding to these compiler passes.</p> <p>In addition, when we provide a function stub in an <code>.ml</code> file that you need to complete, that means that we expect that you will use that function (with those arguments and types (if supplied)) as written (filling in the <code>TODO</code> parts, of course).  In particular, you're not allowed to change the number of arguments to the function, or their types (if supplied).  If a function is completely implemented (no <code>TODO</code>s), you should leave it as-is. On the other hand, you can write as many extra functions as you like. (If we don't like your choices, we'll let you know during code reviews!)</p> <p>Note</p> <p>The one exception to this rule is in the <code>graph_coloring.ml</code> file. We provide function stubs with <code>TODO</code>s as usual, as well as an implementation of the <code>color</code> function that uses those functions, but if you don't like this, you are allowed to completely rewrite the entire module, as long as you end up with a <code>color</code> function with the correct type signature which works correctly.</p>"},{"location":"assignments/2/passes/#passes-that-are-unchanged-from-assignment-1","title":"Passes that are unchanged from assignment 1","text":"<p>Since the focus of this assignment is on register allocation, those passes that come before register allocation do not have to be modified from assignment 1 (in your <code>ch2/</code> directory).  This includes:</p> <ul> <li><code>uniquify.ml</code></li> <li><code>remove_complex.ml</code></li> <li><code>explicate_control.ml</code></li> </ul> <p>Note that you are free to edit your old code, in case you think you have a better way of doing things than what you wrote previously.</p>"},{"location":"assignments/2/passes/#1-select-instructions-select_instructionsml","title":"1. Select instructions (<code>select_instructions.ml</code>)","text":"<p>The \"select instructions\" pass has no fundamental changes, but there are some trivial changes because the <code>X86Program</code> type in <code>x86_var.ml[i]</code> has changed. The new version has different info types for the program and also has block info types.  For this pass, the block info is a placeholder type (containing no information) called <code>binfo1</code>.  Some of the type annotations will need to be changed slightly, and the blocks will all contain a <code>Binfo1</code> constructor. The type checker should point out exactly where your old code needs to be changed.</p>"},{"location":"assignments/2/passes/#2-uncover-live-uncover_liveml","title":"2. Uncover live (<code>uncover_live.ml</code>)","text":"<p>The \"uncover live\" pass has to implement the function <code>uncover_live</code> with this signature:</p> <pre><code>val uncover_live :\n  (X86_var.info1, X86_var.binfo1) X86_var.program -&gt;\n  (X86_var.info1, X86_var.binfo2) X86_var.program\n</code></pre> <p>The <code>X86_var.program</code> type is parameterized on two kinds of \"info\" types: one for the program as a whole (with variants <code>info1</code>, <code>info2</code>, and <code>info3</code>), and one for blocks (with variants <code>binfo1</code> and <code>binfo2</code>). The <code>info1</code> and <code>binfo1</code> types are placeholder types, containing no data. All that this pass does is compute the <code>binfo2</code> value, which contains the liveness information described in the textbook (section 3.2) and in the lectures. The instructions are not changed. The <code>binfo2</code> type has this definition:</p> <pre><code>type live =\n  {\n    initial : LocSet.t;       (* initial live variables/registers *)\n    afters  : LocSet.t list;  (* live vars/regs after each instruction *)\n  }\n\ntype binfo2 = Binfo2 of live\n</code></pre> <p>The liveness data is represented as a list of sets of locations, where a location is a variable, a register, or a stack location. Sets of locations are represented by the type <code>LocSet.t</code>. Since liveness sets apply between instructions, we use the <code>initial</code> field to represent the initial set of live locations, and the <code>afters</code> field represents, for each instruction, the set of live locations after that instruction.</p> <p>Note</p> <p>In principle, we could have added the liveness data directly to the instructions, but we prefer to keep it separate, partly because it's only used in this pass. It's important to be aware that there is a one-to-one correspondence between the instructions in the program and the <code>after</code> sets of the <code>live</code> record: the Nth item in the <code>after</code> sets is the after set for the Nth instruction in the program.</p> <p>We provide an implementation for the <code>uncover_live</code> function, which calls the function <code>uncover_live_in_block</code> to compute the liveness sets.  You have to implement that function. The inputs to that function are the list of instructions in the block, and <code>live_before_labels</code>, which is a map between block names and the live locations before that block executes. Here, there is only one such block: <code>conclusion</code>, with live locations (registers) <code>%rax</code> and <code>%rsp</code>.</p> <p>You can implement <code>uncover_live_in_block</code> as you like (as long as it's functional \u2014 don't use mutation!) but we recommend that you define a helper function to compute the liveness set for a single instruction given the instruction and its live-after set.</p> <p>Also, be aware that <code>callq</code> instructions require special handling. First, executing a <code>callq</code> instruction can result in any of the caller-saved registers being overwritten. There is a list of caller-saved registers in the <code>Types</code> module as <code>caller_saved_regs</code>; don't hard-code the caller-saved registers! Second, <code>callq</code> instructions with arity (number of arguments) greater than 0 have to read from registers for the first 6 arguments. These registers are given in the <code>Types</code> module as <code>arg_passing_regs</code>; these arguments are (in order) <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code> (all of which are caller-saved registers, which should make sense). We recommend that you write a helper function to determine the change in the liveness set just for <code>callq</code> instructions, incorporating all of this information.</p> <p>The algorithm for computing liveness sets is described in detail in section 3.2 of the textbook and in the lectures.</p>"},{"location":"assignments/2/passes/#3-build-interference-graph-build_interferenceml","title":"3. Build interference graph (<code>build_interference.ml</code>)","text":"<p>The \"build interference\" pass has to implement the function <code>build_interference</code> with this signature:</p> <pre><code>val build_interference :\n  (X86_var.info1, X86_var.binfo2) X86_var.program -&gt;\n  (X86_var.info2, X86_var.binfo1) X86_var.program\n</code></pre> <p>From this, we can see that the block info <code>binfo2</code> value (containing the liveness data) goes back to the placeholder <code>binfo1</code> type, but the program info <code>info1</code> value (containing nothing but the types of variables) gets extended into the <code>info2</code> type, which has this definition:</p> <pre><code>type info2 = Info2 of\n  {\n    locals_types : (var * ty) list;\n    conflicts    : LocUgraph.t\n  }\n</code></pre> <p>What this does is add the interference graph information (as the <code>conflicts</code> field) to the program.</p> <p>Note</p> <p>You might wonder why the liveness data is stored in a block info type while the interference graph is stored in a program info type. The liveness data is stored in a block-by-block manner, while there is only one interference graph per function. (Here, our programs are a single <code>main</code> function.) Note that most functions will have multiple blocks. Ours also do (the <code>start</code> block plus the prelude and conclusion) but we don't have to compute the liveness data for the prelude and conclusion because they are so simple. In later compilers, our programs will have many more blocks to handle conditionals, loops and user-defined functions.</p> <p>We supplied an implementation of the <code>build_interference</code> function which calls the <code>make_graph</code> function to compute the interference graph. You need to implement <code>make_graph</code>, following the algorithm given in section 3.3 of the textbook and in the lectures. You'll almost certainly want to split this function up into multiple helper functions. Pay particular attention to <code>movq</code> and <code>callq</code> instructions; remember that for <code>callq</code> you need to create an edge between all the locations in the live-after set and all caller-save registers.</p> <p>Note</p> <p>This is unrelated to the handling of caller-save registers in liveness analysis, which normally does nothing but is included for completeness.  Here, creating the edges between call-live variables and caller-save registers is extremely important, because it prevents call-live variables from being placed into caller-save registers, where they would have to be saved and restored before and after the call.  Thus, they will normally be put into callee-save registers, unless there are none available, in which case they will be placed onto the stack.  The register allocation algorithms handle all of this automatically!</p>"},{"location":"assignments/2/passes/#4-graph-coloring-graph_coloringml","title":"4. Graph coloring (<code>graph_coloring.ml</code>)","text":"<p>This module is not technically a compiler pass, but it's an integral part of the \"allocate registers\" pass.  However, the algorithm is more general, and the implementation is not specialized to locations (registers, variables and stack locations) until the <code>GraphColor</code> functor (defined in this module) is specialized to locations in <code>allocate_registers.ml</code>.  The algorithm is described in some detail in section 3.4 of the textbook as well as in the lectures.</p> <p>The <code>GraphColor</code> functor is parameterized on several modules:</p> <ul> <li> <p>the graph element type (which will be locations in <code>allocate_registers.ml</code>)</p> </li> <li> <p>the element map type (made from the <code>MapS</code> functor,   which is just an extension of the normal OCaml <code>Map</code> functor;   note that <code>MapS</code> is defined in <code>support/functors.ml[i]</code>)</p> </li> <li> <p>a priority queue module   (we use the priority queue defined in <code>support/priority_queue.ml[i]</code>)</p> </li> <li> <p>an undirected graph module (the interference graph)</p> </li> </ul> <p>The functor is instantiated in <code>allocate_registers.ml</code>, so you don't have to worry about how to do that.  Inside the functor, a type <code>node</code> is defined that contains information about the elements (locations) which isn't stored in the interference graph, and that changes as the algorithm progresses. The two components of a <code>node</code> are the color of the element (an <code>int option</code>, since the element is initially uncolored), and the saturation set (a set of integers, representing the colors that the element is not allowed to have).  As the algorithm progresses, the colors (which mostly start as <code>None</code>) get filled in, and the saturation sets increase in size, which constrains the color choices.</p> <p>We define a <code>nodemap</code> type which is a map between elements and <code>node</code>s. We also provide a debugging function called <code>_print_nodemap</code> which can print out the nodemap at any point in the algorithm to help debugging.</p> <p>Note</p> <p>The name is <code>_print_nodemap</code> instead of <code>print_nodemap</code> because it isn't exported from the functor, and OCaml issues a warning about unused functions if their names don't start with an underscore.</p> <p>The only function that needs to be implemented is the <code>color</code> function, which takes an interference graph and a map of precolored elements (an element-to-<code>int</code> map) as its arguments. Recall that the only precolored elements we are using are the reserved registers, which are <code>%rax</code> (color <code>-1</code>), and <code>%rsp</code> (color <code>-2</code>).  The return value of the function is the full element-to-<code>int</code> map, containing color assignments for all variables.</p> <p>Because this is a somewhat tricky algorithm, we've provided you with a starting point. We've given our version of the <code>color</code> function, which calls a number of helper functions. You may choose to simply implement all the helper functions in <code>graph_coloring.ml</code>. Or, if you would prefer to implement the <code>color</code> function from scratch, you are free to delete any or all of our helper functions and rewrite the <code>color</code> function accordingly.</p> <p>Note</p> <p>The only restriction we'll insist on is that your code for this module should be purely functional. Don't use <code>ref</code> cells or any other imperative features. In a real-world setting, you might choose to use imperative code for efficiency or convenience, but it's definitely not necessary. Also, functional code is easier to get right.</p> <p>The total amount of code you need to write is less than 100 extra lines.</p>"},{"location":"assignments/2/passes/#testing-the-graph-coloring-algorithm","title":"Testing the graph coloring algorithm","text":"<p>There is a very trivial test script for the graph coloring algorithm only in the file <code>test_graph_coloring.ml</code>. You can run in in the interactive interpreter as follows:</p> <pre><code>$ make repl\n# #use \"test_graph_coloring.ml\";;\n</code></pre> <p>This will run the test and print <code>TEST PASSED!</code> if it passes or <code>TEST FAILED!</code> if not. More importantly, since this is done interactively, you can inspect the results of graph coloring to see how they differed from the expected results. The example given is the same one given in the book and in the lectures.</p>"},{"location":"assignments/2/passes/#5-allocate-registers-allocate_registersml","title":"5. Allocate registers (<code>allocate_registers.ml</code>)","text":"<p>Once you've implemented the graph coloring algorithm, the \"allocate registers\" pass is simple.  You need to do these things:</p> <ol> <li> <p>Run the graph coloring algorithm and assign registers    (or, if there are no available registers, stack locations)    to all variables.    This is done in the functions <code>get_variable_location_map</code>,    which is supplied to you, and <code>varmap_of_colormap</code>,    which you need to fill in.    Your implementation of <code>varmap_of_colormap</code>    should use the helper function <code>location_of_color</code>,    which you also need to fill in.</p> </li> <li> <p>Use the mapping between variable bindings and locations    (registers or stack locations)    to determine the number of stack slots needed.    This is done in the function <code>get_num_spilled</code>,    which you need to fill in.    Be careful that you don't count a stack location more than once!</p> </li> <li> <p>Use the same mapping between variable bindings and locations    to collect a set of all the callee-save registers    used in the program.    This is done in the function <code>get_used_callee</code>,    which you need to fill in.</p> </li> <li> <p>Convert all the instructions that use variables    to use the corresponding registers or stack locations.    This is done in the function <code>convert_block</code>,    which you need to fill in.    You'll probably want to define some helper functions    in your implementation of this function.</p> </li> </ol> <p>All the other code for this pass has been supplied. In particular, code for selecting which registers are available (based ultimately on the command-line arguments to the <code>compile</code> program) is supplied and should not be altered.</p>"},{"location":"assignments/2/passes/#6-patch-instructions-patch_instructionsml","title":"6. Patch instructions (<code>patch_instructions.ml</code>)","text":"<p>Aside from trivial type changes, the only significant change in this pass is that instructions of the form <code>Movq (x, x)</code> (moving a value from a location to the same location) are removed.</p>"},{"location":"assignments/2/passes/#7-prelude-and-conclusion-prelude_conclusionml","title":"7. Prelude and conclusion (<code>prelude_conclusion.ml</code>)","text":"<p>This pass has a few changes from the corresponding pass in the last assignment.</p> <p>The <code>info</code> record type attached to the <code>program</code> type in <code>x86_int.mli</code> has these fields:</p> <pre><code>locals_types : (var * ty) list;\nnum_spilled  : int;\nused_callee  : RegSet.t\n</code></pre> <p>We won't be concerned with <code>locals_types</code>, but the other two are relevant to generating a correct prelude and conclusion. <code>num_spilled</code> is the number of stack slots needed for variables that were not placed in registers. <code>used_callee</code> are the names of the callee-save registers that are used in the program.</p> <p>Recall that the program is one big function (the <code>main</code> function), and so the values of any callee-saved variables that are used inside this function must be saved in the prelude and restored in the conclusion. They will be saved to the stack and restored from the stack. Therefore, the total number of stack slots needed can be more than <code>num_spilled</code>; it's actually <code>num_spilled</code> plus the number of callee-save registers used. And to make it even more confusing, the size of the stack frame (the total amount of stack space reserved for the function) must be a multiple of 16 bytes, so it can be even bigger!</p> <p>Fortunately, we have defined a function called <code>align_16</code> in the <code>Utils</code> module of the <code>support</code> directory.  This will take a non-negative integer and round it up to the nearest multiple of 16. So the total stack space required is actually (in pseudocode):</p> <pre><code>stack_space = align_16(8 * (num_spilled * size(used_callees)))\n</code></pre> <p>However, it's still a bit more complicated than this. We will be saving the callee-save registers by pushing them to the stack with the <code>pushq</code> instruction, and restoring them with the <code>popq</code> instruction. The <code>pushq</code> instruction subtracts 8 bytes from the stack pointer, and the <code>popq</code> adds it back. The effect of this is that, after all the callee-save registers have been pushed to the stack using <code>pushq</code> instructions, we've already allocated a big chunk of the total stack space required. The additional stack space we need to allocate can be computed from these equations (in pseudocode):</p> <pre><code>n_callees = size(used_callees)\nextra_stack_space = align_16 (8 * (num_spilled + n_callees)) - 8 * n_callees\n</code></pre> <p>This is already computed for you in the <code>prelude_conclusion</code> function.</p> <p>From here, you have to do two things:</p> <ol> <li> <p>Compute the prelude and conclusion    (collectively called the \"epilog\" in the code because we place it    after the code in the <code>start</code> block).    This is done in the <code>epilog</code> function which takes the    set of callee-save registers and the amount of extra stack space needed    as arguments.</p> </li> <li> <p>Adjust all instructions in the <code>start</code> block that access stack locations,    because the callee-save registers on the stack use up space    at the beginning of the stack frame,    which means that any stack location access    which is relative to the base pointer in <code>%rbp</code>    has to be changed to account for this extra space.    This is done in the <code>asm_of_lb</code> function,    which takes a labelled block (the <code>start</code> block, in this case)    and the amount of space that stack locations need to be shifted by    (called <code>deref_adjust</code>)    as its arguments.  You'll probably want to define helper functions    to write this function, as (we hope) you did in the last assignment.</p> </li> </ol> <p>The <code>prelude_conclusion</code> function appends the epilog to the <code>start</code> block code to generate the final program.</p> <p>Here are a couple of notes about the functions you need to write.</p> <ol> <li> <p>For <code>asm_of_lb</code>, all you need to do is go through all instructions,    changing any stack location accesses    by subtracting the <code>deref_adjust</code> value.</p> </li> <li> <p>For <code>epilog</code>, after you've established the base pointer in the prelude,    you need to push the callee-save register values onto the stack, and then    adjust the stack pointer by subtracting the extra space needed for    the stack-resident variables before jumping to the <code>start</code> block.    (Recall that the stack grows downwards,    so subtracting from the stack pointer reserves stack space.)    In the conclusion, you have to add the extra space for the stack-resident    variables back to the stack (reclaiming the stack space),    and then pop the callee-save register values back to their registers    before resetting the base pointer and returning.    Make sure that you pop the callee-save registers in reverse order    to the order in which you pushed them!    (Remember, the stack is a last-in, first out (LIFO) data structure.)    Also, only push and pop the callee-save registers you actually used;    if your program didn't use any,    you don't have to do any pushing and popping.</p> </li> </ol> <p>This sounds much more complicated than it is! This pass is really just a little bit of (somewhat annoying) bookkeeping.</p>"},{"location":"assignments/2/testing/","title":"Assignment 2: Testing the compiler","text":""},{"location":"assignments/2/testing/#compiling-the-compile-program","title":"Compiling the <code>compile</code> program","text":"<p>To compile the compiler, <code>cd</code> into the <code>src/ch3</code> directory and type <code>make</code>. This will compile the compiler (which is an executable file called <code>compile</code>). You should see a number of warnings when you compile the compiler; that's expected. (As you fill in the code for the compiler passes, these warnings will go away).</p>"},{"location":"assignments/2/testing/#running-the-compile-program","title":"Running the <code>compile</code> program","text":"<p>To run the compiler, type <code>./compile</code> in the <code>ch3</code> directory, along with the path of a file to compile and (optionally) some command-line options. Most of this is the same as it was in the last assignment.</p> <p>Typing <code>./compile --help</code> (or just <code>./compile</code> with no arguments) will display this usage message (wrapped for readability):</p> <pre><code>usage: compile &lt;filename&gt; [-pass &lt;pass&gt;] [-only] [-eval] [-sexp-width n]\n                          [-sexp-indent n] [-regs reg1,reg2,...] [-help]\n  -pass Last compiler pass (one of: lvar un rc ec si ul bi ar pi pc pa)\n  -only Only do one compiler pass\n  -eval Evaluate after compiling\n  -sexp-width S-expression maximum line width\n  -sexp-indent S-expression indent\n  -regs Registers to use\n  -help  Display this list of options\n  --help  Display this list of options\n</code></pre> <p>This is the same as the <code>compile</code> usage message from the previous assignment, except that there is a new command-line option:</p> <ul> <li><code>-regs reg1,reg2,...</code></li> </ul> <p>This is a new feature of the compiler, starting with this assignment   and continuing through all the subsequent ones.   It allows you to select which registers can be used for register allocation.   If this option is not used, all registers (other than the reserved ones)   can be used.   This is extremely useful for checking for whether variables get spilled   to the stack correctly once there are no more registers available,   and for whether callee-saved registers are handled correctly   in the preludes and conclusions of functions.</p> <p>The test scripts use this option in these ways:</p> <ul> <li>unused -- use all avaiable registers</li> <li><code>-regs rcx</code> -- only use the <code>%rcx</code> register (caller-saved)</li> <li><code>-regs rbx</code> -- only use the <code>%rbx</code> register (callee-saved)</li> <li><code>-regs rcx,rbx</code> -- only use the <code>%rcx</code> and <code>%rbx</code> registers</li> </ul>"},{"location":"assignments/2/testing/#testing-your-compiler-the-test-scripts","title":"Testing your compiler: the test scripts","text":"<p>The test scripts are the same as those described in the previous assignment, except that the test scripts will also use the <code>-regs</code> command-line option as described above.</p>"},{"location":"intro/language/","title":"Implementation language","text":"<p>In principle, any programming language can be used to write a compiler. Many compiled languages, after \"bootstrapping\" their compiler from another language, then rewrite the compiler in the language being compiled (this is called \"self-hosting\").  Self-hosting serves as a test of the power of the language (any language that is powerful enough to write its own compiler has to be pretty powerful) and allows the language developers to only use the new language in later development (often called \"eating one's own dog food\").</p> <p>In this course, we will use the OCaml programming language exclusively. Out of all the possible choices of programming language, why did we choose this comparatively obscure language for writing our compilers?</p> <p>Part of the reason is subjective: we like OCaml as a language, we are very familiar with it, and we find that it occupies a useful \"sweet spot\" between lower-level languages like C, Java and Python and very high-level languages like Haskell.  Its functional programming support is useful in reducing code duplication, and its impurity means that you can also use imperative code when it's desirable to do so.</p> <p>The main reason, though, is that OCaml is a language which is superbly well-adapted to the task of writing a compiler.1 Features that are particularly helpful include:</p> <ul> <li> <p>Very strong static type checking.   Compilers are large, complicated and subtle programs,   and we need all the help we can get in preventing and tracking down errors.   OCaml's type checking is extremely stringent,   to the point that if a program compiles at all,   there is a very good chance that it will run correctly.   More importantly, type checking rules out almost all trivial errors.</p> </li> <li> <p>Algebraic datatypes.  These map almost perfectly to the structure of a   compiler's various intermediate languages, and provide an extremely   lightweight way to specify new datatypes.</p> </li> <li> <p>Garbage collection.  Compilers are complicated enough without having   to worry about memory leaks from manual memory management.</p> </li> <li> <p>A fast compiler.  Waiting for your compiler to compile isn't fun, and our   compilers will compile almost instantaneously.</p> </li> <li> <p>An excellent build system.   The dune build system   makes compiling OCaml projects nearly effortless.</p> </li> <li> <p>An excellent package manager.   The opam package manager   makes installing new packages completely painless.</p> </li> <li> <p>Excellent serialization. OCaml has the facility   (not built-in, but provided by libraries)   to convert any complex datatype to an \"S-expression\"   (a simple and readable serialization format).   Since compilers consist of a series of code transformations,   being able to easily view the output of each transformation   is incredibly useful for debugging.</p> </li> </ul> <p>There are other useful features of OCaml we will encounter as we proceed.</p> <p>One indication of how useful OCaml is as a language for writing compilers is to consider which languages' compilers and other language-related tools were originally written in OCaml.2 These include:</p> <ul> <li> <p>the Rust language compiler</p> </li> <li> <p>the Hack language compiler   (a statically-typed PHP dialect from Facebook)</p> </li> <li> <p>the Flow   static analyzer for Javascript from Facebook</p> </li> <li> <p>the Infer   static analyzer for Java/C/C++/Objective-C from Facebook</p> </li> <li> <p>the pyre-check   static analyzer for Python from Facebook</p> </li> <li> <p>ReasonML,   an alternative syntax for OCaml which compiles to Javascript   (also from Facebook!)</p> </li> <li> <p>Frama-C,   a static analysis framework for the C language</p> </li> <li> <p>The WebAssembly language   reference implementation   (WebAssembly is a low-level language for running code in a web browser) 3</p> </li> <li> <p>the Coq proof assistant   (take CS 128 to learn all about Coq)</p> </li> </ul> <p>and no doubt many more.  OCaml is an excellent tool for building language-related tools, including compilers.</p> <ol> <li> <p>Jason Hickey, the last person to teach compilers at Caltech before this course, referred to OCaml as \"a near-perfect language for writing a compiler\".\u00a0\u21a9</p> </li> <li> <p>In some of these cases, the compiler was eventually rewritten in the language being compiled, so that the language could be self-hosted.\u00a0\u21a9</p> </li> <li> <p>Technically, the WebAssembly implementation is a reference interpreter, which is a language evaluator/runtime instead of a compiler, but it still illustrates the usefulness of OCaml for language implementations.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/welcome/","title":"Welcome to CS 164!","text":"<p>This course is called Compilers, and is a course on implementing compilers, which are programs which convert program source code to code that can run directly on a computer. Compilers are a tremendously interesting and fun topic, and can teach you a great deal about programming and about how computers work. We hope you enjoy this subject as much as we do!</p> <p>This book serves as the official course notes, so that lectures are less of a brain dump of details and more an opportunity to interactively go through course topics, answer questions, and get you thinking about compilers. In addition, we will be posting most of the course-related content in these pages, including:</p> <ul> <li>the course syllabus   (which you should read as soon as possible!)</li> <li>administrative details</li> <li>instructions on how to set up your computer with the course software</li> <li>assignments</li> <li>coding notes and tips</li> </ul> <p>and anything else we consider useful.</p> <p>Your feedback on these notes will be very helpful to us in improving them, so please let us know if anything is hard to understand or if something that should be here isn't.</p> <p>Course-related material we won't post here includes:</p> <ul> <li>the PDF of the textbook</li> <li>lecture slides</li> <li>assignment code zip files</li> <li>some administrative information</li> </ul> <p>These will be posted on the course Canvas page in the Modules section.</p>"},{"location":"ocaml/install/","title":"Installing OCaml","text":"<p>Here are the steps you should go through to install OCaml on your computer. You should install the latest OCaml version, which as of this writing is version 5.1.0.</p>"},{"location":"ocaml/install/#install-ocaml-and-opam","title":"Install OCaml and <code>opam</code>","text":"<p>See the instructions on the OCaml website. Note that <code>opam</code> is the OCaml package manager, which needs to be installed in order to install critical libraries.</p>"},{"location":"ocaml/install/#macos","title":"MacOS","text":"<p>The instructions for MacOS refer to the Homebrew package manager, which needs to be installed first. Follow the instructions on the Homebrew website to install it.</p> <p>Note</p> <p>Don't use the MacPorts package manager.  Use Homebrew. (Trust us.)</p>"},{"location":"ocaml/install/#linux","title":"Linux","text":"<p>If you are using Linux, you should install OCaml using your distribution's package manager. The instructions linked to above contain more details. For example, for Ubuntu Linux the commands are</p> <pre><code>$ sudo apt update\n$ sudo apt install opam\n</code></pre> <p>The <code>sudo</code> is so you don't have to install the software as the root user. You may be asked to enter your password, which you should do.</p>"},{"location":"ocaml/install/#windows","title":"Windows","text":"<p>If you are using Windows, you should install an Ubuntu Linux system inside of Windows using the Windows Subsystem for Linux, also known as \"WSL\". Then you can use <code>apt</code> like on any Ubuntu Linux system.</p> <p>It's possible to install OCaml directly on Windows, but it's probably not worth the trouble. WSL is a much easier solution, and it will work fine with external editors like VS Code (discussed below). This course does not support OCaml directly on Windows, because we assume a Unix-like environment (<code>Makefile</code>s etc.) for much of our tooling.</p>"},{"location":"ocaml/install/#initialization","title":"Initialization","text":"<p>Once you have a version of OCaml and <code>opam</code> installed, you need to set it up, and, if necessary, upgrade the versions. Start up your terminal program and go through the following steps.</p> <ul> <li> <p>Initialize <code>opam</code> by typing <code>opam init</code> in a terminal and following the   instructions.</p> <p>Note</p> <p>There is an issue with initializing <code>opam</code> inside of WSL (Windows Subsystem for Linux). Basically, due to the way WSL works, you have to initialize <code>opam</code> differently by disabling sandboxing.  This theoretically can cause some problems if a package does something really stupid, but it probably won't. The fix is to use this command instead of just <code>opam init</code>::</p> <pre><code>$ opam init --disable-sandboxing\n</code></pre> </li> </ul> <ul> <li> <p>At the end of the <code>opam init</code> command,   it will ask you to run <code>eval ${opam env}</code>.   (Or it might say <code>eval ${opam config env}</code> or something similar.   It all does the same thing.)   This sets up the <code>PATH</code> variable of your shell   to point to the <code>opam</code> directories.   This is important, because if you don't do this,   adding new packages (and new OCaml versions) will not work.   Opam will also ask you if it can change your shell initialization file   (e.g. <code>~/.bashrc</code> for <code>bash</code>)   by adding some commands.   You should say yes, because if you don't,   every time you start up a new terminal   you will have to type <code>eval ${opam env}</code>   to get <code>opam</code> to work correctly.</p> </li> <li> <p>In your terminal, type</p> <pre><code>$ opam update\n$ opam upgrade\n</code></pre> <p>to make sure the package repository is up to date and all OCaml packages have been upgraded to the most recent versions.</p> </li> <li> <p>Check the OCaml version by typing <code>ocaml --version</code>.   If it's the most current version   (which is 5.1.0 as of this writing)   you are done with this part.   Otherwise do <code>opam switch create 5.1.0</code>   and wait for the new version to be installed.   (This will take a while.)</p> </li> <li> <p>Install these libraries::</p> <pre><code>$ opam install ocamlfind dune utop sexplib ppx_sexp_conv ocaml-lsp-server\n</code></pre> </li> </ul> <p>Note particularly the <code>utop</code> library,   which installs the <code>utop</code> program.   <code>utop</code> is an improved version of the <code>ocaml</code> interpreter,   and you should use it instead of <code>ocaml</code> when testing code interactively.</p> <p>The <code>ocaml-lsp-server</code> library is important   if you want to use Visual Studio Code as your editor (see below).</p>"},{"location":"ocaml/install/#using-ocaml","title":"Using OCaml","text":"<p>There are only a few things you need to know in order to use OCaml effectively.</p>"},{"location":"ocaml/install/#starting-ocaml","title":"Starting OCaml","text":"<p>You can start OCaml by opening a terminal and typing:</p> <pre><code>$ utop\n</code></pre> <p>at the terminal prompt. This will bring up the OCaml interactive interpreter, which is a good environment for experimenting with the language and for testing code you've written.</p> <p>Note</p> <p>You can also use <code>ocaml</code> instead of <code>utop</code>, but <code>utop</code> is much more full-featured.</p> <p><code>utop</code> makes it possible to easily recall and edit previously-input lines of text by using the up and down arrow keys. To see what it can do, start it up</p> <pre><code>$ utop\n</code></pre> <p>and type the following commands (one per line, hitting the return key at the end of each line):</p> <pre><code># Printf.printf \"hello\\n\" ;;\n# Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>Note that the OCaml interpreter prompt is the hash sign (<code>#</code>); don't type that!  These lines should, when evaluated, print the words <code>hello</code> and <code>goodbye</code> respectively.  Once you've done this, you should be able to recall either line by using the up arrow key.  For instance, you can hit the up arrow key once to get the line:</p> <pre><code>Printf.printf \"goodbye\\n\" ;;\n</code></pre> <p>and edit it so that it says:</p> <pre><code>Printf.printf \"adios\\n\" ;;\n</code></pre> <p>When you hit return, it should print out <code>adios</code> on a separate line. You can also use control-a to get to the beginning of a line you are editing and control-e to get to the end. control-l (lower-case L) clears the terminal and puts the cursor at the top of the terminal window.</p> <p>One annoying thing about <code>utop</code> is that it tends to go overboard on command completion.  You can disable this by typing this inside <code>utop</code>:</p> <pre><code># #utop_prompt_dummy;;\n# UTop.set_show_box false;;\n</code></pre> <p>It's annoying to type this every time you start <code>utop</code>, so what I do is make a <code>utop</code> initialization file called <code>init.ml</code> and put it in the directory <code>~/.config/utop</code> (creating that directory if necessary). Then these commands will be run every time <code>utop</code> starts.</p> <p>Note</p> <p>Unfortunately, this will not work properly if used in a directory that has a <code>.ocamlinit</code> file in it (usually your home directory).  There are workarounds, but most of the time it will work properly.  Other than that, <code>utop</code> is far superior to the basic <code>ocaml</code> interpreter.</p>"},{"location":"ocaml/install/#using-visual-studio-code","title":"Using Visual Studio Code","text":"<p>You can use any text editor you like to write OCaml code, but we recommend you try Visual Studio Code (also known as VS Code), which has excellent OCaml support. In order to use it, you need to do the following steps:</p> <ul> <li> <p>Make sure you've install the OCaml Language Server Protocol   (we did this above).  If you haven't, type this::</p> <pre><code>$ opam install ocaml-lsp-server\n</code></pre> </li> <li> <p>Install Visual Studio Code from https://code.visualstudio.com/.</p> </li> <li> <p>When inside VS Code, look at the Extensions pane   (select View/Extensions from the menu).   Type \"OCaml\" into the search bar at the top,   and select and install \"OCaml Platform\".</p> </li> </ul> <p>Now you will get nice syntax highlighting and code completion when you edit OCaml source code.  You can also start a terminal while inside VS Code to test your code by running the OCaml interpreter.  When you do, make sure you choose a WSL (Ubuntu Linux) terminal, not a PowerShell terminal!</p> <p>Now you are ready to write OCaml code!</p>"},{"location":"ocaml/install/#using-the-terminal","title":"Using the terminal","text":"<p>In this book, we assume that you will be running OCaml from inside a Unix-like terminal environment, such as you can find on Linux, MacOS, or Windows (if you're using WSL).  This means that we will assume that you know how to do basic terminal tasks and commands such as</p> <ul> <li>creating a directory (<code>mkdir</code>)</li> <li>removing a directory (<code>rmdir</code>)</li> <li>changing directories (<code>cd</code>)</li> <li>removing files (<code>rm</code>)</li> <li>running programs</li> </ul> <p>In addition, we will be using the GNU <code>make</code> program to build our compilers. We will include instructions on how to use <code>make</code> in the assignments, but you should ensure that <code>make</code> is installed by typing</p> <pre><code>$ which make\n</code></pre> <p>If it replies with <code>make not found</code> or something similar, you need to install it.  On a Mac with Homebrew, type:</p> <pre><code>$ brew install make\n</code></pre> <p>On an Ubuntu Linux system or Windows with WSL, type:</p> <pre><code>$ sudo apt install make\n</code></pre> <p>However, it's likely that <code>make</code> is already installed.</p>"},{"location":"ocaml/macos/","title":"Notes on MacOS","text":"<p>The compilers we will write in this course all generate x86-64 assembly language as their final output. This is the assembly language used by Intel processors, and is very widely used, especially on Windows and Linux computers. Older Mac computers also use x86-64 assembly language, but newer ones (Macs which use the M1 and M2 processors) use Arm64 assembly language, which is completely different from x86-64 assembly language and is not compatible with it. However, Apple has also had the foresight to provide a way to run x86-64 code on their M1/M2 series computers, called Rosetta 2. If you have an M-series Mac, you will need to install this. Start a terminal and type this:</p> <pre><code>$ softwareupdate --install-rosetta\n</code></pre> <p>Agree to the terms and conditions and hit return.  Now Rosetta is installed!</p> <p>Note</p> <p>What Rosetta does is allow you to run x86-64 binary executable programs on a Mac which natively runs Arm64 code. It does this by translating the x86-64 code to Arm64 code on-the-fly. Surprisingly, there is little or no performance loss in most cases when doing this!</p> <p>Having Rosetta installed is not all that is needed in order to run your compilers and generate working executables. You also need to be able to compile the assembly code to x86-64 executables. Again fortunately, the <code>clang</code> C compiler that Apple uses has the ability to \"cross-compile\" to x86-64 executables simply by adding the command-line arguments <code>-arch x86_64</code>. Our test scripts will do this if you add the <code>-arm64</code> command-line argument to them; this will be covered in the assignment writeups.</p> <p>Note also that in order to be able to use the C compiler on a Mac at all, you have to install the Apple command-line tools by typing this:</p> <pre><code>$ xcode-select --install\n</code></pre> <p>In the future, we may offer the option of compiling to Arm64 assembly language directly. For now, Mac users should compile to x86-64 as described above and run their code using Rosetta.</p>"},{"location":"ocaml/notes/basic/","title":"Basic programming tips","text":""},{"location":"ocaml/notes/basic/#warnings","title":"Warnings","text":"<p>Warnings are always bad, unless you expect them (e.g. because code is only partially written). Never ignore warnings. Your finished code should never generate warnings.</p>"},{"location":"ocaml/notes/basic/#use-let-instead-of-match-when-there-is-only-one-variant","title":"Use <code>let</code> instead of <code>match</code> when there is only one variant","text":"<p>It's not uncommon to have types that only have one variant. We see this in the <code>program</code> types of our compilers, for instance:</p> <pre><code>type program = Program of exp\n</code></pre> <p>If you have a <code>program</code> value and you want to extract the <code>exp</code> component, you can use a pattern match as usual:</p> <pre><code>match prog with\n| Program e -&gt; e  (* the only case *)\n</code></pre> <p>However, this is overkill for such a simple case. The idiomatic way to do this is with a <code>let</code>:</p> <pre><code>let (Program e) = prog in ...\n</code></pre> <p>You can think of a <code>let</code> used in this way as a one-variant pattern match.  Never use a <code>match</code> when a <code>let</code> suffices; a <code>match</code> in this case is excessive and harder to read.</p>"},{"location":"ocaml/notes/debug/","title":"Debugging tips","text":"<p>Although strictly-typed functional languages like OCaml greatly reduce the number of bugs in your programs, you will still make mistakes and have to debug them.  Debugging functional languages can be challenging; here are some tips we've found to be useful.</p>"},{"location":"ocaml/notes/debug/#printf-style-debugging","title":"<code>printf</code>-style debugging","text":"<p><code>printf</code>-style debugging is highly effective if you do it right.  The wrong way is to add <code>printf</code> statements to otherwise functional code:</p> <pre><code>let x = ... in\nPrintf.printf \"x = %s\\n\" x;\nlet y = ... in\n...\n</code></pre> <p>Even though this can work, you are embedding imperative code inside functional code, and you can get into tricky syntax issues as a result. A better way to do it is like this:</p> <pre><code>let x = ... in\nlet _ = Printf.printf \"x = %s\\n\" x in\nlet y = ... in\n...\n</code></pre> <p>This also embeds imperative code, but uses functional syntax, so there won't be any syntax issues.</p> <p>Note</p> <p>If the surrounding code is imperative (like a <code>begin</code> expression), the exact opposite criterion applies: favor the naked <code>Printf.printf ...</code> instead of the <code>let _ = Printf.printf ...</code> idiom.</p> <p>Also, you should add <code>%!</code> at the end of the <code>printf</code> format string:</p> <pre><code>let x = ... in\nlet _ = Printf.printf \"x = %s\\n%!\" x in\nlet y = ... in\n...\n</code></pre> <p>This makes OCaml flush the string as soon as the <code>printf</code> executes. If you don't do that, sometimes error messages before a crash can be lost.</p> <p>Finally, for debugging, consider writing your <code>printf</code>s unindented this way:</p> <pre><code>    let x = ... in\nlet _ = Printf.printf \"DEBUG: x = %s\\n%!\" x in\nlet y = ... in\n...\n</code></pre> <p>This way, it's easy to spot these lines, which is good because you are going to want to delete them once debugging is done.</p>"},{"location":"ocaml/notes/debug/#using-the-repl","title":"Using the REPL","text":"<p>\"REPL\" means \"Read-Eval-Print-Loop\" and refers to the interactive interpreter (what you get into if you type <code>ocaml</code> or <code>utop</code> at a terminal prompt). You might think that it's hard to use a REPL in a large, multi-file project like the compiler assignments, but we've got you covered!</p> <p>Typing <code>make repl</code> in any directory will bring up a REPL in which all the modules of the program are accessible.  This allows you to interactively test your code.  Some kinds of code are easier to test in this way than others, but don't underestimate how useful this can be, especially when trying to track down a tricky bug.  All you need to do is to open the relevant module:</p> <pre><code># open Some_Compiler_Pass_That_Isnt_Working;;\n</code></pre> <p>and you can play with all the functions in that module.</p>"},{"location":"ocaml/notes/debug/#insert-debugging-code-into-tricky-algorithms","title":"Insert debugging code into tricky algorithms","text":"<p>Some passes involve tricky algorithms.  In those cases, it's a good idea to define a <code>debug</code> variable at the top of the file:</p> <pre><code>let debug = ref false  (* change to `true` when you need debug output *)\n</code></pre> <p>and then put debug code into the tricky algorithm that prints out the inputs and outputs:</p> <pre><code>let tricky_algorithm weird_inputs =\nif !debug then\nPrintf.printf \"INPUT: %s\\n\" (string_of_weird_inputs weird_inputs);\n... (* rest of algorithm *)\n</code></pre> <p>To do this, you need to be able to convert the algorithm inputs/output to strings.  Most of the data structures you will be using can be easily converted to S-expressions, and there is a <code>print_sexp</code> function in the <code>Utils</code> module that will print an S-expression in a readable fashion (this is discussed in the next section). This is extremely useful for tracking down algorithm errors.</p>"},{"location":"ocaml/notes/design/","title":"Design tips","text":""},{"location":"ocaml/notes/design/#write-stubs","title":"Write stubs!","text":"<p>When you are starting to write a function, write a \"stub\". This is an incomplete function. Just put in</p> <ul> <li> <p>the arguments</p> </li> <li> <p>type annotations for arguments and the return type   (This is very important!  Don't skip this step!)</p> </li> <li> <p>and <code>failwith \"TODO\"</code> for the body.</p> </li> </ul> <p>Then fill it in later.</p> <p>Here's an example of a stub:</p> <pre><code>let halts_on_all_inputs (f : int -&gt; int) : bool =\nfailwith \"TODO\"\n</code></pre> <p>(This particular function might be a bit hard to write, though.)</p> <p>Writing stubs is a great way to get past \"coder's block\". Once the stub is written, you can compile it and make sure it type checks. If it's recursive, you can usually easily fill in the base cases. At that point, you're ready to work on the body of the function.</p>"},{"location":"ocaml/notes/design/#use-wishful-thinking","title":"Use wishful thinking!","text":"<p>If a function seems too difficult/complex to write directly, ask yourself \"what function do I need which would make it really easy to write this function?\" Then assume that that function exists (i.e. write a stub for it), and write your main function using the assumed function. When that's done, go back and write the body of the assumed function.</p> <p>This is one of the most useful programming tips. It's explored at some length in the CS 4 textbook  Structure and Interpretation of Computer Programs (SICP).</p>"},{"location":"ocaml/notes/design/#use-the-support-library","title":"Use the <code>support</code> library!","text":"<p>The <code>support</code> library (which is part of the CS 164 code base) contains a number of modules with useful functions and data structures. Often, this can save you a lot of time versus writing them yourself. Here, we will briefly discuss the modules, but we strongly encourage you to read the comments in the <code>support/*.mli</code> files to find out more. We will remind you in the assignments which functions and data structures are particularly useful for that assignment.</p> <p>The <code>support</code> library contains these modules:</p> <ul> <li><code>Functors</code></li> </ul> <p>This module defines three module types: <code>OrderedTypeS</code>,   <code>SetS.S</code> and <code>MapS.S</code>.  They are extensions of the standard OCaml   module types <code>OrderedType</code>, <code>Set.S</code> and <code>Map.S</code>.   The extensions mostly have to do with functions that convert   instances of the internal datatypes to and from S-expressions, as well   as a few other utility functions.  There are also new functors called   <code>SetS.Make</code> and <code>MapS.Make</code> that create modules with the module types   <code>SetS.S</code> and <code>MapS.S</code> respectively, given a module of module type   <code>OrderedTypeS</code>.</p> <p>In general, you should never be using a module of module type   <code>OrderedType</code>, <code>Set.S</code>, or <code>Map.S</code>.  Always use the extended versions   (<code>OrderedTypeS</code>, <code>SetS.S</code>, or <code>MapS.S</code>).  Usually, all you have to do   is type the extra <code>S</code> at the end of the name.</p> <ul> <li><code>Dgraph</code></li> </ul> <p>This module contains a functor called <code>Make</code>   which makes a module of type <code>Dgraph.S</code>,   which implements a directed graph.   The functor takes an ordered type module (module type <code>OrderedTypeS</code>)   as its argument.</p> <p>Note that this (like the other graph implementations in this library)   is implemented in a purely functional way.   This is not as efficient as an imperative graph could be,   but it's more than sufficient for our needs   and tends to be very well-behaved   (as functional data structures usually are).</p> <ul> <li><code>Multigraph</code></li> </ul> <p>This is like <code>Dgraph</code>, but implements a directed multigraph.</p> <ul> <li><code>PriorityQueue</code></li> </ul> <p>This module contains a very simple (some might call it \"brain dead\") version   of a priority queue module called <code>PriorityQueue.Simple</code>.   One day we may provide a more efficient one, but this will do for now.</p> <ul> <li><code>Ugraph</code></li> </ul> <p>This is like <code>Dgraph</code>, but implements an undirected graph.</p> <ul> <li><code>Utils</code></li> </ul> <p>This contains lots of little utility functions that aren't found in the   OCaml standard libraries.  There are string and list functions,   functions to generate unique variable names, functions to work with   S-expressions, and so on.  This is a module you will want to get familiar   with.</p> <p>You use the <code>support</code> library by <code>open</code>ing it and then <code>open</code>ing whatever modules you need from it:</p> <pre><code>open Support\nopen Functors\nopen Utils\n</code></pre> <p>If you only need one module, you can alternatively do this:</p> <pre><code>open Support.Utils\n</code></pre> <p>Or you can <code>open Support</code> and then use a qualified function e.g. <code>Utils.last</code>.</p>"},{"location":"ocaml/notes/design/#avoid-functions-that-raise-unhelpful-exceptions","title":"Avoid functions that raise unhelpful exceptions!","text":"<p>Avoid using functions that raise unhelpful and hard-to-track-down exceptions like <code>Not_found</code>. One example is the <code>find</code> function of the <code>Map</code> functor. You should prefer to use the <code>find_opt</code> variant, which returns an option type. Then handle the <code>None</code> case explicitly, usually by raising an exception with a specific error message.</p> <p>Also, most uses of <code>find_opt</code> use this pattern:</p> <pre><code>match Map.find_opt key map with\n| None -&gt; failwith \"some error message\"\n| Some v -&gt; (* do something with `v` *)\n</code></pre> <p>We've provided a helper function called <code>find_or_fail</code> in the extended <code>MapS</code> implementation in the <code>support</code> library.  The above code would become:</p> <pre><code>let v = Map.find_or_fail key map ~err_msg: \"some error message\" in\n(* do something with `v` *)\n</code></pre> <p>We recommend you use <code>find_or_fail</code> for this case, and only use <code>find_opt</code> when this isn't sufficient.  You should never use plain <code>find</code> unless you are 100% certain that there is no way that the key won't be found.</p> <p>Note</p> <p>Somehow, the OCaml gods delight in showing you that something that \"can't possibly happen\" can indeed happen, so we recommend coding somewhat defensively.</p> <p>We also provide a more general function called <code>find_or</code>, which can do arbitrary actions in the case of a lookup failure. It takes a labelled argument called <code>f</code> which is a function of type <code>(unit -&gt; 'a)</code>, where <code>'a</code> is the value type. You can use this to return a default value, or to raise an arbitrary exception on lookup failure.</p>"},{"location":"ocaml/notes/design/#be-careful-with-catch-all-match-cases","title":"Be careful with catch-all <code>match</code> cases!","text":"<p>Many functions in your compilers will be large <code>match</code> expressions handling a lot of different constructors. In addition, new constructors for many types will be added with each new version of the compiler. Some functions will require that you handle (say) one case specially, and then all other cases can be handled in a generic manner. It's totally natural to write such functions with a <code>match</code> expression that looks like this:</p> <pre><code>match &lt;thing to match&gt; with\n| &lt;special case&gt; -&gt; &lt;special case code&gt;\n| _ -&gt; &lt;generic code for all other cases&gt;\n</code></pre> <p>In normal OCaml programming, this would be fine. For us, it's not optimal, because it's very easy to forget to handle new constructors when you add them in later compilers. If that happens, the new constructors will be handled by the generic code (the catch-all handler), which will probably be wrong and which may be hard to debug.</p> <p>Instead of this, we recommend this style:</p> <pre><code>match &lt;thing to match&gt; with\n| &lt;special case&gt; -&gt; &lt;special case code&gt;\n| &lt;case 1&gt;\n| &lt;case 2&gt;\n| &lt;case 3&gt;\n| ... -&gt;\n&lt;generic code for all other cases&gt;\n</code></pre> <p>Each <code>&lt;case N&gt;</code> form is a constructor with a wildcard for the constructor arguments e.g. for a constructor <code>Foo</code> it would be <code>Foo _</code> (assuming that <code>Foo</code> has arguments). This way, if you add another constructor in the next compiler, and you forget to handle that case, you will get a warning about a non-exhaustive pattern match, and you will be able to fix the problem right away!</p> <p>You can also write this more concisely as:</p> <pre><code>match &lt;thing to match&gt; with\n| &lt;special case&gt; -&gt; &lt;special case code&gt;\n| &lt;case 1&gt; | &lt;case 2&gt; | &lt;case 3&gt; | ... -&gt;\n&lt;generic code for all other cases&gt;\n</code></pre> <p>This is a bit easier on the eyes.</p>"},{"location":"ocaml/notes/functional/","title":"Functional programming tips","text":""},{"location":"ocaml/notes/functional/#use-functional-style-by-default","title":"Use functional style by default","text":"<p>Code should be written in a functional style (no <code>ref</code>s, arrays, or records with mutable fields) except where indicated.  Marks will be taken off if this rule is violated.  We will let you know when it's OK to use imperative idioms. Certain imperative idioms (like <code>while</code> and <code>for</code> loops) are almost never used, but we do use <code>ref</code> cells on occasion to make code simpler.</p> <p>Many of the tips below describe ways to effectively use functional style. They are not in any particular order, so feel free to browse until you find something interesting.</p>"},{"location":"ocaml/notes/functional/#use-tail-recursion-by-default","title":"Use tail recursion by default","text":"<p>As you recall, a lot of CS 4 was spent teaching you to write functions using recursion instead of loops, and specifically using tail recursion. We use tail recursion because it has desirable space properties, so in general, when you write a recursive function, try hard to make it tail recursive. If you can't do this, be prepared to explain why during code reviews.</p>"},{"location":"ocaml/notes/functional/#persistent-data-structures","title":"Persistent data structures","text":"<p>Probably the hardest part of using functional programming effectively is getting used to persistent data structures (like lists) instead of mutable data structures (like arrays).</p> <p>In this course, almost all data structures are persistent, which means that when you change something in the data structure, it returns the updated version without altering the input version.  This is very different to how imperative languages work.</p> <p>Tip</p> <p>If you think you need to use <code>List.iter</code> (which would be appropriate for a mutable data structure) you almost always want to actually use <code>List.fold_left</code> or an iterative helper function (which is appropriate for a persistent data structure).</p> <p>Even though you may find functional programming awkward at first, it is vastly easier to write correct code in a functional style than in an imperative style. There is simply less that can go wrong.</p>"},{"location":"ocaml/notes/functional/#folds-are-your-friend","title":"Folds are your friend!","text":"<p>Programmers new to functional programming are often frustrated by what they perceive as the difficulty of doing simple things.  A good example of this is accumulation. You have a list and want to compute some value from the list elements. For instance, say you want to get the maximum value of the list (and assume that you only have a two-element <code>max</code> function to compute maximums). A Python programmer could immediately write this code:</p> <pre><code>def max_list(lst):\n\"\"\"Compute the maximum of a list of positive integers.\"\"\"\nif len(lst) == 0:\nreturn 0\nmx = lst[0]\nfor item in lst:\nmx = max(mx, item)\nreturn mx\n</code></pre> <p>In OCaml, we do this sort of thing using folds, specifically left folds.</p> <pre><code>let max_list lst =\nList.fold_left\n(fun mx item -&gt; max mx item)\n0\nlst\n</code></pre> <p>This can be simplified further:</p> <pre><code>let max_list lst = List.fold_left max 0 lst\n</code></pre> <p>Whenever you need to write code which accumulates something over a list, you generally want to use a fold.</p> <p>A common beginner's style error is to do this with an iterative helper function:</p> <pre><code>let max_list lst =\nlet rec iter rest mx =\nmatch rest with\n| [] -&gt; mx\n| h :: t -&gt; iter t (max h mx)\nin\niter lst 0\n</code></pre> <p>This is not so bad, but the iterative helper function can be replaced by <code>List.fold_left</code> and the entire function becomes a one-liner! Be alert for this kind of situation -- there's no benefit to using a functional language if you don't take advantage of what it offers.</p> <p>On the other hand, sometimes you are accumulating more than one thing in an iteration. You can still use <code>List.fold_left</code> in such cases by accumulating a tuple of all the things you're accumulating, but in my experience, it's often easier to just write an iterative helper function.</p>"},{"location":"ocaml/notes/functional/#left-vs-right-folds","title":"Left vs. right folds","text":"<p>95% of the time or more, if you want to use a fold in OCaml, you want to use a left fold (<code>List.fold_left</code>) instead of a right fold (<code>List.fold_right</code>). Left folds are tail recursive (space efficient) and are more natural than right folds, which are not tail recursive and thus not space efficient.</p> <p>On the other hand, there are cases where right folds are the right thing to use.  When you want to accumulate things in a list from the right going back to the left, a right fold is usually going to be simpler than a left fold, and you shouldn't feel bad about using one in that case.</p>"},{"location":"ocaml/notes/functional/#nested-pattern-matching","title":"Nested pattern matching","text":"<p>It's very common to want to write a pattern match inside another pattern match.  There are two cases to consider.</p> <ol> <li> <p>Where the two pattern matches can be combined.  Consider this code:</p> <pre><code>let f (maybe_lst : int list option) : int option =\nmatch maybe_lst with\n| None -&gt; None\n| Some lst -&gt;\nbegin\nmatch lst with\n| h :: _ -&gt; Some h\n| [] -&gt; None\nend\n</code></pre> <p>You can merge both pattern matches as follows:</p> <pre><code>let f (maybe_lst : int list option) : int option =\nmatch maybe_lst with\n| Some (h :: _) -&gt; Some h\n| _ -&gt; None\n</code></pre> <p>Note how much shorter and clearer the code is. Also note the use of the wildcard (<code>_</code>) pattern for \"don't care\" situations.</p> <p>Merging pattern matches is almost always possible if the inner pattern match doesn't depend on a value computed using information from the outer pattern match. Unnecessary pattern matches are bad style and will be marked down (but we'll try to alert you of this issue during code reviews).</p> </li> <li> <p>Where the two pattern matches can't be combined.    Consider this code:</p> <pre><code>let f (lst : int list) : (int * int) option =\nmatch lst with\n| h :: t -&gt;\nbegin\nmatch List.sort compare t with\n| h' :: _ -&gt; Some (h, h')\n| _ -&gt; None\nend\n| _ -&gt; None\n</code></pre> <p>The inner match is matching on the result of the <code>List.sort</code> function applied to the tail of the list. You can't combine these pattern matches because the inner one depends on a value which must be computed (it's not structural). For very simple cases, you can use a <code>when</code> clause instead of the inner match, but often this isn't feasible. So you have nested <code>match</code> expressions.</p> <p>When you have nested <code>match</code> expressions, you must surround them by either <code>begin</code>/<code>end</code> delimiters (as we did above) or parentheses, which looks like this:</p> <pre><code>let f (lst : int list) : (int * int) option =\nmatch lst with\n| h :: t -&gt;\n(match List.sort compare t with\n| h' :: _ -&gt; Some (h, h')\n| _ -&gt; None)\n| _ -&gt; None\n</code></pre> <p>Using parentheses looks more concise, but it's easy to forget to close the open parenthesis, so we prefer to use <code>begin</code>/<code>end</code>. (It reads better, too.)  What you definitely do not want to do is this:</p> <pre><code>let f (lst : int list) : (int * int) option =\nmatch lst with\n| h :: t -&gt;\nmatch List.sort compare t with\n| h' :: _ -&gt; Some (h, h')\n| _ -&gt; None\n| _ -&gt; None\n</code></pre> <p>If you do this, you will get strange error messages because OCaml will consider the last line to be part of the inner pattern match. Remember, OCaml is not whitespace sensitive! So don't forget the <code>begin</code>/<code>end</code>.</p> </li> </ol>"},{"location":"ocaml/notes/new_features/","title":"OCaml features you may not be familiar with","text":"<p>Here are some OCaml features that weren't discussed in CS 4, but which are very useful in day-to-day programming.</p>"},{"location":"ocaml/notes/new_features/#the-pipe-operator","title":"The <code>|&gt;</code> (pipe) operator","text":"<p>The <code>|&gt;</code> (pipe) operator is a reverse-apply operator (analogous to a Unix pipe). It's very convenient when you want to transform some inputs repeatedly by applying one function after another.</p> <p>Instead of writing this:</p> <pre><code>func3 (func2 (func1 data))\n</code></pre> <p>you can write this:</p> <pre><code>data |&gt; func1 |&gt; func2 |&gt; func3\n</code></pre> <p>Aside from having fewer parentheses, it's often easier to read: \"Create <code>data</code>, then apply <code>func1</code>, <code>func2</code>, and <code>func3</code> to it in succession.\"</p> <p>Also, because of OCaml's auto-currying of functions, it even works if one or more of the functions take additional arguments, just as long as the data structure is the last argument to the function. So we might have e.g.:</p> <pre><code>data |&gt; func1 arg1 |&gt; func2 arg2a arg2b |&gt; func3\n</code></pre> <p>instead of:</p> <pre><code>func3 (func2 arg2a arg2b (func1 arg1 data))\n</code></pre> <p>Whether this is clearer is up to you.</p> <p>When there are a lot of transformations, it's nice to write them on  multiple lines:</p> <pre><code>data\n|&gt; transform1\n|&gt; transform2\n|&gt; transform3 arg\n|&gt; transform4 arg1 arg2\n(* etc. *)\n</code></pre> <p>This is much more readable than the usual notation:</p> <pre><code>transform4 arg1 arg2 (transform3 arg (transform2 (transform1 data)))\n</code></pre> <p>and it's also easier to extend with more transformations.</p>"},{"location":"ocaml/notes/new_features/#the-apply-operator","title":"The <code>@@</code> (apply) operator","text":"<p>The \"cousin\" of the <code>|&gt;</code> operator is the <code>@@</code> (forward apply) operator. Like <code>|&gt;</code>, it's never required, but sometimes it can make code a bit nicer by removing the need for some parentheses.</p> <p>Note</p> <p>If you know the Haskell language, you'll recognize the <code>@@</code> operator as the same thing as the <code>$</code> operator in Haskell.</p> <p>The <code>@@</code> operator is used to apply a function to its argument, so <code>f @@ x</code> is the same as <code>f x</code>.  Seems pointless, right? But consider <code>f (1 + 2)</code>.  With <code>@@</code> this becomes <code>f @@ 1 + 2</code> and you've eliminated the need for the parentheses.  Similarly:</p> <pre><code>func3 (func2 (func1 data))\n</code></pre> <p>can be written as:</p> <pre><code>func3 @@ func2 @@ func1 data\n</code></pre> <p>and the parenthesis-saving is even greater! (Note that this operator associates to the right.)</p> <p>A common use for this is when signalling errors.  In the course compilers, most errors use the <code>failwith</code> function:</p> <pre><code>failwith \"my error message\"\n</code></pre> <p>This is fine, but very often, the error message needs to contain formatted data e.g.</p> <pre><code>if i &gt; max_i then\nfailwith (Printf.sprintf \"i value: (%d) is too large\" i)\nelse\n...\n</code></pre> <p>This can be rewritten using the <code>@@</code> operator as:</p> <pre><code>if i &gt; max_i then\nfailwith @@ Printf.sprintf \"i value: (%d) is too large\" i\nelse\n...\n</code></pre> <p>and sometimes it's nice to put the <code>Printf.sprintf</code> on its own line:</p> <pre><code>if i &gt; max_i then\nfailwith @@\nPrintf.sprintf \"i value: (%d) is too large\" i\nelse\n...\n</code></pre> <p>In fact, this case is so common that we've written a helper function called <code>failwithf</code> (\"<code>failwith</code> with formatting\"). Using that, we could rewrite the above code as:</p> <pre><code>open Support.Utils\n...\nif i &gt; max_i then\nfailwithf \"i value: (%d) is too large\" i\nelse\n...\n</code></pre>"},{"location":"ocaml/notes/new_features/#labelled-arguments","title":"Labelled arguments","text":"<p>OCaml has a neat feature called labelled arguments which we didn't cover in CS 4. Just like you'd expect, this feature means that you can label a function argument with a name, and you have to use that name when calling the function. What's nice is that you don't have to put labelled arguments in any particular order; as long as the label is there, the function will know what to do about them.</p> <p>The syntax is described in detail in the link, but here's an example:</p> <pre><code>let f ~x ~y = x - y     (* x and y are labelled arguments *)\nlet _ = f ~x:10 ~y:20   (* you need the labels when calling the function *)\nlet _ = f ~y:20 ~x:10   (* does the same thing *) \n</code></pre> <p>Why would you use this?</p> <p>In our experience, the toughest OCaml bugs to track down are in functions that have more than one argument of the same type.  It's easy to switch the arguments by mistake, and then you have a very hard-to-find bug.</p> <p>The solution is to use labelled arguments.  This way, when you call the function, you have to specify which argument you mean, which makes errors of this kind far less likely.</p> <p>We're not suggesting you do this for every function, but it's certainly a trick to keep in mind, and one which we've used in much of the supporting code.</p> <p>Also, OCaml supports optional arguments, which are like labelled arguments except the function gets a default value you specify if the labelled argument is left off.  The link above describes those too.</p>"},{"location":"ocaml/notes/overview/","title":"Coding notes: overview","text":"<p>In this section we will cover some notes and tips that should improve your OCaml programming experience. We also describe our expectations of how we want you to write your OCaml code, so don't just skip this document!</p>"},{"location":"ocaml/notes/sexp/","title":"On S-expressions","text":""},{"location":"ocaml/notes/sexp/#what-s-expressions-are","title":"What S-expressions are","text":"<p>S-expressions are described in this Wikipedia article. Essentially, they are an extremely simple way (perhaps the most simple way) to represent structured data. The \"S\" in \"S-expression\" originally meant \"symbolic\"; these were originally the way to represent arbitrary data in the Lisp programming language. (They were also used to represent Lisp code as well, but that's another story.) Even now, S-expressions are often associated with Lisp-like programming languages such as Scheme, Clojure, and Racket, but they are more generally useful, as we'll see.</p> <p>An S-expression is essentially just a nested list of arbitrary symbols. S-expressions can be described recursively as either</p> <ul> <li>a symbol   (a string without quotes which   doesn't have internal spaces, quotes, or parentheses)</li> <li>a list of S-expressions</li> </ul> <p>Usually, we use parentheses to delimit a list.  Here are some sample S-expressions:</p> <ul> <li><code>foo</code></li> <li><code>(a b c)</code></li> <li><code>(this is (a (nested list) of) symbols)</code></li> <li><code>((foo 1) (bar 2) (baz 3))</code></li> </ul> <p>Any kind of structured data can be represented as an S-expression.</p>"},{"location":"ocaml/notes/sexp/#how-we-use-them","title":"How we use them","text":"<p>We use S-expressions as both a serialization format and a visualization tool. \"Serialization\" means that we can take arbitrary OCaml datatypes and convert them to and from S-expressions without losing any information.  For visualization, we take some OCaml datatype we want to look at, convert it to an S-expression, and then pretty-print the S-expression in a readable format.</p> <p>Visualization is incredibly useful for debugging.  We will be using a lot of fairly complex OCaml datatypes, and our compiler passes will have the job of converting one datatype into another.  We would like to be able to inspect these datatypes to make sure that we converted them correctly.  If we had to write special string conversion functions for all our datatypes, that would be an enormous amount of boring work.  Instead, there are OCaml libraries that will allow us to automatically convert any datatype to an S-expression if we add small annotations to our code.  (These libraries are the <code>sexplib</code> and <code>ppx_sexp_conv</code> libraries.)</p> <p>In order to get OCaml to generate the S-expression conversion code, we  have to add an annotation after type declarations:</p> <pre><code>type value =\n| Bool of bool\n| Int of int\n| Function of (value -&gt; value)\n[@@deriving sexp]   (* this is the annotation *)\n</code></pre> <p>The <code>[@@deriving sexp]</code> line is what is called a PPX extension; it's a kind of code-generating macro which, when interpreted by OCaml, will generate two functions: <code>sexp_of_value</code> (convert a <code>value</code> to an S-expression) and <code>value_of_sexp</code> (convert an S-expression to a value). We tend to use the first function(s) much more than the second, because we usually want to convert our types to S-expressions.</p> <p>We will use this facility for nearly all our data structures. Fortunately, you don't have to worry about it! Just don't remove those annotations; they are doing real work.</p> <p>All you really need to know is that for any datatype <code>foo</code> which has the <code>[@@deriving sexp]</code> annotation, (which is almost all of them) there will be functions called <code>sexp_of_foo</code> and <code>foo_of_sexp</code> generated. There is also a function in the <code>Support.Utils</code> module called <code>print_sexp</code> which will print out an S-expression in a readable format. So if you need to print out the data structure, just convert it to an S-expression with (say) <code>sexp_of_foo</code> and then print it using <code>print_sexp</code>.</p> <p>Note</p> <p>There is much, much more that could be said about OCaml's PPX extension system, which is a relatively new feature of the language (and which wasn't discussed at all in CS 4 or CS 131). It's a very powerful code-generation system, but it also has a steep learning curve.</p>"},{"location":"ocaml/notes/types/","title":"Type annotations","text":"<p>We strongly recommend that you add type annotations to all functions that are internal to a module. It will save you a lot of grief. Just because OCaml can do type inference doesn't mean that you have to rely on it! When you specify the types manually, you will usually get better error messages.</p> <p>For example, instead of writing this code:</p> <pre><code>let rec insert x lst =\nmatch lst with\n| [] -&gt; [x]\n| h :: t -&gt;\nif x &lt; h then x :: lst else h :: insert x t\n</code></pre> <p>we recomment that you write it like this:</p> <pre><code>let rec insert (x : 'a) (lst : 'a list) : 'a list =\nmatch lst with\n| [] -&gt; [x]\n| h :: t -&gt;\nif x &lt; h then x :: lst else h :: insert x t\n</code></pre> <p>(Actually, you'd probably rewrite it to be tail recursive, but that's another topic.)</p> <p>In many cases, you could substitute a more specific type for <code>'a</code> (say, <code>int</code>), which would be beneficial in the event that the type that was actually passed to <code>insert</code> was something other than a list of <code>int</code>s.</p> <p>Also, don't remove the type annotations once the code is working \"because it looks prettier\"; leave them in. It's good documentation and it will be really important if you ever have to modify the code.</p> <p>Note</p> <p>We didn't have this guideline in CS 4, primarily because the code base was so much smaller. The more complicated the code gets, the more helpful explicit type annotations are.</p>"}]}